<!doctype html><html lang=ru class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/architecture/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/architecture/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/architecture/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/architecture/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/architecture/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/architecture/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/architecture/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/architecture/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/architecture/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/architecture/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/architecture/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ru/docs/concepts/architecture/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Кластерная Архитектура | Kubernetes</title><meta property="og:title" content="Кластерная Архитектура"><meta property="og:description" content="Архитектурные концепции, лежащие в основе Kubernetes.
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ru/docs/concepts/architecture/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Кластерная Архитектура"><meta itemprop=description content="Архитектурные концепции, лежащие в основе Kubernetes.
"><meta name=twitter:card content="summary"><meta name=twitter:title content="Кластерная Архитектура"><meta name=twitter:description content="Архитектурные концепции, лежащие в основе Kubernetes.
"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Архитектурные концепции, лежащие в основе Kubernetes.
"><meta property="og:description" content="Архитектурные концепции, лежащие в основе Kubernetes.
"><meta name=twitter:description content="Архитектурные концепции, лежащие в основе Kubernetes.
"><meta property="og:url" content="https://kubernetes.io/ru/docs/concepts/architecture/"><meta property="og:title" content="Кластерная Архитектура"><meta name=twitter:title content="Кластерная Архитектура"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ru/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ru/docs/>Документация</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ru/community/>Сообщество</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ru/case-studies/>Примеры использования</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ru/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ru/docs/concepts/architecture/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ru/docs/concepts/architecture/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ru/docs/concepts/architecture/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ru/docs/concepts/architecture/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ru/docs/concepts/architecture/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Русский (Russian)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/architecture/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/architecture/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/architecture/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/architecture/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/architecture/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/architecture/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/architecture/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/architecture/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/architecture/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/architecture/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/architecture/>Tiếng Việt (Vietnamese)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Это многостраничный печатный вид этого раздела.
<a href=# onclick="return print(),!1">Нажмите что бы печатать</a>.</p><p><a href=/ru/docs/concepts/architecture/>Вернуться к обычному просмотру страницы</a>.</p></div><h1 class=title>Кластерная Архитектура</h1><div class=lead>Архитектурные концепции, лежащие в основе Kubernetes.</div><ul><li>1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>Узлы</a></li><li>2: <a href=#pg-c0251def6da29b30afebfb04549f1703>Связь между плоскостью управления и узлом</a></li><li>3: <a href=#pg-ca8819042a505291540e831283da66df>Контроллеры</a></li><li>4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Диспетчер облачных контроллеров</a></li><li>5: <a href=#pg-44a2e2e592af0846101e970aff9243e5>Сборщик мусора</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>1 - Узлы</h1><p>Kubernetes запускает ваши приложения, помещая контейнеры в Поды для запуска на Узлах (<em>Nodes</em>).
В зависимости от кластера, узел может быть виртуальной или физической машиной. Каждый узел
содержит сервисы, необходимые для запуска
<a class=glossary-tooltip title='Самый маленький и простой объект в Kubernetes. Под — это набор запущенных контейнеров в кластере.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Подов>Подов</a>, управляемых
<a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='плоскостью управления'>плоскостью управления</a>.</p><p>Обычно у вас есть несколько узлов в кластере; однако в среде обучения или среде
с ограниченными ресурсами у вас может быть только один.</p><p><a href=/ru/docs/concepts/overview/components/##%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D1%83%D0%B7%D0%BB%D0%B0>Компоненты</a> на узле включают
<a class=glossary-tooltip title='Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>,
<a class=glossary-tooltip title='Среда выполнения контейнера — это программа, предназначенная для выполнения контейнеров.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='среду выполнения контейнера'>среду выполнения контейнера</a> и
<a class=glossary-tooltip title='kube-proxy — сетевой прокси, работающий на каждом узле в кластере.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>.</p><h2 id=управление>Управление</h2><p>Существует два основных способа добавления Узлов в <a class=glossary-tooltip title='Компонент панели управления, обслуживающий API Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='API сервер'>API сервер</a>:</p><ol><li>Kubelet на узле саморегистрируется в плоскости управления</li><li>Вы или другой пользователь вручную добавляете объект Узла</li></ol><p>После того как вы создадите объект Узла или kubelet на узле самозарегистируется,
плоскость управления проверяет, является ли новый объект Узла валидным (правильным). Например, если вы
попробуете создать Узел при помощи следующего JSON манифеста:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kubernetes создает внутри себя объект Узла (представление). Kubernetes проверяет,
что kubelet зарегистрировался на API сервере, который совпадает со значением поля <code>metadata.name</code> Узла.
Если узел здоров (если все необходимые сервисы запущены),
он имеет право на запуск Пода. В противном случае этот узел игнорируется для любой активности кластера
до тех пор, пока он не станет здоровым.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>Kubernetes сохраняет объект для невалидного Узла и продолжает проверять, становится ли он здоровым.</p><p>Вы или <a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллер>контроллер</a> должны явно удалить объект Узла, чтобы
остановить проверку доступности узла.</p></div><p>Имя объекта Узла должно быть валидным
<a href=/ru/docs/concepts/overview/working-with-objects/names#%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0-%D0%BF%D0%BE%D0%B4%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2-dns>именем поддомена DNS</a>.</p><h3 id=саморегистрация-узлов>Саморегистрация Узлов</h3><p>Когда kubelet флаг <code>--register-node</code> имеет значение <em>true</em> (по умолчанию), то kubelet будет пытаться
зарегистрировать себя на API сервере. Это наиболее предпочтительная модель, используемая большинством дистрибутивов.</p><p>Для саморегистрации kubelet запускается со следующими опциями:</p><ul><li><p><code>--kubeconfig</code> - Путь к учетным данным для аутентификации на API сервере.</p></li><li><p><code>--cloud-provider</code> - Как общаться с <a class=glossary-tooltip title='Организация, которая предлагает платформу облачных вычислений.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/cloud-providers target=_blank aria-label='облачным провайдером'>облачным провайдером</a>, чтобы прочитать метаданные о себе.</p></li><li><p><code>--register-node</code> - Автоматически зарегистрироваться на API сервере.</p></li><li><p><code>--register-with-taints</code> - Зарегистрировать узел с приведенным списком <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label='ограничений (taints)'>ограничений (taints)</a> (разделенных запятыми <code>&lt;key>=&lt;value>:&lt;effect></code>).</p><p>Ничего не делает, если <code>register-node</code> - <em>false</em>.</p></li><li><p><code>--node-ip</code> - IP-адрес узла.</p></li><li><p><code>--node-labels</code> - <a class=glossary-tooltip title='Группирует объекты на основе произвольных критериев, по которым пользователи могут их идентифицировать.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=Метки>Метки</a> для добавления при регистрации узла в кластере (смотрите ограничения для меток, установленные <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>плагином согласования (admission plugin) NodeRestriction</a>).</p></li><li><p><code>--node-status-update-frequency</code> - Указывает, как часто kubelet отправляет статус узла мастеру.</p></li></ul><p>Когда <a href=/docs/reference/access-authn-authz/node/>режим авторизации Узла</a> и
<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>плагин согласования NodeRestriction</a> включены,
kubelet'ы имеют право только создавать/изменять свой собственный ресурс Узла.</p><h3 id=ручное-администрирование-узла>Ручное администрирование узла</h3><p>Вы можете создавать и изменять объекты узла используя
<a class=glossary-tooltip title='A command line tool for communicating with a Kubernetes cluster.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>.</p><p>Когда вы хотите создать объекты Узла вручную, установите kubelet флаг <code>--register-node=false</code>.</p><p>Вы можете изменять объекты Узла независимо от настройки <code>--register-node</code>.
Например, вы можете установить метки на существующем Узле или пометить его не назначаемым.</p><p>Вы можете использовать метки на Узлах в сочетании с селекторами узла на Подах для управления планированием.
Например, вы можете ограничить Под, иметь право на запуск только на группе доступных узлов.</p><p>Маркировка узла как не назначаемого предотвращает размещение планировщиком новых подов на этом Узле,
но не влияет на существующие Поды на Узле. Это полезно в качестве
подготовительного шага перед перезагрузкой узла или другим обслуживанием.</p><p>Чтобы отметить Узел не назначаемым, выполните:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Поды, являющиеся частью <a class=glossary-tooltip title='Гарантирует, что копия Pod выполняется в наборе узлов кластера.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a> допускают
запуск на не назначаемом Узле. DaemonSets обычно обеспечивает локальные сервисы узла,
которые должны запускаться на Узле, даже если узел вытесняется для запуска приложений.</div><h2 id=статус-узла>Статус Узла</h2><p>Статус узла содержит следующие данные:</p><ul><li><a href=#%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0>Адреса (Addresses)</a></li><li><a href=#%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5>Условия (Conditions)</a></li><li><a href=#%D0%B5%D0%BC%D0%BA%D0%BE%D1%81%D1%82%D1%8C>Емкость и Выделяемые ресурсы (Capacity and Allocatable)</a></li><li><a href=#%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F>Информация (Info)</a></li></ul><p>Вы можете использовать <code>kubectl</code> для просмотра статуса Узла и других деталей:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe node &lt;insert-node-name-here&gt;
</span></span></code></pre></div><p>Каждая секция из вывода команды описана ниже.</p><h3 id=адреса-addresses>Адреса (Addresses)</h3><p>Использование этих полей варьируется в зависимости от вашего облачного провайдера или конфигурации физических серверов (<em>bare metal</em>).</p><ul><li>HostName: Имя хоста, сообщаемое ядром узла. Может быть переопределено через kubelet <code>--hostname-override</code> параметр.</li><li>ExternalIP: Обычно, IP адрес узла, который является внешне маршрутизируемым (доступен за пределами кластера).</li><li>InternalIP: Обычно, IP адрес узла, который маршрутизируется только внутри кластера.</li></ul><h3 id=условие>Условия (Conditions)</h3><p>Поле <code>conditions</code> описывает статус всех <code>Running</code> узлов. Примеры условий включают в себя:</p><table><caption style=display:none>Условия узла и описание того, когда применяется каждое условие.</caption><thead><tr><th>Условие Узла</th><th>Описание</th></tr></thead><tbody><tr><td><code>Ready</code></td><td><code>True</code> если узел здоров и готов принять поды, <code>False</code> если узел нездоров и не принимает поды, и <code>Unknown</code> если контроллер узла не получал информацию от узла в течение последнего периода <code>node-monitor-grace-period</code> (по умолчанию 40 секунд)</td></tr><tr><td><code>DiskPressure</code></td><td><code>True</code> если присутствует давление на размер диска - то есть, если емкость диска мала; иначе <code>False</code></td></tr><tr><td><code>MemoryPressure</code></td><td><code>True</code> если существует давление на память узла - то есть, если памяти на узле мало; иначе <code>False</code></td></tr><tr><td><code>PIDPressure</code></td><td><code>True</code> если существует давление на процессы - то есть, если на узле слишком много процессов; иначе <code>False</code></td></tr><tr><td><code>NetworkUnavailable</code></td><td><code>True</code> если сеть для узла настроена некорректно, иначе <code>False</code></td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Если вы используете инструменты командной строки для вывода сведений об блокированном узле,
то Условие включает <code>SchedulingDisabled</code>. <code>SchedulingDisabled</code> не является Условием в Kubernetes API;
вместо этого блокированные узлы помечены как Не назначаемые в их спецификации.</div><p>Состояние узла представлено в виде JSON объекта. Например, следующая структура описывает здоровый узел:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Если значение параметра Status для условия Ready остается <code>Unknown</code> или <code>False</code>
дольше чем период <code>pod-eviction-timeout</code>(аргумент, переданный в
<a class=glossary-tooltip title='Компонент Control Plane запускает процессы контроллера.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>), то все Поды
на узле планируются к удалению контроллером узла. По умолчанию таймаут выселения <strong>пять минут</strong>.
В некоторых случаях, когда узел недоступен, API сервер не может связаться с kubelet на узле.
Решение об удалении подов не может быть передано в kubelet до тех пор, пока связь с API сервером не будет восстановлена.
В то же время поды, которые запланированы к удалению, могут продолжать работать на отделенном узле.</p><p>Контроллер узла не будет принудительно удалять поды до тех пор, пока не будет подтверждено,
что они перестали работать в кластере. Вы можете видеть, что поды, которые могут работать на недоступном узле,
находятся в состоянии <code>Terminating</code> или <code>Unknown</code>. В тех случаях, когда Kubernetes не может сделать вывод
из основной инфраструктуры о том, что узел окончательно покинул кластер, администратору кластера может потребоваться
удалить объект узла вручную. Удаление объекта узла из Kubernetes приводит к удалению всех объектов Подов, запущенных
на узле, с API сервера и освобождает их имена.</p><p>Контроллер жизненного цикла узла автоматически создает
<a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>ограничения (taints)</a>, которые представляют собой условия.
Планировщик учитывает ограничения Узла при назначении Пода на Узел.
Поды так же могут иметь допуски (tolerations), что позволяет им сопротивляться ограничениям Узла.</p><p>Смотрите раздел <a href=/docs/concepts/configuration/taint-and-toleration/#taint-nodes-by-condition>Ограничить Узлы по Условию</a>
для дополнительной информации.</p><h3 id=емкость>Емкость и Выделяемые ресурсы (Capacity and Allocatable)</h3><p>Описывает ресурсы, доступные на узле: CPU, память и максимальное количество подов,
которые могут быть запланированы на узле.</p><p>Поля в блоке capacity указывают общее количество ресурсов, которые есть на Узле.
Блок allocatable указывает количество ресурсов на Узле,
которые доступны для использования обычными Подами.</p><p>Вы можете прочитать больше о емкости и выделяемых ресурсах, изучая, как <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>зарезервировать вычислительные ресурсы</a> на Узле.</p><h3 id=информация-info>Информация (Info)</h3><p>Описывает общую информацию об узле, такую как версия ядра, версия Kubernetes (версии kubelet и kube-proxy), версия Docker (если используется) и название ОС.
Эта информация собирается Kubelet'ом на узле.</p><h3 id=контроллер-узла>Контроллер узла</h3><p><a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label='Контроллер '>Контроллер</a> узла является компонентом
плоскости управления Kubernetes, который управляет различными аспектами узлов.</p><p>Контроллер узла играет различные роли в жизни узла. Первая - назначение CIDR-блока узлу
при его регистрации (если включено назначение CIDR).</p><p>Вторая - поддержание в актуальном состоянии внутреннего списка узлов контроллера узла
согласно списку доступных машин облачного провайдера. При работе в облачной среде всякий раз,
когда узел неисправен, контроллер узла запрашивает облачного провайдера, доступна ли
виртуальная машина для этого узла. Если нет, то контроллер узла удаляет узел из
своего списка узлов.</p><p>Третья - это мониторинг работоспособности узлов. Контроллер узла
отвечает за обновление условия NodeReady для NodeStatus на
ConditionUnknown, когда узел становится недоступным (т.е. контроллер узла
по какой-то причине перестает получать сердцебиения (heartbeats) от узла,
например, из-за того, что узел упал), и затем позже выселяет все поды с узла
(используя мягкое (graceful) завершение) если узел продолжает быть недоступным.
(По умолчанию таймауты составляют 40 секунд, чтобы начать сообщать <code>ConditionUnknown</code>,
и 5 минут после, чтобы начать выселять поды.)</p><p>Контроллер узла проверяет состояние каждого узла каждые <code>--node-monitor-period</code> секунд.</p><h4 id=сердцебиения>Сердцебиения</h4><p>Сердцебиения, посылаемые узлами Kubernetes, помогают определить доступность узла.</p><p>Существует две формы сердцебиений: обновление <code>NodeStatus</code> и
<a href=/docs/reference/generated/kubernetes-api/v1.25/#lease-v1-coordination-k8s-io>Lease объект</a>.
Каждый узел имеет связанный с ним Lease объект в <code>kube-node-lease</code>
<a class=glossary-tooltip title='An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.
Lease - это легковесный ресурс, который улучшает производительность
сердцебиений узла при масштабировании кластера.</p><p>Kubelet отвечает за создание и обновление <code>NodeStatus</code> и Lease объекта.</p><ul><li>Kubelet обновляет <code>NodeStatus</code> либо когда происходит изменение статуса,
либо если в течение настроенного интервала обновления не было. По умолчанию
интервал для обновлений <code>NodeStatus</code> составляет 5 минут (намного больше,
чем 40-секундный стандартный таймаут для недоступных узлов).</li><li>Kubelet создает и затем обновляет свой Lease объект каждый 10 секунд
(интервал обновления по умолчанию). Lease обновления происходят независимо от
<code>NodeStatus</code> обновлений. Если обновление Lease завершается неудачно,
kubelet повторяет попытку с экспоненциальным откатом, начинающимся с 200 миллисекунд и ограниченным 7 секундами.</li></ul><h4 id=надежность>Надежность</h4><p>В большинстве случаев контроллер узла ограничивает скорость выселения
до <code>--node-eviction-rate</code> (по умолчанию 0,1) в секунду, что означает,
что он не выселяет поды с узлов быстрее чем с одного узла в 10 секунд.</p><p>Поведение выселения узла изменяется, когда узел в текущей зоне доступности
становится нездоровым. Контроллер узла проверяет, какой процент узлов в зоне
нездоров (NodeReady условие в значении ConditionUnknown или ConditiononFalse)
в одно и то же время. Если доля нездоровых узлов не меньше
<code>--unhealthy-zone-threshold</code> (по умолчанию 0.55), то скорость выселения уменьшается:
если кластер небольшой (т.е. количество узлов меньше или равно
<code>--large-cluster-size-threshold</code> - по умолчанию, 50), то выселения прекращаются,
в противном случае скорость выселения снижается до
<code>--secondary-node-eviction-rate</code> (по умолчанию, 0.01) в секунду.</p><p>Причина, по которой эти политики реализуются для каждой зоны доступности, заключается в том,
что одна зона доступности может стать отделенной от мастера, в то время как другие
остаются подключенными. Если ваш кластер не охватывает несколько зон доступности
облачного провайдера, то существует только одна зона доступности (весь кластер).</p><p>Основная причина разнесения ваших узлов по зонам доступности заключается в том,
что приложения могут быть перенесены в здоровые зоны, когда одна из зон полностью
становится недоступной. Поэтому, если все узлы в зоне нездоровы, то контроллер узла
выселяет поды с нормальной скоростью <code>--node-eviction-rate</code>. Крайний случай - когда все зоны
полностью нездоровы (т.е. в кластере нет здоровых узлов). В таком случае
контроллер узла предполагает, что существует некоторая проблема с подключением к мастеру,
и останавливает все выселения, пока какое-нибудь подключение не будет восстановлено.</p><p>Контроллер узла также отвечает за выселение подов, запущенных на узлах с
<code>NoExecute</code> ограничениями, за исключением тех подов, которые сопротивляются этим ограничениям.
Контроллер узла так же добавляет <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=ограничения>ограничения</a>
соответствующие проблемам узла, таким как узел недоступен или не готов. Это означает,
что планировщик не будет размещать поды на нездоровых узлах.</p><div class="alert alert-warning caution callout" role=alert><strong>Внимание:</strong> <code>kubectl cordon</code> помечает узел как 'не назначаемый', что имеет побочный эффект от контроллера сервисов,
удаляющего узел из любых списков целей LoadBalancer узла, на которые он ранее имел право,
эффективно убирая входящий трафик балансировщика нагрузки с блокированного узла(ов).</div><h3 id=емкость-узла>Емкость узла</h3><p>Объекты узла отслеживают информацию о емкости ресурсов узла (например,
объем доступной памяти и количество CPU).
Узлы, которые <a href=#%D1%81%D0%B0%D0%BC%D0%BE%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D1%83%D0%B7%D0%BB%D0%BE%D0%B2>самостоятельно зарегистрировались</a>, сообщают
о своей емкости во время регистрации. Если вы <a href=#%D1%80%D1%83%D1%87%D0%BD%D0%BE%D0%B5-%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%83%D0%B7%D0%BB%D0%B0>вручную</a>
добавляете узел, то вам нужно задать информацию о емкости узла при его добавлении.</p><p><a class=glossary-tooltip title='Компонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=Планировщик>Планировщик</a> Kubernetes гарантирует,
что для всех Подов на Узле достаточно ресурсов. Планировщик проверяет,
что сумма requests от контейнеров на узле не превышает емкость узла.
Эта сумма requests включает все контейнеры, управляемые kubelet,
но исключает любые контейнеры, запущенные непосредственно средой выполнения контейнера,
а также исключает любые процессы, запущенные вне контроля kubelet.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Если вы явно хотите зарезервировать ресурсы для процессов, не связанных с Подами, смотрите раздел
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>зарезервировать ресурсы для системных демонов</a>.</div><h2 id=топология-узла>Топология узла</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>Если вы включили <code>TopologyManager</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>, то kubelet
может использовать подсказки топологии при принятии решений о выделении ресурсов.
Смотрите <a href=/docs/tasks/administer-cluster/topology-manager/>Контроль Политик Управления Топологией на Узле</a>
для дополнительной информации.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Подробнее про<a href=/ru/docs/concepts/overview/components/#%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D1%83%D0%B7%D0%BB%D0%B0>компоненты</a> из которых состоит узел.</li><li>Подробнее про <a href=/docs/reference/generated/kubernetes-api/v1.25/#node-v1-core>Определение API для Узла</a>.</li><li>Подробнее про <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Узлы</a>
of the architecture design document.</li><li>Подробнее про <a href=/docs/concepts/configuration/taint-and-toleration/>ограничения и допуски</a>.</li><li>Подробнее про <a href=/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaling>авто масштабирование кластера</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0251def6da29b30afebfb04549f1703>2 - Связь между плоскостью управления и узлом</h1><p>Этот документ описывает связь между плоскостью управления (apiserver) и кластером Kubernetes. Цель состоит в том, чтобы позволить пользователям настраивать свою установку для усиления сетевой конфигурации, чтобы кластер мог работать в ненадежной сети (или на полностью общедоступных IP-адресах облачного провайдера).</p><h2 id=связь-между-плоскостью-управления-и-узлом>Связь между плоскостью управления и узлом</h2><p>В Kubernetes имеется API шаблон «ступица и спица» (hub-and-spoke). Все используемые API из узлов (или которые запускают pod-ы) завершает apiserver. Ни один из других компонентов плоскости управления не предназначен для предоставления удаленных сервисов. Apiserver настроен на прослушивание удаленных подключений через безопасный порт HTTPS (обычно 443) с одной или несколькими включенными формами <a href=/docs/reference/access-authn-authz/authentication/>аутентификации</a> клиента.</p><p>Должна быть включена одна или несколько форм <a href=/docs/reference/access-authn-authz/authorization/>авторизации</a>, особенно, если разрешены <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>анонимные запросы</a> или <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>ServiceAccount токены</a>.</p><p>Узлы должны быть снабжены публичным корневым сертификатом для кластера, чтобы они могли безопасно подключаться к apiserver-у вместе с действительными учетными данными клиента. Хороший подход заключается в том, чтобы учетные данные клиента, предоставляемые kubelet-у, имели форму клиентского сертификата. См. Информацию о загрузке kubelet TLS <a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLS bootstrapping</a> для автоматической подготовки клиентских сертификатов kubelet.</p><p>Pod-ы, которые хотят подключиться к apiserver, могут сделать это безопасно, используя ServiceAccount, чтобы Kubernetes автоматически вводил общедоступный корневой сертификат и действительный токен-носитель в pod при его создании.
Служба <code>kubernetes</code> (в пространстве имен <code>default</code>) настроена с виртуальным IP-адресом, который перенаправляет (через kube-proxy) на HTTPS эндпоинт apiserver-а.</p><p>Компоненты уровня управления также взаимодействуют с кластером apiserver-а через защищенный порт.</p><p>В результате режим работы по умолчанию для соединений от узлов и модулей, работающих на узлах, к плоскости управления по умолчанию защищен и может работать в ненадежных и/или общедоступных сетях.</p><h2 id=узел-к-плоскости-управления>Узел к плоскости управления</h2><p>Существуют два пути связи плоскости управления (apiserver) с узлами. Первый - от apiserver-а до kubelet процесса, который выполняется на каждом узле кластера. Второй - от apiserver к любому узлу, pod-у или службе через промежуточную функциональность apiserver-а.</p><h3 id=apiserver-в-kubelet>apiserver в kubelet</h3><p>Соединение из apiserver-а к kubelet используются для:</p><ul><li>Извлечения логов с pod-ов.</li><li>Прикрепление (через kubectl) к запущенным pod-ам.</li><li>Обеспечение функциональности переадресации портов kubelet.</li></ul><p>Эти соединения завершаются на HTTPS эндпоинте kubelet-a. По умолчанию apiserver не проверяет сертификат обслуживания kubelet-ов, что делает соединение подверженным к атаке «человек посередине» (man-in-the-middle) и <strong>небезопасным</strong> к запуску в ненадежных и/или общедоступных сетях.</p><p>Для проверки этого соединения используется флаг <code>--kubelet-certificate-authority</code> чтобы предоставить apiserver-у набор корневых (root) сертификатов для проверки сертификата обслуживания kubelet-ов.</p><p>Если это не возможно, используйте <a href=#ssh-tunnels>SSH-тунелирование</a> между apiserver-ом и kubelet, если это необходимо, чтобы избежать подключения по ненадежной или общедоступной сети.</p><p>Наконец, должны быть включены <a href=/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/>аутентификация или авторизация kubelet</a> для защиты kubelet API.</p><h3 id=apiserver-для-узлов-pod-ов-и-служб>apiserver для узлов, pod-ов, и служб</h3><p>Соединения с apiserver к узлу, поду или сервису по умолчанию осуществляются по-обычному HTTP-соединению и поэтому не аутентифицируются, и не шифруются. Они могут быть запущены по защищенному HTTPS-соединению, после добавления префикса <code>https:</code> к имени узла, пода или сервиса в URL-адресе API, но они не будут проверять сертификат предоставленный HTTPS эндпоинтом, как и не будут предоставлять учетные данные клиента. Таким образом, хотя соединение будет зашифровано, оно не обеспечит никаких гарантий целостности. Эти соединения <strong>в настоящее время небезопасны</strong> для запуска в ненадежных или общедоступных сетях.</p><h3 id=ssh-туннели>SSH-туннели</h3><p>Kubernetes поддерживает SSH-туннели для защиты плоскости управления узлов от путей связи. В этой конфигурации apiserver инициирует SSH-туннель для каждого узла в кластере (подключается к ssh-серверу, прослушивая порт 22) и передает весь трафик предназначенный для kubelet, узлу, pod-у или службе через туннель. Этот туннель гарантирует, что трафик не выводится за пределы сети, в которой работает узел.</p><p>SSH-туннели в настоящее время устарели, поэтому вы не должны использовать их, если не знаете, что делаете. Служба подключения является заменой этого канала связи.</p><h3 id=служба-подключения>Служба подключения</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>В качестве замены SSH-туннелям, служба подключения обеспечивает уровень полномочия TCP для плоскости управления кластерной связи. Служба подключения состоит из двух частей: сервер подключения к сети плоскости управления и агентов подключения в сети узлов. Агенты службы подключения инициируют подключения к серверу подключения и поддерживают сетевое подключение. После включения службы подключения, весь трафик с плоскости управления на узлы проходит через эти соединения.</p><p>Следуйте инструкциям <a href=/docs/tasks/extend-kubernetes/setup-konnectivity/>Задача службы подключения,</a> чтобы настроить службу подключения в кластере.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>3 - Контроллеры</h1><p>В робототехнике и автоматизации, <em>цикл управления</em> - это непрерывный цикл, который регулирует состояние системы.</p><p>Вот один из примеров контура управления: термостат в помещении.</p><p>Когда вы устанавливаете температуру, это говорит термостату о вашем <em>желаемом состоянии</em>. Фактическая температура в помещении - это
<em>текущее состояние</em>. Термостат действует так, чтобы приблизить текущее состояние к желаемому состоянию, путем включения или выключения оборудования.</p>Контроллеры в Kubernetes - управляющие циклы, которые отслеживают состояние вашего
<a class=glossary-tooltip title='Набор машин, так называемые узлы, которые запускают контейнеризированные приложения. Кластер имеет как минимум один рабочий узел.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=кластера>кластера</a>, затем вносят или запрашивают
изменения там, где это необходимо.
Каждый контроллер пытается привести текущее состояние кластера ближе к желаемому состоянию.<h2 id=шаблон-контроллера>Шаблон контроллера</h2><p>Контроллер отслеживает по крайней мере один тип ресурса Kubernetes.
Эти <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>объекты</a>
имеют поле спецификации, которое представляет желаемое состояние. Контроллер (ы) для этого ресурса несут ответственность за приближение текущего состояния к желаемому состоянию</p><p>Контроллер может выполнить это действие сам; чаще всего в Kubernetes,
контроллер отправляет сообщения на
<a class=glossary-tooltip title='Компонент панели управления, обслуживающий API Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='сервер API'>сервер API</a> которые имеют
полезные побочные эффекты. Пример этого вы можете увидеть ниже.</p><h3 id=управление-с-помощью-сервера-api>Управление с помощью сервера API</h3><p>Контроллер <a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> является примером встроенного контроллера Kubernetes. Встроенные контроллеры управляют состоянием, взаимодействуя с кластером сервера API.</p><p>Задание - это ресурс Kubernetes, который запускает
<a class=glossary-tooltip title='Самый маленький и простой объект в Kubernetes. Под — это набор запущенных контейнеров в кластере.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>, или возможно несколько Pod-ов, выполняющих задачу и затем останавливающихся.</p><p>(После <a href=/docs/concepts/scheduling-eviction/>планирования</a>, Pod объекты становятся частью желаемого состояния для kubelet).</p><p>Когда контроллер задания видит новую задачу, он убеждается что где-то в вашем кластере kubelet-ы на множестве узлов запускают нужное количество Pod-ов для выполнения работы.
Контроллер задания сам по себе не запускает никакие Pod-ы или контейнеры. Вместо этого контроллер задания сообщает серверу API о создании или удалении Pod-ов.
Другие компоненты в
<a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='плоскости управления'>плоскости управления</a>
действуют на основе информации (имеются ли новые запланированные Pod-ы для запуска), и в итоге работа завершается.</p><p>После того как вы создадите новое задание, желаемое состояние для этого задания будет завершено. Контроллер задания приближает текущее состояние этой задачи к желаемому состоянию: создает Pod-ы, выполняющие работу, которую вы хотели для этой задачи, чтобы задание было ближе к завершению.</p><p>Контроллеры также обновляют объекты которые их настраивают.
Например: как только работа выполнена для задания, контроллер задания обновляет этот объект задание, чтобы пометить его как <code>Завершенный</code>.</p><p>(Это немного похоже на то, как некоторые термостаты выключают свет, чтобы указать, что теперь ваша комната имеет установленную вами температуру).</p><h3 id=прямое-управление>Прямое управление</h3><p>В отличие от Задания, некоторым контроллерам нужно вносить изменения в вещи за пределами вашего кластера.</p><p>Например, если вы используете контур управления, чтобы убедиться, что в вашем кластере достаточно <a class=glossary-tooltip title='Узел — рабочая машина в Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Узлов>Узлов</a>,
тогда этому контроллеру нужно что-то вне текущего кластера, чтобы при необходимости запустить новые узлы.</p><p>Контроллеры, которые взаимодействуют с внешним состоянием, находят свое желаемое состояние с сервера API, а затем напрямую взаимодействуют с внешней системой, чтобы приблизить текущее состояние.</p><p>(На самом деле существует <a href=https://github.com/kubernetes/autoscaler/>контроллер</a>, который горизонтально масштабирует узлы в вашем кластере.)</p><p>Важным моментом здесь является то, что контроллер вносит некоторые изменения, чтобы вызвать желаемое состояние, а затем сообщает текущее состояние обратно на сервер API вашего кластера. Другие контуры управления могут наблюдать за этими отчетными данными и предпринимать собственные действия.</p><p>В примере с термостатом, если в помещении очень холодно, тогда другой контроллер может также включить обогреватель для защиты от замерзания. В кластерах Kubernetes, плоскость управления косвенно работает с инструментами управления IP-адресами, службами хранения данных, API облачных провайдеров и другими службами для реализации
<a href=/docs/concepts/extend-kubernetes/>расширения Kubernetes</a>.</p><h2 id=desired-vs-current>Желаемое против текущего состояния</h2><p>Kubernetes использует систему вида cloud-native и способен справляться с постоянными изменениями.</p><p>Ваш кластер может изменяться в любой по мере выполнения работы и контуры управления автоматически устраняют сбой. Это означает, что потенциально Ваш кластер никогда не достигнет стабильного состояния.</p><p>Пока контроллеры вашего кластера работают и могут вносить полезные изменения, не имеет значения, является ли общее состояние стабильным или нет.</p><h2 id=дизайн>Дизайн</h2><p>В качестве принципа своей конструкции Kubernetes использует множество контроллеров, каждый из которых управляет определенным аспектом состояния кластера. Чаще всего конкретный контур управления (контроллер) использует один вид ресурса в качестве своего желаемого состояния и имеет другой вид ресурса, которым он управляет, чтобы это случилось. Например, контроллер для заданий отслеживает объекты заданий (для обнаружения новой работы) и объекты модулей (для выполнения заданий, а затем для того, чтобы видеть, когда работа завершена). В этом случае что-то еще создает задания, тогда как контроллер заданий создает Pod-ы.</p><p>Полезно иметь простые контроллеры, а не один монолитный набор взаимосвязанных контуров управления. Контроллеры могут выйти из строя, поэтому Kubernetes предназначен для этого.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>Существует несколько контроллеров, которые создают или обновляют один и тот же тип объекта. За кулисами контроллеры Kubernetes следят за тем, чтобы обращать внимание только на ресурсы, связанные с их контролирующим ресурсом.</p><p>Например, у вас могут быть развертывания и задания; они оба создают Pod-ы. Контроллер заданий не удаляет Pod-ы созданные вашим развертыванием, потому что имеется информационные (<a class=glossary-tooltip title='Группирует объекты на основе произвольных критериев, по которым пользователи могут их идентифицировать.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=метки>метки</a>)
которые могут быть использованы контроллерами тем самым показывая отличие Pod-ов.</p></div><h2 id=running-controllers>Способы запуска контроллеров</h2><p>Kubernetes поставляется с набором встроенных контроллеров, которые работают внутри <a class=glossary-tooltip title='Компонент Control Plane запускает процессы контроллера.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>. Эти встроенные контроллеры обеспечивают важные основные функции.</p><p>Контроллер развертывания и контроллер заданий - это примеры контроллеров, которые входят в состав самого Kubernetes («встроенные» контроллеры).
Kubernetes позволяет вам запускать устойчивую плоскость управления, так что в случае отказа одного из встроенных контроллеров работу берет на себя другая часть плоскости управления.</p><p>Вы можете найти контроллеры, которые работают вне плоскости управления, чтобы расширить Kubernetes.
Или, если вы хотите, можете написать новый контроллер самостоятельно. Вы можете запустить свой собственный контроллер в виде наборов Pod-ов,
или внешнее в Kubernetes. Что подойдет лучше всего, будет зависеть от того, что делает этот конкретный контроллер.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Прочтите о <a href=/docs/concepts/overview/components/#control-plane-components>плоскости управления Kubernetes</a></li><li>Откройте для себя некоторые из основных <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/>объектов Kubernetes</a></li><li>Узнайте больше о <a href=/docs/concepts/overview/kubernetes-api/>Kubernetes API</a></li><li>Если вы хотите написать собственный контроллер, см <a href=/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>Шаблоны расширения</a> в расширении Kubernetes.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>4 - Диспетчер облачных контроллеров</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>Технологии облачной инфраструктуры позволяют запускать Kubernetes в общедоступных, частных и гибридных облаках. Kubernetes верит в автоматизированную, управляемую API инфраструктуру без жесткой связи между компонентами.</p><p><p>Диспетчер облачных контроллеров компонент <a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='панель управления'>панель управления</a> Kubernetes - это встраиваемый в логику управления облочная спецификация. Диспетчер облачных контроллеров позволяет связать кластер с API поставщика облачных услуг и отделить компоненты, взаимодействующие с этой облачной платформой, от компонентов, взаимодействующих только с вашим кластером.</p></p><p>Отделяя логику взаимодействия между Kubernetes и базовой облачной инфраструктурой, компонент cloud-controller-manager позволяет поставщикам облачных услуг выпускать функции в другом темпе по сравнению с основным проектом Kubernetes.</p><p>Диспетчер облачных контроллеров спроектирован с использованием механизма плагинов, которые позволяют различным облачным провайдерам интегрировать свои платформы с Kubernetes.</p><h2 id=дизайн>Дизайн</h2><p><img src=/images/docs/components-of-kubernetes.svg alt="Kubernetes components"></p><p>Диспетчер облачных контроллеров работает в панели управления как реплицированный набор процессов (обычно это контейнер в Pod-ах). Каждый диспетчер облачных контроллеров реализует множество <a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллеров>контроллеров</a> в единственном процессе.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Вы также можете запустить диспетчер облачных контроллеров как <a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=дополнение>дополнение</a> Kubernetes, а не как часть панели управления.</div><h2 id=functions-of-the-ccm>Функции диспетчера облачных контроллеров</h2><p>Контроллеры внутри диспетчера облачных контроллеров включают в себя:</p><h3 id=контроллер-узла>Контроллер узла</h3><p>Контроллер узла отвечает за создание объектов <a class=glossary-tooltip title='Узел — рабочая машина в Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=узла>узла</a> при создании новых серверов в вашей облачной инфраструктуре. Контроллер узла получает информацию о работающих хостах внутри вашей арендуемой инфраструктуры облачного провайдера.
Контроллер узла выполняет следующие функции:</p><ol><li>Инициализация объектов узла для каждого сервера, которые контроллер получает через API облачного провайдера.</li><li>Аннотирование и маркировка объектов узла специфичной для облака информацией, такой как регион узла и доступные ему ресурсы (процессор, память и т.д.).</li><li>Получение имени хоста и сетевых адресов.</li><li>Проверка работоспособности узла. В случае, если узел перестает отвечать на запросы, этот контроллер проверяет с помощью API вашего облачного провайдера, был ли сервер деактивирован / удален / прекращен. Если узел был удален из облака, контроллер удаляет объект узла из вашего Kubernetes кластера.</li></ol><p>Некоторые облачные провайдеры реализуют его разделение на контроллер узла и отдельный контроллер жизненного цикла узла.</p><h3 id=контроллер-маршрута>Контроллер маршрута</h3><p>Контроллер маршрута отвечает за соответствующую настройку маршрутов в облаке, чтобы контейнеры на разных узлах кластера Kubernetes могли взаимодействовать друг с другом.</p><p>В зависимости от облачного провайдера, контроллер маршрута способен также выделять блоки IP-адресов для сети Pod-ов.</p><h3 id=контроллер-сервисов>Контроллер сервисов</h3><p><a class=glossary-tooltip title='Способ представления приложения, запущенного в наборе подов, в виде сетевого сервиса.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Сервисы>Сервисы</a> интегрируются с компонентами облачной инфраструктуры, такими как управляемые балансировщики нагрузки, IP-адреса, фильтрация сетевых пакетов и проверка работоспособности целевых объектов. Контроллер сервисов взаимодействует с API вашего облачного провайдера для настройки требуемых балансировщиков нагрузки и других компонентов инфраструктуры, когда вы объявляете ресурсы сервисов.</p><h2 id=авторизация>Авторизация</h2><p>В этом разделе разбирается доступ к различным объектам API, который нужен облачным контроллерам для выполнения своих операций.</p><h3 id=authorization-node-controller>Контроллер узла</h3><p>Контроллер узла работает только с объектом узла. Он требует полного доступа на чтение и изменение объектов узла.</p><p><code>v1/Node</code>:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=authorization-route-controller>Контроллер маршрута</h3><p>Контроллер маршрута прослушивает создание объектов узла и соответствующим образом настраивает маршруты. Для этого требуется получить доступ к объектам узла.</p><p><code>v1/Node</code>:</p><ul><li>Get</li></ul><h3 id=authorization-service-controller>Контроллер сервисов</h3><p>Контроллер сервисов прослушивает события Create, Update и Delete объектов служб, а затем соответствующим образом настраивает конечные точки для соответствующих сервисов.</p><p>Для доступа к сервисам требуется доступ к событиям List и Watch. Для обновления сервисов требуется доступ к событиям Patch и Update.</p><p>Чтобы настроить ресурсы конечных точек для сервисов, требуется доступ к событиям Create, List, Get, Watch и Update.</p><p><code>v1/Service</code>:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=authorization-miscellaneous>Другие</h3><p>Реализация ядра диспетчера облачных контроллеров требует доступ для создания объектов событий, а для обеспечения безопасной работы требуется доступ к созданию сервисных учетных записей (ServiceAccounts).</p><p><code>v1/Event</code>:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p><code>v1/ServiceAccount</code>:</p><ul><li>Create</li></ul><p><a class=glossary-tooltip title='Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a> ClusterRole для диспетчера облачных контроллеров выглядит так:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=что-дальше>Что дальше</h2><p><a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>Администрирование диспетчера облачных контроллеров</a>
содержит инструкции по запуску и управлению диспетчером облачных контроллеров.</p><p>Хотите знать, как реализовать свой собственный диспетчер облачных контроллеров или расширить проект?</p><p>Диспетчер облачных контроллеров использует интерфейсы Go, которые позволяют реализовать подключение из любого облака. В частности, он использует интерфейс <code>CloudProvider</code>, который определен в <a href=https://github.com/kubernetes/cloud-provider/blob/release-1.21/cloud.go#L42-L69><code>cloud.go</code></a> из <a href=https://github.com/kubernetes/cloud-provider>kubernetes/cloud-provider</a>.</p><p>Реализация общих контроллеров, описанных в этом документе (Node, Route, и Service), а также некоторые другие вспомогательные конструкции, вместе с общим интерфейсом облачного провайдера являются частью ядра Kubernetes. Особые реализации для облачных провайдеров находятся вне ядра Kubernetes и реализуют интерфейс <code>CloudProvider</code>.</p><p>Дополнительные сведения о разработке плагинов см. в разделе <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Разработка диспетчера облачных контроллеров</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-44a2e2e592af0846101e970aff9243e5>5 - Сборщик мусора</h1><p>Сборщик мусора - это собирательный термин для различных механизмов? используемых Kubernetes для очистки ресурсов кластера. Это позволить очистить ресурсы, такие как:</p><ul><li><a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>Неудачные pod-ы</a></li><li><a href=/docs/concepts/workloads/controllers/ttlafterfinished/>Завершенные задания</a></li><li><a href=#owners-dependents>Объекты без ссылок на владельца Objects</a></li><li><a href=#containers-images>Не используемые контейнеры и образы контейнеров</a></li><li><a href=/docs/concepts/storage/persistent-volumes/#delete>Dynamically provisioned PersistentVolumes with a StorageClass reclaim policy of Delete</a></li><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process>Устаревшие или просроченные запросы подписания сертификатов (CSR)</a></li><li><a class=glossary-tooltip title='Узел — рабочая машина в Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Nodes>Nodes</a> удалено в следующих сценариях:<ul><li>В облаке, когда кластер использует <a href=/docs/concepts/architecture/cloud-controller/>диспетчер облачных контроллеров</a></li><li>Локально когда кластер использует дополнение, аналогичное диспетчер облачных контроллеров</li></ul></li><li><a href=/docs/concepts/architecture/nodes/#heartbeats>Объекты аренды узлов</a></li></ul><h2 id=owners-dependents>Владельцы и зависимости</h2><p>Многие объекты в Kubernetes ссылаются друг на друга через <a href=/docs/concepts/overview/working-with-objects/owners-dependents/><em>ссылки владельцев</em></a>.
Ссылки владельцев сообщают плоскости управления какие объекты зависят от других.
Kubernetes использует ссылки владельцев, чтобы предоставить плоскости управления и другим API
клиентам, возможность очистить связанные ресурсы перед удалением объекта. В большинстве случаев, Kubernetes автоматический управляет ссылками владельцев.</p><p>Владелец отличается от <a href=/docs/concepts/overview/working-with-objects/labels/>меток и селекторов</a>
которые также используют некоторые ресурсы. Например, рассмотрим
<a class=glossary-tooltip title='Способ представления приложения, запущенного в наборе подов, в виде сетевого сервиса.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Службу>Службу</a> которая создает объект
<code>EndpointSlice</code>. Служба использует <em>метки</em> чтобы позволить плоскости управления определить какие <code>EndpointSlice</code> объекты используются для этой службы. В дополнение
к меткам, каждый <code>EndpointSlice</code> управляет ои имени службы, имеет
ссылку владельца. Ссылки владельцев помогают различным частям Kubernetes избегать
вмешательства в объекты, которые они не контролируют.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>Ссылки на владельцев перекрестных пространств имен запрещены по дизайну.
Зависимости пространства имен могут указывать на область действия кластера или владельцев пространства имен.
Владелец пространства имен <strong>должен</strong> быть в том же пространстве имен, что и зависимости.
Если это не возможно, ссылка владельца считается отсутствующей и зависимый объект подлежит удалению, как только будет проверено отсутствие всех владельцев.</p><p>Зависимости области действия кластер может указывать только владельцев области действия кластера.
В версии v1.20+, если зависимость с областью действия кластера указывает на пространство имен как владелец,
тогда он рассматривается как имеющий неразрешимую ссылку на владельца и не может быть обработан сборщиком мусора.</p><p>В версии v1.20+, если сборщик мусора обнаружит недопустимое перекрестное пространство имен <code>ownerReference</code>,
или зависящие от области действия кластера <code>ownerReference</code> ссылка на тип пространства имен, предупреждающее событие с причиной <code>OwnerRefInvalidNamespace</code> и <code>involvedObject</code> сообщающее о недействительной зависимости.
Вы можете проверить наличие такого рода событий, выполнив <code>kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace</code>.</p></div><h2 id=cascading-deletion>Каскадное удаление</h2><p>Kubernetes проверяет и удаляет объекты, на которые больше нет ссылок владельцев, так же как и pod-ов, оставленных после удаления ReplicaSet. Когда Вы удаляете объект, вы можете контролировать автоматический ли Kubernetes удаляет зависимые объекты автоматически в процессе вызова <em>каскадного удаления</em>. Существует два типа каскадного удаления, а именно:</p><ul><li>Каскадное удаление Foreground</li><li>Каскадное удаление Background</li></ul><p>Вы так же можете управлять как и когда сборщик мусора удаляет ресурсы, на которые ссылаются владельцы с помощью Kubernetes <a class=glossary-tooltip title='A namespaced key that tells Kubernetes to wait until specific conditions are met before it fully deletes an object marked for deletion.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=finalizers>finalizers</a>.</p><h3 id=foreground-deletion>Каскадное удаление Foreground</h3><p>В Каскадном удалении Foreground, объект владельца, который вы удаляете, сначала переходить в состояние <em>в процессе удаления</em>. В этом состоянии с объектом-владельцем происходить следующее:</p><ul><li>Сервер Kubernetes API устанавливает полю объекта <code>metadata.deletionTimestamp</code>
время, когда объект был помечен для удаления.</li><li>Сервер Kubernetes API так же устанавливает метку <code>metadata.finalizers</code>для поля
<code>foregroundDeletion</code>.</li><li>Объект остается видимым благодаря Kubernetes API пока процесс удаления не завершиться</li></ul><p>После того как владелец объекта переходит в состояние прогресса удаления, контроллер удаляет зависимые объекты. После удаления всех зависимых объектов, контроллер удаляет объект владельца. На этом этапе, объект больше не отображается в Kubernetes API.</p><p>Во время каскадного удаления foreground, единственным зависимым, которые блокируют удаления владельца, являются те, у кого имеется поле <code>ownerReference.blockOwnerDeletion=true</code>.
Чтобы узнать больше. Смотрите <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-foreground-cascading-deletion>Использование каскадного удаления foreground</a>.</p><h3 id=background-deletion>Каскадное удаление Background</h3><p>В каскадном удалении background, сервер Kubernetes API немедленно удаляет владельца объекта, а контроллер очищает зависимые объекты в фоновом режиме. По умолчанию, Kubernetes использует каскадное удаление background, если вы в ручную не используете удаление foreground или не решите отключить зависимые объекты.</p><p>Чтобы узнать больше. Смотрите <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-background-cascading-deletion>Использование каскадного удаления background</a>.</p><h3 id=осиротевшие-зависимости>Осиротевшие зависимости</h3><p>Когда Kubernetes удаляет владельца объекта, оставшиеся зависимости называются <em>осиротевшими</em> объектами. По умолчанию, Kubernetes удаляет зависимые объекты. Чтобы узнать, как переопределить это поведение смотрите <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#set-orphan-deletion-policy>Удаление объектов владельца и осиротевших зависимостей</a>.</p><h2 id=containers-images>Сбор мусора из неиспользуемых контейнеров и изображений</h2><p><a class=glossary-tooltip title='Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> выполняет сбор мусора для неиспользуемых образов каждые пять минут и для неиспользуемых контейнеров каждую минуту. Вам следует избегать использования внешних инструментов для сборки мусора, так как они могут
нарушить поведение kubelet и удалить контейнеры, которые должны существовать.</p><p>Чтобы настроить параметры для сборщика мусора для неиспользуемого контейнера и сборки мусора образа, подстройте
kubelet использую <a href=/docs/tasks/administer-cluster/kubelet-config-file/>конфигурационный файл</a>
и измените параметры, связанные со сборщиком мусора используя тип ресурса
<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration><code>KubeletConfiguration</code></a>.</p><h3 id=жизненный-цикл-контейнерных-образов-container-image-lifecycle>Жизненный цикл контейнерных образов Container image lifecycle</h3><p>Kubernetes управляет жизненным циклом всех образов с помощью своего <em>менеджера образов</em>, которые являются частью kubelet, в сотрудничестве с cadvisor. При принятии решений о сборке мусора, kubelet учитывает следующие ограничения использования диска:</p><ul><li><code>HighThresholdPercent</code></li><li><code>LowThresholdPercent</code></li></ul><p>Использование диска выше настроенного значения <code>HighThresholdPercent</code> запускает сборку мусора, которая удаляет образы в порядке основанном на последнем использовании, начиная с самого старого. Kubelet удаляет образы до тех пор, пока использование диска не достигнет значения <code>LowThresholdPercent</code>.</p><h3 id=container-image-garbage-collection>Сборщик мусора контейнерных образов</h3><p>Kubelet собирает не используемые контейнеры на основе следующих переменных, которые вы можете определить:</p><ul><li><code>MinAge</code>: минимальный возраст, при котором kubelet может начать собирать мусор контейнеров. Отключить, установив значение <code>0</code>.</li><li><code>MaxPerPodContainer</code>: максимальное количество неактивных контейнеров, которое может быть у каждой пары Pod-ов. Отключить, установив значение меньше чем <code>0</code>.</li><li><code>MaxContainers</code>: максимальное количество не используемых контейнеров, которые могут быть в кластере. Отключить, установив значение меньше чем <code>0</code>.</li></ul><p>В дополнение к этим переменным, kubelet собирает неопознанные и удаленные контейнеры, обычно начиная с самого старого.</p><p><code>MaxPerPodContainer</code> и <code>MaxContainer</code> могут потенциально конфликтовать друг с другом в ситуациях, когда требуется максимальное количество контейнеров в Pod-е (<code>MaxPerPodContainer</code>) выйдет за пределы допустимого общего количества глобальных не используемых контейнеров (<code>MaxContainers</code>). В этой ситуации kubelet регулирует <code>MaxPodPerContainer</code> для устранения конфликта. Наихудшим сценарием было бы понизить <code>MaxPerPodContainer</code> да <code>1</code> и изгнать самые старые контейнеры.
Кроме того, владельцы контейнеров в pod-е могут быть удалены, как только они становятся старше чем <code>MinAge</code>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Kubelet собирает мусор только у контейнеров, которыми он управляет.</div><h2 id=configuring-gc>Настройка сборщик мусора</h2><p>Вы можете настроить сборку мусора ресурсов, настроив параметры, специфичные для контроллеров, управляющих этими ресурсами. В последующих страницах показано, как настроить сборку мусора:</p><ul><li><a href=/docs/tasks/administer-cluster/use-cascading-deletion/>Настройка каскадного удаления объектов Kubernetes</a></li><li><a href=/docs/concepts/workloads/controllers/ttlafterfinished/>Настройка очистки завершенных заданий</a></li></ul><h2 id=что-дальше>Что дальше</h2><ul><li>Узнайте больше о <a href=/docs/concepts/overview/working-with-objects/owners-dependents/>ownership of Kubernetes objects</a>.</li><li>Узнайте больше о Kubernetes <a href=/docs/concepts/overview/working-with-objects/finalizers/>finalizers</a>.</li><li>Узнать о <a href=/docs/concepts/workloads/controllers/ttlafterfinished/>TTL контроллере</a> (beta) that cleans up finished Jobs.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ru/docs/home/>Главная</a>
<a class=text-white href=/ru/community/>Сообщество</a>
<a class=text-white href=/ru/case-studies/>Примеры использования</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Авторы Kubernetes | Документация распространяется под лицензией <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. Все права защищены. The Linux Foundation является зарегистрированной торговой маркой. Список торговых марок The Linux Foundation приведен на странице <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>использования торговых марок</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>