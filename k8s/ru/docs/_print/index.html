<!doctype html><html lang=ru class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/><link rel=alternate hreflang=hi href=https://kubernetes.io/hi/docs/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ru/docs/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Документация | Kubernetes</title><meta property="og:title" content="Документация"><meta property="og:description" content="Первоклассная оркестрация контейнеров"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ru/docs/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Документация"><meta itemprop=description content="Первоклассная оркестрация контейнеров"><meta name=twitter:card content="summary"><meta name=twitter:title content="Документация"><meta name=twitter:description content="Первоклассная оркестрация контейнеров"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/ru/docs/"><meta property="og:title" content="Документация"><meta name=twitter:title content="Документация"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ru/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ru/docs/>Документация</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ru/community/>Сообщество</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ru/case-studies/>Примеры использования</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ru/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ru/docs/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ru/docs/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ru/docs/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ru/docs/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ru/docs/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Русский (Russian)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/>English</a>
<a class=dropdown-item href=/zh-cn/docs/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/>Français (French)</a>
<a class=dropdown-item href=/it/docs/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/>Bahasa Indonesia</a>
<a class=dropdown-item href=/hi/docs/>हिन्दी (Hindi)</a>
<a class=dropdown-item href=/vi/docs/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/pl/docs/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Это многостраничный печатный вид этого раздела.
<a href=# onclick="return print(),!1">Нажмите что бы печатать</a>.</p><p><a href=/ru/docs/>Вернуться к обычному просмотру страницы</a>.</p></div><h1 class=title>Документация</h1><ul><li>1: <a href=#pg-e735cee7e913aa88bc0aa10594d12966>Документация по Kubernetes</a></li><ul><li>1.1: <a href=#pg-92dfff0ca612d0bff40171aa9df6c4ae>Версии Kubernetes с поддержкой документации</a></li></ul><li>2: <a href=#pg-7743f043c43f7b12e8654e2227dbc658>Генерация сертификатов вручную</a></li><li>3: <a href=#pg-66b565805ca1061be35ff2c0165f13c1>Настройка</a></li><ul><li>3.1: <a href=#pg-0b597086a9d1382f86abadcfeab657d6>Среда обучения</a></li><ul><li>3.1.1: <a href=#pg-8b996bf57bd8e67340235da1a1fb8e95>Установка Kubernetes с помощью Minikube</a></li><li>3.1.2: <a href=#pg-861dedab439fb9a133b35009a34655ec>Установка Kubernetes с помощью Kind</a></li></ul><li>3.2: <a href=#pg-89cb5486440b5e96f31dbb3956f2ad9e>Пользовательские облачные решения</a></li><ul></ul></ul><li>4: <a href=#pg-dd948255948d6b59b32c471abcb62997>Концепции</a></li><ul><li>4.1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>Обзор</a></li><ul><li>4.1.1: <a href=#pg-45bdca6129cf540121623e903c18ba46>Что такое Kubernetes</a></li><li>4.1.2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Компоненты Kubernetes</a></li><li>4.1.3: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>API Kubernetes</a></li><li>4.1.4: <a href=#pg-110f33530cf761140cb1dab536baef04>Работа с объектами Kubernetes</a></li><ul><li>4.1.4.1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>Изучение объектов Kubernetes</a></li><li>4.1.4.2: <a href=#pg-6751db8ff5409476de8225d17d6c42dd>Управление объектами Kubernetes</a></li><li>4.1.4.3: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>Имена и идентификаторы объектов</a></li><li>4.1.4.4: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>Пространства имён</a></li><li>4.1.4.5: <a href=#pg-f1dec4557fb8ffbac9f11390aaaf9fa4>Метки и селекторы</a></li><li>4.1.4.6: <a href=#pg-93cd7a1d4e1623e2bf01afc49a5af69c>Аннотации</a></li><li>4.1.4.7: <a href=#pg-046c03090d47bc4b89b818dc645c3865>Селекторы полей</a></li><li>4.1.4.8: <a href=#pg-5dd62c6a4a481b4cf1ac50f6799eb581>Рекомендуемые метки</a></li></ul></ul><li>4.2: <a href=#pg-2bf36ccd6b3dbeafecf87c39761b07c7>Кластерная Архитектура</a></li><ul><li>4.2.1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>Узлы</a></li><li>4.2.2: <a href=#pg-c0251def6da29b30afebfb04549f1703>Связь между плоскостью управления и узлом</a></li><li>4.2.3: <a href=#pg-ca8819042a505291540e831283da66df>Контроллеры</a></li><li>4.2.4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Диспетчер облачных контроллеров</a></li><li>4.2.5: <a href=#pg-44a2e2e592af0846101e970aff9243e5>Сборщик мусора</a></li></ul><li>4.3: <a href=#pg-285a3785fd3d20f437c28d87ca4dadca>Администрирование кластера</a></li><ul><li>4.3.1: <a href=#pg-2bf9a93ab5ba014fb6ff70b22c29d432>Сертификаты</a></li><li>4.3.2: <a href=#pg-85d633ae590aa20ec024f1b7af1d74fc>Установка дополнений</a></li></ul></ul><li>5: <a href=#pg-68ec2370d0409cc27325be36693f9368>Руководства</a></li><ul><li>5.1: <a href=#pg-5e3051fff9e84735871d9fb5e7b93f33>Привет, Minikube</a></li><li>5.2: <a href=#pg-3c83f53a74233ace9b289ac5e24c3e62>Основы Kubernetes</a></li><ul><li>5.2.1: <a href=#pg-7df66040311338d6098ebeab43ba9afb>Создание кластера</a></li><ul><li>5.2.1.1: <a href=#pg-de49316920e97a82e36763cb66781ada>Использование Minikube для создания кластера</a></li><li>5.2.1.2: <a href=#pg-323b75976001e8dfe35d67d61bc74f1a>Интерактивный урок - Создание кластера</a></li></ul><li>5.2.2: <a href=#pg-76d78b3fba507f7ed33cef14a35b631d>Развёртывание приложения</a></li><ul><li>5.2.2.1: <a href=#pg-2b1bba431989008c7493109a0f049ece>Использование kubectl для развёртывания приложения</a></li><li>5.2.2.2: <a href=#pg-f8997ec143b382fa6c9621941ea62ca3>Интерактивный урок - Развёртывание приложения</a></li></ul><li>5.2.3: <a href=#pg-250d620a73ec8be7e1f7d835574c4596>Изучение приложения</a></li><ul><li>5.2.3.1: <a href=#pg-2771f4e8c45321b17cb0114a2d266453>Изучение подов и узлов</a></li><li>5.2.3.2: <a href=#pg-4b01eab98a9844ad91131079654199dd>Интерактивный урок - Изучение приложения</a></li></ul><li>5.2.4: <a href=#pg-4b0e31c9e0eae68bbb0a358b4042ada9>Открытие доступа к приложению</a></li><ul><li>5.2.4.1: <a href=#pg-8ef4dad8f743b191a9e8c6f891cb191a>Создание сервиса для открытия доступа к приложению</a></li><li>5.2.4.2: <a href=#pg-352241d22effe0714772d21c7d1b512d>Интерактивный урок - Открытие доступа к приложению</a></li></ul><li>5.2.5: <a href=#pg-be4996c93fb39c459a30b6669569d423>Масштабирование приложения</a></li><ul><li>5.2.5.1: <a href=#pg-d1c15c9bd4f625adbc13149b1475287c>Запуск нескольких экземпляров приложения</a></li><li>5.2.5.2: <a href=#pg-7bdb3fbaa1177ff5dfa3fe86bd35ef59>Интерактивный урок - Масштабирование приложения</a></li></ul><li>5.2.6: <a href=#pg-62b8b17dadfb55f1801cf8439e944e58>Обновление приложения</a></li><ul><li>5.2.6.1: <a href=#pg-12e04355145afad615ca3c38335ba019>Выполнение плавающего обновления</a></li><li>5.2.6.2: <a href=#pg-dddc0cb356c280e0339bcf42776987dc>Интерактивный урок - Обновление приложения</a></li></ul></ul></ul><li>6: <a href=#pg-b00a88a07ceb21b1a83e5822e0c86c1d>Ссылки</a></li><ul><li>6.1: <a href=#pg-2b03679960950df772fb4fe7d78427b9>Стандартизированный глоссарий</a></li><li>6.2: <a href=#pg-03460a7254c6c73eb2a1bb3dd7d25910>kubectl CLI</a></li><ul><li>6.2.1: <a href=#pg-f14fe15ecc2d41b5e901ef5e872ca657>Обзор kubectl</a></li><li>6.2.2: <a href=#pg-a938176c695852fe70362c29cf615f1c>Поддержка JSONPath</a></li><li>6.2.3: <a href=#pg-4d3e62632c189fcc3c1357cd8fb8799c>kubectl</a></li><li>6.2.4: <a href=#pg-a7abc09192597e614b58f8b552b682f5>kubectl для пользователей Docker</a></li><li>6.2.5: <a href=#pg-d7ffbf04ffbefb241fd0722423b80f5a>Команды kubectl</a></li><li>6.2.6: <a href=#pg-8aba901ac13f124e5782b90ddb166ee2>Шпаргалка по kubectl</a></li></ul></ul><li>7: <a href=#pg-4985cb55ddfb184639d767ec54b9f0f7>Участие в документации Kubernetes</a></li><ul><li>7.1: <a href=#pg-3609b0e10614f1dc39ed781858319204>Участие для начинающих</a></li><li>7.2: <a href=#pg-9ff7ba6b379b0f8b652beaabf6e4f8d6>Участие для продвинутых</a></li><li>7.3: <a href=#pg-8111429863728051b460e1f3a75b6fea>Существенный вклад</a></li><li>7.4: <a href=#pg-a2d946282df02cdeb47d9f54dfef198e>Обзор оформления документации</a></li><ul><li>7.4.1: <a href=#pg-75de610057816ac48210db20ec633217>Руководство по оформлению документации</a></li><li>7.4.2: <a href=#pg-3b9549b1c8f5ef9d6ae0a841cc99c180>Руководство по содержанию документации</a></li><li>7.4.3: <a href=#pg-4f09c4b708d2dd4ac9eac1080dab6728>Написание новой темы</a></li><li>7.4.4: <a href=#pg-6d95158118c9a27343edd2e6e23f0247>Использование шаблонов страниц</a></li><li>7.4.5: <a href=#pg-357f2ddd61035f18c2aa63fe86203f9c>Организация контента</a></li><li>7.4.6: <a href=#pg-6d76d18115f82583d526bdaf5d05edbc>Пользовательские макрокоды Hugo</a></li></ul><li>7.5: <a href=#pg-29765496ca296ad24e34e5c0cd42a63f>Обзор справочной документации</a></li><ul><li>7.5.1: <a href=#pg-a5eac5b2b794f16aa703a2fa212d7c39>Участие в основном коде Kubernetes</a></li><li>7.5.2: <a href=#pg-f4f605fa4c2e23622d56b067ef56c239>Руководство по быстрому старту</a></li><li>7.5.3: <a href=#pg-6e4e78f20e40bac9bcad59941e974af6>Генерация справочной документации для API Kubernetes</a></li><li>7.5.4: <a href=#pg-03de26b330a5cfdb26672f6bc75dcc04>Генерация справочной документации для команд kubectl</a></li><li>7.5.5: <a href=#pg-28fc50a0072b0b2b444aa24e552d2e60>Генерация справочных страниц для компонентов и инструментов Kubernetes</a></li></ul><li>7.6: <a href=#pg-849a2fdb87779db1c212fe5a9f88ff0d>Локализация документации Kubernetes</a></li><li>7.7: <a href=#pg-e1098d3fca853af3d9dd514e4309cbba>Участие в SIG Docs</a></li></ul></ul><div class=content></div></div><div class=td-content><h1 id=pg-e735cee7e913aa88bc0aa10594d12966>1 - Документация по Kubernetes</h1></div><div class=td-content><h1 id=pg-92dfff0ca612d0bff40171aa9df6c4ae>1.1 - Версии Kubernetes с поддержкой документации</h1><p>На сайте можно найти документацию для текущей и четырёх прошлых версий Kubernetes.</p><h2 id=текущая-версия>Текущая версия</h2><p>Текущая версия:
<a href=/>v1.25</a>.</p><h2 id=предыдущие-версии>Предыдущие версии</h2><ul><li><a href=https://v1-24.docs.kubernetes.io>v1.24</a></li><li><a href=https://v1-23.docs.kubernetes.io>v1.23</a></li><li><a href=https://v1-22.docs.kubernetes.io>v1.22</a></li><li><a href=https://v1-21.docs.kubernetes.io>v1.21</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-7743f043c43f7b12e8654e2227dbc658>2 - Генерация сертификатов вручную</h1><p>При аутентификации с помощью клиентского сертификата сертификаты можно генерировать вручную с помощью <code>easyrsa</code>, <code>openssl</code> или <code>cfssl</code>.</p><h3 id=easyrsa>easyrsa</h3><p><strong>easyrsa</strong> поддерживает ручную генерацию сертификатов для кластера.</p><ol><li><p>Скачайте, распакуйте и инициализируйте пропатченную версию <code>easyrsa3</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -LO https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz
</span></span><span style=display:flex><span>tar xzf easy-rsa.tar.gz
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> easy-rsa-master/easyrsa3
</span></span><span style=display:flex><span>./easyrsa init-pki
</span></span></code></pre></div></li><li><p>Создайте новый центр сертификации (certificate authority, CA). <code>--batch</code> задает автоматический режим;
<code>--req-cn</code> указывает общее имя (Common Name, CN) для нового корневого сертификата CA.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>./easyrsa --batch <span style=color:#b44>&#34;--req-cn=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>MASTER_IP</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>@`date +%s`&#34;</span> build-ca nopass
</span></span></code></pre></div></li><li><p>Сгенерируйте сертификат и ключ сервера.</p><p>Аргумент <code>--subject-alt-name</code> задает допустимые IP-адреса и DNS-имена, с которых будет осуществляться доступ к серверу API. <code>MASTER_CLUSTER_IP</code> обычно является первым IP из CIDR сервиса, который указан в качестве аргумента <code>--service-cluster-ip-range</code> как для сервера API, так и для менеджера контроллеров. Аргумент <code>--days</code> задает количество дней, через которое истекает срок действия сертификата. В приведенном ниже примере предполагается, что <code>cluster.local</code> используется в качестве доменного имени по умолчанию.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>./easyrsa --subject-alt-name<span style=color:#666>=</span><span style=color:#b44>&#34;IP:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>MASTER_IP</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;IP:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>MASTER_CLUSTER_IP</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes.default,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes.default.svc,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes.default.svc.cluster,&#34;</span><span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span><span style=color:#b44>&#34;DNS:kubernetes.default.svc.cluster.local&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--days<span style=color:#666>=</span><span style=color:#666>10000</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>build-server-full server nopass
</span></span></code></pre></div></li><li><p>Скопируйте <code>pki/ca.crt</code>, <code>pki/issued/server.crt</code> и <code>pki/private/server.key</code> в свою директорию.</p></li><li><p>Заполните и добавьте следующие параметры в параметры запуска сервера API:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--client-ca-file<span style=color:#666>=</span>/yourdirectory/ca.crt
</span></span><span style=display:flex><span>--tls-cert-file<span style=color:#666>=</span>/yourdirectory/server.crt
</span></span><span style=display:flex><span>--tls-private-key-file<span style=color:#666>=</span>/yourdirectory/server.key
</span></span></code></pre></div></li></ol><h3 id=openssl>openssl</h3><p><strong>openssl</strong> поддерживает ручную генерацию сертификатов для кластера.</p><ol><li><p>Сгенерируйте 2048-разрядный ключ ca.key:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl genrsa -out ca.key <span style=color:#666>2048</span>
</span></span></code></pre></div></li><li><p>На основе ca.key сгенерируйте ca.crt (используйте <code>-days</code> для установки времени действия сертификата):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -x509 -new -nodes -key ca.key -subj <span style=color:#b44>&#34;/CN=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>MASTER_IP</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span> -days <span style=color:#666>10000</span> -out ca.crt
</span></span></code></pre></div></li><li><p>Сгенерируйте 2048-битный ключ server.key:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl genrsa -out server.key <span style=color:#666>2048</span>
</span></span></code></pre></div></li><li><p>Создайте файл конфигурации для генерации запроса на подписание сертификата (Certificate Signing Request, CSR).</p><p>Замените значения, помеченные угловыми скобками (например, <code>&lt;MASTER_IP></code>), нужными значениями перед сохранением в файл (например, <code>csr.conf</code>). Обратите внимание, что значение для <code>MASTER_CLUSTER_IP</code> – это cluster IP сервиса для сервера API, как описано в предыдущем подразделе. В приведенном ниже примере предполагается, что <code>cluster.local</code> используется в качестве доменного имени по умолчанию.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ req ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>default_bits</span> <span style=color:#666>=</span> <span style=color:#b44>2048</span>
</span></span><span style=display:flex><span><span style=color:#b44>prompt</span> <span style=color:#666>=</span> <span style=color:#b44>no</span>
</span></span><span style=display:flex><span><span style=color:#b44>default_md</span> <span style=color:#666>=</span> <span style=color:#b44>sha256</span>
</span></span><span style=display:flex><span><span style=color:#b44>req_extensions</span> <span style=color:#666>=</span> <span style=color:#b44>req_ext</span>
</span></span><span style=display:flex><span><span style=color:#b44>distinguished_name</span> <span style=color:#666>=</span> <span style=color:#b44>dn</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ dn ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>C</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;country&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>ST</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;state&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>L</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;city&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>O</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;organization&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>OU</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;organization unit&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>CN</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;MASTER_IP&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ req_ext ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>subjectAltName</span> <span style=color:#666>=</span> <span style=color:#b44>@alt_names</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ alt_names ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.1</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.2</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes.default</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.3</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes.default.svc</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.4</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes.default.svc.cluster</span>
</span></span><span style=display:flex><span><span style=color:#b44>DNS.5</span> <span style=color:#666>=</span> <span style=color:#b44>kubernetes.default.svc.cluster.local</span>
</span></span><span style=display:flex><span><span style=color:#b44>IP.1</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;MASTER_IP&gt;</span>
</span></span><span style=display:flex><span><span style=color:#b44>IP.2</span> <span style=color:#666>=</span> <span style=color:#b44>&lt;MASTER_CLUSTER_IP&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>[ v3_ext ]</span>
</span></span><span style=display:flex><span><span style=color:#b44>authorityKeyIdentifier</span><span style=color:#666>=</span><span style=color:#b44>keyid,issuer:always</span>
</span></span><span style=display:flex><span><span style=color:#b44>basicConstraints</span><span style=color:#666>=</span><span style=color:#b44>CA:FALSE</span>
</span></span><span style=display:flex><span><span style=color:#b44>keyUsage</span><span style=color:#666>=</span><span style=color:#b44>keyEncipherment,dataEncipherment</span>
</span></span><span style=display:flex><span><span style=color:#b44>extendedKeyUsage</span><span style=color:#666>=</span><span style=color:#b44>serverAuth,clientAuth</span>
</span></span><span style=display:flex><span><span style=color:#b44>subjectAltName</span><span style=color:#666>=</span><span style=color:#b44>@alt_names</span>
</span></span></code></pre></div></li><li><p>Сгенерируйте запрос на подписание сертификата, используя файл конфигурации:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -new -key server.key -out server.csr -config csr.conf
</span></span></code></pre></div></li><li><p>С помощью ca.key, ca.crt и server.csr сгенерируйте сертификат сервера:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -CAcreateserial -out server.crt -days <span style=color:#666>10000</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    -extensions v3_ext -extfile csr.conf
</span></span></code></pre></div></li><li><p>Используйте следующую команду, чтобы просмотреть запрос на подписание сертификата:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req  -noout -text -in ./server.csr
</span></span></code></pre></div></li><li><p>Используйте следующую команду, чтобы просмотреть сертификат:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl x509  -noout -text -in ./server.crt
</span></span></code></pre></div></li></ol><p>Наконец, добавьте эти параметры в конфигурацию запуска сервера API.</p><h3 id=cfssl>cfssl</h3><p><strong>cfssl</strong> – еще один инструмент для генерации сертификатов.</p><ol><li><p>Скачайте, распакуйте и подготовьте пакеты, как показано ниже.</p><p>Обратите внимание, что команды необходимо адаптировать под архитектуру и используемую версию cfssl.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl_1.5.0_linux_amd64 -o cfssl
</span></span><span style=display:flex><span>chmod +x cfssl
</span></span><span style=display:flex><span>curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssljson_1.5.0_linux_amd64 -o cfssljson
</span></span><span style=display:flex><span>chmod +x cfssljson
</span></span><span style=display:flex><span>curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl-certinfo_1.5.0_linux_amd64 -o cfssl-certinfo
</span></span><span style=display:flex><span>chmod +x cfssl-certinfo
</span></span></code></pre></div></li><li><p>Создайте директорию для хранения артефактов и инициализируйте cfssl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir cert
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> cert
</span></span><span style=display:flex><span>../cfssl print-defaults config &gt; config.json
</span></span><span style=display:flex><span>../cfssl print-defaults csr &gt; csr.json
</span></span></code></pre></div></li><li><p>Создайте JSON-конфиг для генерации файла CA (например, <code>ca-config.json</code>):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;signing&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;default&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;expiry&#34;</span>: <span style=color:#b44>&#34;8760h&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;profiles&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;usages&#34;</span>: [
</span></span><span style=display:flex><span>          <span style=color:#b44>&#34;signing&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#b44>&#34;key encipherment&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#b44>&#34;server auth&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#b44>&#34;client auth&#34;</span>
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;expiry&#34;</span>: <span style=color:#b44>&#34;8760h&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>Создайте JSON-конфиг для запроса на подписание сертификата (CSR) (например,
<code>ca-csr.json</code>). Замените значения, помеченные угловыми скобками, на нужные.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;CN&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;key&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;algo&#34;</span>: <span style=color:#b44>&#34;rsa&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;size&#34;</span>: <span style=color:#666>2048</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;names&#34;</span>:[{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;C&#34;</span>: <span style=color:#b44>&#34;&lt;country&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;ST&#34;</span>: <span style=color:#b44>&#34;&lt;state&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;L&#34;</span>: <span style=color:#b44>&#34;&lt;city&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;O&#34;</span>: <span style=color:#b44>&#34;&lt;organization&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;OU&#34;</span>: <span style=color:#b44>&#34;&lt;organization unit&gt;&#34;</span>
</span></span><span style=display:flex><span>  }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>Сгенерируйте ключ CA (<code>ca-key.pem</code>) и сертификат (<code>ca.pem</code>):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>../cfssl gencert -initca ca-csr.json | ../cfssljson -bare ca
</span></span></code></pre></div></li><li><p>Создайте конфигурационный JSON-файл для генерации ключей и сертификатов для сервера API (например, <code>server-csr.json</code>). Замените значения, помеченные угловыми скобками, на нужные. <code>MASTER_CLUSTER_IP</code> – это cluster IP сервиса для сервера API, как описано в предыдущем подразделе. В приведенном ниже примере предполагается, что <code>cluster.local</code> используется в качестве доменного имени по умолчанию.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;CN&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;hosts&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;&lt;MASTER_IP&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;&lt;MASTER_CLUSTER_IP&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes.default&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes.default.svc&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes.default.svc.cluster&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;kubernetes.default.svc.cluster.local&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;key&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;algo&#34;</span>: <span style=color:#b44>&#34;rsa&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;size&#34;</span>: <span style=color:#666>2048</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;names&#34;</span>: [{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;C&#34;</span>: <span style=color:#b44>&#34;&lt;country&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;ST&#34;</span>: <span style=color:#b44>&#34;&lt;state&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;L&#34;</span>: <span style=color:#b44>&#34;&lt;city&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;O&#34;</span>: <span style=color:#b44>&#34;&lt;organization&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;OU&#34;</span>: <span style=color:#b44>&#34;&lt;organization unit&gt;&#34;</span>
</span></span><span style=display:flex><span>  }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>Сгенерируйте ключ и сертификат для сервера API (по умолчанию они сохраняются в файлах <code>server-key.pem</code> и <code>server.pem</code> соответственно):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>../cfssl gencert -ca<span style=color:#666>=</span>ca.pem -ca-key<span style=color:#666>=</span>ca-key.pem <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>     --config<span style=color:#666>=</span>ca-config.json -profile<span style=color:#666>=</span>kubernetes <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>     server-csr.json | ../cfssljson -bare server
</span></span></code></pre></div></li></ol><h2 id=распространение-самоподписанного-сертификата-ca>Распространение самоподписанного сертификата CA</h2><p>Клиентский узел может отказаться признавать самоподписанный сертификат CA действительным. В случае его использования не в production или в инсталляциях, защищенных межсетевым экраном, самоподписанный сертификат CA можно распространить среди всех клиентов и обновить локальный список действительных сертификатов.</p><p>Для этого на каждом клиенте выполните следующие операции:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo cp ca.crt /usr/local/share/ca-certificates/kubernetes.crt
</span></span><span style=display:flex><span>sudo update-ca-certificates
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Updating certificates in /etc/ssl/certs...
1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....
done.
</code></pre><h2 id=api-для-сертификатов>API для сертификатов</h2><p>Для создания сертификатов x509, которые будут использоваться для аутентификации, можно воспользоваться API <code>certificates.k8s.io</code>. Для дополнительной информации см. <a href=/docs/tasks/tls/managing-tls-in-a-cluster>Управление TLS-сертификатами в кластере</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-66b565805ca1061be35ff2c0165f13c1>3 - Настройка</h1><p>Используйте информацию на этой странице, чтобы найти наиболее подходящее для вас решение по установке и настройке.</p><p>Решение о том, как запускать Kubernetes, зависит от доступных ресурсов и необходимого уровня гибкости использования. Запуск Kubernetes возможен практически на чём угодно, от вашего ноутбука или виртуальных машины у облачного провайдера и до физических серверов. Решения позволяют как настроить полностью управляемый кластер запуском единственной команды так и создать пользовательский кластер на физических серверах.</p><h2 id=решения-для-запуска-на-локальной-машине>Решения для запуска на локальной машине</h2><p>Запуск на локальной машине позволяет легко начать работу с Kubernetes. Можно создавать и тестировать кластер Kubernetes не беспокоясь о трате облачных ресурсов и квотах.</p><p>Вам следует выбрать запуск на локальной машине, если вы:</p><ul><li>Пробуете или начинаете работу с Kubernetes</li><li>Локально разрабатываете и тестируете кластер</li></ul><p>Выбрать <a href=/docs/setup/learning-environment/>решение для запуска на локальной машине</a>.</p><h2 id=управляемые-решения>Управляемые решения</h2><p>Управляемые решения позволяют надёжно и удобно создавать и поддерживать кластеры Kubernetes. Они настраивают и управляют кластером самостоятельно, не требуя ручного вмешательства.</p><p>Вам следует выбрать управляемое решение, если вы:</p><ul><li>Хотите получить полностью самоуправляемое решение</li><li>Хотите сконцентрироваться на разработке собственных приложений или сервисов</li><li>Хотите получить высокую доступность, но у вас нет выделенной команды по обеспечению надёжности приложения (SRE).</li><li>Не имеете ресурсов для размещения и мониторинга собственных кластеров</li></ul><p>Выбрать <a href=/docs/setup/pick-right-solution/#hosted-solutions>управляемое решение</a>.</p><h2 id=облачные-решения-под-ключ>Облачные решения "под ключ"</h2><p>Такие решения позволяют создавать кластеры Kubernetes с помощью небольшого количества команд. Эти решения имеют большую поддержку сообществом и активно развиваются. Они могут быть размещены на разнообразных IaaS облачных провайдерах, при этом предлагая большую свободу и гибкость в обмен на приложенные усилия.</p><p>Вам следует выбрать облачное решение "под ключ", если вы:</p><ul><li>Хотите получить больший контроль над кластерами, чем позволяют размещённые решения</li><li>Хотите получить больше контроля над операциями</li></ul><p>Выбрать <a href=/docs/setup/pick-right-solution/#turnkey-cloud-solutions>облачное решение "под ключ"</a></p><h2 id=местное-резервное-решение-под-ключ>Местное резервное решение "под ключ"</h2><p>Такие решения позволяют с помощью небольшого количества команд создавать кластеры Kubernetes в ваших внутренних, защищённых облачных сетях.</p><p>Вам следует выбрать местное резервное решение "под ключ", если:</p><ul><li>Вы хотите развернуть кластер в приватной облачной сети</li><li>У вас есть выделенная команда SRE-специалистов</li><li>У вас есть ресурсы для размещения и мониторинга собственных кластеров</li></ul><p>Выбрать <a href=/docs/setup/pick-right-solution/#on-premises-turnkey-cloud-solutions>местное резервное решение "под ключ"</a>.</p><h2 id=пользовательские-решения>Пользовательские решения</h2><p>Пользовательские решения позволяют достичь наибольшей свободы в управлении кластерами, но при этом требуют наибольшей экспертизы. Можно найти такие решения как для размещения на физических серверах, так и у облачных провайдеров на разных операционных системах.</p><p>Выбрать <a href=/docs/setup/pick-right-solution/#custom-solutions>пользовательское решение</a>.</p><h2 id=что-дальше>Что дальше</h2><p>Перейти к <a href=/docs/setup/pick-right-solution/>выбору подходящего решения</a>, чтобы ознакомить с полным списком доступных решений.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0b597086a9d1382f86abadcfeab657d6>3.1 - Среда обучения</h1></div><div class=td-content><h1 id=pg-8b996bf57bd8e67340235da1a1fb8e95>3.1.1 - Установка Kubernetes с помощью Minikube</h1><p>Minikube — это инструмент, позволяющий легко запускать Kubernetes на локальной машине. Для тех, кто хочет попробовать Kubernetes или рассмотреть возможность его использования в повседневной разработке, Minikube станет отличным вариантом, потому что он запускает одноузловой кластер Kubernetes внутри виртуальной машины (VM) на компьютере пользователя.</p><h2 id=возможности-minikube>Возможности Minikube</h2><p>Minikube поддерживает следующие возможности Kubernetes:</p><ul><li>DNS</li><li>Сервисы NodePort</li><li>Словари конфигурации (ConfigMaps) и секреты (Secrets)</li><li>Панель управления (Dashboard)</li><li>Среда выполнения контейнера: Docker, <a href=https://cri-o.io/>CRI-O</a> и <a href=https://github.com/containerd/containerd>containerd</a></li><li>Поддержка CNI (Container Network Interface)</li><li>Ingress</li></ul><h2 id=установка>Установка</h2><p>Посмотрите страницу <a href=/ru/docs/tasks/tools/install-minikube/>Установка Minikube</a>.</p><h2 id=краткое-руководство>Краткое руководство</h2><p>Эта простая демонстрация поможет запустить, использовать и удалить Minikube на локальной машине. Следуйте перечисленным ниже шагам, чтобы начать знакомство с Minikube.</p><ol><li><p>Запустите Minikube и создайте кластер:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start
</span></span></code></pre></div><p>Вывод будет примерно следующим:</p><pre tabindex=0><code>Starting local Kubernetes cluster...
Running pre-create checks...
Creating machine...
Starting local Kubernetes cluster...
</code></pre><p>Дополнительную информацию о запуске кластера в определенной версии Kubernetes, виртуальной машине или среде выполнения контейнера смотрите в разделе <a href=#%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-%D0%BA%D0%BB%D0%B0%D1%81%D1%82%D0%B5%D1%80%D0%B0>Запуск кластера</a>.</p></li><li><p>Теперь вы можете работать со своим кластером через CLI-инструмент kubectl. Для получения дополнительной информации смотрите раздел <a href=#%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BA%D0%BB%D0%B0%D1%81%D1%82%D0%B5%D1%80%D0%BE%D0%BC>Работа с кластером</a>.</p><p>Давайте создадим развёртывание (Deployment) в Kubernetes, используя существующий образ <code>echoserver</code>, представляющий простой HTTP-сервер, и сделаем его доступным на порту 8080 с помощью <code>--port</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment hello-minikube --image<span style=color:#666>=</span>k8s.gcr.io/echoserver:1.10
</span></span></code></pre></div><p>Вывод будет примерно следующим:</p><pre tabindex=0><code>deployment.apps/hello-minikube created
</code></pre></li><li><p>Чтобы получить доступ к объекту Deployment <code>hello-minikube</code> извне, создайте объект сервиса (Service):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment hello-minikube --type<span style=color:#666>=</span>NodePort --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div><p>Опция <code>--type=NodePort</code> определяет тип сервиса.</p><p>Вывод будет примерно следующим:</p><pre tabindex=0><code>service/hello-minikube exposed
</code></pre></li><li><p>Под (Pod) <code>hello-minikube</code> теперь запущен, но нужно подождать, пока он начнёт функционировать, прежде чем обращаться к нему.</p><p>Проверьте, что под работает:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod
</span></span></code></pre></div><p>Если в столбце вывода <code>STATUS</code> выводится <code>ContainerCreating</code>, значит под все еще создается:</p><pre tabindex=0><code>NAME                              READY     STATUS              RESTARTS   AGE
hello-minikube-3383150820-vctvh   0/1       ContainerCreating   0          3s
</code></pre><p>Если в столбце <code>STATUS</code> указано <code>Running</code>, то под теперь в рабочем состоянии:</p><pre tabindex=0><code>NAME                              READY     STATUS    RESTARTS   AGE
hello-minikube-3383150820-vctvh   1/1       Running   0          13s
</code></pre></li><li><p>Узнайте URL-адрес открытого (exposed) сервиса, чтобы просмотреть подробные сведения о сервисе:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube service hello-minikube --url
</span></span></code></pre></div></li><li><p>Чтобы ознакомиться с подробной информацией о локальном кластере, скопируйте и откройте полученный из вывода команды на предыдущем шаге URL-адрес в браузере.</p><p>Вывод будет примерно следующим:</p><pre tabindex=0><code>Hostname: hello-minikube-7c77b68cff-8wdzq

Pod Information:
    -no pod information available-

Server values:
    server_version=nginx: 1.13.3 - lua: 10008

Request Information:
    client_address=172.17.0.1
    method=GET
    real path=/
    query=
    request_version=1.1
    request_scheme=http
    request_uri=http://192.168.99.100:8080/

Request Headers:
    accept=*/*
    host=192.168.99.100:30674
    user-agent=curl/7.47.0

Request Body:
    -no body in request-
</code></pre><p>Если сервис и кластер вам больше не нужны, их можно удалить.</p></li><li><p>Удалите сервис <code>hello-minikube</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete services hello-minikube
</span></span></code></pre></div><p>Вывод будет примерно следующим:</p><pre tabindex=0><code>service &#34;hello-minikube&#34; deleted
</code></pre></li><li><p>Удалите развёртывание <code>hello-minikube</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment hello-minikube
</span></span></code></pre></div><p>Вывод будет примерно следующим:</p><pre tabindex=0><code>deployment.extensions &#34;hello-minikube&#34; deleted
</code></pre></li><li><p>Остановите локальный кластер Minikube:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube stop
</span></span></code></pre></div><p>Вывод будет примерно следующим:</p><pre tabindex=0><code>Stopping &#34;minikube&#34;...
&#34;minikube&#34; stopped.
</code></pre><p>Подробности смотрите в разделе <a href=#%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%BA%D0%BB%D0%B0%D1%81%D1%82%D0%B5%D1%80%D0%B0>Остановка кластера</a>.</p></li><li><p>Удалите локальный кластер Minikube:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube delete
</span></span></code></pre></div><p>Вывод будет примерно следующим:</p><pre tabindex=0><code>Deleting &#34;minikube&#34; ...
The &#34;minikube&#34; cluster has been deleted.
</code></pre><p>Подробности смотрите в разделе <a href=#%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BB%D0%B0%D1%81%D1%82%D0%B5%D1%80%D0%B0>Удаление кластера</a>.</p></li></ol><h2 id=управление-кластером>Управление кластером</h2><h3 id=запуск-кластера>Запуск кластера</h3><p>Команда <code>minikube start</code> используется для запуска кластера.
Эта команда создаёт и конфигурирует виртуальную машину, которая запускает одноузловой кластер Kubernetes.
Эта команда также настраивает вашу установку <a href=/docs/user-guide/kubectl-overview/>kubectl</a> для взаимодействия с этим кластером.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>Если вы работаете из-под веб-прокси, вам нужно указать данные прокси в команде <code>minikube start</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>https_proxy</span><span style=color:#666>=</span>&lt;my proxy&gt; minikube start --docker-env <span style=color:#b8860b>http_proxy</span><span style=color:#666>=</span>&lt;my proxy&gt; --docker-env <span style=color:#b8860b>https_proxy</span><span style=color:#666>=</span>&lt;my proxy&gt; --docker-env <span style=color:#b8860b>no_proxy</span><span style=color:#666>=</span>192.168.99.0/24
</span></span></code></pre></div><p>К сожалению, установка переменных окружения не cработает.</p><p>Minikube также создает контекст "minikube" и устанавливает его по умолчанию в kubectl.
Чтобы вернуться к этому контексту, выполните следующую команду: <code>kubectl config use-context minikube</code>.</p></div><h4 id=указание-версии-kubernetes>Указание версии Kubernetes</h4><p>Вы можете указать используемую версию Kubernetes в Minikube, добавив параметр <code>--kubernetes-version</code> в команду <code>minikube start</code>. Например, чтобы запустить Minikube из-под версии v1.25.0, вам нужно выполнить следующую команду:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start --kubernetes-version v1.25.0
</span></span></code></pre></div><h4 id=указание-драйвера-виртуальной-машины>Указание драйвера виртуальной машины</h4><p>Вы можете изменить драйвер виртуальной машины, добавив флаг <code>--vm-driver=&lt;enter_driver_name></code> в команду <code>minikube start</code>.</p><p>Тогда команда будет выглядеть так:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start --vm-driver<span style=color:#666>=</span>&lt;driver_name&gt;
</span></span></code></pre></div><p>Minikube поддерживает следующие драйверы:</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Смотрите страницу <a href=https://minikube.sigs.k8s.io/docs/reference/drivers/>DRIVERS</a> для получения подробной информации о поддерживаемых драйверах и как устанавливать плагины.</div><ul><li>virtualbox</li><li>vmwarefusion</li><li>docker (ЭКСПЕРИМЕНТАЛЬНЫЙ)</li><li>kvm2 (<a href=https://minikube.sigs.k8s.io/docs/reference/drivers/kvm2/>установка драйвера</a>)</li><li>hyperkit (<a href=https://minikube.sigs.k8s.io/docs/reference/drivers/hyperkit/>установка драйвера</a>)</li><li>hyperv (<a href=https://minikube.sigs.k8s.io/docs/reference/drivers/hyperv/>установка драйвера</a>)
Обратите внимание, что указанный IP-адрес на этой странице является динамическим и может изменяться. Его можно получить с помощью <code>minikube ip</code>.</li><li>vmware (<a href=https://minikube.sigs.k8s.io/docs/reference/drivers/vmware/>установка драйвера</a>) (VMware unified driver)</li><li>parallels (<a href=https://minikube.sigs.k8s.io/docs/reference/drivers/parallels/>установка драйвера</a>)</li><li>none (Запускает компоненты Kubernetes на хосте, а не на виртуальной машине. Использование этого драйвера требует использование Linux и установленного <a class=glossary-tooltip title='Docker — это программное обеспечение для виртуализации на уровне операционной системы, которая известна как контейнеризация.' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>.)</li></ul><div class="alert alert-warning caution callout" role=alert><strong>Внимание:</strong> Если вы используете драйвер <code>none</code>, некоторые компоненты Kubernetes запускаются как привилегированные контейнеры, которые имеют побочные эффекты вне окружения Minikube. Эти побочные эффекты означают, что драйвер <code>none</code> не рекомендуется использовать в личных рабочих станций.</div><h4 id=запуск-кластера-в-других-средах-выполнения-контейнеров>Запуск кластера в других средах выполнения контейнеров</h4><p>Вы можете запустить Minikube в следующих средах выполнения контейнеров.</p><ul class="nav nav-tabs" id=container-runtimes role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#container-runtimes-0 role=tab aria-controls=container-runtimes-0 aria-selected=true>containerd</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#container-runtimes-1 role=tab aria-controls=container-runtimes-1>CRI-O</a></li></ul><div class=tab-content id=container-runtimes><div id=container-runtimes-0 class="tab-pane show active" role=tabpanel aria-labelledby=container-runtimes-0><p><p>Чтобы использовать <a href=https://github.com/containerd/containerd>containerd</a> в качестве среды выполнения контейнера, выполните команду ниже:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>minikube start <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --network-plugin<span style=color:#666>=</span>cni <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --enable-default-cni <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --container-runtime<span style=color:#666>=</span>containerd <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --bootstrapper<span style=color:#666>=</span>kubeadm
</span></span></code></pre></div><p>Также можете использовать расширенную вариант команды:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>minikube start <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --network-plugin<span style=color:#666>=</span>cni <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --enable-default-cni <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --extra-config<span style=color:#666>=</span>kubelet.container-runtime<span style=color:#666>=</span>remote <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --extra-config<span style=color:#666>=</span>kubelet.container-runtime-endpoint<span style=color:#666>=</span>unix:///run/containerd/containerd.sock <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --extra-config<span style=color:#666>=</span>kubelet.image-service-endpoint<span style=color:#666>=</span>unix:///run/containerd/containerd.sock <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --bootstrapper<span style=color:#666>=</span>kubeadm
</span></span></code></pre></div></div><div id=container-runtimes-1 class=tab-pane role=tabpanel aria-labelledby=container-runtimes-1><p><p>Чтобы использовать <a href=https://cri-o.io/>CRI-O</a> в качестве среды выполнения контейнера, выполните команду ниже:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>minikube start <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --network-plugin<span style=color:#666>=</span>cni <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --enable-default-cni <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --container-runtime<span style=color:#666>=</span>cri-o <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --bootstrapper<span style=color:#666>=</span>kubeadm
</span></span></code></pre></div><p>Также можете использовать расширенную вариант команды:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>minikube start <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --network-plugin<span style=color:#666>=</span>cni <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --enable-default-cni <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --extra-config<span style=color:#666>=</span>kubelet.container-runtime<span style=color:#666>=</span>remote <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --extra-config<span style=color:#666>=</span>kubelet.container-runtime-endpoint<span style=color:#666>=</span>/var/run/crio.sock <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --extra-config<span style=color:#666>=</span>kubelet.image-service-endpoint<span style=color:#666>=</span>/var/run/crio.sock <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --bootstrapper<span style=color:#666>=</span>kubeadm
</span></span></code></pre></div></div></div><h4 id=использование-локальных-образов-путём-повторного-использования-демона-docker>Использование локальных образов путём повторного использования демона Docker</h4><p>При использовании одной виртуальной машины для Kubernetes легко повторно использовать демон Docker, встроенный в Minikube. В этом случае нет необходимости создавать реестр Docker на вашей хост-машине и отправлять образ туда. Вместо этого вы можете создать реестр внутри того же демона Docker, который использует Minikube, что позволит ускорить локальные запуски.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Обязательно пометьте собственным тегом Docker-образ, и затем при получении образа всегда указывайте его. Так как <code>:latest</code> — это тег по умолчанию, поэтому наряду с соответствующей стандартной политикой получения образа, равной <code>Always</code>, в конечном итоге возникнет ошибка при получении образа (<code>ErrImagePull</code>), если Docker-образ не найден в базовом реестре Docker (как правило, в DockerHub).</div><p>Для работы с Docker-демоном на вашем хосте под управлением Mac/Linux, запустите последнюю строку из вывода команды <code>minikube docker-env</code>.</p><p>Теперь вы можете использовать Docker в командной строке вашего хост-компьютера на Mac/Linux для взаимодействия с демоном Docker внутри виртуальной машины Minikube:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>На Centos 7 Docker может возникнуть следующая ошибка:</p><pre tabindex=0><code>Could not read CA certificate &#34;/etc/docker/ca.pem&#34;: open /etc/docker/ca.pem: no such file or directory
</code></pre><p>Для исправления этой ошибки обновите файл <code>/etc/sysconfig/docker</code>, чтобы учитывались изменения в среде Minikube:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&lt; <span style=color:#b8860b>DOCKER_CERT_PATH</span><span style=color:#666>=</span>/etc/docker
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>&gt; <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>[</span> -z <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>DOCKER_CERT_PATH</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span> <span style=color:#666>]</span>; <span style=color:#a2f;font-weight:700>then</span>
</span></span><span style=display:flex><span>&gt;   <span style=color:#b8860b>DOCKER_CERT_PATH</span><span style=color:#666>=</span>/etc/docker
</span></span><span style=display:flex><span>&gt; <span style=color:#a2f;font-weight:700>fi</span>
</span></span></code></pre></div></div><h3 id=конфигурация-kubernetes>Конфигурация Kubernetes</h3><p>Minikube имеет такую возможность как "конфигуратор" ("configurator"), позволяющая пользователям настраивать компоненты Kubernetes произвольными значениями.
Чтобы использовать эту возможность, используйте флаг <code>--extra-config</code> в команде <code>minikube start</code>.</p><p>Этот флаг можно дублировать, поэтому вы можете указать его несколько раз с несколькими разными значениями, чтобы установить несколько опций.</p><p>Этот флаг принимает строку вида <code>component.key=value</code>, где <code>component</code> — это одно из значение в приведённом ниже списка, <code>key</code> — ключ из структуры конфигурации, а <code>value</code> — значение, которое нужно установить.</p><p>Допустимые ключи можно найти в документации по <code>componentconfigs</code> в Kubernetes каждого компонента.
Ниже вы найдете документации по каждой поддерживаемой конфигурации:</p><ul><li><a href=https://godoc.org/k8s.io/kubernetes/pkg/kubelet/apis/config#KubeletConfiguration>kubelet</a></li><li><a href=https://godoc.org/k8s.io/kubernetes/cmd/kube-apiserver/app/options#ServerRunOptions>apiserver</a></li><li><a href=https://godoc.org/k8s.io/kubernetes/pkg/proxy/apis/config#KubeProxyConfiguration>proxy</a></li><li><a href=https://godoc.org/k8s.io/kubernetes/pkg/controller/apis/config#KubeControllerManagerConfiguration>controller-manager</a></li><li><a href=https://godoc.org/github.com/coreos/etcd/etcdserver#ServerConfig>etcd</a></li><li><a href=https://godoc.org/k8s.io/kubernetes/pkg/scheduler/apis/config#KubeSchedulerConfiguration>scheduler</a></li></ul><h4 id=примеры>Примеры</h4><p>Чтобы изменить настройку <code>MaxPods</code> на значение 5 в Kubelet, передайте этот флаг <code>--extra-config=kubelet.MaxPods=5</code>.</p><p>Эта возможность также поддерживает вложенные структуры. Для изменения настройки <code>LeaderElection.LeaderElect</code> на значение <code>true</code> в планировщике, передайте флаг <code>--extra-config=scheduler.LeaderElection.LeaderElect=true</code>.</p><p>Чтобы изменить настройку <code>AuthorizationMode</code> в <code>apiserver</code> на значение <code>RBAC</code>, используйте флаг <code>--extra-config=apiserver.authorization-mode=RBAC</code>.</p><h3 id=остановка-кластера>Остановка кластера</h3><p>Команда <code>minikube stop</code> используется для остановки кластера.
Эта команда выключает виртуальную машины Minikube, но сохраняет всё состояние кластера и данные.
Повторный запуск кластера вернет его в прежнее состояние.</p><h3 id=удаление-кластера>Удаление кластера</h3><p>Команда <code>minikube delete</code> используется для удаления кластера.
Эта команда выключает и удаляет виртуальную машину Minikube.
Данные или состояние не сохраняются.</p><h3 id=обновление-minikube>Обновление minikube</h3><p>Смотрите <a href=https://minikube.sigs.k8s.io/docs/start/macos/>инструкцию по обновлению minikube</a>.</p><h2 id=работа-с-кластером>Работа с кластером</h2><h3 id=kubectl>Kubectl</h3><p>Команда <code>minikube start</code> создает <a href=/docs/reference/generated/kubectl/kubectl-commands#-em-set-context-em->контекст kubectl</a> под именем "minikube".
Этот контекст содержит конфигурацию для взаимодействия с кластером Minikube.</p><p>Minikube автоматически устанавливает этот контекст, но если вам потребуется явно использовать его в будущем, выполните команду ниже:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config use-context minikube
</span></span></code></pre></div><p>Либо передайте контекст при выполнении команды следующим образом: <code>kubectl get pods --context=minikube</code>.</p><h3 id=панель-управления>Панель управления</h3><p>Чтобы получить доступ к <a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>веб-панели управления Kubernetes</a>, запустите эту команду в командной оболочке после запуска Minikube, чтобы получить адрес:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube dashboard
</span></span></code></pre></div><h3 id=сервисы>Сервисы</h3><p>Чтобы получить доступ к сервису, открытой через порт узла, выполните команду в командной оболочке после запуска Minikube, чтобы получить адрес:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube service <span style=color:#666>[</span>-n NAMESPACE<span style=color:#666>]</span> <span style=color:#666>[</span>--url<span style=color:#666>]</span> NAME
</span></span></code></pre></div><h2 id=организация-сети>Организация сети</h2><p>Виртуальная машина Minikube доступна только хост-системе через IP-адрес, который можно получить с помощью команды <code>minikube ip</code>.
Вы можете использовать IP-адрес для доступа к любому сервису типа <code>NodePort</code>.</p><p>Чтобы определить NodePort для вашего сервиса, вы можете использовать такую команду <code>kubectl</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get service <span style=color:#b8860b>$SERVICE</span> --output<span style=color:#666>=</span><span style=color:#b44>&#39;jsonpath=&#34;{.spec.ports[0].nodePort}&#34;&#39;</span>
</span></span></code></pre></div><h2 id=постоянные-тома>Постоянные тома</h2><p>Minikube поддерживает <a href=/docs/concepts/storage/persistent-volumes/>PersistentVolumes</a> типа <code>hostPath</code>.
Эти постоянные тома монтируются в виртуальную машину Minikube.</p><p>Виртуальная машина Minikube загружается в файловую систему tmpfs, поэтому большинство директорий не будет сохранено при перезагрузках (<code>minikube stop</code>).
Однако Minikube сконфигурирован на сохранение файлов, хранящихся в перечисленных ниже директорий хоста.</p><ul><li><code>/data</code></li><li><code>/var/lib/minikube</code></li><li><code>/var/lib/docker</code></li></ul><p>Пример конфигурации PersistentVolume для сохранения данных в директории <code>/data</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv0001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/data/pv0001/<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=смонтированные-директории-хоста>Смонтированные директории хоста</h2><p>Некоторые драйверы монтируют директорию хоста в виртуальную машину, чтобы можно было легко обмениваться файлами между виртуальной машиной и хостом. В настоящее время это не настраивается и отличается от используемого драйвера и ОС.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Совместное использование директории хоста еще не реализовано в драйвере KVM.</div><table><thead><tr><th>Driver</th><th>OS</th><th>HostFolder</th><th>VM</th></tr></thead><tbody><tr><td>VirtualBox</td><td>Linux</td><td>/home</td><td>/hosthome</td></tr><tr><td>VirtualBox</td><td>macOS</td><td>/Users</td><td>/Users</td></tr><tr><td>VirtualBox</td><td>Windows</td><td>C://Users</td><td>/c/Users</td></tr><tr><td>VMware Fusion</td><td>macOS</td><td>/Users</td><td>/mnt/hgfs/Users</td></tr><tr><td>Xhyve</td><td>macOS</td><td>/Users</td><td>/Users</td></tr></tbody></table><h2 id=приватные-реестры-контейнеров>Приватные реестры контейнеров</h2><p>Для доступа к реестру приватных контейнеров, выполните шаги, описанные на <a href=/docs/concepts/containers/images/>этой странице</a>.</p><p>Мы рекомендуем использовать <code>ImagePullSecrets</code>, но если вам нужно обратиться к нему из виртуальной машины Minikube, нужно поместить файл <code>.dockercfg</code> в директорию <code>/home/docker</code> или <code>config.json</code> в директорию <code>/home/docker/.docker</code>.</p><h2 id=дополнения>Дополнения</h2><p>Для того, чтобы Minikube смог запустить или перезапустить пользовательские дополнения, поместите дополнения, которые вы хотите запускать с помощью Minikube, в директорию <code>~/.minikube/addons</code>. Дополнения в этой директории будут перемещены в виртуальную машину Minikube и запускаться каждый раз при запуске или перезапуске Minikube.</p><h2 id=использование-minikube-с-помощью-http-прокси>Использование Minikube с помощью HTTP-прокси</h2><p>Minikube создаёт виртуальную машину, включающая в себя Kubernetes и демон Docker.
Когда Kubernetes планирует выполнение контейнеров с использованием Docker, демону Docker может потребоваться доступ к внешней сети для получения контейнеров.</p><p>Если вы работаете через HTTP-прокси, вам нужно сконфигурировать настройки прокси для Docker.
Для этого нужно передать необходимые переменные окружения в флаги перед выполнением команды <code>minikube start</code>.</p><p>Например:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start --docker-env <span style=color:#b8860b>http_proxy</span><span style=color:#666>=</span>http://<span style=color:#b8860b>$YOURPROXY</span>:PORT <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>                 --docker-env <span style=color:#b8860b>https_proxy</span><span style=color:#666>=</span>https://<span style=color:#b8860b>$YOURPROXY</span>:PORT
</span></span></code></pre></div><p>Если адрес вашей виртуальной машины 192.168.99.100, то, скорее всего, настройки прокси помешают <code>kubectl</code> обратиться к ней.
Чтобы прокси игнорировал этот IP-адрес, нужно скорректировать настройки no_proxy следующим образом:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>no_proxy</span><span style=color:#666>=</span><span style=color:#b8860b>$no_proxy</span>,<span style=color:#a2f;font-weight:700>$(</span>minikube ip<span style=color:#a2f;font-weight:700>)</span>
</span></span></code></pre></div><h2 id=известные-проблемы>Известные проблемы</h2><p>Функциональность, для которой требуется несколько узлов, не будет работать в Minikube.</p><h2 id=реализация>Реализация</h2><p>Minikube использует <a href=https://github.com/docker/machine/tree/master/libmachine>libmachine</a> для подготовки виртуальных машин и <a href=https://github.com/kubernetes/kubeadm>kubeadm</a> для инициализации кластера Kubernetes.</p><p>Для получения дополнительной информации о Minikube посмотрите <a href=https://git.k8s.io/community/contributors/design-proposals/cluster-lifecycle/local-cluster-ux.md>статью</a>.</p><h2 id=дополнительные-ссылки>Дополнительные ссылки</h2><ul><li><strong>Цели</strong>: цели проекта Minikube смотрите в <a href=https://git.k8s.io/minikube/docs/contributors/roadmap.md>дорожной карте</a>.</li><li><strong>Руководство по разработке</strong>: посмотрите <a href=https://git.k8s.io/minikube/CONTRIBUTING.md>CONTRIBUTING.md</a>, чтобы ознакомиться с тем, как отправлять пулрексты.</li><li><strong>Сборка Minikube</strong>: инструкции по сборке/тестированию Minikube из исходного кода смотрите в <a href=https://git.k8s.io/minikube/docs/contributors/build_guide.md>руководстве по сборке</a>.</li><li><strong>Добавление новой зависимости</strong>: инструкции по добавлению новой зависимости в Minikube смотрите в <a href=https://git.k8s.io/minikube/docs/contributors/adding_a_dependency.md>руководстве по добавлению зависимостей</a>.</li><li><strong>Добавление нового дополнения</strong>: инструкции по добавлению нового дополнения для Minikube смотрите в <a href=https://git.k8s.io/minikube/docs/contributors/adding_an_addon.md>руководстве по добавлению дополнений</a>.</li><li><strong>MicroK8</strong>: пользователи Linux, которые не хотят использовать виртуальную машину, могут в качестве альтернативы посмотреть в сторону <a href=https://microk8s.io/>MicroK8s</a>.</li></ul><h2 id=сообщество>Сообщество</h2><p>Помощь, вопросы и комментарии приветствуются и поощряются! Разработчики Minikube проводят время на <a href=https://kubernetes.slack.com>Slack</a> в канале #minikube (получить приглашение можно <a href=http://slack.kubernetes.io/>здесь</a>). У нас также есть <a href=https://groups.google.com/a/kubernetes.io/g/dev/>список рассылки dev@kubernetes на Google Groups</a>. Если вы отправляете сообщение в список, пожалуйста, начните вашу тему с "minikube: ".</p></div><div class=td-content style=page-break-before:always><h1 id=pg-861dedab439fb9a133b35009a34655ec>3.1.2 - Установка Kubernetes с помощью Kind</h1><p>Kind — это инструмент для запуска локальных кластеров Kubernetes с помощью "узлов" контейнера Docker.</p><h2 id=установка>Установка</h2><p>Смотрите страницу <a href=https://kind.sigs.k8s.io/docs/user/quick-start/>по установке Kind</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-89cb5486440b5e96f31dbb3956f2ad9e>3.2 - Пользовательские облачные решения</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-dd948255948d6b59b32c471abcb62997>4 - Концепции</h1><p>Раздел "Концепции" поможет вам узнать о частях системы Kubernetes и об абстракциях, которые Kubernetes использует для представления вашего <a class=glossary-tooltip title='Набор машин, так называемые узлы, которые запускают контейнеризированные приложения. Кластер имеет как минимум один рабочий узел.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=кластера>кластера</a>, и помогает вам глубже понять, как работает Kubernetes.</p><h2 id=краткий-обзор>Краткий обзор</h2><p>Чтобы работать с Kubernetes, вы используете <em>объекты API Kubernetes</em> для описания <em>желаемого состояния вашего кластера</em>: какие приложения или другие рабочие нагрузки вы хотите запустить, какие образы контейнеров они используют, количество реплик, какие сетевые и дисковые ресурсы вы хотите использовать и сделать доступными и многое другое. Вы устанавливаете желаемое состояние, создавая объекты с помощью API Kubernetes, обычно через интерфейс командной строки <code>kubectl</code>. Вы также можете напрямую использовать API Kubernetes для взаимодействия с кластером и установки или изменения желаемого состояния.</p><p>После того, как вы установили желаемое состояние, <em>Плоскость управления Kubernetes</em> заставляет текущее состояние кластера соответствовать желаемому состоянию с помощью генератора событий жизненного цикла подов (<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md>Pod Lifecycle Event Generator, PLEG</a>). Для этого Kubernetes автоматически выполняет множество задач, таких как запуск или перезапуск контейнеров, масштабирование количества реплик данного приложения и многое другое. Плоскость управления Kubernetes состоит из набора процессов, запущенных в вашем кластере:</p><ul><li><strong>Мастер Kubernetes</strong> — это коллекция из трех процессов, которые выполняются на одном узле в вашем кластере, который обозначен как главный узел. Это процессы: <a href=/docs/admin/kube-apiserver/>kube-apiserver</a>, <a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a> и <a href=/docs/admin/kube-scheduler/>kube-scheduler</a>.</li><li>Каждый отдельный неосновной узел в вашем кластере выполняет два процесса:<ul><li><strong><a href=/docs/admin/kubelet/>kubelet</a></strong>, который взаимодействует с мастером Kubernetes.</li><li><strong><a href=/docs/admin/kube-proxy/>kube-proxy</a></strong>, сетевой прокси, который обрабатывает сетевые сервисы Kubernetes на каждом узле.</li></ul></li></ul><h2 id=объекты-kubernetes>Объекты Kubernetes</h2><p>Kubernetes содержит ряд абстракций, которые представляют состояние вашей системы: развернутые контейнеризованные приложения и рабочие нагрузки, связанные с ними сетевые и дисковые ресурсы и другую информацию о том, что делает ваш кластер. Эти абстракции представлены объектами в API Kubernetes. См. <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects>Понимание объектов Kubernetes</a> для получения более подробной информации.</p><p>Основные объекты Kubernetes включают в себя:</p><ul><li><a href=/docs/concepts/workloads/pods/pod-overview/>Pod</a></li><li><a href=/docs/concepts/services-networking/service/>Service</a></li><li><a href=/docs/concepts/storage/volumes/>Том</a></li><li><a href=/docs/concepts/overview/working-with-objects/namespaces/>Namespace</a></li></ul><p>Kubernetes также содержит абстракции более высокого уровня, которые опираются на <a href=/docs/concepts/architecture/controller/>Контроллеры</a> для создания базовых объектов и предоставляют дополнительные функциональные и удобные функции. Они включают:</p><ul><li><a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a></li><li><a href=/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li><li><a href=/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a></li><li><a href=/docs/concepts/workloads/controllers/jobs-run-to-completion/>Job</a></li></ul><h2 id=плоскость-управления-kubernetes>Плоскость управления Kubernetes</h2><p>Различные части панели управления Kubernetes, такие как мастер Kubernetes и процессы kubelet, определяют, как Kubernetes взаимодействует с кластером. Плоскость управления поддерживает запись всех объектов Kubernetes в системе и запускает непрерывные циклы управления для обработки состояния этих объектов. В любое время циклы управления панели управления будут реагировать на изменения в кластере и работать, чтобы фактическое состояние всех объектов в системе соответствовало желаемому состоянию, которое вы указали.</p><p>Например, когда вы используете API Kubernetes для создания развертывания, вы предоставляете новое желаемое состояние для системы. Плоскость управления Kubernetes записывает создание этого объекта и выполняет ваши инструкции, запуская необходимые приложения и планируя их на узлы кластера, чтобы фактическое состояние кластера соответствовало желаемому состоянию.</p><h3 id=мастер-kubernetes>Мастер Kubernetes</h3><p>Мастер Kubernetes отвечает за поддержание желаемого состояния для вашего кластера. Когда вы взаимодействуете с Kubernetes, например, используя интерфейс командной строки <code>kubectl</code>, вы работаете с мастером Kubernetes вашего кластера.</p><blockquote><p>Под "мастером" понимается совокупность процессов, которые управляют состоянием кластера. Обычно все эти процессы выполняются на одном узле кластера, и поэтому этот узел называется главным (master). Мастер также может быть реплицирован для доступности и резервирования.</p></blockquote><h3 id=узлы-kubernetes>Узлы Kubernetes</h3><p>Узлы в кластере - это машины (виртуальные машины, физические серверы и т.д.), на которых работают ваши приложения и облачные рабочие процессы. Мастер Kubernetes контролирует каждый узел; вы редко будете взаимодействовать с узлами напрямую.</p><h2 id=что-дальше>Что дальше</h2><p>Если вы хотите описать концепт, обратитесь к странице
<a href=/docs/home/contribute/page-templates/>Использование шаблонов страниц</a>
для получения информации о типе страницы и шаблоне концепции.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>4.1 - Обзор</h1></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>4.1.1 - Что такое Kubernetes</h1><p>Эта страница посвящена краткому обзору Kubernetes.</p><p>Kubernetes — это портативная расширяемая платформа с открытым исходным кодом для управления контейнеризованными рабочими нагрузками и сервисами, которая облегчает как декларативную настройку, так и автоматизацию. У платформы есть большая, быстро растущая экосистема. Сервисы, поддержка и инструменты Kubernetes широко доступны.</p><p>Название Kubernetes происходит от греческого, что означает рулевой или штурман. Google открыл исходный код Kubernetes в 2014 году. Kubernetes основывается на <a href=https://research.google/pubs/pub43438>десятилетнем опыте работы Google с масштабными рабочими нагрузками</a>, в сочетании с лучшими в своем классе идеями и практиками сообщества.</p><h2 id=история>История</h2><p>Давайте вернемся назад и посмотрим, почему Kubernetes так полезен.</p><p><img src=/images/docs/Container_Evolution.svg alt="Эволюция развертывания"></p><p><strong>Традиционная эра развертывания:</strong>
Ранее организации запускали приложения на физических серверах. Не было никакого способа определить границы ресурсов для приложений на физическом сервере, и это вызвало проблемы с распределением ресурсов. Например, если несколько приложений выполняются на физическом сервере, могут быть случаи, когда одно приложение будет занимать большую часть ресурсов, и в результате чего другие приложения будут работать хуже. Решением этого было запустить каждое приложение на другом физическом сервере. Но это не масштабировалось, поскольку ресурсы использовались не полностью, из-за чего организациям было накладно поддерживать множество физических серверов.</p><p><strong>Эра виртуального развертывания:</strong> В качестве решения была представлена виртуализация. Она позволила запускать несколько виртуальных машин (ВМ) на одном физическом сервере. Виртуализация изолирует приложения между виртуальными машинами и обеспечивает определенный уровень безопасности, поскольку информация одного приложения не может быть свободно доступна другому приложению.</p><p>Виртуализация позволяет лучше использовать ресурсы на физическом сервере и обеспечивает лучшую масштабируемость, поскольку приложение можно легко добавить или обновить, кроме этого снижаются затраты на оборудование и многое другое. С помощью виртуализации можно превратить набор физических ресурсов в кластер одноразовых виртуальных машин.</p><p>Каждая виртуальная машина представляет собой полноценную машину, на которой выполняются все компоненты, включая собственную операционную систему, поверх виртуализированного оборудования.</p><p><strong>Эра контейнеров:</strong> Контейнеры похожи на виртуальные машины, но у них есть свойства изоляции для совместного использования операционной системы (ОС) между приложениями. Поэтому контейнеры считаются легкими. Подобно виртуальной машине, контейнер имеет свою собственную файловую систему, процессор, память, пространство процесса и многое другое. Поскольку они не связаны с базовой инфраструктурой, они переносимы между облаками и дистрибутивами ОС.</p><p>Контейнеры стали популярными из-за таких дополнительных преимуществ как:</p><ul><li>Гибкое создание и развертывание приложений: простота и эффективность создания образа контейнера по сравнению с использованием образа виртуальной машины.</li><li>Непрерывная разработка, интеграция и развертывание: обеспечивает надежную и частую сборку и развертывание образа контейнера с быстрым и простым откатом (благодаря неизменности образа).</li><li>Разделение задач между Dev и Ops: создавайте образы контейнеров приложений во время сборки/релиза, а не во время развертывания, тем самым отделяя приложения от инфраструктуры.</li><li>Наблюдаемость охватывает не только информацию и метрики на уровне ОС, но также информацию о работоспособности приложений и другие сигналы.</li><li>Идентичная окружающая среда при разработке, тестировании и релизе: на ноутбуке работает так же, как и в облаке.</li><li>Переносимость облачных и операционных систем: работает на Ubuntu, RHEL, CoreOS, on-prem, Google Kubernetes Engine и в любом другом месте.</li><li>Управление, ориентированное на приложения: повышает уровень абстракции от запуска ОС на виртуальном оборудовании до запуска приложения в ОС с использованием логических ресурсов.</li><li>Слабосвязанные, распределенные, гибкие, выделенные микросервисы: вместо монолитного стека на одной большой выделенной машине, приложения разбиты на более мелкие независимые части, которые можно динамически развертывать и управлять.</li><li>Изоляция ресурсов: предсказуемая производительность приложения.</li><li>Грамотное использование ресурсов: высокая эффективность и компактность.</li></ul><h2 id=зачем-вам-kubernetes-и-что-он-может-сделать>Зачем вам Kubernetes и что он может сделать?</h2><p>Контейнеры — отличный способ связать и запустить ваши приложения. В производственной среде необходимо управлять контейнерами, которые запускают приложения, и гарантировать отсутствие простоев. Например, если контейнер выходит из строя, необходимо запустить другой контейнер. Не было бы проще, если бы такое поведение обрабатывалось системой?</p><p>Вот тут Kubernetes приходит на помощь! Kubernetes дает вам фреймворк для гибкой работы распределенных систем. Он занимается масштабированием и обработкой ошибок в приложении, предоставляет шаблоны развертывания и многое другое. Например, Kubernetes может легко управлять канареечным развертыванием вашей системы.</p><p>Kubernetes предоставляет вам:</p><ul><li><strong>Мониторинг сервисов и распределение нагрузки</strong>
Kubernetes может обнаружить контейнер, используя имя DNS или собственный IP-адрес. Если трафик в контейнере высокий, Kubernetes может сбалансировать нагрузку и распределить сетевой трафик, чтобы развертывание было стабильным.</li><li><strong>Оркестрация хранилища</strong>
Kubernetes позволяет вам автоматически смонтировать систему хранения по вашему выбору, такую как локальное хранилище, провайдеры общедоступного облака и многое другое.</li><li><strong>Автоматическое развертывание и откаты</strong>
Используя Kubernetes можно описать желаемое состояние развернутых контейнеров и изменить фактическое состояние на желаемое. Например, вы можете автоматизировать Kubernetes на создание новых контейнеров для развертывания, удаления существующих контейнеров и распределения всех их ресурсов в новый контейнер.</li><li><strong>Автоматическое распределение нагрузки</strong>
Вы предоставляете Kubernetes кластер узлов, который он может использовать для запуска контейнерных задач. Вы указываете Kubernetes, сколько ЦП и памяти (ОЗУ) требуется каждому контейнеру. Kubernetes может разместить контейнеры на ваших узлах так, чтобы наиболее эффективно использовать ресурсы.</li><li><strong>Самоконтроль</strong>
Kubernetes перезапускает отказавшие контейнеры, заменяет и завершает работу контейнеров, которые не проходят определенную пользователем проверку работоспособности, и не показывает их клиентам, пока они не будут готовы к обслуживанию.</li><li><strong>Управление конфиденциальной информацией и конфигурацией</strong>
Kubernetes может хранить и управлять конфиденциальной информацией, такой как пароли, OAuth-токены и ключи SSH. Вы можете развертывать и обновлять конфиденциальную информацию и конфигурацию приложения без изменений образов контейнеров и не раскрывая конфиденциальную информацию в конфигурации стека.</li></ul><h2 id=чем-kubernetes-не-является>Чем Kubernetes не является</h2><p>Kubernetes ― это не традиционная комплексная система PaaS (платформа как услуга). Поскольку Kubernetes работает на уровне контейнеров, а не на уровне оборудования, у него имеется определенные общеприменимые возможности, характерные для PaaS, такие как развертывание, масштабирование, балансировка нагрузки, ведение журналов и мониторинг. Тем не менее, Kubernetes это не монолитное решение, поэтому указанные возможности по умолчанию являются дополнительными и подключаемыми. У Kubernetes есть компоненты для создания платформы разработчика, но он сохраняет право выбора за пользователем и гибкость там, где это важно.</p><p>Kubernetes:</p><ul><li>Не ограничивает типы поддерживаемых приложений. Kubernetes стремится поддерживать широкий спектр рабочих нагрузок, включая те, у которых есть или отсутствует состояние, а также связанные с обработкой данных. Если приложение может работать в контейнере, оно должно отлично работать и в Kubernetes.</li><li>Не развертывает исходный код и не собирает приложение. Рабочие процессы непрерывной интеграции, доставки и развертывания (CI/CD) определяются культурой и предпочтениями организации, а также техническими требованиями.</li><li>Не предоставляет сервисы для приложения, такие как промежуточное программное обеспечение (например, очереди сообщений), платформы обработки данных (например, Spark), базы данных (например, MySQL), кеши или кластерные системы хранения (например, Ceph), как встроенные сервисы. Такие компоненты могут работать в Kubernetes и/или могут быть доступны для приложений, работающих в Kubernetes, через переносные механизмы, такие как Open Service Broker.</li><li>Не включает решения для ведения журнала, мониторинга или оповещения. Он обеспечивает некоторые интеграции в качестве доказательства концепции и механизмы для сбора и экспорта метрик.</li><li>Не указывает и не требует настройки языка/системы (например, Jsonnet). Он предоставляет декларативный API, который может быть нацелен на произвольные формы декларативных спецификаций.</li><li>Не предоставляет и не принимает никаких комплексных систем конфигурации, технического обслуживания, управления или самовосстановления.</li><li>Кроме того, Kubernetes — это не просто система оркестрации. Фактически, Kubernetes устраняет необходимость в этом. Техническое определение оркестрации — это выполнение определенного рабочего процесса: сначала сделай A, затем B, затем C. Напротив, Kubernetes содержит набор независимых, компонуемых процессов управления, которые непрерывно переводит текущее состояние к предполагаемому состоянию. Неважно, как добраться от А до С. Не требуется также централизованный контроль. Это делает систему более простой в использовании, более мощной, надежной, устойчивой и расширяемой.</li></ul><h2 id=что-дальше>Что дальше</h2><ul><li>Изучите <a href=/docs/concepts/overview/components/>Компоненты Kubernetes</a></li><li>Готовы <a href=/docs/setup/>начать</a>?</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>4.1.2 - Компоненты Kubernetes</h1><p>При развёртывании Kubernetes вы имеете дело с кластером.<p><p>Кластер Kubernetes cluster состоит из набор машин, так называемые узлы, которые запускают контейнеризированные приложения. Кластер имеет как минимум один рабочий узел.</p></p><p>В рабочих узлах размещены поды, являющиеся компонентами приложения. Плоскость управления управляет рабочими узлами и подами в кластере. В промышленных средах плоскость управления обычно запускается на нескольких компьютерах, а кластер, как правило, развёртывается на нескольких узлах, гарантируя отказоустойчивость и высокую надёжность.</p></p><p>На этой странице в общих чертах описывается различные компоненты, необходимые для работы кластера Kubernetes.</p><p>Ниже показана диаграмма кластера Kubernetes со всеми связанными компонентами.</p><p><img src=/images/docs/components-of-kubernetes.png alt="Компоненты Kubernetes"></p><h2 id=плоскость-управления-компонентами>Плоскость управления компонентами</h2><p>Компоненты панели управления отвечают за основные операции кластера (например, планирование), а также обрабатывают события кластера (например, запускают новый <a class=glossary-tooltip title='Самый маленький и простой объект в Kubernetes. Под — это набор запущенных контейнеров в кластере.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=под>под</a>, когда поле <code>replicas</code> развертывания не соответствует требуемому количеству реплик).</p><p>Компоненты панели управления могут быть запущены на любой машине в кластере. Однако для простоты сценарии настройки обычно запускают все компоненты панели управления на одном компьютере и в то же время не позволяют запускать пользовательские контейнеры на этом компьютере. Смотрите страницу <a href=/docs/admin/high-availability/>Создание высоконадёжных кластеров</a> для примера настройки нескольких ведущих виртуальных машин.</p><h3 id=kube-apiserver>kube-apiserver</h3><p>Сервер API — компонент Kubernetes
<a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='панели управления'>панели управления</a>, который представляет API Kubernetes.
API-сервер — это клиентская часть панели управления Kubernetes</p><p>Основной реализацией API-сервера Kubernetes является <a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a>.
kube-apiserver предназначен для горизонтального масштабирования, то есть развёртывание на несколько экземпляров.
Вы можете запустить несколько экземпляров kube-apiserver и сбалансировать трафик между этими экземплярами.</p><h3 id=etcd>etcd</h3><p>Распределённое и высоконадёжное хранилище данных в формате "ключ-значение", которое используется как основное хранилище всех данных кластера в Kubernetes.</p><p>Если ваш кластер Kubernetes использует etcd в качестве основного хранилища, убедитесь, что у вас <a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>настроено резервное копирование</a> данных.</p><p>Вы можете найти подробную информацию о etcd в <a href=https://etcd.io/docs/>официальной документации</a>.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Компонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать.</p><p>При планировании развёртывания подов на узлах учитываются множество факторов, включая требования к ресурсам, ограничения, связанные с аппаратными/программными политиками, принадлежности (affinity) и непринадлежности (anti-affinity) узлов/подов, местонахождения данных, предельных сроков.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Компонент Control Plane запускает процессы <a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллера>контроллера</a>.</p><p>Вполне логично, что каждый <a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллер>контроллер</a> в свою очередь представляет собой отдельный процесс, и для упрощения все такие процессы скомпилированы в один двоичный файл и выполняются в одном процессе.</p><p>Эти контроллеры включают:</p><ul><li>Контроллер узла (Node Controller): уведомляет и реагирует на сбои узла.</li><li>Контроллер репликации (Replication Controller): поддерживает правильное количество подов для каждого объекта контроллера репликации в системе.</li><li>Контроллер конечных точек (Endpoints Controller): заполняет объект конечных точек (Endpoints), то есть связывает сервисы (Services) и поды (Pods).</li><li>Контроллеры учетных записей и токенов (Account & Token Controllers): создают стандартные учетные записи и токены доступа API для новых пространств имен.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3><p><a href=/docs/tasks/administer-cluster/running-cloud-controller/>cloud-controller-manager</a> запускает контроллеры, которые взаимодействуют с основными облачными провайдерами. Двоичный файл cloud-controller-manager — это альфа-функциональность, появившиеся в Kubernetes 1.6.</p><p>cloud-controller-manager запускает только циклы контроллера, относящиеся к облачному провайдеру. Вам нужно отключить эти циклы контроллера в kube-controller-manager. Вы можете отключить циклы контроллера, установив флаг <code>--cloud-provider</code> со значением <code>external</code> при запуске kube-controller-manager.</p><p>С помощью cloud-controller-manager код как облачных провайдеров, так и самого Kubernetes может разрабатываться независимо друг от друга. В предыдущих версиях код ядра Kubernetes зависел от кода, предназначенного для функциональности облачных провайдеров. В будущих выпусках код, специфичный для облачных провайдеров, должен поддерживаться самим облачным провайдером и компоноваться с cloud-controller-manager во время запуска Kubernetes.</p><p>Следующие контроллеры зависят от облачных провайдеров:</p><ul><li>Контроллер узла (Node Controller): проверяет облачный провайдер, чтобы определить, был ли удален узел в облаке после того, как он перестал работать</li><li>Контроллер маршрутов (Route Controller): настраивает маршруты в основной инфраструктуре облака</li><li>Контроллер сервисов (Service Controller): создаёт, обновляет и удаляет балансировщики нагрузки облачного провайдера.</li><li>Контроллер тома (Volume Controller): создаёт, присоединяет и монтирует тома, а также взаимодействует с облачным провайдером для оркестрации томов.</li></ul><h2 id=компоненты-узла>Компоненты узла</h2><p>Компоненты узла работают на каждом узле, поддерживая работу подов и среды выполнения Kubernetes.</p><h3 id=kubelet>kubelet</h3><p>Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде.</p><p>Утилита kubelet принимает набор PodSpecs, и гарантирует работоспособность и исправность определённых в них контейнеров. Агент kubelet не отвечает за контейнеры, не созданные Kubernetes.</p><h3 id=kube-proxy>kube-proxy</h3><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> — сетевой прокси, работающий на каждом узле в кластере, и реализующий часть концепции <a class=glossary-tooltip title='Способ представления приложения, запущенного в наборе подов, в виде сетевого сервиса.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=сервис>сервис</a>.</p><p>kube-proxy конфигурирует правила сети на узлах. При помощи них разрешаются сетевые подключения к вашими подам изнутри и снаружи кластера.</p><p>kube-proxy использует уровень фильтрации пакетов в операционной системы, если он доступен. В противном случае, kube-proxy сам обрабатывает передачу сетевого трафика.</p><h3 id=среда-выполнения-контейнера>Среда выполнения контейнера</h3><p>Среда выполнения контейнера — это программа, предназначенная для выполнения контейнеров.</p><p>Kubernetes поддерживает несколько сред для запуска контейнеров: <a class=glossary-tooltip title='Docker — это программное обеспечение для виртуализации на уровне операционной системы, которая известна как контейнеризация.' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>,
<a class=glossary-tooltip title='Среда выполнения контейнера с упором на простоту, надежность и переносимость' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>, <a class=glossary-tooltip title='Оптимизированная среда выполнения контейнеров, разработанная специально для Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>,
и любая реализация <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime
Interface)</a>.</p><h2 id=дополнения>Дополнения</h2><p>Дополнения используют ресурсы Kubernetes (<a class=glossary-tooltip title='Гарантирует, что копия Pod выполняется в наборе узлов кластера.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>, <a class=glossary-tooltip title='API-объект, управляющий реплицированным приложением.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a> и т.д.) для расширения функциональности кластера. Поскольку дополнения охватывают весь кластер, ресурсы относятся к пространству имен <code>kube-system</code>.</p><p>Некоторые из дополнений описаны ниже; более подробный список доступных расширений вы можете найти на странице <a href=/docs/concepts/cluster-administration/addons/>Дополнения</a>.</p><h3 id=dns>DNS</h3><p>Хотя прочие дополнения не являются строго обязательными, однако при этом у всех Kubernetes-кластеров должен быть <a href=/docs/concepts/services-networking/dns-pod-service/>кластерный DNS</a>, так как многие примеры предполагают его наличие.</p><p>Кластерный DNS — это DNS-сервер наряду с другими DNS-серверами в вашем окружении, который обновляет DNS-записи для сервисов Kubernetes.</p><p>Контейнеры, запущенные посредством Kubernetes, автоматически включают этот DNS-сервер в свои DNS.</p><h3 id=веб-интерфейс-dashboard>Веб-интерфейс (Dashboard)</h3><p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>Dashboard</a> — это универсальный веб-интерфейс для кластеров Kubernetes. С помощью этой панели, пользователи могут управлять и устранять неполадки кластера и приложений, работающих в кластере.</p><h3 id=мониторинг-ресурсов-контейнера>Мониторинг ресурсов контейнера</h3><p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Мониторинг ресурсов контейнера</a> записывает общие метрики о контейнерах в виде временных рядов в центральной базе данных и предлагает пользовательский интерфейс для просмотра этих данных.</p><h3 id=логирование-кластера>Логирование кластера</h3><p>Механизм <a href=/docs/concepts/cluster-administration/logging/>логирования кластера</a> отвечает за сохранение логов контейнера в централизованном хранилище логов с возможностью их поиска/просмотра.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Подробнее про <a href=/docs/concepts/architecture/nodes/>узлы</a></li><li>Подробнее про <a href=/docs/concepts/architecture/controller/>контроллеры</a></li><li>Подробнее про <a href=/docs/concepts/scheduling/kube-scheduler/>kube-scheduler</a></li><li>Официальная <a href=https://etcd.io/docs/>документация</a> etcd</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>4.1.3 - API Kubernetes</h1><p>Общие соглашения API описаны на <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>странице соглашений API</a>.</p><p>Конечные точки API, типы ресурсов и примеры описаны в <a href=/ru/docs/reference>справочнике API</a>.</p><p>Удаленный доступ к API обсуждается в <a href=/docs/reference/access-authn-authz/controlling-access/>Controlling API Access doc</a>.</p><p>API Kubernetes также служит основой декларативной схемы конфигурации системы. С помощью инструмента командной строки <a href=/ru/docs/reference/kubectl/overview/>kubectl</a> можно создавать, обновлять, удалять и получать API-объекты.</p><p>Kubernetes также сохраняет сериализованное состояние (в настоящее время в хранилище <a href=https://coreos.com/docs/distributed-configuration/getting-started-with-etcd/>etcd</a>) каждого API-ресурса.</p><p>Kubernetes как таковой состоит из множества компонентов, которые взаимодействуют друг с другом через собственные API.</p><h2 id=изменения-в-api>Изменения в API</h2><p>Исходя из нашего опыта, любая успешная система должна улучшаться и изменяться по мере появления новых сценариев использования или изменения существующих. Поэтому мы надеемся, что и API Kubernetes будет постоянно меняться и расширяться. Однако в течение продолжительного периода времени мы будем поддерживать хорошую обратную совместимость с существующими клиентами. В целом, новые ресурсы API и поля ресурсов будут добавляться часто. Удаление ресурсов или полей регулируются <a href=/docs/reference/using-api/deprecation-policy/>соответствующим процессом</a>.</p><p>Определение совместимого изменения и методы изменения API подробно описаны в <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md>документе об изменениях API</a>.</p><h2 id=определения-openapi-и-swagger>Определения OpenAPI и Swagger</h2><p>Все детали API документируется с использованием <a href=https://www.openapis.org/>OpenAPI</a>.</p><p>Начиная с Kubernetes 1.10, API-сервер Kubernetes основывается на спецификации OpenAPI через конечную точку <code>/openapi/v2</code>.
Нужный формат устанавливается через HTTP-заголовки:</p><table><thead><tr><th>Заголовок</th><th>Возможные значения</th></tr></thead><tbody><tr><td>Accept</td><td><code>application/json</code>, <code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code> (по умолчанию заголовок Content-Type установлен в <code>application/json</code> с <code>*/*</code>, допустимо также пропускать этот заголовок)</td></tr><tr><td>Accept-Encoding</td><td><code>gzip</code> (можно не передавать этот заголовок)</td></tr></tbody></table><p>До версии 1.14 конечные точки с форматом (<code>/swagger.json</code>, <code>/swagger-2.0.0.json</code>, <code>/swagger-2.0.0.pb-v1</code>, <code>/swagger-2.0.0.pb-v1.gz</code>) предоставляли спецификацию OpenAPI в разных форматах. Эти конечные точки были объявлены устаревшими и удалены в Kubernetes 1.14.</p><p><strong>Примеры получения спецификации OpenAPI</strong>:</p><table><thead><tr><th>До 1.10</th><th>С версии Kubernetes 1.10</th></tr></thead><tbody><tr><td>GET /swagger.json</td><td>GET /openapi/v2 <strong>Accept</strong>: application/json</td></tr><tr><td>GET /swagger-2.0.0.pb-v1</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf</td></tr><tr><td>GET /swagger-2.0.0.pb-v1.gz</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf <strong>Accept-Encoding</strong>: gzip</td></tr></tbody></table><p>В Kubernetes реализован альтернативный формат сериализации API, основанный на Protobuf, который в первую очередь предназначен для взаимодействия внутри кластера. Описание этого формата можно найти в <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md>проектом решении</a>, а IDL-файлы по каждой схемы — в пакетах Go, определяющих API-объекты.</p><p>До версии 1.14 apiserver Kubernetes также представлял API, который можно использовать для получения спецификации <a href=http://swagger.io/>Swagger v1.2</a> для API Kubernetes по пути <code>/swaggerapi</code>. Эта конечная точка устарела и была удалена в Kubernetes 1.14</p><h2 id=версионирование-api>Версионирование API</h2><p>Чтобы упростить удаления полей или изменение ресурсов, Kubernetes поддерживает несколько версий API, каждая из которых доступна по собственному пути, например, <code>/api/v1</code> или <code>/apis/extensions/v1beta1</code>.</p><p>Мы выбрали версионирование API, а не конкретных ресурсов или полей, чтобы API отражал четкое и согласованное представление о системных ресурсах и их поведении, а также, чтобы разграничивать API, которые уже не поддерживаются и/или находятся в экспериментальной стадии. Схемы сериализации JSON и Protobuf следуют одним и тем же правилам по внесению изменений в схему, поэтому описание ниже охватывают оба эти формата.</p><p>Обратите внимание, что версионирование API и программное обеспечение косвенно связаны друг с другом. <a href=https://git.k8s.io/community/contributors/design-proposals/release/versioning.md>Предложение по версионированию API и новых выпусков</a> описывает, как связаны между собой версии API с версиями программного обеспечения.</p><p>Разные версии API характеризуются разными уровнями стабильности и поддержки. Критерии каждого уровня более подробно описаны в <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions>документации изменений API</a>. Ниже приводится краткое изложение:</p><ul><li>Альфа-версии:<ul><li>Названия версий включают надпись <code>alpha</code> (например, <code>v1alpha1</code>).</li><li>Могут содержать баги. Включение такой функциональности может привести к ошибкам. По умолчанию она отключена.</li><li>Поддержка функциональности может быть прекращена в любое время без какого-либо оповещения об этом.</li><li>API может быть несовместим с более поздними версиями без упоминания об этом.</li><li>Рекомендуется для использования только в тестировочных кластерах с коротким жизненным циклом из-за высокого риска наличия багов и отсутствия долгосрочной поддержки.</li></ul></li><li>Бета-версии:<ul><li>Названия версий включают надпись <code>beta</code> (например, <code>v2beta3</code>).</li><li>Код хорошо протестирован. Активация этой функциональности — безопасно. Поэтому она включена по умолчанию.</li><li>Поддержка функциональности в целом не будет прекращена, хотя кое-что может измениться.</li><li>Схема и/или семантика объектов может стать несовместимой с более поздними бета-версиями или стабильными выпусками. Когда это случится, мы даем инструкции по миграции на следующую версию. Это обновление может включать удаление, редактирование и повторного создание API-объектов. Этот процесс может потребовать тщательного анализа. Кроме этого, это может привести к простою приложений, которые используют данную функциональность.</li><li>Рекомендуется только для неосновного производственного использования из-за риска возникновения возможных несовместимых изменений с будущими версиями. Если у вас есть несколько кластеров, которые возможно обновить независимо, вы можете снять это ограничение.</li><li><strong>Пожалуйста, попробуйте в действии бета-версии функциональности и поделитесь своими впечатлениями! После того как функциональность выйдет из бета-версии, нам может быть нецелесообразно что-то дальше изменять.</strong></li></ul></li><li>Стабильные версии:<ul><li>Имя версии <code>vX</code>, где <code>vX</code> — целое число.</li><li>Стабильные версии функциональностей появятся в новых версиях.</li></ul></li></ul><h2 id=api-группы>API-группы</h2><p>Чтобы упростить расширение API Kubernetes, реализованы <a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md><em>группы API</em></a>.
Группа API указывается в пути REST и в поле <code>apiVersion</code> сериализованного объекта.</p><p>В настоящее время используется несколько API-групп:</p><ol><li><p>Группа <em>core</em>, которая часто упоминается как <em>устаревшая</em> (<em>legacy group</em>), доступна по пути <code>/api/v1</code> и использует <code>apiVersion: v1</code>.</p></li><li><p>Именованные группы находятся в пути REST <code>/apis/$GROUP_NAME/$VERSION</code> и используют <code>apiVersion: $GROUP_NAME/$VERSION</code> (например, <code>apiVersion: batch/v1</code>). Полный список поддерживаемых групп API можно увидеть в <a href=/ru/docs/reference/>справочнике API Kubernetes</a>.</p></li></ol><p>Есть два поддерживаемых пути к расширению API с помощью <a href=/docs/concepts/api-extension/custom-resources/>пользовательских ресурсов</a>:</p><ol><li><a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/>CustomResourceDefinition</a> для пользователей, которым нужен очень простой CRUD.</li><li>Пользователи, которым нужна полная семантика API Kubernetes, могут реализовать собственный apiserver и использовать <a href=/docs/tasks/access-kubernetes-api/configure-aggregation-layer/>агрегатор</a> для эффективной интеграции для клиентов.</li></ol><h2 id=включение-или-отключение-групп-api>Включение или отключение групп API</h2><p>Некоторые ресурсы и группы API включены по умолчанию. Их можно включить или отключить, установив <code>--runtime-config</code> для apiserver. Флаг <code>--runtime-config</code> принимает значения через запятую. Например, чтобы отключить batch/v1, используйте <code>--runtime-config=batch/v1=false</code>, а чтобы включить batch/v2alpha1, используйте флаг <code>--runtime-config=batch/v2alpha1</code>.
Флаг набор пар ключ-значение, указанных через запятую, который описывает конфигурацию во время выполнения сервера.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Включение или отключение групп или ресурсов требует перезапуска apiserver и controller-manager для применения изменений <code>--runtime-config</code>.</div><h2 id=включение-определённых-ресурсов-в-группу-extensions-v1beta1>Включение определённых ресурсов в группу extensions/v1beta1</h2><p>DaemonSets, Deployments, StatefulSet, NetworkPolicies, PodSecurityPolicies и ReplicaSets в API-группе <code>extensions/v1beta1</code> по умолчанию отключены.
Например: чтобы включить deployments и daemonsets, используйте флаг <code>--runtime-config=extensions/v1beta1/deployments=true,extensions/v1beta1/daemonsets=true</code>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Включение/отключение отдельных ресурсов поддерживается только в API-группе <code>extensions/v1beta1</code> по историческим причинам.</div></div><div class=td-content style=page-break-before:always><h1 id=pg-110f33530cf761140cb1dab536baef04>4.1.4 - Работа с объектами Kubernetes</h1></div><div class=td-content><h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>4.1.4.1 - Изучение объектов Kubernetes</h1><p>На этой странице объясняется, как объекты Kubernetes представлены в API Kubernetes, и как их можно определить в формате <code>.yaml</code>.</p><h2 id=kubernetes-objects>Изучение объектов Kubernetes</h2><p><em>Объекты Kubernetes</em> — сущности, которые хранятся в Kubernetes. Kubernetes использует их для представления состояния кластера. В частности, они описывают следующую информацию:</p><ul><li>Какие контейнеризированные приложения запущены (и на каких узлах).</li><li>Доступные ресурсы для этих приложений.</li><li>Стратегии управления приложения, которые относятся, например, к перезапуску, обновлению или отказоустойчивости.</li></ul><p>После создания объекта Kubernetes будет следить за существованием объекта. Создавая объект, вы таким образом указываете системе Kubernetes, какой должна быть рабочая нагрузка кластера; это <em>требуемое состояние</em> кластера.</p><p>Для работы с объектами Kubernetes – будь то создание, изменение или удаление — нужно использовать <a href=/docs/concepts/overview/kubernetes-api/>API Kubernetes</a>. Например, при использовании CLI-инструмента <code>kubectl</code>, он обращается к API Kubernetes. С помощью одной из <a href=/docs/reference/using-api/client-libraries/>клиентской библиотеки</a> вы также можете использовать API Kubernetes в собственных программах.</p><h3 id=спецификация-и-статус-объекта>Спецификация и статус объекта</h3><p>Почти в каждом объекте Kubernetes есть два вложенных поля-объекта, которые управляют конфигурацией объекта: <em><code>spec</code></em> и <em><code>status</code></em>.
При создании объекта в поле <code>spec</code> указывается <em>требуемое состояние</em> (описание характеристик, которые должны быть у объекта).</p><p>Поле <code>status</code> описывает <em>текущее состояние</em> объекта, которое создаётся и обновляется самим Kubernetes и его компонентами. <a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='Плоскость управления'>Плоскость управления</a> Kubernetes непрерывно управляет фактическим состоянием каждого объекта, чтобы оно соответствовало требуемому состоянию, которое было задано пользователем.</p><p>Например: Deployment — это объект Kubernetes, представляющий работающее приложение в кластере. При создании объекта Deployment вы можете указать в его поле <code>spec</code>, что хотите иметь три реплики приложения. Система Kubernetes получит спецификацию объекта Deployment и запустит три экземпляра приложения, таким образом обновит статус (состояние) объекта, чтобы он соответствовал заданной спецификации. В случае сбоя одного из экземпляров (это влечет за собой изменение состояние), Kubernetes обнаружит несоответствие между спецификацией и статусом и исправит его, т.е. активирует новый экземпляр вместо того, который вышел из строя.</p><p>Для получения дополнительной информации о спецификации объекта, статусе и метаданных смотрите документ с <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>соглашениями API Kubernetes</a>.</p><h3 id=описание-объекта-kubernetes>Описание объекта Kubernetes</h3><p>При создании объекта в Kubernetes нужно передать спецификацию объекта, которая содержит требуемое состояние, а также основную информацию об объекте (например, его имя). Когда вы используете API Kubernetes для создания объекта (напрямую либо через <code>kubectl</code>), соответствующий API-запрос должен включать в теле запроса всю указанную информацию в JSON-формате. <strong>В большинстве случаев вы будете передавать <code>kubectl</code> эти данные, записанные в файле .yaml</strong>. Тогда инструмент <code>kubectl</code> преобразует их в формат JSON при выполнении запроса к API.</p><p>Ниже представлен пример <code>.yaml</code>-файла, в котором заданы обязательные поля и спецификация объекта, необходимая для объекта Deployment в Kubernetes:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ru/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># до версии 1.9.0 нужно использовать apps/v1beta2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># запускает 2 пода, созданных по шаблону</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Один из способов создания объекта Deployment с помощью файла <code>.yaml</code>, показанного выше — использовать команду <a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>, которая принимает в качестве аргумента файл в формате <code>.yaml</code>. Например:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record
</span></span></code></pre></div><p>Вывод будет примерно таким:</p><pre tabindex=0><code>deployment.apps/nginx-deployment created
</code></pre><h3 id=обязательные-поля>Обязательные поля</h3><p>В файле <code>.yaml</code> создаваемого объекта Kubernetes необходимо указать значения для следующих полей:</p><ul><li><code>apiVersion</code> — используемая для создания объекта версия API Kubernetes</li><li><code>kind</code> — тип создаваемого объекта</li><li><code>metadata</code> — данные, позволяющие идентифицировать объект (<code>name</code>, <code>UID</code> и необязательное поле <code>namespace</code>)</li><li><code>spec</code> — требуемое состояние объекта</li></ul><p>Конкретный формат поля-объекта <code>spec</code> зависит от типа объекта Kubernetes и содержит вложенные поля, предназначенные только для используемого объекта. В <a href=/docs/reference/generated/kubernetes-api/v1.25/>справочнике API Kubernetes</a> можно найти формат спецификации любого объекта Kubernetes.
Например, формат <code>spec</code> для объекта Pod находится в <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>ядре PodSpec v1</a>, а формат <code>spec</code> для Deployment — в <a href=/docs/reference/generated/kubernetes-api/v1.25/#deploymentspec-v1-apps>DeploymentSpec v1 apps</a>.</p><h2 id=что-дальше>Что дальше</h2><ul><li><a href=/docs/reference/using-api/api-overview/>Обзор API Kubernetes</a> более подробно объясняет некоторые из API-концепций</li><li>Познакомиться с наиболее важными и основными объектами в Kubernetes, например, с <a href=/docs/concepts/workloads/pods/pod-overview/>подами</a>.</li><li>Узнать подробнее про <a href=/docs/concepts/architecture/controller/>контролеры</a> в Kubernetes</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6751db8ff5409476de8225d17d6c42dd>4.1.4.2 - Управление объектами Kubernetes</h1><p>В инструменте командной строки <code>kubectl</code> есть несколько разных способов создания и управления объектами Kubernetes. На этой странице рассматриваются различные подходы. Изучите <a href=https://kubectl.docs.kubernetes.io>документацию по Kubectl</a> для получения подробной информации по управлению объектами с помощью Kubectl.</p><h2 id=способы-управления>Способы управления</h2><div class="alert alert-danger warning callout" role=alert><strong>Предупреждение:</strong> Используйте только один способ для управления объектами Kubernetes. Применение нескольких методов управления к одному и тому же объекту может привести к неопределенному поведению.</div><table><thead><tr><th>Способ управления</th><th>Область применения</th><th>Рекомендуемое окружение</th><th>Количество поддерживаемых авторов</th><th>Трудность изучения</th></tr></thead><tbody><tr><td>Императивные команды</td><td>Активные объекты</td><td>Проекты в стадии разработки</td><td>1+</td><td>Низкая</td></tr><tr><td>Императивная конфигурация объекта</td><td>Отдельные файлы</td><td>Продакшен-проекты</td><td>1</td><td>Средняя</td></tr><tr><td>Декларативная конфигурация объекта</td><td>Директории или файлы</td><td>Продакшен-проекты</td><td>1+</td><td>Сложная</td></tr></tbody></table><h2 id=императивные-команды>Императивные команды</h2><p>При использовании императивных команд пользователь работает непосредственно с активными (текущими) объектами в кластере. Пользователь указывает выполняемые операции команде <code>kubectl</code> в качестве аргументов или флагов.</p><p>Это самый простой способ начать или выполнять одноразовые задачи в кластере. Из-за того, что происходит работа с активными объектами напрямую, нет возможности посмотреть историю предыдущих конфигураций.</p><h3 id=примеры>Примеры</h3><p>Запустите экземпляр контейнера nginx, посредством создания объекта Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl run nginx --image nginx
</span></span></code></pre></div><p>То же самое, но с другим синтаксисом:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create deployment nginx --image nginx
</span></span></code></pre></div><h3 id=плюсы-и-минусы>Плюсы и минусы</h3><p>Преимущества по сравнению с конфигурацией объекта:</p><ul><li>Простые команды, которые легко выучить и запомнить.</li><li>Для применения изменений в кластер нужно только выполнить команды.</li></ul><p>Недостатки по сравнению с конфигурацией объекта:</p><ul><li>Команды не интегрированы с процессом проверки (обзора) изменений.</li><li>У команд нет журнала с изменениями.</li><li>Команды не дают источник записей, за исключением активных объектов.</li><li>Команды не содержат шаблон для создания новых объектов.</li></ul><h2 id=императивная-конфигурация-объекта>Императивная конфигурация объекта</h2><p>В случае использования императивной конфигурации объекта команде kubectl устанавливают действие (создание, замена и т.д.), необязательные флаги и как минимум одно имя файла. Файл должен содержать полное определение объекта в формате YAML или JSON.</p><p>Посмотрите <a href=/docs/reference/generated/kubernetes-api/v1.25/>Справочник API</a> для получения более подробной информации про определения объекта.</p><div class="alert alert-danger warning callout" role=alert><strong>Предупреждение:</strong> Императивная команда <code>replace</code> заменяет существующую спецификацию новой (переданной), удаляя все изменения в объекте, которые не определены в конфигурационном файле. Такой подход не следует использовать для типов ресурсов, спецификации которых обновляются независимо от конфигурационного файла.
Например, поле <code>externalIPs</code> в сервисах типа <code>LoadBalancer</code> обновляется кластером независимо от конфигурации.</div><h3 id=примеры-1>Примеры</h3><p>Создать объекты, определенные в конфигурационном файле:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create -f nginx.yaml
</span></span></code></pre></div><p>Удалить объекты, определенные в двух конфигурационных файлах:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl delete -f nginx.yaml -f redis.yaml
</span></span></code></pre></div><p>Обновить объекты, определенные в конфигурационном файле, перезаписав текущую конфигурацию:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl replace -f nginx.yaml
</span></span></code></pre></div><h3 id=плюсы-и-минусы-1>Плюсы и минусы</h3><p>Преимущества по сравнению с императивными командами:</p><ul><li>Конфигурация объекта может храниться в системе управления версиями, такой как Git.</li><li>Конфигурация объекта может быть интегрирована с процессами проверки изменений и логирования.</li><li>Конфигурация объекта предусматривает шаблон для создания новых объектов.</li></ul><p>Недостатки по сравнению с императивными командами:</p><ul><li>Конфигурация объекта требует наличие общего представления об схеме объекта.</li><li>Конфигурация объекта предусматривает написание файла YAML.</li></ul><p>Преимущества по сравнению с декларативной конфигурацией объекта:</p><ul><li>Императивная конфигурация объекта проще и легче для понимания.</li><li>Начиная с Kubernetes 1.5, конфигурация императивных объектов стала лучше и совершеннее.</li></ul><p>Недостатки по сравнению с декларативной конфигурацией объекта:</p><ul><li>Императивная конфигурация объекта наилучшим образом работает с файлами, а не с директориями.</li><li>Обновления текущих объектов должны быть описаны в файлах конфигурации, в противном случае они будут потеряны при следующей замене.</li></ul><h2 id=декларативная-конфигурация-объекта>Декларативная конфигурация объекта</h2><p>При использовании декларативной конфигурации объекта пользователь работает с локальными конфигурационными файлами объекта, при этом он не определяет операции, которые будут выполняться над этими файлами. Операции создания, обновления и удаления автоматически для каждого объекта определяются <code>kubectl</code>. Этот механизм позволяет работать с директориями, в ситуациях, когда для разных объектов может потребоваться выполнение других операций.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Декларативная конфигурация объекта сохраняет изменения, сделанные другими, даже если эти изменения не будут зафиксированы снова в конфигурационный файл объекта.
Это достигается путем использования API-операции <code>patch</code>, чтобы записать только обнаруженные изменения, а не использовать для этого API-операцию <code>replace</code>, которая полностью заменяет конфигурацию объекта.</div><h3 id=примеры-2>Примеры</h3><p>Обработать все конфигурационные файлы объектов в директории <code>configs</code> и создать либо частично обновить активные объекты. Сначала можно выполнить <code>diff</code>, чтобы посмотреть, какие изменения будут внесены, и только после этого применить их:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -f configs/
</span></span><span style=display:flex><span>kubectl apply -f configs/
</span></span></code></pre></div><p>Рекурсивная обработка директорий:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -R -f configs/
</span></span><span style=display:flex><span>kubectl apply -R -f configs/
</span></span></code></pre></div><h3 id=плюсы-и-минусы-2>Плюсы и минусы</h3><p>Преимущества по сравнению с императивной конфигурацией объекта:</p><ul><li>Изменения, внесенные непосредственно в активные объекты, будут сохранены, даже если они не отражены в конфигурационных файлах.</li><li>Декларативная конфигурация объекта лучше работает с директориями и автоматически определяет тип операции (создание, частичное обновление, удаление) каждого объекта.</li></ul><p>Недостатки по сравнению с императивной конфигурацией объекта:</p><ul><li>Декларативную конфигурацию объекта сложнее отладить и понять, когда можно получить неожиданные результаты.</li><li>Частичные обновления с использованием различий приводит к сложным операциям слияния и исправления.</li></ul><h2 id=что-дальше>Что дальше</h2><ul><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-command/>Управление объектами Kubernetes с помощью императивных команд</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-config/>Управление объектами Kubernetes с помощью императивной конфигурации объекта</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/declarative-config/>Управление объектами Kubernetes с помощью декларативной конфигурации объекта</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/kustomization/>Управление объектами Kubernetes с помощью Kustomize (декларативный способ)</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Справочник по командам Kubectl</a></li><li><a href=https://kubectl.docs.kubernetes.io>Документация Kubectl</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>Справочник API Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>4.1.4.3 - Имена и идентификаторы объектов</h1><p>Каждый объект в кластере имеет уникальное <a href=#%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0><em>имя</em></a> для конкретного типа ресурса.
Кроме этого, у каждого объекта Kubernetes есть собственный <a href=#%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B><em>уникальный идентификатор (UID)</em></a> в пределах кластера.</p><p>Например, в одном и том же <a href=/ru/docs/concepts/overview/working-with-objects/namespaces/>пространстве имён</a> может быть только один Pod-объект с именем <code>myapp-1234</code>, и при этом существовать объект Deployment с этим же названием <code>myapp-1234</code>.</p><p>Для создания пользовательских неуникальных атрибутов у Kubernetes есть <a href=/ru/docs/concepts/overview/working-with-objects/labels/>метки</a> и <a href=/ru/docs/concepts/overview/working-with-objects/annotations/>аннотации</a>.</p><h2 id=имена>Имена</h2><p>Клиентская строка, предназначенная для ссылки на объект в URL-адресе ресурса, например <code>/api/v1/pods/some-name</code>.</p><p>Указанное имя может иметь только один объект определённого типа. Но если вы удалите этот объект, вы можете создать новый с таким же именем</p><p>Ниже перечислены три типа распространённых требований к именам ресурсов.</p><h3 id=имена-поддоменов-dns>Имена поддоменов DNS</h3><p>Большинству типов ресурсов нужно указать имя, используемое в качестве имени поддомена DNS в соответствии с <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>. Соответственно, имя должно:</p><ul><li>содержать не более 253 символов</li><li>иметь только строчные буквенно-цифровые символы, '-' или '.'</li><li>начинаться с буквенно-цифрового символа</li><li>заканчивается буквенно-цифровым символом</li></ul><h3 id=имена-меток-dns>Имена меток DNS</h3><p>Некоторые типы ресурсов должны соответствовать стандарту меток DNS, который описан в <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>. Таким образом, имя должно:</p><ul><li>содержать не более 63 символов</li><li>содержать только строчные буквенно-цифровые символы или '-'</li><li>начинаться с буквенно-цифрового символа</li><li>заканчивается буквенно-цифровым символом</li></ul><h3 id=имена-сегментов-пути>Имена сегментов пути</h3><p>Определённые имена типов ресурсов должны быть закодированы для использования в качестве сегмента пути. Проще говоря, имя не может быть "." или "..", а также не может содержать "/" или "%".</p><p>Пример файла манифеста пода <code>nginx-demo</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> У отдельных типов ресурсов есть дополнительные ограничения именования.</div><h2 id=уникальные-идентификаторы>Уникальные идентификаторы</h2><p>Уникальная строка, сгенерированная самим Kubernetes, для идентификации объектов.</p><p>У каждого объекта, созданного в течение всего периода работы кластера Kubernetes, есть собственный уникальный идентификатор (UID). Он предназначен для выяснения различий между событиями похожих сущностей.</p><p>Уникальные идентификатор (UID) в Kubernetes — это универсальные уникальные идентификаторы (известные также как Universally Unique IDentifier, сокращенно UUID).
Эти идентификаторы стандартизированы под названием ISO/IEC 9834-8, а также как ITU-T X.667.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Узнать подробнее про <a href=/ru/docs/concepts/overview/working-with-objects/labels/>метки</a> в Kubernetes.</li><li>Посмотреть архитектуру <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/identifiers.md>идентификаторов и имён Kubernetes</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>4.1.4.4 - Пространства имён</h1><p>Kubernetes поддерживает несколько виртуальных кластеров в одном физическом кластере. Такие виртуальные кластеры называются пространствами имён.</p><h2 id=причины-использования-нескольких-пространств-имён>Причины использования нескольких пространств имён</h2><p>Пространства имён применяются в окружениях с многочисленными пользователями, распределенными по нескольким командам или проектам. Пространства имён не нужно создавать, если есть кластеры с небольшим количеством пользователей (например, десяток пользователей). Пространства имён имеет смысл использовать, когда необходима такая функциональность.</p><p>Пространства имён определяют область имён. Имена ресурсов должны быть уникальными в пределах одного и того же пространства имён. Пространства имён не могут быть вложенными, а каждый ресурс Kubernetes может находиться только в одном пространстве имён.</p><p>Пространства имён — это способ разделения ресурсов кластера между несколькими пользователями (с помощью <a href=/docs/concepts/policy/resource-quotas/>квоты ресурсов</a>).</p><p>По умолчанию в будущих версиях Kubernetes объекты в одном и том же пространстве имён будут иметь одинаковую политику контроля доступа.</p><p>Не нужно использовать пространства имён только для разделения слегка отличающихся ресурсов, например, в случае разных версий одного и того же приложения. Используйте <a href=/ru/docs/concepts/overview/working-with-objects/labels/>метки</a>, чтобы различать ресурсы в рамках одного пространства имён.</p><h2 id=использование-пространств-имён>Использование пространств имён</h2><p>Создание и удаление пространств имён описаны в <a href=/docs/admin/namespaces>руководстве администратора по пространствам имён</a>.</p><h3 id=просмотр-пространств-имён>Просмотр пространств имён</h3><p>Используйте следующую команду, чтобы вывести список существующих пространств имён в кластере:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME          STATUS    AGE
default       Active    1d
kube-system   Active    1d
kube-public   Active    1d
</code></pre><p>По умолчанию в Kubernetes определены три пространства имён:</p><ul><li><code>default</code> — пространство имён по умолчанию для объектов без какого-либо другого пространства имён.</li><li><code>kube-system</code> — пространство имён для объектов, созданных Kubernetes</li><li><code>kube-public</code> — создаваемое автоматически пространство имён, которое доступно для чтения всем пользователям (включая также неаутентифицированных пользователей). Как правило, это пространство имён используется кластером, если некоторые ресурсы должны быть общедоступными для всего кластера. Главная особенность этого пространства имён — оно всего лишь соглашение, а не требование.</li></ul><h3 id=определение-пространства-имён-для-отдельных-команд>Определение пространства имён для отдельных команд</h3><p>Используйте флаг <code>--namespace</code>, чтобы определить пространство имён только для текущего запроса.</p><p>Примеры:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span></code></pre></div><h3 id=определение-пространства-имён-для-всех-команд>Определение пространства имён для всех команд</h3><p>Можно определить пространство имён, которое должно использоваться для всех выполняемых команд kubectl в текущем контексте.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Проверка</span>
</span></span><span style=display:flex><span>kubectl config view --minify | grep namespace:
</span></span></code></pre></div><h2 id=пространства-имён-и-dns>Пространства имён и DNS</h2><p>При создании <a href=/docs/user-guide/services>сервиса</a> создаётся соответствующая ему <a href=/docs/concepts/services-networking/dns-pod-service/>DNS-запись</a>.
Эта запись вида <code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code> означает, что если контейнер использует только <code>&lt;service-name></code>, то он будет локальным сервисом в пространстве имён. Это позволит применять одну и ту же конфигурацию в нескольких пространствах имен (например, development, staging и production). Если нужно обращаться к другим пространствам имён, то нужно использовать полностью определенное имя домена (FQDN).</p><h2 id=объекты-без-пространства-имён>Объекты без пространства имён</h2><p>Большинство ресурсов Kubernetes (например, поды, сервисы, контроллеры репликации и другие) расположены в определённых пространствах имён. При этом сами ресурсы пространства имён не находятся ни в других пространствах имён. А такие низкоуровневые ресурсы, как <a href=/docs/admin/node>узлы</a> и persistentVolumes, не принадлежат ни одному пространству имён.</p><p>Чтобы посмотреть, какие ресурсы Kubernetes находятся в пространстве имён, а какие — нет, используйте следующие команды:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Ресурсы в пространстве имён</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Ресурсы, не принадлежавшие ни одному пространству имён</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h2 id=что-дальше>Что дальше</h2><ul><li>Узнать подробнее про <a href=/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace>создание нового пространства имён</a>.</li><li>Узнать подробнее про <a href=/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace>удаление пространства имён</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f1dec4557fb8ffbac9f11390aaaf9fa4>4.1.4.5 - Метки и селекторы</h1><p><em>Метки</em> — это пары ключ-значение, которые добавляются к объектам, как поды.
Метки предназначены для идентификации атрибутов объектов, которые имеют значимость и важны для пользователей, но при этом не относятся напрямую к основной системе.
Метки можно использовать для группировки и выбора подмножеств объектов. Метки могут быть добавлены к объектам во время создания и изменены в любое время после этого.
Каждый объект может иметь набор меток в виде пары ключ-значение. Каждый ключ должен быть уникальным в рамках одного и того же объекта.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Метки используются при получении и отслеживании объектов и в веб-панелях и CLI-инструментах. Любая неидентифицирующая информация должна быть записана в <a href=/ru/docs/concepts/overview/working-with-objects/annotations/>аннотации</a>.</p><h2 id=причины-использования>Причины использования</h2><p>Метки позволяют пользователям гибко сопоставить их организационные структуры с системными объектами, не требуя от клиентов хранить эти соответствия.</p><p>Развертывания сервисов и процессы пакетной обработки часто являются многомерными сущностями (например, множество разделов или развертываний, несколько групп выпусков, несколько уровней приложения, несколько микросервисов на каждый уровень приложения). Для управления часто требуются сквозные операции, которые нарушают инкапсуляцию строго иерархических представлений, особенно жестких иерархий, определяемых инфраструктурой, а не пользователями.</p><p>Примеры меток:</p><ul><li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li><li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li><li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li><li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li><li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li></ul><p>Это всего лишь примеры часто используемых меток; конечно, вы можете использовать свои собственные. Помните о том, что ключ метки должна быть уникальной в пределах одного объекта.</p><h2 id=синтаксис-и-набор-символов>Синтаксис и набор символов</h2><p><em>Метки</em> представляют собой пары ключ-значение. Разрешенные ключи метки имеют два сегмента, разделённые слешем (<code>/</code>): префикс (необязательно) и имя. Сегмент имени обязателен и должен содержать не более 63 символов, среди которых могут быть буквенно-цифровые символы (<code>[a-z0-9A-Z]</code>), а также дефисы (<code>-</code>), знаки подчеркивания (<code>_</code>), точки (<code>.</code>). Префикс не обязателен, но он быть поддоменом DNS: набор меток DNS, разделенных точками (<code>.</code>), общей длиной не более 253 символов, за которыми следует слеш (<code>/</code>).</p><p>Если префикс не указан, ключ метки считается закрытым для пользователя. Компоненты автоматизированной системы (например, <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code> или другие сторонние), которые добавляют метки к объектам пользователя, должны указывать префикс.</p><p>Префиксы <code>kubernetes.io/</code> и <code>k8s.io/</code> зарезервированы для использования основными компонентами Kubernetes.</p><p>Например, ниже представлен конфигурационный файл объекта Pod с двумя метками <code>environment: production</code> и <code>app: nginx</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>label-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=селекторы-меток>Селекторы меток</h2><p>В отличие от <a href=/docs/user-guide/identifiers>имен и идентификаторов</a>, метки не гарантируют уникальность. Поэтому мы предполагаем, что многие объекты будут иметь одинаковые метки.</p><p>С помощью <em>селектора меток</em> клиент/пользователь может идентифицировать набор объектов. Селектор меток — основное средство группировки в Kubernetes.</p><p>В настоящее время API поддерживает два типа селекторов: <em>на равенстве</em> и <em>на наборе</em>.
Селектор меток может состоять из нескольких <em>условий</em>, разделенных запятыми. В таком случае все условия должны быть выполнены, поэтому запятая-разделитель работает как логический оператор <em>И</em> (<code>&&</code>).</p><p>Работа пустых или неопределённых селекторов зависит от контекста. Типы API, которые использует селекторы, должны задокументировать это поведение.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Для некоторых API-типов, например, ReplicaSets, селекторы меток двух экземпляров не должны дублироваться в пространстве имен, в противном случае контроллер может рассматривать их как конфликтующие инструкции и не сможет определить количество реплик.</div><div class="alert alert-warning caution callout" role=alert><strong>Внимание:</strong> Как для условий, основанных на равенстве, так и для условий на основе набора, не существует логического оператора <em>ИЛИ</em> (<code>||</code>). Убедитесь, что синтаксис фильтрации правильно составлен.</div><h3 id=условие-равенства>Условие <em>равенства</em></h3><p>Условия <em>равенства</em> или <em>неравенства</em> позволяют отфильтровать объекты по ключам и значениям меток. Сопоставляемые объекты должны удовлетворять всем указанным условиям меток, хотя при этом у объектов также могут быть заданы другие метки.
Доступны три оператора: <code>=</code>,<code>==</code>,<code>!=</code>. Первые два означают <em>равенство</em> (и являются всего лишь синонимами), а последний оператор определяет <em>неравенство</em>. Например:</p><pre tabindex=0><code>environment = production
tier != frontend
</code></pre><p>Первый пример выбирает все ресурсы с ключом <code>environment</code>, у которого значение указано <code>production</code>.
Последний получает все ресурсы с ключом <code>tier</code> без значения <code>frontend</code>, а также все ресурсы, в которых нет метки с ключом <code>tier</code>.
Используя оператор запятой можно совместить показанные два условия в одно, запросив ресурсы, в которых есть значение метки <code>production</code> и исключить <code>frontend</code>: <code>environment=production,tier!=frontend</code>.</p><p>С помощью условия равенства в объектах Pod можно указать, какие нужно выбрать ресурсы. Например, в примере ниже объект Pod выбирает узлы с меткой "<code>accelerator=nvidia-tesla-p100</code>".</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=условие-набора>Условие <em>набора</em></h3><p>Условие меток <em>на основе набора</em> фильтрует ключи в соответствии с набором значений. Поддерживаются три вида операторов: <code>in</code>, <code>notin</code> и <code>exists</code> (только идентификатор ключа). Например:</p><pre tabindex=0><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><p>В первом примере выбираются все ресурсы с ключом <code>environment</code> и значением <code>production</code> или <code>qa</code>.
Во втором примере выбираются все ресурсы с ключом <code>tier</code> и любыми значениями, кроме <code>frontend</code> и <code>backend</code>, а также все ресурсы без меток с ключом <code>tier</code>.
Третий пример выбирает все ресурсы, включая метку с ключом <code>partition</code> (с любым значением).
В четвертом примере выбираются все ресурсы без метки с ключом <code>partition</code> (с любым значением).
Как и логический оператор <em>И</em> работает разделитель в виде запятой. Таким образом, фильтрация ресурсов по ключу <code>partition</code> (вне зависимости от значения) и ключу <code>environment</code> с любым значением, кроме <code>qa</code>, можно получить с помощью следующего выражения: <code>partition,environment notin (qa)</code>.
Селектор меток <em>на основе набора</em> — основная форма равенства, поскольку <code>environment=production</code> то же самое, что и <code>environment in (production)</code>; аналогично, оператор <code>!=</code> соответствует <code>notin</code>.</p><p>Условия <em>набора</em> могут использоваться одновременно с условия <em>равенства</em>. Например, так: <code>partition in (customerA, customerB),environment!=qa</code>.</p><h2 id=api>API</h2><h3 id=фильтрация-list-и-watch>Фильтрация LIST и WATCH</h3><p>Операции LIST и WATCH могут использовать параметр запроса, чтобы указать селекторы меток фильтрации наборов объектов. Есть поддержка обоих условий (строка запроса URL ниже показывается в исходном виде):</p><ul><li>Условия <em>на основе равенства</em>: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li>Условия <em>на основе набора</em>: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>Указанные выше формы селектора меток можно использовать для просмотра или отслеживания ресурсов через REST-клиент. Например, <code>apiserver</code> с <code>kubectl</code>, который использует <em>условие равенства</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>environment</span><span style=color:#666>=</span>production,tier<span style=color:#666>=</span>frontend
</span></span></code></pre></div><p>Либо используя условия <em>на основе набора</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production),tier in (frontend)&#39;</span>
</span></span></code></pre></div><p>Как уже показывалось, <em>условия набора</em> дают больше возможностей. Например, в них можно использовать подобие оператора <em>И</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production, qa)&#39;</span>
</span></span></code></pre></div><p>Либо можно воспользоваться исключающим сопоставлением с помощью оператора <em>exists</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment,environment notin (frontend)&#39;</span>
</span></span></code></pre></div><h3 id=установка-ссылок-в-api-объекты>Установка ссылок в API-объекты</h3><p>Некоторые объекты Kubernetes, такие как <a href=/docs/user-guide/services><code>services</code></a> и <a href=/docs/user-guide/replication-controller><code>replicationcontrollers</code></a>, также используют селекторы меток для ссылки на наборы из других ресурсов, например, <a href=/docs/user-guide/pods>подов</a>.</p><h4 id=service-и-replicationcontroller>Service и ReplicationController</h4><p>Набор подов, на которые указывает <code>service</code>, определяется через селектор меток. Аналогичным образом, количество подов, которыми должен управлять <code>replicationcontroller</code>, также формируются с использованием селектора меток.</p><p>Селекторы меток для обоих объектов записываются в словарях файлов формата <code>json</code> и <code>yaml</code>, при этом поддерживаются только селекторы с условием <em>равенства</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;selector&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span> : <span style=color:#b44>&#34;redis&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Или:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div><p>Этот селектор (как в формате <code>json</code>, так и в <code>yaml</code>) эквивалентен <code>component=redis</code> или <code>component in (redis)</code>.</p><h4 id=ресурсы-поддерживающие-условия-набора>Ресурсы, поддерживающие условия набора</h4><p>Новые ресурсы, такие как <a href=/docs/concepts/workloads/controllers/jobs-run-to-completion/><code>Job</code></a>, <a href=/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>, <a href=/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a> и <a href=/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>, также поддерживают условия <em>набора</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[cache]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: environment, operator: NotIn, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>matchLabels</code> — словарь пар <code>{key,value}</code>. Каждая пара <code>{key,value}</code> в словаре <code>matchLabels</code> эквивалентна элементу <code>matchExpressions</code>, где поле <code>key</code> — "key", поле <code>operator</code> — "In", а массив <code>values</code> содержит только "value".
<code>matchExpressions</code> представляет собой список условий селектора пода. В качестве операторов могут быть In, NotIn, Exists и DoesNotExist. В случае использования In и NotIn должны заданы непустые значения. Все условия, как для <code>matchLabels</code>, так и для <code>matchExpressions</code>, объединяются с помощью логического И, поэтому при выборке объектов все они должны быть выполнены.</p><h4 id=выбор-наборов-узлов>Выбор наборов узлов</h4><p>Один из вариантов использования меток — возможность выбора набора узлов, в которых может быть развернут под.
Смотрите документацию про <a href=/docs/concepts/configuration/assign-pod-node/>выбор узлов</a>, чтобы получить дополнительную информацию.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-93cd7a1d4e1623e2bf01afc49a5af69c>4.1.4.6 - Аннотации</h1><p>Аннотации Kubernetes можно использовать для добавления собственных метаданных к объектам. Такие клиенты, как инструменты и библиотеки, могут получить эти метаданные.</p><h2 id=добавление-метаданных-к-объектам>Добавление метаданных к объектам</h2><p>Вы можете использовать метки или аннотации для добавления метаданных к объектам Kubernetes. Метки можно использовать для выбора объектов и для поиска коллекций объектов, которые соответствуют определенным условиям. В отличие от них аннотации не используются для идентификации и выбора объектов. Метаданные в аннотации могут быть маленькими или большими, структурированными или неструктурированными, кроме этого они включать символы, которые не разрешены в метках.</p><p>Аннотации, как и метки, являются коллекциями с наборами пар ключ-значение:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;annotations&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Некоторые примеры информации, которая может быть в аннотациях:</p><ul><li><p>Поля, управляемые декларативным уровнем конфигурации. Добавление этих полей в виде аннотаций позволяет отличать их от значений по умолчанию, установленных клиентами или серверами, а также от автоматически сгенерированных полей и полей, заданных системами автоматического масштабирования.</p></li><li><p>Информация о сборке, выпуске или образе, например, метка времени, идентификаторы выпуска, ветка git, номера PR, хеши образов и адрес реестра.</p></li><li><p>Ссылки на репозитории логирования, мониторинга, аналитики или аудита.</p></li><li><p>Информация о клиентской библиотеке или инструменте, которая может использоваться при отладке (например, имя, версия и информация о сборке).</p></li><li><p>Информация об источнике пользователя или инструмента/системы, например, URL-адреса связанных объектов из других компонентов экосистемы.</p></li><li><p>Небольшие метаданные развертывания (например, конфигурация или контрольные точки).</p></li><li><p>Номера телефонов или пейджеров ответственных лиц или записи в справочнике, в которых можно найти нужную информацию, например, сайт группы.</p></li><li><p>Инструкции от конечных пользователей по исправлению работы или использования нестандартной функциональности.</p></li></ul><p>Вместо использования аннотаций, вы можете сохранить такого рода информацию во внешней базе данных или директории, хотя это усложнило бы создание общих клиентских библиотек и инструментов развертывания, управления, самодиагностики и т.д.</p><h2 id=синтаксис-и-набор-символов>Синтаксис и набор символов</h2><p><em>Аннотации</em> представляют собой пары ключ-значение. Разрешенные ключи аннотации имеют два сегмента, разделённые слешем (<code>/</code>): префикс (необязательно) и имя. Сегмент имени обязателен и должен содержать не более 63 символов, среди которых могут быть буквенно-цифровые символы(<code>[a-z0-9A-Z]</code>), а также дефисы (<code>-</code>), знаки подчеркивания (<code>_</code>), точки (<code>.</code>). Префикс не обязателен, но он быть поддоменом DNS: набор меток DNS, разделенных точками (<code>.</code>), общей длиной не более 253 символов, за которыми следует слеш (<code>/</code>).</p><p>Если префикс не указан, ключ аннотации считается закрытым для пользователя. Компоненты автоматизированной системы (например, <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code> или другие сторонние), которые добавляют аннотации к объектам пользователя, должны указывать префикс.</p><p>Префиксы <code>kubernetes.io/</code> и <code>k8s.io/</code> зарезервированы для использования основными компонентами Kubernetes.</p><p>Например, ниже представлен конфигурационный файл объекта Pod с аннотацией <code>imageregistry: https://hub.docker.com/</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotations-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageregistry</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://hub.docker.com/&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=что-дальше>Что дальше</h2><p>Узнать подробнее про <a href=/ru/docs/concepts/overview/working-with-objects/labels/>метки и селекторы</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-046c03090d47bc4b89b818dc645c3865>4.1.4.7 - Селекторы полей</h1><p><em>Селекторы полей</em> позволяют <a href=/ru/docs/concepts/overview/working-with-objects/kubernetes-objects>выбирать ресурсы Kubernetes</a>, исходя из значения одного или нескольких полей ресурсов. Ниже приведены несколько примеров запросов селекторов полей:</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>Следующая команда <code>kubectl</code> выбирает все Pod-объекты, в которых значение поля <a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase><code>status.phase</code></a> равно <code>Running</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>По сути, селекторы полей являются <em>фильтрами</em> ресурсов. По умолчанию нет установленных селекторов/фильтров, поэтому выбираются ресурсы всех типов. Это означает, что два запроса <code>kubectl</code> ниже одинаковы:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span><span style=display:flex><span>kubectl get pods --field-selector <span style=color:#b44>&#34;&#34;</span>
</span></span></code></pre></div></div><h2 id=поддерживаемые-поля>Поддерживаемые поля</h2><p>Доступные селекторы полей зависят от типа ресурса Kubernetes. У всех типов ресурсов есть поля <code>metadata.name</code> и <code>metadata.namespace</code>. При использовании несуществующего селекторов полей приведёт к возникновению ошибки. Например:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</span></span></code></pre></div><pre tabindex=0><code>Error from server (BadRequest): Unable to find &#34;ingresses&#34; that match label selector &#34;&#34;, field selector &#34;foo.bar=baz&#34;: &#34;foo.bar&#34; is not a known field selector: only &#34;metadata.name&#34;, &#34;metadata.namespace&#34;
</code></pre><h2 id=поддерживаемые-операторы>Поддерживаемые операторы</h2><p>Можно использовать операторы <code>=</code>, <code>==</code> и <code>!=</code> в селекторах полей (<code>=</code> и <code>==</code> — синонимы). Например, следующая команда <code>kubectl</code> выбирает все сервисы Kubernetes, не принадлежавшие пространству имен <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div><h2 id=составные-селекторы>Составные селекторы</h2><p>Аналогично <a href=/ru/docs/concepts/overview/working-with-objects/labels>метки</a> и другим селекторам, несколько селекторы полей могут быть объединены через запятую. Приведенная ниже команда <code>kubectl</code> выбирает все Pod-объекты, у которых значение поле <code>status.phase</code>, отличное от <code>Running</code>, а поле <code>spec.restartPolicy</code> имеет значение <code>Always</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</span></span></code></pre></div><h2 id=множественные-типы-ресурсов>Множественные типы ресурсов</h2><p>Можно использовать селекторы полей с несколькими типами ресурсов одновременно. Команда <code>kubectl</code> выбирает все объекты StatefulSet и Services, не включенные в пространство имен <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5dd62c6a4a481b4cf1ac50f6799eb581>4.1.4.8 - Рекомендуемые метки</h1><p>Вы можете визуализировать и управлять объектами Kubernetes не только с помощью kubectl и панели управления. С помощью единого набора меток можно единообразно описывать объекты, что позволяет инструментам согласованно работать между собой.</p><p>В дополнение к существующим инструментам, рекомендуемый набор меток описывают приложения в том виде, в котором они могут быть получены.</p><p>Метаданные сосредоточены на понятии <em>приложение</em>. Kubernetes — это не платформа как услуга (PaaS), поэтому не закрепляет формальное понятие приложения.
Вместо этого приложения являются неформальными и описываются через метаданные. Определение приложения довольно расплывчатое.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Это рекомендуемые для использования метки. Они облегчают процесс управления приложениями, но при этом не являются обязательными для основных инструментов.</div><p>Общие метки и аннотации используют один и тот же префикс: <code>app.kubernetes.io</code>. Метки без префикса являются приватными для пользователей. Совместно используемый префикс гарантирует, что общие метки не будут влиять на пользовательские метки.</p><h2 id=метки>Метки</h2><p>Чтобы извлечь максимум пользы от использования таких меток, они должны добавляться к каждому ресурсному объекту.</p><table><thead><tr><th>Ключ</th><th>Описание</th><th>Пример</th><th>Тип</th></tr></thead><tbody><tr><td><code>app.kubernetes.io/name</code></td><td>Имя приложения</td><td><code>mysql</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/instance</code></td><td>Уникальное имя экземпляра приложения</td><td><code>wordpress-abcxzy</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/version</code></td><td>Текущая версия приложения (например, семантическая версия, хеш коммита и т.д.)</td><td><code>5.7.21</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/component</code></td><td>Имя компонента в архитектуре</td><td><code>database</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/part-of</code></td><td>Имя основного приложения, частью которого является текущий объект</td><td><code>wordpress</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/managed-by</code></td><td>Инструмент управления приложением</td><td><code>helm</code></td><td>string</td></tr></tbody></table><p>Для демонстрации этих меток, рассмотрим следующий объект <code>StatefulSet</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=приложения-и-экземпляры-приложений>Приложения и экземпляры приложений</h2><p>Одно и то же приложение может быть установлено несколько раз в кластер Kubernetes, в ряде случаев — в одинаковое пространство имен. Например, WordPress может быть установлен более одного раза, тогда каждый из сайтов будет иметь собственный установленный экземпляр WordPress.</p><p>Имя приложения и имя экземпляра хранятся по отдельности. Например, WordPress имеет ключ <code>app.kubernetes.io/name</code> со значением <code>wordpress</code>, при этом у него есть имя экземпляра, представленное ключом <code>app.kubernetes.io/instance</code> со значением <code>wordpress-abcxzy</code>. Такой механизм позволяет идентифицировать как приложение, так и экземпляры приложения. У каждого экземпляра приложения должно быть уникальное имя.</p><h2 id=примеры>Примеры</h2><p>Следующие примеры показывают разные способы использования общих меток, поэтому они различаются по степени сложности.</p><h3 id=простой-сервис-без-состояния>Простой сервис без состояния</h3><p>Допустим, у нас есть простой сервис без состояния, развернутый с помощью объектов <code>Deployment</code> и <code>Service</code>. Следующие два фрагмента конфигурации показывают, как можно использовать метки в самом простом варианте.</p><p>Объект <code>Deployment</code> используется для наблюдения за подами, на которых запущено приложение.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Объект <code>Service</code> используется для открытия доступа к приложению.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=веб-приложение-с-базой-данных>Веб-приложение с базой данных</h3><p>Рассмотрим случай немного посложнее: веб-приложение (WordPress), которое использует базу данных (MySQL), установленное с помощью Helm. В следующих фрагментов конфигурации объектов отображена отправная точка развертывания такого приложения.</p><p>Следующий объект <code>Deployment</code> используется для WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Объект <code>Service</code> используется для открытия доступа к WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQL открывается в виде <code>StatefulSet</code> с метаданными как для самого приложения, так и основного (родительского) приложения, к которому принадлежит СУБД:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Объект <code>Service</code> предоставляет MySQL в составе WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Вы заметите, что <code>StatefulSet</code> и <code>Service</code> MySQL содержат больше информации о MySQL и WordPress.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf36ccd6b3dbeafecf87c39761b07c7>4.2 - Кластерная Архитектура</h1><div class=lead>Архитектурные концепции, лежащие в основе Kubernetes.</div></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>4.2.1 - Узлы</h1><p>Kubernetes запускает ваши приложения, помещая контейнеры в Поды для запуска на Узлах (<em>Nodes</em>).
В зависимости от кластера, узел может быть виртуальной или физической машиной. Каждый узел
содержит сервисы, необходимые для запуска
<a class=glossary-tooltip title='Самый маленький и простой объект в Kubernetes. Под — это набор запущенных контейнеров в кластере.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Подов>Подов</a>, управляемых
<a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='плоскостью управления'>плоскостью управления</a>.</p><p>Обычно у вас есть несколько узлов в кластере; однако в среде обучения или среде
с ограниченными ресурсами у вас может быть только один.</p><p><a href=/ru/docs/concepts/overview/components/##%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D1%83%D0%B7%D0%BB%D0%B0>Компоненты</a> на узле включают
<a class=glossary-tooltip title='Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>,
<a class=glossary-tooltip title='Среда выполнения контейнера — это программа, предназначенная для выполнения контейнеров.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='среду выполнения контейнера'>среду выполнения контейнера</a> и
<a class=glossary-tooltip title='kube-proxy — сетевой прокси, работающий на каждом узле в кластере.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>.</p><h2 id=управление>Управление</h2><p>Существует два основных способа добавления Узлов в <a class=glossary-tooltip title='Компонент панели управления, обслуживающий API Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='API сервер'>API сервер</a>:</p><ol><li>Kubelet на узле саморегистрируется в плоскости управления</li><li>Вы или другой пользователь вручную добавляете объект Узла</li></ol><p>После того как вы создадите объект Узла или kubelet на узле самозарегистируется,
плоскость управления проверяет, является ли новый объект Узла валидным (правильным). Например, если вы
попробуете создать Узел при помощи следующего JSON манифеста:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kubernetes создает внутри себя объект Узла (представление). Kubernetes проверяет,
что kubelet зарегистрировался на API сервере, который совпадает со значением поля <code>metadata.name</code> Узла.
Если узел здоров (если все необходимые сервисы запущены),
он имеет право на запуск Пода. В противном случае этот узел игнорируется для любой активности кластера
до тех пор, пока он не станет здоровым.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>Kubernetes сохраняет объект для невалидного Узла и продолжает проверять, становится ли он здоровым.</p><p>Вы или <a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллер>контроллер</a> должны явно удалить объект Узла, чтобы
остановить проверку доступности узла.</p></div><p>Имя объекта Узла должно быть валидным
<a href=/ru/docs/concepts/overview/working-with-objects/names#%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0-%D0%BF%D0%BE%D0%B4%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2-dns>именем поддомена DNS</a>.</p><h3 id=саморегистрация-узлов>Саморегистрация Узлов</h3><p>Когда kubelet флаг <code>--register-node</code> имеет значение <em>true</em> (по умолчанию), то kubelet будет пытаться
зарегистрировать себя на API сервере. Это наиболее предпочтительная модель, используемая большинством дистрибутивов.</p><p>Для саморегистрации kubelet запускается со следующими опциями:</p><ul><li><p><code>--kubeconfig</code> - Путь к учетным данным для аутентификации на API сервере.</p></li><li><p><code>--cloud-provider</code> - Как общаться с <a class=glossary-tooltip title='Организация, которая предлагает платформу облачных вычислений.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/cloud-providers target=_blank aria-label='облачным провайдером'>облачным провайдером</a>, чтобы прочитать метаданные о себе.</p></li><li><p><code>--register-node</code> - Автоматически зарегистрироваться на API сервере.</p></li><li><p><code>--register-with-taints</code> - Зарегистрировать узел с приведенным списком <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label='ограничений (taints)'>ограничений (taints)</a> (разделенных запятыми <code>&lt;key>=&lt;value>:&lt;effect></code>).</p><p>Ничего не делает, если <code>register-node</code> - <em>false</em>.</p></li><li><p><code>--node-ip</code> - IP-адрес узла.</p></li><li><p><code>--node-labels</code> - <a class=glossary-tooltip title='Группирует объекты на основе произвольных критериев, по которым пользователи могут их идентифицировать.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=Метки>Метки</a> для добавления при регистрации узла в кластере (смотрите ограничения для меток, установленные <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>плагином согласования (admission plugin) NodeRestriction</a>).</p></li><li><p><code>--node-status-update-frequency</code> - Указывает, как часто kubelet отправляет статус узла мастеру.</p></li></ul><p>Когда <a href=/docs/reference/access-authn-authz/node/>режим авторизации Узла</a> и
<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>плагин согласования NodeRestriction</a> включены,
kubelet'ы имеют право только создавать/изменять свой собственный ресурс Узла.</p><h3 id=ручное-администрирование-узла>Ручное администрирование узла</h3><p>Вы можете создавать и изменять объекты узла используя
<a class=glossary-tooltip title='A command line tool for communicating with a Kubernetes cluster.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>.</p><p>Когда вы хотите создать объекты Узла вручную, установите kubelet флаг <code>--register-node=false</code>.</p><p>Вы можете изменять объекты Узла независимо от настройки <code>--register-node</code>.
Например, вы можете установить метки на существующем Узле или пометить его не назначаемым.</p><p>Вы можете использовать метки на Узлах в сочетании с селекторами узла на Подах для управления планированием.
Например, вы можете ограничить Под, иметь право на запуск только на группе доступных узлов.</p><p>Маркировка узла как не назначаемого предотвращает размещение планировщиком новых подов на этом Узле,
но не влияет на существующие Поды на Узле. Это полезно в качестве
подготовительного шага перед перезагрузкой узла или другим обслуживанием.</p><p>Чтобы отметить Узел не назначаемым, выполните:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Поды, являющиеся частью <a class=glossary-tooltip title='Гарантирует, что копия Pod выполняется в наборе узлов кластера.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a> допускают
запуск на не назначаемом Узле. DaemonSets обычно обеспечивает локальные сервисы узла,
которые должны запускаться на Узле, даже если узел вытесняется для запуска приложений.</div><h2 id=статус-узла>Статус Узла</h2><p>Статус узла содержит следующие данные:</p><ul><li><a href=#%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0>Адреса (Addresses)</a></li><li><a href=#%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5>Условия (Conditions)</a></li><li><a href=#%D0%B5%D0%BC%D0%BA%D0%BE%D1%81%D1%82%D1%8C>Емкость и Выделяемые ресурсы (Capacity and Allocatable)</a></li><li><a href=#%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F>Информация (Info)</a></li></ul><p>Вы можете использовать <code>kubectl</code> для просмотра статуса Узла и других деталей:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe node &lt;insert-node-name-here&gt;
</span></span></code></pre></div><p>Каждая секция из вывода команды описана ниже.</p><h3 id=адреса-addresses>Адреса (Addresses)</h3><p>Использование этих полей варьируется в зависимости от вашего облачного провайдера или конфигурации физических серверов (<em>bare metal</em>).</p><ul><li>HostName: Имя хоста, сообщаемое ядром узла. Может быть переопределено через kubelet <code>--hostname-override</code> параметр.</li><li>ExternalIP: Обычно, IP адрес узла, который является внешне маршрутизируемым (доступен за пределами кластера).</li><li>InternalIP: Обычно, IP адрес узла, который маршрутизируется только внутри кластера.</li></ul><h3 id=условие>Условия (Conditions)</h3><p>Поле <code>conditions</code> описывает статус всех <code>Running</code> узлов. Примеры условий включают в себя:</p><table><caption style=display:none>Условия узла и описание того, когда применяется каждое условие.</caption><thead><tr><th>Условие Узла</th><th>Описание</th></tr></thead><tbody><tr><td><code>Ready</code></td><td><code>True</code> если узел здоров и готов принять поды, <code>False</code> если узел нездоров и не принимает поды, и <code>Unknown</code> если контроллер узла не получал информацию от узла в течение последнего периода <code>node-monitor-grace-period</code> (по умолчанию 40 секунд)</td></tr><tr><td><code>DiskPressure</code></td><td><code>True</code> если присутствует давление на размер диска - то есть, если емкость диска мала; иначе <code>False</code></td></tr><tr><td><code>MemoryPressure</code></td><td><code>True</code> если существует давление на память узла - то есть, если памяти на узле мало; иначе <code>False</code></td></tr><tr><td><code>PIDPressure</code></td><td><code>True</code> если существует давление на процессы - то есть, если на узле слишком много процессов; иначе <code>False</code></td></tr><tr><td><code>NetworkUnavailable</code></td><td><code>True</code> если сеть для узла настроена некорректно, иначе <code>False</code></td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Если вы используете инструменты командной строки для вывода сведений об блокированном узле,
то Условие включает <code>SchedulingDisabled</code>. <code>SchedulingDisabled</code> не является Условием в Kubernetes API;
вместо этого блокированные узлы помечены как Не назначаемые в их спецификации.</div><p>Состояние узла представлено в виде JSON объекта. Например, следующая структура описывает здоровый узел:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Если значение параметра Status для условия Ready остается <code>Unknown</code> или <code>False</code>
дольше чем период <code>pod-eviction-timeout</code>(аргумент, переданный в
<a class=glossary-tooltip title='Компонент Control Plane запускает процессы контроллера.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>), то все Поды
на узле планируются к удалению контроллером узла. По умолчанию таймаут выселения <strong>пять минут</strong>.
В некоторых случаях, когда узел недоступен, API сервер не может связаться с kubelet на узле.
Решение об удалении подов не может быть передано в kubelet до тех пор, пока связь с API сервером не будет восстановлена.
В то же время поды, которые запланированы к удалению, могут продолжать работать на отделенном узле.</p><p>Контроллер узла не будет принудительно удалять поды до тех пор, пока не будет подтверждено,
что они перестали работать в кластере. Вы можете видеть, что поды, которые могут работать на недоступном узле,
находятся в состоянии <code>Terminating</code> или <code>Unknown</code>. В тех случаях, когда Kubernetes не может сделать вывод
из основной инфраструктуры о том, что узел окончательно покинул кластер, администратору кластера может потребоваться
удалить объект узла вручную. Удаление объекта узла из Kubernetes приводит к удалению всех объектов Подов, запущенных
на узле, с API сервера и освобождает их имена.</p><p>Контроллер жизненного цикла узла автоматически создает
<a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>ограничения (taints)</a>, которые представляют собой условия.
Планировщик учитывает ограничения Узла при назначении Пода на Узел.
Поды так же могут иметь допуски (tolerations), что позволяет им сопротивляться ограничениям Узла.</p><p>Смотрите раздел <a href=/docs/concepts/configuration/taint-and-toleration/#taint-nodes-by-condition>Ограничить Узлы по Условию</a>
для дополнительной информации.</p><h3 id=емкость>Емкость и Выделяемые ресурсы (Capacity and Allocatable)</h3><p>Описывает ресурсы, доступные на узле: CPU, память и максимальное количество подов,
которые могут быть запланированы на узле.</p><p>Поля в блоке capacity указывают общее количество ресурсов, которые есть на Узле.
Блок allocatable указывает количество ресурсов на Узле,
которые доступны для использования обычными Подами.</p><p>Вы можете прочитать больше о емкости и выделяемых ресурсах, изучая, как <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>зарезервировать вычислительные ресурсы</a> на Узле.</p><h3 id=информация-info>Информация (Info)</h3><p>Описывает общую информацию об узле, такую как версия ядра, версия Kubernetes (версии kubelet и kube-proxy), версия Docker (если используется) и название ОС.
Эта информация собирается Kubelet'ом на узле.</p><h3 id=контроллер-узла>Контроллер узла</h3><p><a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label='Контроллер '>Контроллер</a> узла является компонентом
плоскости управления Kubernetes, который управляет различными аспектами узлов.</p><p>Контроллер узла играет различные роли в жизни узла. Первая - назначение CIDR-блока узлу
при его регистрации (если включено назначение CIDR).</p><p>Вторая - поддержание в актуальном состоянии внутреннего списка узлов контроллера узла
согласно списку доступных машин облачного провайдера. При работе в облачной среде всякий раз,
когда узел неисправен, контроллер узла запрашивает облачного провайдера, доступна ли
виртуальная машина для этого узла. Если нет, то контроллер узла удаляет узел из
своего списка узлов.</p><p>Третья - это мониторинг работоспособности узлов. Контроллер узла
отвечает за обновление условия NodeReady для NodeStatus на
ConditionUnknown, когда узел становится недоступным (т.е. контроллер узла
по какой-то причине перестает получать сердцебиения (heartbeats) от узла,
например, из-за того, что узел упал), и затем позже выселяет все поды с узла
(используя мягкое (graceful) завершение) если узел продолжает быть недоступным.
(По умолчанию таймауты составляют 40 секунд, чтобы начать сообщать <code>ConditionUnknown</code>,
и 5 минут после, чтобы начать выселять поды.)</p><p>Контроллер узла проверяет состояние каждого узла каждые <code>--node-monitor-period</code> секунд.</p><h4 id=сердцебиения>Сердцебиения</h4><p>Сердцебиения, посылаемые узлами Kubernetes, помогают определить доступность узла.</p><p>Существует две формы сердцебиений: обновление <code>NodeStatus</code> и
<a href=/docs/reference/generated/kubernetes-api/v1.25/#lease-v1-coordination-k8s-io>Lease объект</a>.
Каждый узел имеет связанный с ним Lease объект в <code>kube-node-lease</code>
<a class=glossary-tooltip title='An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.
Lease - это легковесный ресурс, который улучшает производительность
сердцебиений узла при масштабировании кластера.</p><p>Kubelet отвечает за создание и обновление <code>NodeStatus</code> и Lease объекта.</p><ul><li>Kubelet обновляет <code>NodeStatus</code> либо когда происходит изменение статуса,
либо если в течение настроенного интервала обновления не было. По умолчанию
интервал для обновлений <code>NodeStatus</code> составляет 5 минут (намного больше,
чем 40-секундный стандартный таймаут для недоступных узлов).</li><li>Kubelet создает и затем обновляет свой Lease объект каждый 10 секунд
(интервал обновления по умолчанию). Lease обновления происходят независимо от
<code>NodeStatus</code> обновлений. Если обновление Lease завершается неудачно,
kubelet повторяет попытку с экспоненциальным откатом, начинающимся с 200 миллисекунд и ограниченным 7 секундами.</li></ul><h4 id=надежность>Надежность</h4><p>В большинстве случаев контроллер узла ограничивает скорость выселения
до <code>--node-eviction-rate</code> (по умолчанию 0,1) в секунду, что означает,
что он не выселяет поды с узлов быстрее чем с одного узла в 10 секунд.</p><p>Поведение выселения узла изменяется, когда узел в текущей зоне доступности
становится нездоровым. Контроллер узла проверяет, какой процент узлов в зоне
нездоров (NodeReady условие в значении ConditionUnknown или ConditiononFalse)
в одно и то же время. Если доля нездоровых узлов не меньше
<code>--unhealthy-zone-threshold</code> (по умолчанию 0.55), то скорость выселения уменьшается:
если кластер небольшой (т.е. количество узлов меньше или равно
<code>--large-cluster-size-threshold</code> - по умолчанию, 50), то выселения прекращаются,
в противном случае скорость выселения снижается до
<code>--secondary-node-eviction-rate</code> (по умолчанию, 0.01) в секунду.</p><p>Причина, по которой эти политики реализуются для каждой зоны доступности, заключается в том,
что одна зона доступности может стать отделенной от мастера, в то время как другие
остаются подключенными. Если ваш кластер не охватывает несколько зон доступности
облачного провайдера, то существует только одна зона доступности (весь кластер).</p><p>Основная причина разнесения ваших узлов по зонам доступности заключается в том,
что приложения могут быть перенесены в здоровые зоны, когда одна из зон полностью
становится недоступной. Поэтому, если все узлы в зоне нездоровы, то контроллер узла
выселяет поды с нормальной скоростью <code>--node-eviction-rate</code>. Крайний случай - когда все зоны
полностью нездоровы (т.е. в кластере нет здоровых узлов). В таком случае
контроллер узла предполагает, что существует некоторая проблема с подключением к мастеру,
и останавливает все выселения, пока какое-нибудь подключение не будет восстановлено.</p><p>Контроллер узла также отвечает за выселение подов, запущенных на узлах с
<code>NoExecute</code> ограничениями, за исключением тех подов, которые сопротивляются этим ограничениям.
Контроллер узла так же добавляет <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=ограничения>ограничения</a>
соответствующие проблемам узла, таким как узел недоступен или не готов. Это означает,
что планировщик не будет размещать поды на нездоровых узлах.</p><div class="alert alert-warning caution callout" role=alert><strong>Внимание:</strong> <code>kubectl cordon</code> помечает узел как 'не назначаемый', что имеет побочный эффект от контроллера сервисов,
удаляющего узел из любых списков целей LoadBalancer узла, на которые он ранее имел право,
эффективно убирая входящий трафик балансировщика нагрузки с блокированного узла(ов).</div><h3 id=емкость-узла>Емкость узла</h3><p>Объекты узла отслеживают информацию о емкости ресурсов узла (например,
объем доступной памяти и количество CPU).
Узлы, которые <a href=#%D1%81%D0%B0%D0%BC%D0%BE%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D1%83%D0%B7%D0%BB%D0%BE%D0%B2>самостоятельно зарегистрировались</a>, сообщают
о своей емкости во время регистрации. Если вы <a href=#%D1%80%D1%83%D1%87%D0%BD%D0%BE%D0%B5-%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%83%D0%B7%D0%BB%D0%B0>вручную</a>
добавляете узел, то вам нужно задать информацию о емкости узла при его добавлении.</p><p><a class=glossary-tooltip title='Компонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=Планировщик>Планировщик</a> Kubernetes гарантирует,
что для всех Подов на Узле достаточно ресурсов. Планировщик проверяет,
что сумма requests от контейнеров на узле не превышает емкость узла.
Эта сумма requests включает все контейнеры, управляемые kubelet,
но исключает любые контейнеры, запущенные непосредственно средой выполнения контейнера,
а также исключает любые процессы, запущенные вне контроля kubelet.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Если вы явно хотите зарезервировать ресурсы для процессов, не связанных с Подами, смотрите раздел
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>зарезервировать ресурсы для системных демонов</a>.</div><h2 id=топология-узла>Топология узла</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>Если вы включили <code>TopologyManager</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>, то kubelet
может использовать подсказки топологии при принятии решений о выделении ресурсов.
Смотрите <a href=/docs/tasks/administer-cluster/topology-manager/>Контроль Политик Управления Топологией на Узле</a>
для дополнительной информации.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Подробнее про<a href=/ru/docs/concepts/overview/components/#%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D1%83%D0%B7%D0%BB%D0%B0>компоненты</a> из которых состоит узел.</li><li>Подробнее про <a href=/docs/reference/generated/kubernetes-api/v1.25/#node-v1-core>Определение API для Узла</a>.</li><li>Подробнее про <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Узлы</a>
of the architecture design document.</li><li>Подробнее про <a href=/docs/concepts/configuration/taint-and-toleration/>ограничения и допуски</a>.</li><li>Подробнее про <a href=/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaling>авто масштабирование кластера</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0251def6da29b30afebfb04549f1703>4.2.2 - Связь между плоскостью управления и узлом</h1><p>Этот документ описывает связь между плоскостью управления (apiserver) и кластером Kubernetes. Цель состоит в том, чтобы позволить пользователям настраивать свою установку для усиления сетевой конфигурации, чтобы кластер мог работать в ненадежной сети (или на полностью общедоступных IP-адресах облачного провайдера).</p><h2 id=связь-между-плоскостью-управления-и-узлом>Связь между плоскостью управления и узлом</h2><p>В Kubernetes имеется API шаблон «ступица и спица» (hub-and-spoke). Все используемые API из узлов (или которые запускают pod-ы) завершает apiserver. Ни один из других компонентов плоскости управления не предназначен для предоставления удаленных сервисов. Apiserver настроен на прослушивание удаленных подключений через безопасный порт HTTPS (обычно 443) с одной или несколькими включенными формами <a href=/docs/reference/access-authn-authz/authentication/>аутентификации</a> клиента.</p><p>Должна быть включена одна или несколько форм <a href=/docs/reference/access-authn-authz/authorization/>авторизации</a>, особенно, если разрешены <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>анонимные запросы</a> или <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>ServiceAccount токены</a>.</p><p>Узлы должны быть снабжены публичным корневым сертификатом для кластера, чтобы они могли безопасно подключаться к apiserver-у вместе с действительными учетными данными клиента. Хороший подход заключается в том, чтобы учетные данные клиента, предоставляемые kubelet-у, имели форму клиентского сертификата. См. Информацию о загрузке kubelet TLS <a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLS bootstrapping</a> для автоматической подготовки клиентских сертификатов kubelet.</p><p>Pod-ы, которые хотят подключиться к apiserver, могут сделать это безопасно, используя ServiceAccount, чтобы Kubernetes автоматически вводил общедоступный корневой сертификат и действительный токен-носитель в pod при его создании.
Служба <code>kubernetes</code> (в пространстве имен <code>default</code>) настроена с виртуальным IP-адресом, который перенаправляет (через kube-proxy) на HTTPS эндпоинт apiserver-а.</p><p>Компоненты уровня управления также взаимодействуют с кластером apiserver-а через защищенный порт.</p><p>В результате режим работы по умолчанию для соединений от узлов и модулей, работающих на узлах, к плоскости управления по умолчанию защищен и может работать в ненадежных и/или общедоступных сетях.</p><h2 id=узел-к-плоскости-управления>Узел к плоскости управления</h2><p>Существуют два пути связи плоскости управления (apiserver) с узлами. Первый - от apiserver-а до kubelet процесса, который выполняется на каждом узле кластера. Второй - от apiserver к любому узлу, pod-у или службе через промежуточную функциональность apiserver-а.</p><h3 id=apiserver-в-kubelet>apiserver в kubelet</h3><p>Соединение из apiserver-а к kubelet используются для:</p><ul><li>Извлечения логов с pod-ов.</li><li>Прикрепление (через kubectl) к запущенным pod-ам.</li><li>Обеспечение функциональности переадресации портов kubelet.</li></ul><p>Эти соединения завершаются на HTTPS эндпоинте kubelet-a. По умолчанию apiserver не проверяет сертификат обслуживания kubelet-ов, что делает соединение подверженным к атаке «человек посередине» (man-in-the-middle) и <strong>небезопасным</strong> к запуску в ненадежных и/или общедоступных сетях.</p><p>Для проверки этого соединения используется флаг <code>--kubelet-certificate-authority</code> чтобы предоставить apiserver-у набор корневых (root) сертификатов для проверки сертификата обслуживания kubelet-ов.</p><p>Если это не возможно, используйте <a href=#ssh-tunnels>SSH-тунелирование</a> между apiserver-ом и kubelet, если это необходимо, чтобы избежать подключения по ненадежной или общедоступной сети.</p><p>Наконец, должны быть включены <a href=/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/>аутентификация или авторизация kubelet</a> для защиты kubelet API.</p><h3 id=apiserver-для-узлов-pod-ов-и-служб>apiserver для узлов, pod-ов, и служб</h3><p>Соединения с apiserver к узлу, поду или сервису по умолчанию осуществляются по-обычному HTTP-соединению и поэтому не аутентифицируются, и не шифруются. Они могут быть запущены по защищенному HTTPS-соединению, после добавления префикса <code>https:</code> к имени узла, пода или сервиса в URL-адресе API, но они не будут проверять сертификат предоставленный HTTPS эндпоинтом, как и не будут предоставлять учетные данные клиента. Таким образом, хотя соединение будет зашифровано, оно не обеспечит никаких гарантий целостности. Эти соединения <strong>в настоящее время небезопасны</strong> для запуска в ненадежных или общедоступных сетях.</p><h3 id=ssh-туннели>SSH-туннели</h3><p>Kubernetes поддерживает SSH-туннели для защиты плоскости управления узлов от путей связи. В этой конфигурации apiserver инициирует SSH-туннель для каждого узла в кластере (подключается к ssh-серверу, прослушивая порт 22) и передает весь трафик предназначенный для kubelet, узлу, pod-у или службе через туннель. Этот туннель гарантирует, что трафик не выводится за пределы сети, в которой работает узел.</p><p>SSH-туннели в настоящее время устарели, поэтому вы не должны использовать их, если не знаете, что делаете. Служба подключения является заменой этого канала связи.</p><h3 id=служба-подключения>Служба подключения</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>В качестве замены SSH-туннелям, служба подключения обеспечивает уровень полномочия TCP для плоскости управления кластерной связи. Служба подключения состоит из двух частей: сервер подключения к сети плоскости управления и агентов подключения в сети узлов. Агенты службы подключения инициируют подключения к серверу подключения и поддерживают сетевое подключение. После включения службы подключения, весь трафик с плоскости управления на узлы проходит через эти соединения.</p><p>Следуйте инструкциям <a href=/docs/tasks/extend-kubernetes/setup-konnectivity/>Задача службы подключения,</a> чтобы настроить службу подключения в кластере.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>4.2.3 - Контроллеры</h1><p>В робототехнике и автоматизации, <em>цикл управления</em> - это непрерывный цикл, который регулирует состояние системы.</p><p>Вот один из примеров контура управления: термостат в помещении.</p><p>Когда вы устанавливаете температуру, это говорит термостату о вашем <em>желаемом состоянии</em>. Фактическая температура в помещении - это
<em>текущее состояние</em>. Термостат действует так, чтобы приблизить текущее состояние к желаемому состоянию, путем включения или выключения оборудования.</p>Контроллеры в Kubernetes - управляющие циклы, которые отслеживают состояние вашего
<a class=glossary-tooltip title='Набор машин, так называемые узлы, которые запускают контейнеризированные приложения. Кластер имеет как минимум один рабочий узел.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=кластера>кластера</a>, затем вносят или запрашивают
изменения там, где это необходимо.
Каждый контроллер пытается привести текущее состояние кластера ближе к желаемому состоянию.<h2 id=шаблон-контроллера>Шаблон контроллера</h2><p>Контроллер отслеживает по крайней мере один тип ресурса Kubernetes.
Эти <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>объекты</a>
имеют поле спецификации, которое представляет желаемое состояние. Контроллер (ы) для этого ресурса несут ответственность за приближение текущего состояния к желаемому состоянию</p><p>Контроллер может выполнить это действие сам; чаще всего в Kubernetes,
контроллер отправляет сообщения на
<a class=glossary-tooltip title='Компонент панели управления, обслуживающий API Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='сервер API'>сервер API</a> которые имеют
полезные побочные эффекты. Пример этого вы можете увидеть ниже.</p><h3 id=управление-с-помощью-сервера-api>Управление с помощью сервера API</h3><p>Контроллер <a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> является примером встроенного контроллера Kubernetes. Встроенные контроллеры управляют состоянием, взаимодействуя с кластером сервера API.</p><p>Задание - это ресурс Kubernetes, который запускает
<a class=glossary-tooltip title='Самый маленький и простой объект в Kubernetes. Под — это набор запущенных контейнеров в кластере.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>, или возможно несколько Pod-ов, выполняющих задачу и затем останавливающихся.</p><p>(После <a href=/docs/concepts/scheduling-eviction/>планирования</a>, Pod объекты становятся частью желаемого состояния для kubelet).</p><p>Когда контроллер задания видит новую задачу, он убеждается что где-то в вашем кластере kubelet-ы на множестве узлов запускают нужное количество Pod-ов для выполнения работы.
Контроллер задания сам по себе не запускает никакие Pod-ы или контейнеры. Вместо этого контроллер задания сообщает серверу API о создании или удалении Pod-ов.
Другие компоненты в
<a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='плоскости управления'>плоскости управления</a>
действуют на основе информации (имеются ли новые запланированные Pod-ы для запуска), и в итоге работа завершается.</p><p>После того как вы создадите новое задание, желаемое состояние для этого задания будет завершено. Контроллер задания приближает текущее состояние этой задачи к желаемому состоянию: создает Pod-ы, выполняющие работу, которую вы хотели для этой задачи, чтобы задание было ближе к завершению.</p><p>Контроллеры также обновляют объекты которые их настраивают.
Например: как только работа выполнена для задания, контроллер задания обновляет этот объект задание, чтобы пометить его как <code>Завершенный</code>.</p><p>(Это немного похоже на то, как некоторые термостаты выключают свет, чтобы указать, что теперь ваша комната имеет установленную вами температуру).</p><h3 id=прямое-управление>Прямое управление</h3><p>В отличие от Задания, некоторым контроллерам нужно вносить изменения в вещи за пределами вашего кластера.</p><p>Например, если вы используете контур управления, чтобы убедиться, что в вашем кластере достаточно <a class=glossary-tooltip title='Узел — рабочая машина в Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Узлов>Узлов</a>,
тогда этому контроллеру нужно что-то вне текущего кластера, чтобы при необходимости запустить новые узлы.</p><p>Контроллеры, которые взаимодействуют с внешним состоянием, находят свое желаемое состояние с сервера API, а затем напрямую взаимодействуют с внешней системой, чтобы приблизить текущее состояние.</p><p>(На самом деле существует <a href=https://github.com/kubernetes/autoscaler/>контроллер</a>, который горизонтально масштабирует узлы в вашем кластере.)</p><p>Важным моментом здесь является то, что контроллер вносит некоторые изменения, чтобы вызвать желаемое состояние, а затем сообщает текущее состояние обратно на сервер API вашего кластера. Другие контуры управления могут наблюдать за этими отчетными данными и предпринимать собственные действия.</p><p>В примере с термостатом, если в помещении очень холодно, тогда другой контроллер может также включить обогреватель для защиты от замерзания. В кластерах Kubernetes, плоскость управления косвенно работает с инструментами управления IP-адресами, службами хранения данных, API облачных провайдеров и другими службами для реализации
<a href=/docs/concepts/extend-kubernetes/>расширения Kubernetes</a>.</p><h2 id=desired-vs-current>Желаемое против текущего состояния</h2><p>Kubernetes использует систему вида cloud-native и способен справляться с постоянными изменениями.</p><p>Ваш кластер может изменяться в любой по мере выполнения работы и контуры управления автоматически устраняют сбой. Это означает, что потенциально Ваш кластер никогда не достигнет стабильного состояния.</p><p>Пока контроллеры вашего кластера работают и могут вносить полезные изменения, не имеет значения, является ли общее состояние стабильным или нет.</p><h2 id=дизайн>Дизайн</h2><p>В качестве принципа своей конструкции Kubernetes использует множество контроллеров, каждый из которых управляет определенным аспектом состояния кластера. Чаще всего конкретный контур управления (контроллер) использует один вид ресурса в качестве своего желаемого состояния и имеет другой вид ресурса, которым он управляет, чтобы это случилось. Например, контроллер для заданий отслеживает объекты заданий (для обнаружения новой работы) и объекты модулей (для выполнения заданий, а затем для того, чтобы видеть, когда работа завершена). В этом случае что-то еще создает задания, тогда как контроллер заданий создает Pod-ы.</p><p>Полезно иметь простые контроллеры, а не один монолитный набор взаимосвязанных контуров управления. Контроллеры могут выйти из строя, поэтому Kubernetes предназначен для этого.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>Существует несколько контроллеров, которые создают или обновляют один и тот же тип объекта. За кулисами контроллеры Kubernetes следят за тем, чтобы обращать внимание только на ресурсы, связанные с их контролирующим ресурсом.</p><p>Например, у вас могут быть развертывания и задания; они оба создают Pod-ы. Контроллер заданий не удаляет Pod-ы созданные вашим развертыванием, потому что имеется информационные (<a class=glossary-tooltip title='Группирует объекты на основе произвольных критериев, по которым пользователи могут их идентифицировать.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=метки>метки</a>)
которые могут быть использованы контроллерами тем самым показывая отличие Pod-ов.</p></div><h2 id=running-controllers>Способы запуска контроллеров</h2><p>Kubernetes поставляется с набором встроенных контроллеров, которые работают внутри <a class=glossary-tooltip title='Компонент Control Plane запускает процессы контроллера.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>. Эти встроенные контроллеры обеспечивают важные основные функции.</p><p>Контроллер развертывания и контроллер заданий - это примеры контроллеров, которые входят в состав самого Kubernetes («встроенные» контроллеры).
Kubernetes позволяет вам запускать устойчивую плоскость управления, так что в случае отказа одного из встроенных контроллеров работу берет на себя другая часть плоскости управления.</p><p>Вы можете найти контроллеры, которые работают вне плоскости управления, чтобы расширить Kubernetes.
Или, если вы хотите, можете написать новый контроллер самостоятельно. Вы можете запустить свой собственный контроллер в виде наборов Pod-ов,
или внешнее в Kubernetes. Что подойдет лучше всего, будет зависеть от того, что делает этот конкретный контроллер.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Прочтите о <a href=/docs/concepts/overview/components/#control-plane-components>плоскости управления Kubernetes</a></li><li>Откройте для себя некоторые из основных <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/>объектов Kubernetes</a></li><li>Узнайте больше о <a href=/docs/concepts/overview/kubernetes-api/>Kubernetes API</a></li><li>Если вы хотите написать собственный контроллер, см <a href=/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>Шаблоны расширения</a> в расширении Kubernetes.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>4.2.4 - Диспетчер облачных контроллеров</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>Технологии облачной инфраструктуры позволяют запускать Kubernetes в общедоступных, частных и гибридных облаках. Kubernetes верит в автоматизированную, управляемую API инфраструктуру без жесткой связи между компонентами.</p><p><p>Диспетчер облачных контроллеров компонент <a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='панель управления'>панель управления</a> Kubernetes - это встраиваемый в логику управления облочная спецификация. Диспетчер облачных контроллеров позволяет связать кластер с API поставщика облачных услуг и отделить компоненты, взаимодействующие с этой облачной платформой, от компонентов, взаимодействующих только с вашим кластером.</p></p><p>Отделяя логику взаимодействия между Kubernetes и базовой облачной инфраструктурой, компонент cloud-controller-manager позволяет поставщикам облачных услуг выпускать функции в другом темпе по сравнению с основным проектом Kubernetes.</p><p>Диспетчер облачных контроллеров спроектирован с использованием механизма плагинов, которые позволяют различным облачным провайдерам интегрировать свои платформы с Kubernetes.</p><h2 id=дизайн>Дизайн</h2><p><img src=/images/docs/components-of-kubernetes.svg alt="Kubernetes components"></p><p>Диспетчер облачных контроллеров работает в панели управления как реплицированный набор процессов (обычно это контейнер в Pod-ах). Каждый диспетчер облачных контроллеров реализует множество <a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллеров>контроллеров</a> в единственном процессе.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Вы также можете запустить диспетчер облачных контроллеров как <a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=дополнение>дополнение</a> Kubernetes, а не как часть панели управления.</div><h2 id=functions-of-the-ccm>Функции диспетчера облачных контроллеров</h2><p>Контроллеры внутри диспетчера облачных контроллеров включают в себя:</p><h3 id=контроллер-узла>Контроллер узла</h3><p>Контроллер узла отвечает за создание объектов <a class=glossary-tooltip title='Узел — рабочая машина в Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=узла>узла</a> при создании новых серверов в вашей облачной инфраструктуре. Контроллер узла получает информацию о работающих хостах внутри вашей арендуемой инфраструктуры облачного провайдера.
Контроллер узла выполняет следующие функции:</p><ol><li>Инициализация объектов узла для каждого сервера, которые контроллер получает через API облачного провайдера.</li><li>Аннотирование и маркировка объектов узла специфичной для облака информацией, такой как регион узла и доступные ему ресурсы (процессор, память и т.д.).</li><li>Получение имени хоста и сетевых адресов.</li><li>Проверка работоспособности узла. В случае, если узел перестает отвечать на запросы, этот контроллер проверяет с помощью API вашего облачного провайдера, был ли сервер деактивирован / удален / прекращен. Если узел был удален из облака, контроллер удаляет объект узла из вашего Kubernetes кластера.</li></ol><p>Некоторые облачные провайдеры реализуют его разделение на контроллер узла и отдельный контроллер жизненного цикла узла.</p><h3 id=контроллер-маршрута>Контроллер маршрута</h3><p>Контроллер маршрута отвечает за соответствующую настройку маршрутов в облаке, чтобы контейнеры на разных узлах кластера Kubernetes могли взаимодействовать друг с другом.</p><p>В зависимости от облачного провайдера, контроллер маршрута способен также выделять блоки IP-адресов для сети Pod-ов.</p><h3 id=контроллер-сервисов>Контроллер сервисов</h3><p><a class=glossary-tooltip title='Способ представления приложения, запущенного в наборе подов, в виде сетевого сервиса.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Сервисы>Сервисы</a> интегрируются с компонентами облачной инфраструктуры, такими как управляемые балансировщики нагрузки, IP-адреса, фильтрация сетевых пакетов и проверка работоспособности целевых объектов. Контроллер сервисов взаимодействует с API вашего облачного провайдера для настройки требуемых балансировщиков нагрузки и других компонентов инфраструктуры, когда вы объявляете ресурсы сервисов.</p><h2 id=авторизация>Авторизация</h2><p>В этом разделе разбирается доступ к различным объектам API, который нужен облачным контроллерам для выполнения своих операций.</p><h3 id=authorization-node-controller>Контроллер узла</h3><p>Контроллер узла работает только с объектом узла. Он требует полного доступа на чтение и изменение объектов узла.</p><p><code>v1/Node</code>:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=authorization-route-controller>Контроллер маршрута</h3><p>Контроллер маршрута прослушивает создание объектов узла и соответствующим образом настраивает маршруты. Для этого требуется получить доступ к объектам узла.</p><p><code>v1/Node</code>:</p><ul><li>Get</li></ul><h3 id=authorization-service-controller>Контроллер сервисов</h3><p>Контроллер сервисов прослушивает события Create, Update и Delete объектов служб, а затем соответствующим образом настраивает конечные точки для соответствующих сервисов.</p><p>Для доступа к сервисам требуется доступ к событиям List и Watch. Для обновления сервисов требуется доступ к событиям Patch и Update.</p><p>Чтобы настроить ресурсы конечных точек для сервисов, требуется доступ к событиям Create, List, Get, Watch и Update.</p><p><code>v1/Service</code>:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=authorization-miscellaneous>Другие</h3><p>Реализация ядра диспетчера облачных контроллеров требует доступ для создания объектов событий, а для обеспечения безопасной работы требуется доступ к созданию сервисных учетных записей (ServiceAccounts).</p><p><code>v1/Event</code>:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p><code>v1/ServiceAccount</code>:</p><ul><li>Create</li></ul><p><a class=glossary-tooltip title='Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a> ClusterRole для диспетчера облачных контроллеров выглядит так:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=что-дальше>Что дальше</h2><p><a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>Администрирование диспетчера облачных контроллеров</a>
содержит инструкции по запуску и управлению диспетчером облачных контроллеров.</p><p>Хотите знать, как реализовать свой собственный диспетчер облачных контроллеров или расширить проект?</p><p>Диспетчер облачных контроллеров использует интерфейсы Go, которые позволяют реализовать подключение из любого облака. В частности, он использует интерфейс <code>CloudProvider</code>, который определен в <a href=https://github.com/kubernetes/cloud-provider/blob/release-1.21/cloud.go#L42-L69><code>cloud.go</code></a> из <a href=https://github.com/kubernetes/cloud-provider>kubernetes/cloud-provider</a>.</p><p>Реализация общих контроллеров, описанных в этом документе (Node, Route, и Service), а также некоторые другие вспомогательные конструкции, вместе с общим интерфейсом облачного провайдера являются частью ядра Kubernetes. Особые реализации для облачных провайдеров находятся вне ядра Kubernetes и реализуют интерфейс <code>CloudProvider</code>.</p><p>Дополнительные сведения о разработке плагинов см. в разделе <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Разработка диспетчера облачных контроллеров</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-44a2e2e592af0846101e970aff9243e5>4.2.5 - Сборщик мусора</h1><p>Сборщик мусора - это собирательный термин для различных механизмов? используемых Kubernetes для очистки ресурсов кластера. Это позволить очистить ресурсы, такие как:</p><ul><li><a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>Неудачные pod-ы</a></li><li><a href=/docs/concepts/workloads/controllers/ttlafterfinished/>Завершенные задания</a></li><li><a href=#owners-dependents>Объекты без ссылок на владельца Objects</a></li><li><a href=#containers-images>Не используемые контейнеры и образы контейнеров</a></li><li><a href=/docs/concepts/storage/persistent-volumes/#delete>Dynamically provisioned PersistentVolumes with a StorageClass reclaim policy of Delete</a></li><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process>Устаревшие или просроченные запросы подписания сертификатов (CSR)</a></li><li><a class=glossary-tooltip title='Узел — рабочая машина в Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Nodes>Nodes</a> удалено в следующих сценариях:<ul><li>В облаке, когда кластер использует <a href=/docs/concepts/architecture/cloud-controller/>диспетчер облачных контроллеров</a></li><li>Локально когда кластер использует дополнение, аналогичное диспетчер облачных контроллеров</li></ul></li><li><a href=/docs/concepts/architecture/nodes/#heartbeats>Объекты аренды узлов</a></li></ul><h2 id=owners-dependents>Владельцы и зависимости</h2><p>Многие объекты в Kubernetes ссылаются друг на друга через <a href=/docs/concepts/overview/working-with-objects/owners-dependents/><em>ссылки владельцев</em></a>.
Ссылки владельцев сообщают плоскости управления какие объекты зависят от других.
Kubernetes использует ссылки владельцев, чтобы предоставить плоскости управления и другим API
клиентам, возможность очистить связанные ресурсы перед удалением объекта. В большинстве случаев, Kubernetes автоматический управляет ссылками владельцев.</p><p>Владелец отличается от <a href=/docs/concepts/overview/working-with-objects/labels/>меток и селекторов</a>
которые также используют некоторые ресурсы. Например, рассмотрим
<a class=glossary-tooltip title='Способ представления приложения, запущенного в наборе подов, в виде сетевого сервиса.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Службу>Службу</a> которая создает объект
<code>EndpointSlice</code>. Служба использует <em>метки</em> чтобы позволить плоскости управления определить какие <code>EndpointSlice</code> объекты используются для этой службы. В дополнение
к меткам, каждый <code>EndpointSlice</code> управляет ои имени службы, имеет
ссылку владельца. Ссылки владельцев помогают различным частям Kubernetes избегать
вмешательства в объекты, которые они не контролируют.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>Ссылки на владельцев перекрестных пространств имен запрещены по дизайну.
Зависимости пространства имен могут указывать на область действия кластера или владельцев пространства имен.
Владелец пространства имен <strong>должен</strong> быть в том же пространстве имен, что и зависимости.
Если это не возможно, ссылка владельца считается отсутствующей и зависимый объект подлежит удалению, как только будет проверено отсутствие всех владельцев.</p><p>Зависимости области действия кластер может указывать только владельцев области действия кластера.
В версии v1.20+, если зависимость с областью действия кластера указывает на пространство имен как владелец,
тогда он рассматривается как имеющий неразрешимую ссылку на владельца и не может быть обработан сборщиком мусора.</p><p>В версии v1.20+, если сборщик мусора обнаружит недопустимое перекрестное пространство имен <code>ownerReference</code>,
или зависящие от области действия кластера <code>ownerReference</code> ссылка на тип пространства имен, предупреждающее событие с причиной <code>OwnerRefInvalidNamespace</code> и <code>involvedObject</code> сообщающее о недействительной зависимости.
Вы можете проверить наличие такого рода событий, выполнив <code>kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace</code>.</p></div><h2 id=cascading-deletion>Каскадное удаление</h2><p>Kubernetes проверяет и удаляет объекты, на которые больше нет ссылок владельцев, так же как и pod-ов, оставленных после удаления ReplicaSet. Когда Вы удаляете объект, вы можете контролировать автоматический ли Kubernetes удаляет зависимые объекты автоматически в процессе вызова <em>каскадного удаления</em>. Существует два типа каскадного удаления, а именно:</p><ul><li>Каскадное удаление Foreground</li><li>Каскадное удаление Background</li></ul><p>Вы так же можете управлять как и когда сборщик мусора удаляет ресурсы, на которые ссылаются владельцы с помощью Kubernetes <a class=glossary-tooltip title='A namespaced key that tells Kubernetes to wait until specific conditions are met before it fully deletes an object marked for deletion.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=finalizers>finalizers</a>.</p><h3 id=foreground-deletion>Каскадное удаление Foreground</h3><p>В Каскадном удалении Foreground, объект владельца, который вы удаляете, сначала переходить в состояние <em>в процессе удаления</em>. В этом состоянии с объектом-владельцем происходить следующее:</p><ul><li>Сервер Kubernetes API устанавливает полю объекта <code>metadata.deletionTimestamp</code>
время, когда объект был помечен для удаления.</li><li>Сервер Kubernetes API так же устанавливает метку <code>metadata.finalizers</code>для поля
<code>foregroundDeletion</code>.</li><li>Объект остается видимым благодаря Kubernetes API пока процесс удаления не завершиться</li></ul><p>После того как владелец объекта переходит в состояние прогресса удаления, контроллер удаляет зависимые объекты. После удаления всех зависимых объектов, контроллер удаляет объект владельца. На этом этапе, объект больше не отображается в Kubernetes API.</p><p>Во время каскадного удаления foreground, единственным зависимым, которые блокируют удаления владельца, являются те, у кого имеется поле <code>ownerReference.blockOwnerDeletion=true</code>.
Чтобы узнать больше. Смотрите <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-foreground-cascading-deletion>Использование каскадного удаления foreground</a>.</p><h3 id=background-deletion>Каскадное удаление Background</h3><p>В каскадном удалении background, сервер Kubernetes API немедленно удаляет владельца объекта, а контроллер очищает зависимые объекты в фоновом режиме. По умолчанию, Kubernetes использует каскадное удаление background, если вы в ручную не используете удаление foreground или не решите отключить зависимые объекты.</p><p>Чтобы узнать больше. Смотрите <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-background-cascading-deletion>Использование каскадного удаления background</a>.</p><h3 id=осиротевшие-зависимости>Осиротевшие зависимости</h3><p>Когда Kubernetes удаляет владельца объекта, оставшиеся зависимости называются <em>осиротевшими</em> объектами. По умолчанию, Kubernetes удаляет зависимые объекты. Чтобы узнать, как переопределить это поведение смотрите <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#set-orphan-deletion-policy>Удаление объектов владельца и осиротевших зависимостей</a>.</p><h2 id=containers-images>Сбор мусора из неиспользуемых контейнеров и изображений</h2><p><a class=glossary-tooltip title='Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> выполняет сбор мусора для неиспользуемых образов каждые пять минут и для неиспользуемых контейнеров каждую минуту. Вам следует избегать использования внешних инструментов для сборки мусора, так как они могут
нарушить поведение kubelet и удалить контейнеры, которые должны существовать.</p><p>Чтобы настроить параметры для сборщика мусора для неиспользуемого контейнера и сборки мусора образа, подстройте
kubelet использую <a href=/docs/tasks/administer-cluster/kubelet-config-file/>конфигурационный файл</a>
и измените параметры, связанные со сборщиком мусора используя тип ресурса
<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration><code>KubeletConfiguration</code></a>.</p><h3 id=жизненный-цикл-контейнерных-образов-container-image-lifecycle>Жизненный цикл контейнерных образов Container image lifecycle</h3><p>Kubernetes управляет жизненным циклом всех образов с помощью своего <em>менеджера образов</em>, которые являются частью kubelet, в сотрудничестве с cadvisor. При принятии решений о сборке мусора, kubelet учитывает следующие ограничения использования диска:</p><ul><li><code>HighThresholdPercent</code></li><li><code>LowThresholdPercent</code></li></ul><p>Использование диска выше настроенного значения <code>HighThresholdPercent</code> запускает сборку мусора, которая удаляет образы в порядке основанном на последнем использовании, начиная с самого старого. Kubelet удаляет образы до тех пор, пока использование диска не достигнет значения <code>LowThresholdPercent</code>.</p><h3 id=container-image-garbage-collection>Сборщик мусора контейнерных образов</h3><p>Kubelet собирает не используемые контейнеры на основе следующих переменных, которые вы можете определить:</p><ul><li><code>MinAge</code>: минимальный возраст, при котором kubelet может начать собирать мусор контейнеров. Отключить, установив значение <code>0</code>.</li><li><code>MaxPerPodContainer</code>: максимальное количество неактивных контейнеров, которое может быть у каждой пары Pod-ов. Отключить, установив значение меньше чем <code>0</code>.</li><li><code>MaxContainers</code>: максимальное количество не используемых контейнеров, которые могут быть в кластере. Отключить, установив значение меньше чем <code>0</code>.</li></ul><p>В дополнение к этим переменным, kubelet собирает неопознанные и удаленные контейнеры, обычно начиная с самого старого.</p><p><code>MaxPerPodContainer</code> и <code>MaxContainer</code> могут потенциально конфликтовать друг с другом в ситуациях, когда требуется максимальное количество контейнеров в Pod-е (<code>MaxPerPodContainer</code>) выйдет за пределы допустимого общего количества глобальных не используемых контейнеров (<code>MaxContainers</code>). В этой ситуации kubelet регулирует <code>MaxPodPerContainer</code> для устранения конфликта. Наихудшим сценарием было бы понизить <code>MaxPerPodContainer</code> да <code>1</code> и изгнать самые старые контейнеры.
Кроме того, владельцы контейнеров в pod-е могут быть удалены, как только они становятся старше чем <code>MinAge</code>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Kubelet собирает мусор только у контейнеров, которыми он управляет.</div><h2 id=configuring-gc>Настройка сборщик мусора</h2><p>Вы можете настроить сборку мусора ресурсов, настроив параметры, специфичные для контроллеров, управляющих этими ресурсами. В последующих страницах показано, как настроить сборку мусора:</p><ul><li><a href=/docs/tasks/administer-cluster/use-cascading-deletion/>Настройка каскадного удаления объектов Kubernetes</a></li><li><a href=/docs/concepts/workloads/controllers/ttlafterfinished/>Настройка очистки завершенных заданий</a></li></ul><h2 id=что-дальше>Что дальше</h2><ul><li>Узнайте больше о <a href=/docs/concepts/overview/working-with-objects/owners-dependents/>ownership of Kubernetes objects</a>.</li><li>Узнайте больше о Kubernetes <a href=/docs/concepts/overview/working-with-objects/finalizers/>finalizers</a>.</li><li>Узнать о <a href=/docs/concepts/workloads/controllers/ttlafterfinished/>TTL контроллере</a> (beta) that cleans up finished Jobs.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-285a3785fd3d20f437c28d87ca4dadca>4.3 - Администрирование кластера</h1><div class=lead>Lower-level detail relevant to creating or administering a Kubernetes cluster.</div><p>Обзор администрирования кластера предназначен для всех, кто создает или администрирует кластер Kubernetes. Это предполагает некоторое знакомство с основными <a href=/docs/concepts/>концепциями</a> Kubernetes.</p><h2 id=планирование-кластера>Планирование кластера</h2><p>См. Руководства в разделе <a href=/docs/setup/>настройка</a> для получения примеров того, как планировать, устанавливать и настраивать кластеры Kubernetes. Решения, перечисленные в этой статье, называются <em>distros</em>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> не все дистрибутивы активно поддерживаются. Выбирайте дистрибутивы, протестированные с последней версией Kubernetes.</div><p>Прежде чем выбрать руководство, вот некоторые соображения:</p><ul><li>Вы хотите опробовать Kubernetes на вашем компьютере или собрать много узловой кластер высокой доступности? Выбирайте дистрибутивы, наиболее подходящие для ваших нужд.</li><li>Будете ли вы использовать <strong>размещенный кластер Kubernetes</strong>, такой, как <a href=https://cloud.google.com/kubernetes-engine/>Google Kubernetes Engine</a> или <strong>разместите собственный кластер</strong>?</li><li>Будет ли ваш кластер <strong>в помещении</strong> или <strong>в облаке (IaaS)</strong>? Kubernetes не поддерживает напрямую гибридные кластеры. Вместо этого вы можете настроить несколько кластеров.</li><li><strong>Если вы будете настраивать Kubernetes в помещении (локально)</strong>, подумайте, какая <a href=/docs/concepts/cluster-administration/networking/>сетевая модель</a> подходит лучше всего.</li><li>Будете ли вы запускать Kubernetes на <strong>оборудований "bare metal"</strong> или на <strong>виртуальных машинах (VMs)</strong>?</li><li>Вы хотите <strong>запустить кластер</strong> или планируете <strong>активно разворачивать код проекта Kubernetes</strong>? В последнем случае выберите активно разрабатываемый дистрибутив. Некоторые дистрибутивы используют только двоичные выпуски, но предлагают более широкий выбор.</li><li>Ознакомьтесь с <a href=/docs/concepts/overview/components/>компонентами</a> необходимые для запуска кластера.</li></ul><h2 id=управление-кластером>Управление кластером</h2><ul><li><p>Узнайте как <a href=/docs/concepts/architecture/nodes/>управлять узлами</a>.</p></li><li><p>Узнайте как настроить и управлять <a href=/docs/concepts/policy/resource-quotas/>квотами ресурсов</a> для общих кластеров.</p></li></ul><h2 id=обеспечение-безопасности-кластера>Обеспечение безопасности кластера</h2><ul><li><p><a href=/docs/tasks/administer-cluster/certificates/>Сгенерировать сертификаты</a> описывает шаги по созданию сертификатов с использованием различных цепочек инструментов.</p></li><li><p><a href=/docs/concepts/containers/container-environment/>Kubernetes Container Environment</a> описывает среду для управляемых контейнеров Kubelet на узле Kubernetes.</p></li><li><p><a href=/docs/concepts/security/controlling-access>Управление доступом к Kubernetes API</a> описывает как Kubernetes реализует контроль доступа для своего собственного API.</p></li><li><p><a href=/docs/reference/access-authn-authz/authentication/>Аутентификация</a> объясняет аутентификацию в Kubernetes, включая различные варианты аутентификации.</p></li><li><p><a href=/docs/reference/access-authn-authz/authorization/>Авторизация</a> отделена от аутентификации и контролирует обработку HTTP-вызовов.</p></li><li><p><a href=/docs/reference/access-authn-authz/admission-controllers/>Использование контроллеров допуска</a> explains plug-ins which intercepts requests to the Kubernetes API server after authentication and authorization.</p></li><li><p><a href=/docs/tasks/administer-cluster/sysctl-cluster/>Использование Sysctls в кластере Kubernetes</a> описывает администратору, как использовать sysctl инструмент командной строки для установки параметров ядра.</p></li><li><p><a href=/docs/tasks/debug-application-cluster/audit/>Аудит</a> описывает, как взаимодействовать с журналами аудита Kubernetes.</p></li></ul><h3 id=обеспечение-безопасности-kubelet>Обеспечение безопасности kubelet</h3><ul><li><a href=/docs/concepts/architecture/control-plane-node-communication/>Связь между плоскостью управления и узлом</a></li><li><a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>Загрузка TLS</a></li><li><a href=/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/>Аутентификация/авторизация Kubelet</a></li></ul><h2 id=дополнительные-кластерные-услуги>Дополнительные кластерные услуги</h2><ul><li><p><a href=/docs/concepts/services-networking/dns-pod-service/>Интеграция DNS</a> описывает как разрешить DNS имя непосредственно службе Kubernetes.</p></li><li><p><a href=/docs/concepts/cluster-administration/logging/>Ведение журнала и мониторинг активности кластера</a> объясняет, как работает ведение журнала в Kubernetes и как его реализовать.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf9a93ab5ba014fb6ff70b22c29d432>4.3.1 - Сертификаты</h1><p>Чтобы узнать, как генерировать сертификаты для кластера, см. раздел <a href=/docs/tasks/administer-cluster/certificates/>Сертификаты</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-85d633ae590aa20ec024f1b7af1d74fc>4.3.2 - Установка дополнений</h1><div class="alert alert-secondary callout third-party-content" role=alert><strong>Заметка:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div><p>Надстройки расширяют функциональность Kubernetes.</p><p>На этой странице перечислены некоторые из доступных надстроек и ссылки на соответствующие инструкции по установке.</p><h2 id=сеть-и-сетевая-политика>Сеть и сетевая политика</h2><ul><li><a href=https://www.github.com/noironetworks/aci-containers>ACI</a> обеспечивает интегрированную сеть контейнеров и сетевую безопасность с помощью Cisco ACI.</li><li><a href=https://antrea.io/>Antrea</a> работает на уровне 3, обеспечивая сетевые службы и службы безопасности для Kubernetes, используя Open vSwitch в качестве уровня сетевых данных.</li><li><a href=https://docs.projectcalico.org/latest/introduction/>Calico</a> Calico поддерживает гибкий набор сетевых опций, поэтому вы можете выбрать наиболее эффективный вариант для вашей ситуации, включая сети без оверлея и оверлейные сети, с или без BGP. Calico использует тот же механизм для обеспечения соблюдения сетевой политики для хостов, модулей и (при использовании Istio и Envoy) приложений на уровне сервисной сети (mesh layer).</li><li><a href=https://projectcalico.docs.tigera.io/getting-started/kubernetes/flannel/flannel>Canal</a> объединяет Flannel и Calico, обеспечивая сеть и сетевую политику.</li><li><a href=https://github.com/cilium/cilium>Cilium</a> - это плагин сети L3 и сетевой политики, который может прозрачно применять политики HTTP/API/L7. Поддерживаются как режим маршрутизации, так и режим наложения/инкапсуляции, и он может работать поверх других подключаемых модулей CNI.</li><li><a href=https://github.com/cni-genie/CNI-Genie>CNI-Genie</a> позволяет Kubernetes легко подключаться к выбору плагинов CNI, таких как Calico, Canal, Flannel, Romana или Weave.</li><li><a href=https://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/>Contrail</a>, основан на <a href=https://tungsten.io>Tungsten Fabric</a>, представляет собой платформу для виртуализации мультиоблачных сетей с открытым исходным кодом и управления политиками. Contrail и Tungsten Fabric интегрированы с системами оркестрации, такими как Kubernetes, OpenShift, OpenStack и Mesos, и обеспечивают режимы изоляции для виртуальных машин, контейнеров/подов и рабочих нагрузок без операционной системы.</li><li><a href=https://github.com/flannel-io/flannel#deploying-flannel-manually>Flannel</a> - это поставщик оверлейной сети, который можно использовать с Kubernetes.</li><li><a href=https://github.com/ZTE/Knitter/>Knitter</a> - это плагин для поддержки нескольких сетевых интерфейсов Kubernetes подов.</li><li><a href=https://github.com/k8snetworkplumbingwg/multus-cni>Multus</a> - это плагин Multi для работы с несколькими сетями в Kubernetes, который поддерживает большинство самых популярных <a href=https://github.com/containernetworking/cni>CNI</a> (например: Calico, Cilium, Contiv, Flannel), в дополнение к рабочим нагрузкам основанных на SRIOV, DPDK, OVS-DPDK и VPP в Kubernetes.</li><li><a href=https://github.com/ovn-org/ovn-kubernetes/>OVN-Kubernetes</a> - это сетевой провайдер для Kubernetes основанный на <a href=https://github.com/ovn-org/ovn/>OVN (Open Virtual Network)</a>, реализация виртуальной сети, появившийся в результате проекта Open vSwitch (OVS). OVN-Kubernetes обеспечивает сетевую реализацию на основе наложения для Kubernetes, включая реализацию балансировки нагрузки и сетевой политики на основе OVS.</li><li><a href=https://github.com/opnfv/ovn4nfv-k8s-plugin>OVN4NFV-K8S-Plugin</a> - это подключаемый модуль контроллера CNI на основе OVN для обеспечения облачной цепочки сервисных функций (SFC), несколько наложенных сетей OVN, динамического создания подсети, динамического создания виртуальных сетей, сети поставщика VLAN, сети прямого поставщика и подключаемого к другим Multi Сетевые плагины, идеально подходящие для облачных рабочих нагрузок на периферии в сети с несколькими кластерами.</li><li><a href=https://docs.vmware.com/en/VMware-NSX-T-Data-Center/index.html>NSX-T</a> плагин для контейнера (NCP) обеспечивающий интеграцию между VMware NSX-T и контейнерами оркестраторов, таких как Kubernetes, а так же интеграцию между NSX-T и контейнеров на основе платформы CaaS/PaaS, таких как Pivotal Container Service (PKS) и OpenShift.</li><li><a href=https://github.com/nuagenetworks/nuage-kubernetes/blob/v5.1.1-1/docs/kubernetes-1-installation.rst>Nuage</a> - эта платформа SDN, которая обеспечивает сетевое взаимодействие на основе политик между Kubernetes подами и не Kubernetes окружением, с отображением и мониторингом безопасности.</li><li><a href=https://github.com/romana/romana>Romana</a> - это сетевое решение уровня 3 для сетей подов, которое также поддерживает <a href=/docs/concepts/services-networking/network-policies/>NetworkPolicy API</a>. Подробности установки Kubeadm доступны <a href=https://github.com/romana/romana/tree/master/containerize>здесь</a>.</li><li><a href=https://www.weave.works/docs/net/latest/kubernetes/kube-addon/>Weave Net</a> предоставляет сеть и обеспечивает сетевую политику, будет работать на обеих сторонах сетевого раздела и не требует внешней базы данных.</li></ul><h2 id=обнаружение-служб>Обнаружение служб</h2><ul><li><a href=https://coredns.io>CoreDNS</a> - это гибкий, расширяемый DNS-сервер, который может быть <a href=https://github.com/coredns/deployment/tree/master/kubernetes>установлен</a> в качестве внутрикластерного DNS для подов.</li></ul><h2 id=визуализация-и-контроль>Визуализация и контроль</h2><ul><li><a href=https://github.com/kubernetes/dashboard#kubernetes-dashboard>Dashboard</a> - это веб-интерфейс панели инструментов для Kubernetes.</li><li><a href=https://www.weave.works/documentation/scope-latest-installing/#k8s>Weave Scope</a> - это инструмент для графической визуализации ваших контейнеров, подов, сервисов и т.д. Используйте его вместе с <a href=https://cloud.weave.works/>учетной записью Weave Cloud</a> или разместите пользовательский интерфейс самостоятельно.</li></ul><h2 id=инфраструктура>Инфраструктура</h2><ul><li><a href=https://kubevirt.io/user-guide/#/installation/installation>KubeVirt</a> - это дополнение для запуска виртуальных машин в Kubernetes. Обычно работает на bare-metal кластерах.</li></ul><h2 id=legacy-add-ons>Legacy Add-ons</h2><p>В устаревшем каталоге <a href=https://git.k8s.io/kubernetes/cluster/addons>cluster/addons</a> задокументировано несколько других дополнений.</p><p>Ссылки на те, в хорошем состоянии, должны быть здесь. Пул реквесты приветствуются!</p></div><div class=td-content style=page-break-before:always><h1 id=pg-68ec2370d0409cc27325be36693f9368>5 - Руководства</h1><p>В данном разделе документации Kubernetes можно найти руководства. В них рассказывается, как достичь определённой цели, а не просто выполнить одну <a href=/docs/tasks/>задачу</a>. Большинство уроков состоит из нескольких разделов, каждый из которых включает в себя шаги для последовательного выполнения. Перед тем как приступить к выполнению уроков, может быть полезно ознакомиться со <a href=/ru/docs/reference/glossary/>словарем терминов</a> для последующих обращений.</p><h2 id=основы>Основы</h2><ul><li><p><a href=/ru/docs/tutorials/kubernetes-basics/>Основы Kubernetes</a> - подробное интерактивное руководство, направленное на понимание системы и предлагающее попробовать некоторые основные возможности Kubernetes.</p></li><li><p><a href=https://www.udacity.com/course/scalable-microservices-with-kubernetes--ud615>Масштабируемые микросервисы с Kubernetes (Udacity)</a></p></li><li><p><a href=https://www.edx.org/course/introduction-kubernetes-linuxfoundationx-lfs158x#>Введение в Kubernetes (edX)</a></p></li><li><p><a href=/ru/docs/tutorials/hello-minikube/>Привет, Minikube</a></p></li></ul><h2 id=конфигурирование>Конфигурирование</h2><ul><li><a href=/docs/tutorials/configuration/configure-redis-using-configmap/>Конфигурирование Redis с использованием ConfigMap</a></li></ul><h2 id=приложения-без-состояния>Приложения без состояния</h2><ul><li><p><a href=/docs/tutorials/stateless-application/expose-external-ip-address/>Установка внешнего IP адреса для получения доступа к приложению в кластере</a></p></li><li><p><a href=/docs/tutorials/stateless-application/guestbook/>Пример: развёртывание приложения "Гостевая книга" на PHP с использованием Redis</a></p></li></ul><h2 id=приложения-с-состоянием>Приложения с состоянием</h2><ul><li><p><a href=/docs/tutorials/stateful-application/basic-stateful-set/>Основы StatefulSet</a></p></li><li><p><a href=/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>Пример: WordPress и MySQL с персистентным хранилищем</a></p></li><li><p><a href=/docs/tutorials/stateful-application/cassandra/>Пример: Развёртывание Cassandra с Stateful Sets</a></p></li><li><p><a href=/docs/tutorials/stateful-application/zookeeper/>Запуск ZooKeeper, A CP Distributed System</a></p></li></ul><h2 id=кластеры>Кластеры</h2><ul><li><p><a href=/docs/tutorials/clusters/apparmor/>AppArmor</a></p></li><li><p><a href=/docs/tutorials/clusters/seccomp/>seccomp</a></p></li></ul><h2 id=сервисы>Сервисы</h2><ul><li><a href=/docs/tutorials/services/source-ip/>Использование IP</a></li></ul><h2 id=что-дальше>Что дальше</h2><p>Если вы хотите создать руководство самостоятельно, обратитесь к странице <a href=/ru/docs/home/contribute/page-templates/>Использование шаблонов страниц</a>, чтобы узнать информацию и посмотреть шаблоны для составления руководств.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5e3051fff9e84735871d9fb5e7b93f33>5.1 - Привет, Minikube</h1><p>Это руководство покажет вам, как запустить простое Hello World Node.js приложение
на Kubernetes используя <a href=/docs/getting-started-guides/minikube>Minikube</a> и Katacoda.
Katacoda предоставляет бесплатную, встроенную в браузер Kubernetes среду.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Вы также можете следовать этому руководству, если вы установили <a href=/docs/tasks/tools/install-minikube/>Minikube locally</a>.</div><h2 id=цели>Цели</h2><ul><li>Разверните hello world приложение в Minikube.</li><li>Запустите приложение.</li><li>Посмотрите логи приложения.</li></ul><h2 id=подготовка-к-работе>Подготовка к работе</h2><p>Для этого примера создан образ контейнера, собранный на основе следующих файлов:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ru/examples/minikube/server.js download=minikube/server.js><code>minikube/server.js</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("minikube-server-js")' title="Copy minikube/server.js to clipboard"></img></div><div class=includecode id=minikube-server-js><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a2f;font-weight:700>var</span> http <span style=color:#666>=</span> require(<span style=color:#b44>&#39;http&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>var</span> handleRequest <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>function</span>(request, response) {
</span></span><span style=display:flex><span>  console.log(<span style=color:#b44>&#39;Получен запрос на URL: &#39;</span> <span style=color:#666>+</span> request.url);
</span></span><span style=display:flex><span>  response.writeHead(<span style=color:#666>200</span>);
</span></span><span style=display:flex><span>  response.end(<span style=color:#b44>&#39;Hello World!&#39;</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>var</span> www <span style=color:#666>=</span> http.createServer(handleRequest);
</span></span><span style=display:flex><span>www.listen(<span style=color:#666>8080</span>);
</span></span></code></pre></div></div></div><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ru/examples/minikube/Dockerfile download=minikube/Dockerfile><code>minikube/Dockerfile</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("minikube-dockerfile")' title="Copy minikube/Dockerfile to clipboard"></img></div><div class=includecode id=minikube-dockerfile><pre tabindex=0><code class=language-conf data-lang=conf>FROM node:6.14.2
EXPOSE 8080
COPY server.js .
CMD [ &#34;node&#34;, &#34;server.js&#34; ]
</code></pre></div></div><p>Чтобы получить больше информации по запуску команды <code>docker build</code>, ознакомьтесь с <a href=https://docs.docker.com/engine/reference/commandline/build/>документацией по Docker</a>.</p><h2 id=создание-кластера-minikube>Создание кластера Minikube</h2><ol><li><p>Нажмите <strong>Запуск Терминала</strong></p><script defer src=https://katacoda.com/embed.js></script>
<button class=button onclick=window.katacoda.init()>Launch Terminal</button><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Если у вас локально установлен Minikube, выполните <code>minikube start</code>.</div></li><li><p>Откройте веб-панель Kubernetes в браузере:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube dashboard
</span></span></code></pre></div></li><li><p>Только для окружения Katacoda: В верхней части панели нажмите знак "плюс", а затем на <strong>Select port to view on Host 1</strong> (<strong>Выберите порт для отображения на хосте 1</strong>).</p></li><li><p>Только для окружения Katacoda: введите <code>30000</code>, а затем нажмите <strong>Display Port</strong> (<strong>Показать порт</strong>).</p></li></ol><h2 id=создание-deployment>Создание Deployment</h2><p><a href=/docs/concepts/workloads/pods/pod/><em>Под</em></a> Kubernetes - это группа из одного или более контейнеров, связанных друг с другом с целью адмистрирования и организации сети. В данном руководстве под включает в себя один контейнер. <a href=/docs/concepts/workloads/controllers/deployment/><em>Deployment</em></a> в Kubernetes проверяет здоровье пода и перезагружает контейнер пода в случае его отказа. Deployment-ы являются рекоммендуемым способом организации создания и масштабирования подов.</p><ol><li><p>Используйте команду <code>kubectl create</code> для создание деплоймента для управления подом. Под запускает контейнер на основе предоставленного Docker образа.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment hello-node --image<span style=color:#666>=</span>k8s.gcr.io/echoserver:1.4
</span></span></code></pre></div></li><li><p>Посмотреть информацию о Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployments
</span></span></code></pre></div><p>Вывод:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>hello-node   <span style=color:#666>1</span>         <span style=color:#666>1</span>         <span style=color:#666>1</span>            <span style=color:#666>1</span>           1m
</span></span></code></pre></div></li><li><p>Посмотреть информацию о поде:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>Вывод:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                          READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>hello-node-5f76cf6ccf-br9b5   1/1       Running   <span style=color:#666>0</span>          1m
</span></span></code></pre></div></li><li><p>Посмотреть события кластера:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div></li><li><p>Посмотреть <code>kubectl</code> конфигурацию:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Больше информации о командах <code>kubectl</code> можно найти по ссылке <a href=/docs/user-guide/kubectl-overview/>обзор kubectl</a>.</div></li></ol><h2 id=создание-сервиса>Создание сервиса</h2><p>По-умолчанию под доступен только при обращении по его внутреннему IP адресу внутри кластера Kubernetes. Чтобы сделать контейнер <code>hello-node</code> доступным вне виртульной сети Kubernetes, необходимо представить под как <a href=/docs/concepts/services-networking/service/><em>сервис</em></a> Kubernetes.</p><ol><li><p>Сделать под доступным для публичной сети Интернет можно с помощью команды <code>kubectl expose</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment hello-node --type<span style=color:#666>=</span>LoadBalancer --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div><p>Флаг <code>--type=LoadBalancer</code> показывает, что сервис должен быть виден вне кластера.</p></li><li><p>Посмотреть только что созданный сервис:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services
</span></span></code></pre></div><p>Вывод:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>          AGE
</span></span><span style=display:flex><span>hello-node   LoadBalancer   10.108.144.78   &lt;pending&gt;     8080:30369/TCP   21s
</span></span><span style=display:flex><span>kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          23m
</span></span></code></pre></div><p>Для облачных провайдеров, поддерживающих балансировщики нагрузки, для доступа к сервису будет предоставлен внешний IP адрес. В Minikube тип <code>LoadBalancer</code> делает сервис доступным при обращении с помощью команды <code>minikube service</code>.</p></li><li><p>Выполните следующую команду:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube service hello-node
</span></span></code></pre></div></li><li><p>Только для окружения Katacoda: Нажмите на знак "Плюс", затем нажмите <strong>Select port to view on Host 1</strong>.</p></li><li><p>Только для окружения Katacoda: Введите <code>30369</code> (порт указан рядом с <code>8080</code> в выводе сервиса), затем нажмите ???.</p><p>Откроется окно браузера, в котором запущено ваше приложение и будет отображено сообщение "Hello World".</p></li></ol><h2 id=добавление-дополнений>Добавление дополнений</h2><p>В Minikube есть набор встроенных дополнений, которые могут быть включены, выключены и открыты в локальном окружении Kubernetes.</p><ol><li><p>Отобразить текущие поддерживаемые дополнения:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons list
</span></span></code></pre></div><p>Вывод:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>addon-manager: enabled
</span></span><span style=display:flex><span>dashboard: enabled
</span></span><span style=display:flex><span>default-storageclass: enabled
</span></span><span style=display:flex><span>efk: disabled
</span></span><span style=display:flex><span>freshpod: disabled
</span></span><span style=display:flex><span>gvisor: disabled
</span></span><span style=display:flex><span>heapster: disabled
</span></span><span style=display:flex><span>helm-tiller: disabled
</span></span><span style=display:flex><span>ingress: disabled
</span></span><span style=display:flex><span>ingress-dns: disabled
</span></span><span style=display:flex><span>logviewer: disabled
</span></span><span style=display:flex><span>metrics-server: disabled
</span></span><span style=display:flex><span>nvidia-driver-installer: disabled
</span></span><span style=display:flex><span>nvidia-gpu-device-plugin: disabled
</span></span><span style=display:flex><span>registry: disabled
</span></span><span style=display:flex><span>registry-creds: disabled
</span></span><span style=display:flex><span>storage-provisioner: enabled
</span></span><span style=display:flex><span>storage-provisioner-gluster: disabled
</span></span></code></pre></div></li><li><p>Включить дополнение, например, <code>metrics-server</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons <span style=color:#a2f>enable</span> metrics-server
</span></span></code></pre></div><p>Вывод:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>metrics-server was successfully enabled
</span></span></code></pre></div></li><li><p>Посмотреть Pod и Service, которые вы только что создали:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod,svc -n kube-system
</span></span></code></pre></div><p>Вывод:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                                        READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>pod/coredns-5644d7b6d9-mh9ll                1/1       Running   <span style=color:#666>0</span>          34m
</span></span><span style=display:flex><span>pod/coredns-5644d7b6d9-pqd2t                1/1       Running   <span style=color:#666>0</span>          34m
</span></span><span style=display:flex><span>pod/metrics-server-67fb648c5                1/1       Running   <span style=color:#666>0</span>          26s
</span></span><span style=display:flex><span>pod/etcd-minikube                           1/1       Running   <span style=color:#666>0</span>          34m
</span></span><span style=display:flex><span>pod/influxdb-grafana-b29w8                  2/2       Running   <span style=color:#666>0</span>          26s
</span></span><span style=display:flex><span>pod/kube-addon-manager-minikube             1/1       Running   <span style=color:#666>0</span>          34m
</span></span><span style=display:flex><span>pod/kube-apiserver-minikube                 1/1       Running   <span style=color:#666>0</span>          34m
</span></span><span style=display:flex><span>pod/kube-controller-manager-minikube        1/1       Running   <span style=color:#666>0</span>          34m
</span></span><span style=display:flex><span>pod/kube-proxy-rnlps                        1/1       Running   <span style=color:#666>0</span>          34m
</span></span><span style=display:flex><span>pod/kube-scheduler-minikube                 1/1       Running   <span style=color:#666>0</span>          34m
</span></span><span style=display:flex><span>pod/storage-provisioner                     1/1       Running   <span style=color:#666>0</span>          34m
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>NAME                           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>             AGE
</span></span><span style=display:flex><span>service/metrics-server         ClusterIP   10.96.241.45    &lt;none&gt;        80/TCP              26s
</span></span><span style=display:flex><span>service/kube-dns               ClusterIP   10.96.0.10      &lt;none&gt;        53/UDP,53/TCP       34m
</span></span><span style=display:flex><span>service/monitoring-grafana     NodePort    10.99.24.54     &lt;none&gt;        80:30002/TCP        26s
</span></span><span style=display:flex><span>service/monitoring-influxdb    ClusterIP   10.111.169.94   &lt;none&gt;        8083/TCP,8086/TCP   26s
</span></span></code></pre></div></li><li><p>Отключить <code>metrics-server</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons disable metrics-server
</span></span></code></pre></div><p>Вывод:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>metrics-server was successfully disabled
</span></span></code></pre></div></li></ol><h2 id=освобождение-ресурсов>Освобождение ресурсов</h2><p>Теперь вы можете освободить ресурсы созданного вами кластера:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete service hello-node
</span></span><span style=display:flex><span>kubectl delete deployment hello-node
</span></span></code></pre></div><p>Остановите выполнение виртуальной машины Minikube (опционально):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube stop
</span></span></code></pre></div><p>Удалите виртуальную машину Minikube (опционально):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube delete
</span></span></code></pre></div><h2 id=что-дальше>Что дальше</h2><ul><li>Больше об <a href=/docs/concepts/workloads/controllers/deployment/>объектах деплоймента</a>.</li><li>Больше о <a href=/docs/user-guide/deploying-applications/>развёртывании приложения</a>.</li><li>Больше об <a href=/docs/concepts/services-networking/service/>объектах сервиса</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3c83f53a74233ace9b289ac5e24c3e62>5.2 - Основы Kubernetes</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-9><h2>Основы Kubernetes</h2><p>В данном руководстве вы познакомитесь с основами системы оркестрации кластеров Kubernetes. Каждый модуль содержит краткую справочную информацию по основной функциональности и концепциям Kubernetes, а также включает интерактивные онлайн-уроки. С их помощью вы научитесь самостоятельно управлять простым кластером и контейнеризированными приложениями, которые были в нём развернуты.</p><p>Пройдя интерактивные уроки, вы узнаете, как:</p><ul><li>развёртывать контейнеризированное приложение в кластер;</li><li>масштабировать развёртывание;</li><li>обновить контейнеризированное приложение на новую версию ПО;</li><li>отлаживать контейнеризированное приложение.</li></ul><p>Все руководства используют сервис Katacoda, поэтому в вашем браузере будет показан виртуальный терминал с запущенным Minikube — небольшой локальной средой Kubernetes, которая может работать где угодно. Вам не потребуется устанавливать дополнительное ПО или вообще что-либо настраивать. Каждый интерактивный урок запускается непосредственно в вашем браузере.</p></div></div><br><div class=row><div class=col-md-9><h2>Чем может Kubernetes помочь вам?</h2><p>От современных веб-сервисов пользователи ожидают, что приложения будут доступны 24/7, а разработчики — развёртывать новые версии приложений по нескольку раз в день. Контейнеризация направлена на достижение этой цели, посольку позволяет выпускать и обновлять приложения без простоев. Kubernetes гарантирует, что ваши контейнеризованные приложения будет запущены где угодно и когда угодно, вместе со всеми необходимыми для их работы ресурсами и инструментами. Kubernetes — это готовая к промышленному использованию платформа с открытым исходным кодом, разработанная на основе накопленного опыта Google по оркестровке контейнеров и вобравшая в себя лучшие идеи от сообщества.</p></div></div><br><div id=basics-modules class=content__modules><h2>Учебные модули по основам Kubernetes</h2><div class=row><div class=col-md-12><div class=row><div class=col-md-4><div class=thumbnail><a href=/ru/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_01.svg?v=1469803628347" alt></a><div class=caption><a href=/ru/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/><h5>1. Создание кластера Kubernetes</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/ru/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_02.svg?v=1469803628347" alt></a><div class=caption><a href=/ru/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/><h5>2. Развёртывание приложения</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/ru/docs/tutorials/kubernetes-basics/explore/explore-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_03.svg?v=1469803628347" alt></a><div class=caption><a href=/ru/docs/tutorials/kubernetes-basics/explore/explore-intro/><h5>3. Изучение приложения</h5></a></div></div></div></div></div><div class=col-md-12><div class=row><div class=col-md-4><div class=thumbnail><a href=/ru/docs/tutorials/kubernetes-basics/expose/expose-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_04.svg?v=1469803628347" alt></a><div class=caption><a href=/ru/docs/tutorials/kubernetes-basics/expose/expose-intro/><h5>4. Открытие доступа к приложению</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/ru/docs/tutorials/kubernetes-basics/scale/scale-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_05.svg?v=1469803628347" alt></a><div class=caption><a href=/ru/docs/tutorials/kubernetes-basics/scale/scale-intro/><h5>5. Масштабирование приложения</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/ru/docs/tutorials/kubernetes-basics/update/update-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_06.svg?v=1469803628347" alt></a><div class=caption><a href=/ru/docs/tutorials/kubernetes-basics/update/update-intro/><h5>6. Обновление приложения</h5></a></div></div></div></div></div></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-7df66040311338d6098ebeab43ba9afb>5.2.1 - Создание кластера</h1></div><div class=td-content><h1 id=pg-de49316920e97a82e36763cb66781ada>5.2.1.1 - Использование Minikube для создания кластера</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Темы</h3><ul><li>Узнать, что такое кластер Kubernetes.</li><li>Узнать, что такое Minikube.</li><li>Запуск кластера Kubernetes через онлайн-терминал.</li></ul></div><div class=col-md-8><h3>Кластеры Kubernetes</h3><p><b>Задача Kubernetes заключается в координации кластера компьютеров, работающего как одно целое.</b> Абстрактные объекты в Kubernetes позволяют развертывать контейнеризированные приложения в кластер, не привязывая их к отдельным машинам. Для использования этой новой модели развертывания, приложения должны быть подготовлены так, чтобы они не зависели от конкретных хостов, т.е. они должны быть упакованы в контейнеры. Приложения в контейнерах более гибки и доступны, чем в предыдущих моделях развертывания, когда приложения устанавливались непосредственно на конкретные машины в виде пакетов, тесно связанных с хостом. <b>Kubernetes автоматизирует распределение и выполнение контейнеров приложений для запуска в кластере более эффективным образом.</b> Kubernetes — это платформа с открытым исходным кодом, готовая к промышленной эксплуатации.</p><p>Кластер Kubernetes состоит из двух типов ресурса:<ul><li><b>Мастер (ведущий узел)</b> управляет кластером</li><li><b>Рабочие узлы</b> — машины, на которых выполняются приложения</li></ul></p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Краткое содержание:</h3><ul><li>Кластер Kubernetes</li><li>Minikube</li></ul></div><div class="content__box content__box_fill"><p><i>Kubernetes — платформа с открытым исходным кодом промышленного уровня, которая управляет размещением (планированием) и запуском контейнеров приложений в пределах компьютерных кластеров и между ними.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Схема кластера</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_01_cluster.svg></p></div></div><br><div class=row><div class=col-md-8><p><b>Мастер отвечает за управление кластером.</b> Мастер координирует все процессы в кластере, такие как планирование выполнения приложений, сохранение требуемого состояния приложений, а также их масштабирование и обновление.</p><p><b>Узел — это виртуальная машина или физический компьютер, который выполняет роль рабочего узла в кластере Kubernetes.</b> У каждого узла есть Kubelet — агент, управляющий узлом и взаимодействующий с ведущим узлом Kubernetes. Узел также имеет инструменты для выполнения контейнерных операций, например, Docker или rkt. Кластер Kubernetes в промышленном окружении должен состоять как минимум из трёх узлов.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Ведущие узлы управляют кластером и узлами, которые используются для запуска приложений.</i></p></div></div></div><div class=row><div class=col-md-8><p>При развертывании приложений в Kubernetes вы сообщаете ведущему узлу запускать контейнеры приложений. Ведущий узел планирует выполнение контейнеров на узлах кластера. <b>Узлы взаимодействуют с ведущим узлом посредством <a href=/docs/concepts/overview/kubernetes-api/>API Kubernetes</a></b>, который предлагает ведущий узел. Кроме этого, конечные пользователи могут напрямую использовать API Kubernetes для работы с кластером.</p><p>Kubernetes-кластер может быть развернут на физических или виртуальных машинах. Чтобы начать работать с Kubernetes, можно использовать Minikube. Minikube — это упрощённая реализация Kubernetes, которая создает виртуальную машину на вашем локальном компьютере и разворачивает простой кластер с одним узлом. Minikube доступен для Linux, macOS и Windows. В CLI-инструменте Minikube есть основные операции для инициализации кластера, включая запуск, завершение, просмотра состояния и удаления кластера. Однако в этом уроке вы будете использовать онлайн-терминал с уже установленным Minikube.</p><p>Теперь, когда вы знаете, что такое Kubernetes, можно перейти к онлайн-уроку, где вы запустите ваш первый кластер!</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ru/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/ role=button>Начать интерактивный урок <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-323b75976001e8dfe35d67d61bc74f1a>5.2.1.2 - Интерактивный урок - Создание кластера</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Данный экран слишком маленький, чтобы работать с терминалом, пожалуйста, используйте компьютер или планшет.</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/1 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ru/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/ role=button>Перейти ко второму модулю<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-76d78b3fba507f7ed33cef14a35b631d>5.2.2 - Развёртывание приложения</h1></div><div class=td-content><h1 id=pg-2b1bba431989008c7493109a0f049ece>5.2.2.1 - Использование kubectl для развёртывания приложения</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Темы</h3><ul><li>Узнать про развёртывания приложения.</li><li>Развернуть первое приложение на Kubernetes с помощью kubectl.</li></ul></div><div class=col-md-8><h3>Развёртывания Kubernetes</h3><p>Как только вы запустили кластер Kubernetes, вы можете развернуть на нём свои контейнеризированные приложения. Для этого вам нужно создать конфигурацию <b>развёртывания (Deployment)</b> в Kubernetes. Развёртывание сообщает Kubernetes, как создавать и обновлять экземпляры вашего приложения. После создания развёртывания ведущий узел Kubernetes планирует запустить экземпляры приложения на отдельных узлах в кластере.</p><p>Когда экземпляры приложения были созданы, контроллер развёртывания Kubernetes непрерывно отслеживает их. Если узел, на котором размещен экземпляр, вышёл из строя или был удалён, контроллер развёртывания вместо этого экземпляра использует экземпляр на другом узле в кластере. <b>Этот процесс представляет собой механизм самовосстановления, обеспечивающий работу кластера в случае возникновения аппаратных неисправностей либо технических работ.</b><p>До того, как появились системы оркестровки, для запуска приложений обычно использовались установочные скрипты, которые не перезапускались после сбоя компьютера. Создавая экземпляры приложений и поддерживая их работу на нескольких узлах, развёртывания Kubernetes коренным образом отличаются в плане управления приложениями.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Краткое содержание:</h3><ul><li>Развёртывания</li><li>Kubectl</li></ul></div><div class="content__box content__box_fill"><p><i>Развёртывание отвечает за создание и обновление экземпляров приложения</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Развёртывание вашего первого приложения на Kubernetes</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg></p></div></div><br><div class=row><div class=col-md-8><p>Вы можете создавать и управлять развёртыванием через командный инструмент Kubernetes под названием <b>Kubectl</b>. Kubectl использует API Kubernetes для работы с кластером. В этом модуле вы узнаете про наиболее используемые команды Kubectl, необходимые для создания развёртываний, которые будут запускать приложения в кластере Kubernetes.</p><p>При создании развертывания нужно указать образ контейнера приложения и количество запущенных реплик. Впоследствии эти параметры можно изменить. В модулях <a href=/ru/docs/tutorials/kubernetes-basics/scale/scale-intro/>5</a> и <a href=/ru/docs/tutorials/kubernetes-basics/update/update-intro/>6</a> рассказывается про масштабирование и обновление развертываний.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Чтобы приложение запускалось в Kubernetes, оно должно быть упаковано в один из поддерживаемых форматов контейнеров</i></p></div></div></div><div class=row><div class=col-md-8><p>В качестве первого развёртывания будем использовать приложение на Node.js, упакованное в Docker-контейнер. Следуя инструкциям в <a href=/ru/docs/tutorials/hello-minikube/>руководстве "Привет, Minikube"</a> вы сможете создать такое приложение Node.js и поместить его в контейнер.<p><p>Теперь, когда познакомились с развёртываниями, можно начать онлайн-урок, где вы развернёте своё первое приложение!</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ru/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/ role=button>Начать интерактивный урок <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-f8997ec143b382fa6c9621941ea62ca3>5.2.2.2 - Интерактивный урок - Развёртывание приложения</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=row><div class=col-md-12><p>Под — основной ресурс приложения Kubernetes. Каждый под представляет собой часть рабочей нагрузки, выполняемой в кластере. <a href=/docs/concepts/workloads/pods/pod-overview/#understanding-pods>Узнать подробнее про поды</a>.</p></div></div><br><div class=katacoda><div class=katacoda__alert>Для работы с терминалом, пожалуйста, используйте компьютер или планшет.</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/7 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ru/docs/tutorials/kubernetes-basics/explore/explore-intro/ role=button>Перейти к третьему модулю<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-250d620a73ec8be7e1f7d835574c4596>5.2.3 - Изучение приложения</h1></div><div class=td-content><h1 id=pg-2771f4e8c45321b17cb0114a2d266453>5.2.3.1 - Изучение подов и узлов</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Темы</h3><ul><li>Узнать про поды Kubernetes.</li><li>Узнать про узлы Kubernetes.</li><li>Диагностика развёрнутых приложений.</li></ul></div><div class=col-md-8><h2>Поды Kubernetes</h2><p>После того, как вы создали развёртывание в модуле <a href=/ru/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/>2</a>, Kubernetes создал <b>под (Pod)</b>, в котором был размещён экземпляр вашего приложения. Под — это абстрактный объект Kubernetes, представляющий собой группу из одного или нескольких контейнеров приложения (например, Docker или rkt) и совместно используемых ресурсов для этих контейнеров. Ресурсами могут быть:</p><ul><li>Общее хранилище (тома)</li><li>Сеть (уникальный IP-адрес кластера)</li><li>Информация по выполнению каждого контейнера (версия образа контейнера или используемые номера портов)</li></ul><p>Под представляет специфичный для приложения "логический хост" и может содержать разные контейнеры приложений, которые в общем и целом тесно связаны. Например, в поде может размещаться как контейнер с приложением на Node.js, так и другой контейнер, который использует данные от веб-сервера Node.js. Все контейнеры в поде имеют одни и те же IP-адрес и пространство порта, выполняющиеся в общем контексте на одном и том же узле.</p><p>Поды — неделимая единица в платформе Kubernetes. При создании развёртывания в Kubernetes, создаются поды с контейнерами внутри (в отличие от непосредственного создания контейнеров). Каждый Pod-объект связан с узлом, на котором он размещён, и остаётся там до окончания работы (согласно стратегии перезапуска) либо удаления. В случае неисправности узла такой же под будет распределён на другие доступные узлы в кластере.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Краткое содержание:</h3><ul><li>Поды</li><li>Узлы</li><li>Основные команды Kubectl</li></ul></div><div class="content__box content__box_fill"><p><i>Под — группа из одного или нескольких контейнеров приложений (например, Docker или rkt), включающая общие используемые хранилище (тома), IP-адрес и информацию по их запуску.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Схема подов</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg></p></div></div><br><div class=row><div class=col-md-8><h2>Узлы</h2><p>Под всегда работает в <b>узле</b>. Узел — это рабочая машина в Kubernetes, которая в зависимости от кластера может быть либо виртуальной, либо физической. Каждый узел управляется мастером (ведущим узлом). Узел может содержать несколько подов, которые мастер Kubernetes автоматически размещает на разные узлы кластера. Ведущий узел при автоматическом планировании (распределении подов по узлам) учитывает доступные ресурсы на каждом узле.</p><p>В каждом узле Kubernetes как минимум работает:</p><ul><li>Kubelet — процесс, отвечающий за взаимодействие между мастером Kubernetes и узлом; он управляет подами и запущенными контейнерами на рабочей машине.</li><li>Среда выполнения контейнера (например, Docker или rkt), отвечающая за получение (загрузку) образа контейнера из реестра, распаковку контейнера и запуск приложения.</li></ul></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Контейнеры должны запускаться вместе только в пределах одного пода, если они тесно связаны и должны совместно использовать ресурсы (например, диск)</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Схема узла</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg></p></div></div><br><div class=row><div class=col-md-8><h2>Диагностика с помощью kubectl</h2><p>В модуле <a href=/ru/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/>2</a> вы использовали инструмент командной строки Kubectl. В этом (третьем) модуле вы продолжите его использовать, но для получения информации о развернутых приложениях и окружениях, в которых они работают. Наиболее распространенные операции выполняются с использованием следующих команд kubectl:</p><ul><li><b>kubectl get</b> — вывод списка ресурсов</li><li><b>kubectl describe</b> — вывод подробной информации о ресурсе</li><li><b>kubectl logs</b> — вывод логов контейнера в поде</li><li><b>kubectl exec</b> — выполнение команды в контейнере пода</li></ul><p>Перечисленные выше команды можно использовать, чтобы узнать, когда и где приложения были развернуты, их текущее состояние и конфигурацию.</p><p>Теперь, когда вы познакомились поближе с компонентами кластера и командами, давайте изучим приложение.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Узел — рабочая машина в Kubernetes, которая может быть как виртуальной, так и физической (в зависимости от используемого кластера). В одном узле могут быть запущены несколько подов</i></p></div></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ru/docs/tutorials/kubernetes-basics/explore/explore-interactive/ role=button>Начать интерактивный урок <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-4b01eab98a9844ad91131079654199dd>5.2.3.2 - Интерактивный урок - Изучение приложения</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><br><div class=katacoda><div class=katacoda__alert>Для работы с терминалом, пожалуйста, используйте компьютер или планшет.</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/4 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ru/docs/tutorials/kubernetes-basics/expose/expose-intro/ role=button>Перейти к четвёртому модулю<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-4b0e31c9e0eae68bbb0a358b4042ada9>5.2.4 - Открытие доступа к приложению</h1></div><div class=td-content><h1 id=pg-8ef4dad8f743b191a9e8c6f891cb191a>5.2.4.1 - Создание сервиса для открытия доступа к приложению</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Темы</h3><ul><li>Узнать о сервисах в Kubernetes</li><li>Разобраться с тем, как метки и объекты LabelSelector связаны с сервисом</li><li>Открыть доступ к приложению вне кластера Kubernetes через сервис</li></ul></div><div class=col-md-8><h3>Обзор сервисов Kubernetes</h3><p><a href=/docs/concepts/workloads/pods/pod-overview/>Под</a> — это расходный материал в Kubernetes. У подов есть <a href=/docs/concepts/workloads/pods/pod-lifecycle/>жизненный цикл</a>. Когда рабочий узел завершается, запущенные поды в узле также уничтожаются. После этого <a href=/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> попытается автоматически вернуть кластер обратно в требуемое состояние, создавая новые поды, чтобы поддержать работоспособность приложения. Другой пример — бэкенд для обработки изображений с 3 репликами. Поскольку это взаимозаменяемые реплики, то они не влияют на фронтенд-часть, даже если под был уничтожен и пересоздан. Тем не менее, каждый под в кластере Kubernetes имеет уникальный IP-адрес, даже под на одном и том же узле, поэтому должен быть способ автоматической координации изменений между подами, чтобы приложения продолжали функционировать.</p><p>Сервис в Kubernetes — это абстрактный объект, который определяет логический набор подов и политику доступа к ним. Сервисы создают слабую связь между подами, которые от них зависят. Сервис создаётся в формате YAML <a href=/docs/concepts/configuration/overview/#general-configuration-tips>(рекомендуемый формат)</a> или JSON, как и все остальные объекты в Kubernetes. Как правило, набор подов для сервиса определяется <i>LabelSelector</i> (ниже описано, в каких случаях понадобится сервис без указания <code>selector</code> в спецификации).</p><p>Хотя у каждого пода есть уникальный IP-адрес, эти IP-адреса не доступны за пределами кластера без использования сервиса. Сервисы позволяют приложениям принимать трафик. Сервисы могут быть по-разному открыты, в зависимости от указанного поля <code>type</code> в ServiceSpec:</p><ul><li><i>ClusterIP</i> (по умолчанию) - открывает доступ к сервису по внутреннему IP-адресу в кластере. Этот тип делает сервис доступным только внутри кластера.</li><li><i>NodePort</i> - открывает сервис на одном и том же порту каждого выбранного узла в кластере с помощью NAT. Делает сервис доступным вне кластера, используя <code>&lt;NodeIP>:&lt;NodePort></code>. Является надмножеством ClusterIP.</li><li><i>LoadBalancer</i> - создает внешний балансировщик нагрузки в текущем облаке (если это поддерживается) и назначает фиксированный внешний IP-адрес для сервиса. Является надмножеством NodePort.</li><li><i>ExternalName</i> - открывает доступ к сервису с указанным именем (определённое в поле <code>externalName</code> в спецификации) и возвращает запись CNAME. Прокси не используется. Для этого типа требуется версия <code>kube-dns</code> 1.7 или выше.</li></ul><p>Более подробно узнать о различных типах сервисах можно в руководстве <a href=/docs/tutorials/services/source-ip/>Использование IP-порта источника</a>. Также изучите <a href=/docs/concepts/services-networking/connect-applications-service>Подключение приложений к сервисам</a>.</p><p>Кроме этого, обратите внимание, что в некоторых случаях в сервисах не определяется <code>selector</code> в спецификации. Сервис без <code>selector</code> не будет создавать соответствующий объект конечной точки (Endpoint). Таким образом, пользователь может вручную назначить сервис определённым конечным точкам. Использование <code>type: ExternalName</code> — это другой вариант использования, когда не нужно определять селектор в сервисе.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Краткое содержание</h3><ul><li>Открытие внешнего трафика для подов</li><li>Балансировка нагрузки трафика между подов</li><li>Использование метки</li></ul></div><div class="content__box content__box_fill"><p><i>Сервис Kubernetes — это уровень абстракции, который определяет логический набор подов, перенаправляет внешний трафик, балансирует нагрузку и реализует паттерн Service Discovery для этих подов.</i></p></div></div></div><br><div class=row><div class=col-md-8><h3>Сервисы и метки</h3></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_04_services.svg width=150% height=150%></p></div></div><div class=row><div class=col-md-8><p>Сервис направляет трафик через набор подов. Сервисы — это абстракция, позволяющая взаимозаменять поды Kubernetes без ущерба для приложения. Сервисы в Kubernetes находят и маршрутизируют трафик между зависимыми подами (это могут быть фронтенд- и бэкенд-компоненты приложения).</p><p>Сервисы для выбора набора подов используют <a href=/docs/concepts/overview/working-with-objects/labels>метки и селекторы</a>. Метки — пары ключ-значение, добавленные к объектам; например, они могут использоваться чтобы:</p><ul><li>Идентифицировать объекты для окружений разработки, тестирования и продакшена</li><li>Добавить теги версии</li><li>Классифицировать объекты через теги</li></ul></div></div><br><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg></p></div></div><br><div class=row><div class=col-md-8><p>Метки могут добавляться во время создания объектов или после этого. Они также могут быть изменены в любое время. Теперь давайте откроем доступ к приложению путём создания сервиса и добавление меток.</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ru/docs/tutorials/kubernetes-basics/expose/expose-interactive/ role=button>Начать интерактивный урок <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-352241d22effe0714772d21c7d1b512d>5.2.4.2 - Интерактивный урок - Открытие доступа к приложению</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Для работы с терминалом, пожалуйста, используйте компьютер или планшет.</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/8 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ru/docs/tutorials/kubernetes-basics/scale/scale-intro/ role=button>Перейти к пятому модулю<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-be4996c93fb39c459a30b6669569d423>5.2.5 - Масштабирование приложения</h1></div><div class=td-content><h1 id=pg-d1c15c9bd4f625adbc13149b1475287c>5.2.5.1 - Запуск нескольких экземпляров приложения</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Темы</h3><ul><li>Масштабирование приложения с помощью kubectl.</li></ul></div><div class=col-md-8><h3>Масштабирование приложения</h3><p>В предыдущих модулях мы создали <a href=/docs/concepts/workloads/controllers/deployment/>развёртывание</a>, а затем открыли к нему публичный доступ через <a href=/docs/concepts/services-networking/service/>сервис</a>. Развёртывание создало только один под, в котором работает наше приложение. По мере увеличения трафика необходимо будет промасштабировать приложение, чтобы оно могло справиться с возросшим потоком пользователей.</p><p><b>Масштабирование</b> осуществляется за счёт изменения количества реплик в развёртывании.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Краткое содержание:</h3><ul><li>Масштабирование развёртывания</li></ul></div><div class="content__box content__box_fill"><p><i>Количество экземпляров можно указать прямо при создании развёртывания, используя параметр --replicas команды kubectl run</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Обзор масштабирования</h2></div></div><div class=row><div class=col-md-1></div><div class=col-md-8><div id=myCarousel class=carousel data-ride=carousel data-interval=3000><ol class=carousel-indicators><li data-target=#myCarousel data-slide-to=0 class=active></li><li data-target=#myCarousel data-slide-to=1></li></ol><div class=carousel-inner role=listbox><div class="item carousel-item active"><img src=/docs/tutorials/kubernetes-basics/public/images/module_05_scaling1.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_05_scaling2.svg></div></div><a class="left carousel-control" href=#myCarousel role=button data-slide=prev><span class=sr-only>Предыдущая картинка</span></a>
<a class="right carousel-control" href=#myCarousel role=button data-slide=next><span class=sr-only>Следующая картинка</span></a></div></div></div><br><div class=row><div class=col-md-8><p>В случае масштабирования развёртывания создаются новые поды, которые распределяются по узлам с доступными ресурсами. Масштабирование увеличит количество подов в соответствии с указанным требуемым состоянием. Kubernetes также поддерживает <a href=/docs/user-guide/horizontal-pod-autoscaling/>автоматическое масштабирование</a> подов (не рассматривается в данном уроке). Кроме этого, возможно масштабирование до нуля, тогда завершается работа всех подов в развертывании.</p><p>При запуске нескольких экземпляров приложения нужно правильно распределить трафик между ними. У сервисов есть встроенный балансировщик нагрузки, который распределяет сетевой трафик всех подов в открытом извне развертывания. Сервисы постоянно отслеживают запущенные поды через их конечные точки, чтобы направлять трафик только на доступные поды.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Масштабирование выполняется с помощью изменения количества реплик в развертывании.</i></p></div></div></div><br><div class=row><div class=col-md-8><p>Имея несколько работающих экземпляров приложения можно выполнять плавающие обновления (rolling updates) без простоев. С ними мы познакомимся в следующем модуле. А пока перейдём к онлайн-терминалу и промасштабируем наше приложение.</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ru/docs/tutorials/kubernetes-basics/scale/scale-interactive/ role=button>Начать интерактивный урок <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-7bdb3fbaa1177ff5dfa3fe86bd35ef59>5.2.5.2 - Интерактивный урок - Масштабирование приложения</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Для работы с терминалом, пожалуйста, используйте компьютер или планшет</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/5 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ru/docs/tutorials/kubernetes-basics/update/update-intro/ role=button>Перейти к шестому модулю <span class=btn__next>›</span></a></div></div></main><a class=scrolltop href=#top></a></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-62b8b17dadfb55f1801cf8439e944e58>5.2.6 - Обновление приложения</h1></div><div class=td-content><h1 id=pg-12e04355145afad615ca3c38335ba019>5.2.6.1 - Выполнение плавающего обновления</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Темы</h3><ul><li>Выполнение плавающего обновления с помощью kubectl.</li></ul></div><div class=col-md-8><h3>Обновление приложения</h3><p>Пользователи надеются, что приложения будут работать круглосуточно, а разработчики в свою очередь ожидают развёртывать новые версии приложений по нескольку раз в день. В Kubernetes это возможно благодаря механизму плавающих обновлений (rolling updates). <b>Плавающие обновления</b> позволяет обновить развёртывания без простоев, шаг за шагом заменяя старые поды на новые. Новые поды будут запущены на узлах, имеющих достаточно ресурсов.</p><p>В предыдущем модуле мы промасштабировали приложение до нескольких экземпляров. Это необходимо сделать, чтобы иметь возможность обновлять приложение, не влияя на его доступность. По умолчанию максимальное количество подов, которое может быть недоступно во время обновления, и максимальное количество новых подов, которое можно создать, равны 1. Эти две опции могут быть определены в абсолютном (числа) или относительном соотношении (проценты).
В Kubernetes обновления версионируются, поэтому любое обновление развёртывания можно откатить до предыдущей (стабильной) версии.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Краткое содержание:</h3><ul><li>Обновление приложения</li></ul></div><div class="content__box content__box_fill"><p><i>Плавающие обновления последовательно заменяют экземпляры подов на новые, тем самым позволяя обновить развёртывания без простоев</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Обзор плавающих обновлений</h2></div></div><div class=row><div class=col-md-1></div><div class=col-md-8><div id=myCarousel class=carousel data-ride=carousel data-interval=3000><ol class=carousel-indicators><li data-target=#myCarousel data-slide-to=0 class=active></li><li data-target=#myCarousel data-slide-to=1></li><li data-target=#myCarousel data-slide-to=2></li><li data-target=#myCarousel data-slide-to=3></li></ol><div class=carousel-inner role=listbox><div class="item carousel-item active"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates1.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates2.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates3.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates4.svg></div></div><a class="left carousel-control" href=#myCarousel role=button data-slide=prev><span class=sr-only>Предыдущая картинка</span></a>
<a class="right carousel-control" href=#myCarousel role=button data-slide=next><span class=sr-only>Следующая картинка</span></a></div></div></div><br><div class=row><div class=col-md-8><p>Подобно масштабированию приложения, если развёртывание доступно извне, при обновлении сервис будет балансировать трафик только между доступными подами. Доступный под — это экземпляр, который может быть запущен для пользователей приложения.</p><p>С помощью плавающих обновлений можно:</p><ul><li>Переводить приложение из одного окружения в другое (через обновления образа контейнера)</li><li>Откатываться к предыдущим версиям</li><li>Осуществлять непрерывную интеграцию и непрерывную доставку приложений без простоев</li></ul></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Если развёртывание было открыто наружу, в процессе обновления сервис будет балансировать нагрузку трафика только на доступные поды.</i></p></div></div></div><br><div class=row><div class=col-md-8><p>В следующем интерактивном уроке мы обновим приложение до новой версии, а потом выполним откат, т.е. вернёмся к предыдущей версии</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ru/docs/tutorials/kubernetes-basics/update/update-interactive/ role=button>Начать интерактивный урок <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-dddc0cb356c280e0339bcf42776987dc>5.2.6.2 - Интерактивный урок - Обновление приложения</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Для работы с терминалом, пожалуйста, используйте компьютер или планшет</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/6 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/ru/docs/tutorials/kubernetes-basics/ role=button>Вернуться на главную страницу с основами по Kubernetes<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-b00a88a07ceb21b1a83e5822e0c86c1d>6 - Ссылки</h1><p>Этот раздел документации Kubernetes содержит ссылки.</p><h2 id=ссылки-api>Ссылки API</h2><ul><li><a href=/docs/reference/using-api/api-overview/>Обзор Kubernetes API</a> - Обзор API для Kubernetes.</li><li>Версии Kubernetes API<ul><li><a href=/docs/reference/generated/kubernetes-api/v1.17/>1.17</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.16/>1.16</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.15/>1.15</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.14/>1.14</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.13/>1.13</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.12/>1.12</a></li></ul></li></ul><h2 id=клиентские-библиотеки-api>Клиентские библиотеки API</h2><p>Для вызова API Kubernetes из языка программирования вы можете использовать
<a href=/docs/reference/using-api/client-libraries/>клиентские библиотеки</a>. Официально поддерживаемые клиентские библиотеки:</p><ul><li><a href=https://github.com/kubernetes/client-go/>Клиентская библиотека Go</a></li><li><a href=https://github.com/kubernetes-client/python>Клиентская библиотека Python</a></li><li><a href=https://github.com/kubernetes-client/java>Клиентская библиотека Java</a></li><li><a href=https://github.com/kubernetes-client/javascript>Клиентская библиотека JavaScript</a></li></ul><h2 id=ссылки-cli>Ссылки CLI</h2><ul><li><a href=/docs/user-guide/kubectl-overview>kubectl</a> - Основной инструмент CLI для запуска команд и управления кластерами Kubernetes.</li><li><a href=/docs/user-guide/jsonpath/>JSONPath</a> - Документация по синтаксису использования <a href=http://goessner.net/articles/JsonPath/>выражений JSONPath</a> с kubectl.</li><li><a href=/docs/admin/kubeadm/>kubeadm</a> - Инструмент CLI для легкого разворачивания защищенного кластера Kubernetes.</li><li><a href=/docs/admin/kubefed/>kubefed</a> - Инструмент CLI для помощи в администрировании федеративных кластеров.</li></ul><h2 id=ссылки-на-конфигурации>Ссылки на конфигурации</h2><ul><li><a href=/docs/admin/kubelet/>kubelet</a> - Основной <em>агент ноды</em>, который работает на каждой ноде. Kubelet принимает набор PodSpecs и гарантирует, что описанные контейнеры работают исправно.</li><li><a href=/docs/admin/kube-apiserver/>kube-apiserver</a> - REST API, который проверяет и настраивает данные для объектов API, таких, как модули, службы, контроллеры и репликации.</li><li><a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a> - Демон, который встраивает основные контрольные циклы, поставляемые с Kubernetes.</li><li><a href=/docs/admin/kube-proxy/>kube-proxy</a> - Может выполнять простую пересылку запросов TCP/UDP или циклическую переадресацию TCP/UDP через набор бекендов.</li><li><a href=/docs/admin/kube-scheduler/>kube-scheduler</a> - Планировщик, который управляет доступностью, производительностью и хранилищем.</li><li><a href=/docs/admin/federation-apiserver/>federation-apiserver</a> - Сервер API для федеративных кластеров.</li><li><a href=/docs/admin/federation-controller-manager/>federation-controller-manager</a> - Демон, который встраивает основные контрольные циклы, поставляемые с Kubernetes.</li></ul><h2 id=дизайн-документация>Дизайн документация</h2><p>Архив документации по дизайну для функциональности Kubernetes. Начните с <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md>Архитектуры Kubernetes</a> и <a href=https://git.k8s.io/community/contributors/design-proposals>Обзора дизайна Kubernetes</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2b03679960950df772fb4fe7d78427b9>6.1 - Стандартизированный глоссарий</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-03460a7254c6c73eb2a1bb3dd7d25910>6.2 - kubectl CLI</h1></div><div class=td-content><h1 id=pg-f14fe15ecc2d41b5e901ef5e872ca657>6.2.1 - Обзор kubectl</h1><p>Kubectl — это инструмент командной строки для управления кластерами Kubernetes. <code>kubectl</code> ищет файл config в директории $HOME/.kube. Вы можете указать другие файлы <a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>, установив переменную окружения KUBECONFIG или флаг <a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/><code>--kubeconfig</code></a>.</p><p>На этой странице рассматривается синтаксис kubectl, описаны командные операции и приведены распространённые примеры. Подробную информацию о каждой команде, включая все поддерживаемые в ней флаги и подкоманды, смотрите в справочной документации <a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a>. Инструкции по установке находятся на странице <a href=/ru/docs/tasks/kubectl/install/>Установка и настройка kubectl</a>.</p><h2 id=синтаксис>Синтаксис</h2><p>Используйте следующий синтаксис для выполнения команд <code>kubectl</code> в терминале:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> <span style=color:#666>[</span>flags<span style=color:#666>]</span>
</span></span></code></pre></div><p>где <code>command</code>, <code>TYPE</code>, <code>NAME</code> и <code>flags</code>:</p><ul><li><p><code>command</code>: определяет выполняемую операцию с одним или несколькими ресурсами, например, <code>create</code>, <code>get</code>, <code>describe</code>, <code>delete</code>.</p></li><li><p><code>TYPE</code>: определяет <a href=#%D1%82%D0%B8%D0%BF%D1%8B-%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%BE%D0%B2>тип ресурса</a>. Типы ресурсов не чувствительны к регистру, кроме этого вы можете использовать единственную, множественную или сокращенную форму. Например, следующие команды выведут одно и то же.</p><pre><code>```shell
kubectl get pod pod1
kubectl get pods pod1
kubectl get po pod1
```
</code></pre></li><li><p><code>NAME</code>: определяет имя ресурса. Имена чувствительны к регистру. Если имя не указано, то отображаются подробности по всем ресурсам, например, <code>kubectl get pods</code>.</p><p>При выполнении операции с несколькими ресурсами можно выбрать каждый ресурс по типу и имени, либо сделать это в одном или нескольких файлов:</p><ul><li><p>Выбор ресурсов по типу и имени:</p><ul><li><p>Сгруппировать ресурсы, если все они одного типа: <code>TYPE1 name1 name2 name&lt;#></code>.<br>Пример: <code>kubectl get pod example-pod1 example-pod2</code></p></li><li><p>Выбор нескольких типов ресурсов по отдельности: <code>TYPE1/name1 TYPE1/name2 TYPE2/name3 TYPE&lt;#>/name&lt;#></code>.<br>Пример: <code>kubectl get pod/example-pod1 replicationcontroller/example-rc1</code></p></li></ul></li><li><p>Выбор ресурсов по одному или нескольким файлов: <code>-f file1 -f file2 -f file&lt;#></code></p><ul><li><a href=/docs/concepts/configuration/overview/#general-configuration-tips>Используйте YAML вместо JSON</a>, так как YAML удобнее для пользователей, особенно в конфигурационных файлах.<br>Пример: <code>kubectl get pod -f ./pod.yaml</code></li></ul></li></ul></li><li><p><code>flags</code>: определяет дополнительные флаги. Например, вы можете использовать флаги <code>-s</code> или <code>--server</code>, чтобы указать адрес и порт API-сервера Kubernetes.<br></p></li></ul><div class="alert alert-warning caution callout" role=alert><strong>Внимание:</strong> Указанные вами флаги из командной строки переопределят значения по умолчанию и связанные переменные окружения.</div><p>Если вам нужна помощь, выполните команду <code>kubectl help</code>.</p><h2 id=операции>Операции</h2><p>В следующей таблице приведены краткие описания и общий синтаксис всех операций <code>kubectl</code>:</p><table><thead><tr><th>Операция</th><th>Синтаксис</th><th>Описание</th></tr></thead><tbody><tr><td><code>annotate</code></td><td><code>kubectl annotate (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td><td>Добавить или обновить аннотации одного или нескольких ресурсов.</td></tr><tr><td><code>api-versions</code></td><td><code>kubectl api-versions [flags]</code></td><td>Вывести доступные версии API.</td></tr><tr><td><code>apply</code></td><td><code>kubectl apply -f FILENAME [flags]</code></td><td>Внести изменения в конфигурацию ресурса из файла или потока stdin.</td></tr><tr><td><code>attach</code></td><td><code>kubectl attach POD -c CONTAINER [-i] [-t] [flags]</code></td><td>Подключиться к запущенному контейнеру либо для просмотра потока вывода, либо для работы с контейнером (stdin).</td></tr><tr><td><code>autoscale</code></td><td><code>kubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</code></td><td>Автоматически промасштабировать набор подов, управляемых контроллером репликации.</td></tr><tr><td><code>cluster-info</code></td><td><code>kubectl cluster-info [flags]</code></td><td>Показать информацию о главном узле и сервисах в кластере.</td></tr><tr><td><code>config</code></td><td><code>kubectl config SUBCOMMAND [flags]</code></td><td>Изменить файлы kubeconfig. Подробные сведения смотрите в отдельных подкомандах.</td></tr><tr><td><code>create</code></td><td><code>kubectl create -f FILENAME [flags]</code></td><td>Создать один или несколько ресурсов из файла или stdin.</td></tr><tr><td><code>delete</code></td><td><code>kubectl delete (-f FILENAME | TYPE [NAME | /NAME | -l label | --all]) [flags]</code></td><td>Удалить ресурсы из файла, потока stdin, либо с помощью селекторов меток, имен, селекторов ресурсов или ресурсов.</td></tr><tr><td><code>describe</code></td><td><code>kubectl describe (-f FILENAME | TYPE [NAME_PREFIX | /NAME | -l label]) [flags]</code></td><td>Показать подробное состояние одного или нескольких ресурсов.</td></tr><tr><td><code>diff</code></td><td><code>kubectl diff -f FILENAME [flags]</code></td><td>Diff file or stdin against live configuration (<strong>BETA</strong>)</td></tr><tr><td><code>edit</code></td><td><code>kubectl edit (-f FILENAME | TYPE NAME | TYPE/NAME) [flags]</code></td><td>Отредактировать и обновить определение одного или нескольких ресурсов на сервере, используя редактор по умолчанию.</td></tr><tr><td><code>exec</code></td><td><code>kubectl exec POD [-c CONTAINER] [-i] [-t] [flags] [-- COMMAND [args...]]</code></td><td>Выполнить команду в контейнере пода.</td></tr><tr><td><code>explain</code></td><td><code>kubectl explain [--recursive=false] [flags]</code></td><td>Посмотреть документацию по ресурсам. Например, поды, узлы, сервисы и т.д.</td></tr><tr><td><code>expose</code></td><td><code>kubectl expose (-f FILENAME | TYPE NAME | TYPE/NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type] [flags]</code></td><td>Создать Kubernetes-сервис из контроллера репликации, сервиса или пода.</td></tr><tr><td><code>get</code></td><td><code>kubectl get (-f FILENAME | TYPE [NAME | /NAME | -l label]) [--watch] [--sort-by=FIELD] [[-o | --output]=OUTPUT_FORMAT] [flags]</code></td><td>Вывести один или несколько ресурсов.</td></tr><tr><td><code>label</code></td><td><code>kubectl label (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td><td>Добавить или обновить метки для одного или нескольких ресурсов.</td></tr><tr><td><code>logs</code></td><td><code>kubectl logs POD [-c CONTAINER] [--follow] [flags]</code></td><td>Вывести логи контейнера в поде.</td></tr><tr><td><code>patch</code></td><td><code>kubectl patch (-f FILENAME | TYPE NAME | TYPE/NAME) --patch PATCH [flags]</code></td><td>Обновить один или несколько полей ресурса, используя стратегию слияния патча.</td></tr><tr><td><code>port-forward</code></td><td><code>kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N] [flags]</code></td><td>Переадресовать один или несколько локальных портов в под.</td></tr><tr><td><code>proxy</code></td><td><code>kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]</code></td><td>Запустить прокси для API Kubernetes.</td></tr><tr><td><code>replace</code></td><td><code>kubectl replace -f FILENAME</code></td><td>Заменить ресурс из файла или потока stdin.</td></tr><tr><td><code>rolling-update</code></td><td><code>kubectl rolling-update OLD_CONTROLLER_NAME ([NEW_CONTROLLER_NAME] --image=NEW_CONTAINER_IMAGE | -f NEW_CONTROLLER_SPEC) [flags]</code></td><td>Выполните плавающее обновление, постепенно заменяя указанный контроллер репликации и его поды.</td></tr><tr><td><code>run</code></td><td><code>kubectl run NAME --image=image [--env="key=value"] [--port=port] [--replicas=replicas] [--dry-run=bool] [--overrides=inline-json] [flags]</code></td><td>Запустить указанный образ в кластере.</td></tr><tr><td><code>scale</code></td><td><code>kubectl scale (-f FILENAME | TYPE NAME | TYPE/NAME) --replicas=COUNT [--resource-version=version] [--current-replicas=count] [flags]</code></td><td>Обновить размер указанного контроллера репликации.</td></tr><tr><td><code>version</code></td><td><code>kubectl version [--client] [flags]</code></td><td>Отобразить версию Kubernetes, запущенного на клиенте и сервере.</td></tr></tbody></table><p>Примечание: подробную информацию о командных операциях смотрите в справочную документацию <a href=/ru/docs/user-guide/kubectl/>kubectl</a>.</p><h2 id=типы-ресурсов>Типы ресурсов</h2><p>В следующей таблице перечислены все доступные типы ресурсов вместе с сокращенными аббревиатурами.</p><p>(Это актуальный вывод команды <code>kubectl api-resources</code> с версии Kubernetes 1.13.3.)</p><table><thead><tr><th>Resource Name</th><th>Short Names</th><th>API Group</th><th>Namespaced</th><th>Resource Kind</th></tr></thead><tbody><tr><td><code>bindings</code></td><td></td><td></td><td>true</td><td>Binding</td></tr><tr><td><code>componentstatuses</code></td><td><code>cs</code></td><td></td><td>false</td><td>ComponentStatus</td></tr><tr><td><code>configmaps</code></td><td><code>cm</code></td><td></td><td>true</td><td>ConfigMap</td></tr><tr><td><code>endpoints</code></td><td><code>ep</code></td><td></td><td>true</td><td>Endpoints</td></tr><tr><td><code>limitranges</code></td><td><code>limits</code></td><td></td><td>true</td><td>LimitRange</td></tr><tr><td><code>namespaces</code></td><td><code>ns</code></td><td></td><td>false</td><td>Namespace</td></tr><tr><td><code>nodes</code></td><td><code>no</code></td><td></td><td>false</td><td>Node</td></tr><tr><td><code>persistentvolumeclaims</code></td><td><code>pvc</code></td><td></td><td>true</td><td>PersistentVolumeClaim</td></tr><tr><td><code>persistentvolumes</code></td><td><code>pv</code></td><td></td><td>false</td><td>PersistentVolume</td></tr><tr><td><code>pods</code></td><td><code>po</code></td><td></td><td>true</td><td>Pod</td></tr><tr><td><code>podtemplates</code></td><td></td><td></td><td>true</td><td>PodTemplate</td></tr><tr><td><code>replicationcontrollers</code></td><td><code>rc</code></td><td></td><td>true</td><td>ReplicationController</td></tr><tr><td><code>resourcequotas</code></td><td><code>quota</code></td><td></td><td>true</td><td>ResourceQuota</td></tr><tr><td><code>secrets</code></td><td></td><td></td><td>true</td><td>Secret</td></tr><tr><td><code>serviceaccounts</code></td><td><code>sa</code></td><td></td><td>true</td><td>ServiceAccount</td></tr><tr><td><code>services</code></td><td><code>svc</code></td><td></td><td>true</td><td>Service</td></tr><tr><td><code>mutatingwebhookconfigurations</code></td><td></td><td>admissionregistration.k8s.io</td><td>false</td><td>MutatingWebhookConfiguration</td></tr><tr><td><code>validatingwebhookconfigurations</code></td><td></td><td>admissionregistration.k8s.io</td><td>false</td><td>ValidatingWebhookConfiguration</td></tr><tr><td><code>customresourcedefinitions</code></td><td><code>crd</code>, <code>crds</code></td><td>apiextensions.k8s.io</td><td>false</td><td>CustomResourceDefinition</td></tr><tr><td><code>apiservices</code></td><td></td><td>apiregistration.k8s.io</td><td>false</td><td>APIService</td></tr><tr><td><code>controllerrevisions</code></td><td></td><td>apps</td><td>true</td><td>ControllerRevision</td></tr><tr><td><code>daemonsets</code></td><td><code>ds</code></td><td>apps</td><td>true</td><td>DaemonSet</td></tr><tr><td><code>deployments</code></td><td><code>deploy</code></td><td>apps</td><td>true</td><td>Deployment</td></tr><tr><td><code>replicasets</code></td><td><code>rs</code></td><td>apps</td><td>true</td><td>ReplicaSet</td></tr><tr><td><code>statefulsets</code></td><td><code>sts</code></td><td>apps</td><td>true</td><td>StatefulSet</td></tr><tr><td><code>tokenreviews</code></td><td></td><td>authentication.k8s.io</td><td>false</td><td>TokenReview</td></tr><tr><td><code>localsubjectaccessreviews</code></td><td></td><td>authorization.k8s.io</td><td>true</td><td>LocalSubjectAccessReview</td></tr><tr><td><code>selfsubjectaccessreviews</code></td><td></td><td>authorization.k8s.io</td><td>false</td><td>SelfSubjectAccessReview</td></tr><tr><td><code>selfsubjectrulesreviews</code></td><td></td><td>authorization.k8s.io</td><td>false</td><td>SelfSubjectRulesReview</td></tr><tr><td><code>subjectaccessreviews</code></td><td></td><td>authorization.k8s.io</td><td>false</td><td>SubjectAccessReview</td></tr><tr><td><code>horizontalpodautoscalers</code></td><td><code>hpa</code></td><td>autoscaling</td><td>true</td><td>HorizontalPodAutoscaler</td></tr><tr><td><code>cronjobs</code></td><td><code>cj</code></td><td>batch</td><td>true</td><td>CronJob</td></tr><tr><td><code>jobs</code></td><td></td><td>batch</td><td>true</td><td>Job</td></tr><tr><td><code>certificatesigningrequests</code></td><td><code>csr</code></td><td>certificates.k8s.io</td><td>false</td><td>CertificateSigningRequest</td></tr><tr><td><code>leases</code></td><td></td><td>coordination.k8s.io</td><td>true</td><td>Lease</td></tr><tr><td><code>events</code></td><td><code>ev</code></td><td>events.k8s.io</td><td>true</td><td>Event</td></tr><tr><td><code>ingresses</code></td><td><code>ing</code></td><td>extensions</td><td>true</td><td>Ingress</td></tr><tr><td><code>networkpolicies</code></td><td><code>netpol</code></td><td>networking.k8s.io</td><td>true</td><td>NetworkPolicy</td></tr><tr><td><code>poddisruptionbudgets</code></td><td><code>pdb</code></td><td>policy</td><td>true</td><td>PodDisruptionBudget</td></tr><tr><td><code>podsecuritypolicies</code></td><td><code>psp</code></td><td>policy</td><td>false</td><td>PodSecurityPolicy</td></tr><tr><td><code>clusterrolebindings</code></td><td></td><td>rbac.authorization.k8s.io</td><td>false</td><td>ClusterRoleBinding</td></tr><tr><td><code>clusterroles</code></td><td></td><td>rbac.authorization.k8s.io</td><td>false</td><td>ClusterRole</td></tr><tr><td><code>rolebindings</code></td><td></td><td>rbac.authorization.k8s.io</td><td>true</td><td>RoleBinding</td></tr><tr><td><code>roles</code></td><td></td><td>rbac.authorization.k8s.io</td><td>true</td><td>Role</td></tr><tr><td><code>priorityclasses</code></td><td><code>pc</code></td><td>scheduling.k8s.io</td><td>false</td><td>PriorityClass</td></tr><tr><td><code>csidrivers</code></td><td></td><td>storage.k8s.io</td><td>false</td><td>CSIDriver</td></tr><tr><td><code>csinodes</code></td><td></td><td>storage.k8s.io</td><td>false</td><td>CSINode</td></tr><tr><td><code>storageclasses</code></td><td><code>sc</code></td><td>storage.k8s.io</td><td>false</td><td>StorageClass</td></tr><tr><td><code>volumeattachments</code></td><td></td><td>storage.k8s.io</td><td>false</td><td>VolumeAttachment</td></tr></tbody></table><h2 id=опции-вывода>Опции вывода</h2><p>В следующих разделах рассматривается форматирование и сортировка вывода определенных команд. Дополнительные сведения о том, какие команды поддерживают разные варианты вывода, смотрите в справочной документации <a href=/ru/docs/user-guide/kubectl/>kubectl</a>.</p><h3 id=форматирование-вывода>Форматирование вывода</h3><p>Стандартный формат вывода всех команд <code>kubectl</code> представлен в понятном для человека текстовом формате. Чтобы вывести подробности в определенном формате можно добавить флаги <code>-o</code> или <code>--output</code> к команде <code>kubectl</code>.</p><h4 id=синтаксис-1>Синтаксис</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> -o &lt;output_format&gt;
</span></span></code></pre></div><p>В зависимости от операции <code>kubectl</code> поддерживаются следующие форматы вывода:</p><table><thead><tr><th>Выходной формат</th><th>Описание</th></tr></thead><tbody><tr><td><code>-o custom-columns=&lt;spec></code></td><td>Вывести таблицу с использованием списка <a href=#%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%B5-%D1%81%D1%82%D0%BE%D0%BB%D0%B1%D1%86%D1%8B>пользовательских столбцов</a>, разделённого запятыми.</td></tr><tr><td><code>-o custom-columns-file=&lt;filename></code></td><td>Вывести таблицу с использованием шаблона с <a href=#%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%B5-%D1%81%D1%82%D0%BE%D0%BB%D0%B1%D1%86%D1%8B>пользовательскими столбцами</a> в файле <code>&lt;filename></code>.</td></tr><tr><td><code>-o json</code></td><td>Вывести API-объект в формате JSON.</td></tr><tr><td><code>-o jsonpath=&lt;template></code></td><td>Вывести поля, определенные в выражении <a href=/ru/docs/reference/kubectl/jsonpath/>jsonpath</a>.</td></tr><tr><td><code>-o jsonpath-file=&lt;filename></code></td><td>Вывести поля, определённые в выражении <a href=/ru/docs/reference/kubectl/jsonpath/>jsonpath</a> из файла <code>&lt;filename></code>.</td></tr><tr><td><code>-o name</code></td><td>Вывести только имя ресурса.</td></tr><tr><td><code>-o wide</code></td><td>Вывести в текстовом формате с дополнительной информацией. Для подов отображается имя узла.</td></tr><tr><td><code>-o yaml</code></td><td>Вывести API-объект в формате YAML</td></tr></tbody></table><h5 id=пример>Пример</h5><p>В данном примере следующая команда выводит подробную информацию по указанному поду в виде объекта в YAML-формате:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod web-pod-13je7 -o yaml
</span></span></code></pre></div><p>Примечание: подробную информацию о доступных форматах вывода в определенной команде смотрите в справочной документации <a href=/ru/docs/user-guide/kubectl/>kubectl</a>.</p><h4 id=пользовательские-столбцы>Пользовательские столбцы</h4><p>Для определения пользовательских столбцов и вывода в таблицу только нужных данных, можно использовать опцию <code>custom-columns</code>. Вы можете определить пользовательские столбцы в самой опции, либо сделать это в файле шаблона: <code>-o custom-columns=&lt;spec></code> или <code>-o custom-columns-file=&lt;filename></code>.</p><h5 id=примеры>Примеры</h5><p>Столбцы указаны в самой команде:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods &lt;pod-name&gt; -o custom-columns<span style=color:#666>=</span>NAME:.metadata.name,RSRC:.metadata.resourceVersion
</span></span></code></pre></div><p>Столбцы указаны в файле шаблона:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods &lt;pod-name&gt; -o custom-columns-file<span style=color:#666>=</span>template.txt
</span></span></code></pre></div><p>где файл <code>template.txt</code> содержит следующее:</p><pre tabindex=0><code>NAME          RSRC
metadata.name metadata.resourceVersion
</code></pre><p>Результат выполнения любой из показанной выше команды:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME           RSRC
</span></span><span style=display:flex><span>submit-queue   <span style=color:#666>610995</span>
</span></span></code></pre></div><h4 id=получение-вывода-с-сервера>Получение вывода с сервера</h4><p><code>kubectl</code> может получать информацию об объектах с сервера.
Это означает, что для любого указанного ресурса сервер вернет столбцы и строки по этому ресурсу, которые отобразит клиент.
Благодаря тому, что сервер инкапсулирует реализацию вывода, гарантируется единообразный и понятный для человека вывод на всех клиентах, использующих один и тот же кластер.</p><p>Эта функциональность включена по умолчанию, начиная с <code>kubectl</code> 1.11 и выше. Чтобы отключить ее, добавьте флаг <code>--server-print=false</code> в команду <code>kubectl get</code>.</p><h5 id=примеры-1>Примеры</h5><p>Для вывода информации о состоянии пода, используйте следующую команду:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods &lt;pod-name&gt; --server-print<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><p>Вывод будет выглядеть следующим образом:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME       READY     STATUS              RESTARTS   AGE
</span></span><span style=display:flex><span>pod-name   1/1       Running             <span style=color:#666>0</span>          1m
</span></span></code></pre></div><h3 id=сортировка-списка-объектов>Сортировка списка объектов</h3><p>Для вывода объектов в виде отсортированного списка в терминал используется флаг <code>--sort-by</code> к команде <code>kubectl</code>. Для сортировки объектов нужно указать любое числовое или строковое поле в флаге <code>--sort-by</code>. Для определения поля используйте выражение <a href=/ru/docs/reference/kubectl/jsonpath/>jsonpath</a>.</p><h4 id=синтаксис-2>Синтаксис</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> --sort-by<span style=color:#666>=</span>&lt;jsonpath_exp&gt;
</span></span></code></pre></div><h5 id=пример-1>Пример</h5><p>Чтобы вывести список подов, отсортированных по имени, выполните команду ниже:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --sort-by<span style=color:#666>=</span>.metadata.name
</span></span></code></pre></div><h2 id=примеры-распространенные-операции>Примеры: распространенные операции</h2><p>Посмотрите следующие примеры, чтобы ознакомиться с часто используемыми операциями <code>kubectl</code>:</p><p><code>kubectl apply</code> - Внести изменения или обновить ресурс из файла или потока stdin.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Создать сервис из определения в example-service.yaml.</span>
</span></span><span style=display:flex><span>kubectl apply -f example-service.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Создать контроллер репликации из определения в example-controller.yaml.</span>
</span></span><span style=display:flex><span>kubectl apply -f example-controller.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Создать объекты, которые определены в файлах с расширением .yaml, .yml или .json в директории &lt;directory&gt;.</span>
</span></span><span style=display:flex><span>kubectl apply -f &lt;directory&gt;
</span></span></code></pre></div><p><code>kubectl get</code> - Вывести один или несколько ресурсов.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Вывести все поды в текстовом формате вывода.</span>
</span></span><span style=display:flex><span>kubectl get pods
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывести все поды в текстовом формате вывода и включить дополнительную информацию (например, имя узла).</span>
</span></span><span style=display:flex><span>kubectl get pods -o wide
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывести контроллер репликации с указанным именем в текстовом формате вывода. Совет: вы можете использовать сокращенный псевдоним &#39;rc&#39; вместо &#39;replicationcontroller&#39;.</span>
</span></span><span style=display:flex><span>kubectl get replicationcontroller &lt;rc-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывести все контроллеры репликации и сервисы вместе в текстовом формате вывода.</span>
</span></span><span style=display:flex><span>kubectl get rc,services
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывести все наборы демонов в текстовом формате вывода.</span>
</span></span><span style=display:flex><span>kubectl get ds
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывести все поды, запущенные на узле server01</span>
</span></span><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>spec.nodeName<span style=color:#666>=</span>server01
</span></span></code></pre></div><p><code>kubectl describe</code> - Показать подробное состояние одного или нескольких ресурсов, по умолчанию также включаются неинициализированные ресурсы.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Показать информацию об узле с именем &lt;node-name&gt;.</span>
</span></span><span style=display:flex><span>kubectl describe nodes &lt;node-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Показать подробности пода &lt;pod-name&gt;.</span>
</span></span><span style=display:flex><span>kubectl describe pods/&lt;pod-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Показать подробности всех подов, управляемые контроллером репликации &lt;rc-name&gt;.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Обратите внимание: любые поды, созданные контроллером репликации, имеют префикс с именем контроллера репликации.</span>
</span></span><span style=display:flex><span>kubectl describe pods &lt;rc-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Показать подробности по всем подам</span>
</span></span><span style=display:flex><span>kubectl describe pods
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Как правило, команда <code>kubectl get</code> используется для получения одного или нескольких ресурсов одного и того же типа. Она поддерживает большой набор флагов, с помощью которых можно настроить формат вывода, например, с помощью флага <code>-o</code> или <code>--output</code>.
Вы можете указать флаг <code>-w</code> или <code>--watch</code>, чтобы отслеживать изменения в конкретном объекте. Команда <code>kubectl describe</code> в основном сфокусирована на описание многих взаимосвязанных аспектов указанного ресурса. При генерации вывода для пользователя она может обращаться к API-серверу. К примеру, команда <code>kubectl describe node</code> выдает не только информацию об узле, но и краткий обзор запущенных на нем подов, генерируемых событий и т.д.</div><p><code>kubectl delete</code> - Удалить ресурсы из файла, потока stdin или с помощью селекторов меток, имена, селекторов ресурсов или имен ресурсов.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Удалить под по типу и имени, указанных в файле pod.yaml.</span>
</span></span><span style=display:flex><span>kubectl delete -f pod.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Удалить все поды и сервисы с именем метки &lt;label-name&gt;.</span>
</span></span><span style=display:flex><span>kubectl delete pods,services -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>&lt;label-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Удалить все поды, включая неинициализированные.</span>
</span></span><span style=display:flex><span>kubectl delete pods --all
</span></span></code></pre></div><p><code>kubectl exec</code> - Выполнить команду в контейнере пода.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Получить вывод от запущенной команды &#39;date&#39; в поде &lt;pod-name&gt;. По умолчанию отображается вывод из первого контейнера.</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; date
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Получить вывод из запущенной команды &#39;date&#39; в контейнере &lt;container-name&gt; пода &lt;pod-name&gt;.</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -c &lt;container-name&gt; date
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Получить интерактивный терминал (TTY) и запустить /bin/bash в поде &lt;pod-name&gt;. По умолчанию отображается вывод из первого контейнера.</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -ti &lt;pod-name&gt; /bin/bash
</span></span></code></pre></div><p><code>kubectl logs</code> - Вывести логи контейнера в поде.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Возвращает текущие логи в поде &lt;pod-name&gt;.</span>
</span></span><span style=display:flex><span>kubectl logs &lt;pod-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывод логов в поде &lt;pod-name&gt; в режиме реального времени. Это похоже на команду &#39;tail -f&#39; Linux.</span>
</span></span><span style=display:flex><span>kubectl logs -f &lt;pod-name&gt;
</span></span></code></pre></div><h2 id=примеры-создание-и-использование-плагинов>Примеры: создание и использование плагинов</h2><p>Посмотрите следующие примеры, чтобы ознакомиться с тем, как писать и использовать плагины <code>kubectl</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Плагин может быть на на любом языке, а сам исполняемый файл должен начинается с префикса &#34;kubectl-&#34;.</span>
</span></span><span style=display:flex><span>cat ./kubectl-hello
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#!/bin/bash</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Этот плагин выводит строку &#34;hello world&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;hello world&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Сделать плагин исполняемым</span>
</span></span><span style=display:flex><span>sudo chmod +x ./kubectl-hello
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Переместить его в директорию из PATH</span>
</span></span><span style=display:flex><span>sudo mv ./kubectl-hello /usr/local/bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Плагин дял kubectl создан и &#34;установлен&#34;.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Воспользоваться плагином можно через kubectl, вызвав его подобно обычной команды.</span>
</span></span><span style=display:flex><span>kubectl hello
</span></span></code></pre></div><pre tabindex=0><code>hello world
</code></pre><pre tabindex=0><code># &#34;Отмена установки&#34; плагина происходит через удаление его файла из директории в PATH.
sudo rm /usr/local/bin/kubectl-hello
</code></pre><p>Посмотреть все доступные плагины <code>kubectl</code> можно с помощью подкоманды <code>kubectl plugin list</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl plugin list
</span></span></code></pre></div><pre tabindex=0><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
/usr/local/bin/kubectl-bar
</code></pre><pre tabindex=0><code># Эта команда также может сообщить, что плагин является неисполняемым,
# либо что плагин переопределен другими плагинами

sudo chmod -x /usr/local/bin/kubectl-foo
kubectl plugin list
</code></pre><pre tabindex=0><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo identified as a plugin, but it is not executable
/usr/local/bin/kubectl-bar

error: one plugin warning was found
</code></pre><p>Плагины можно рассматривать как способ создания более сложной функциональности поверх существующих команд kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat ./kubectl-whoami
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#!/bin/bash</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Этот плагин использует команду `kubectl config` для вывода</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># информации о текущем пользователе из текущего выбранного контекста</span>
</span></span><span style=display:flex><span>kubectl config view --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{ range .contexts }}{{ if eq .name &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config current-context<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34; }}Current user: {{ .context.user }}{{ end }}{{ end }}&#39;</span>
</span></span></code></pre></div><p>Выполнение этого плагина генерирует вывод, содержащий пользователя для текущего выбранного контекста в файле KUBECONFIG:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Сделать файл исполняемым</span>
</span></span><span style=display:flex><span>sudo chmod +x ./kubectl-whoami
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Перенести файл в директорию из PATH</span>
</span></span><span style=display:flex><span>sudo mv ./kubectl-whoami /usr/local/bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl whoami
</span></span><span style=display:flex><span>Current user: plugins-user
</span></span></code></pre></div><p>Чтобы узнать больше о плагинах, изучите <a href=https://github.com/kubernetes/sample-cli-plugin>пример CLI-плагина</a>.</p><h2 id=что-дальше>Что дальше</h2><p>Начните использовать команды <a href=/ru/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a938176c695852fe70362c29cf615f1c>6.2.2 - Поддержка JSONPath</h1><p>Kubectl поддерживает шаблон JSONPath.</p><p>Шаблон JSONPath состоит из выражений JSONPath, заключенных в фигурные скобки {}.
Kubectl использует JSONPath-выражения для фильтрации по определенным полям в JSON-объекте и форматирования вывода.
В дополнение к оригинальному синтаксису шаблона JSONPath, допустимы следующие функции и синтаксис:</p><ol><li>Внутри выражений JSONPath текстовые значения заключайте в двойные кавычки.</li><li>Используйте операторы <code>range</code>, <code>end</code>, конечные операторы для перебора списков.</li><li>Используйте отрицательные индексы срезов для перехода на предыдущий элемент в списке. Отрицательные индексы не "зацикливаются" в списке и работают пока истинно выражение <code>-index + listLength >= 0</code>.</li></ol><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><ul><li><p>Оператор <code>$</code> необязателен, поскольку по умолчанию выражение всегда начинается с корневого объекта.</p></li><li><p>Объект результата выводиться через функцию String().</p></li></ul></div><p>Все примеры ниже будут ориентироваться на следующий JSON-объект:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;List&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;items&#34;</span>:[
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>},
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;4&#34;</span>},
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[{<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>}]
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;8&#34;</span>},
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[
</span></span><span style=display:flex><span>          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
</span></span><span style=display:flex><span>          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;another&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.3&#34;</span>}
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;users&#34;</span>:[
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;myself&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {}
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;e2e&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {<span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;admin&#34;</span>, <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;secret&#34;</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><table><thead><tr><th>Функция</th><th>Описание</th><th>Пример</th><th>Результат</th></tr></thead><tbody><tr><td><code>text</code></td><td>обычный текст</td><td><code>kind is {.kind}</code></td><td><code>kind is List</code></td></tr><tr><td><code>@</code></td><td>текущий объект</td><td><code>{@}</code></td><td>то же, что и ввод</td></tr><tr><td><code>.</code> или <code>[]</code></td><td>оператор выбора по ключу</td><td><code>{.kind}</code>, <code>{['kind']}</code> или <code>{['name\.type']}</code></td><td><code>List</code></td></tr><tr><td><code>..</code></td><td>рекурсивный спуск</td><td><code>{..name}</code></td><td><code>127.0.0.1 127.0.0.2 myself e2e</code></td></tr><tr><td><code>*</code></td><td>шаблон подстановки. Получение всех объектов</td><td><code>{.items[*].metadata.name}</code></td><td><code>[127.0.0.1 127.0.0.2]</code></td></tr><tr><td><code>[start:end:step]</code></td><td>оператор индексирования</td><td><code>{.users[0].name}</code></td><td><code>myself</code></td></tr><tr><td><code>[,]</code></td><td>оператор объединения</td><td><code>{.items[*]['metadata.name', 'status.capacity']}</code></td><td><code>127.0.0.1 127.0.0.2 map[cpu:4] map[cpu:8]</code></td></tr><tr><td><code>?()</code></td><td>фильтрация</td><td><code>{.users[?(@.name=="e2e")].user.password}</code></td><td><code>secret</code></td></tr><tr><td><code>range</code>, <code>end</code></td><td>перебор списка</td><td><code>{range .items[*]}[{.metadata.name}, {.status.capacity}] {end}</code></td><td><code>[127.0.0.1, map[cpu:4]] [127.0.0.2, map[cpu:8]]</code></td></tr><tr><td><code>''</code></td><td>интерпретируемая в кавычках строка</td><td><code>{range .items[*]}{.metadata.name}{'\t'}{end}</code></td><td><code>127.0.0.1 127.0.0.2</code></td></tr></tbody></table><p>Примеры использования <code>kubectl</code> и JSONPath-выражений:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -o json
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{@}&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0]}&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0].metadata.name}&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*][&#39;metadata.name&#39;, &#39;status.capacity&#39;]}&#34;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{.metadata.name}{&#34;\t&#34;}{.status.startTime}{&#34;\n&#34;}{end}&#39;</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>В Windows нужно заключить в <em>двойные</em> кавычки JSONPath-шаблон, который содержит пробелы (не в одинарные, как в примерах выше для bash). Таким образом, любые литералы в таких шаблонах нужно оборачивать в одинарные кавычки или экранированные двойные кавычки. Например:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>kubectl get pods -o=jsonpath=<span style=color:#b44>&#34;{range .items[*]}{.metadata.name}{&#39;\t&#39;}{.status.startTime}{&#39;\n&#39;}{end}&#34;</span>
</span></span><span style=display:flex><span>kubectl get pods -o=jsonpath=<span style=color:#b44>&#34;{range .items[*]}{.metadata.name}{\&#34;</span>\t\<span style=color:#b44>&#34;}{.status.startTime}{\&#34;</span>\n\<span style=color:#b44>&#34;}{end}&#34;</span>
</span></span></code></pre></div></div></div><div class=td-content style=page-break-before:always><h1 id=pg-4d3e62632c189fcc3c1357cd8fb8799c>6.2.3 - kubectl</h1><h2 id=synopsis>Synopsis</h2><p>kubectl управляет кластерами Kubernetes.</p><p>Более подробная информация по ссылке: <a href=https://kubernetes.io/ru/docs/reference/kubectl/overview/>https://kubernetes.io/ru/docs/reference/kubectl/overview/</a></p><pre tabindex=0><code>kubectl [flags]
</code></pre><h2 id=options>Options</h2><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--add-dir-header</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Если true, добавляет директорию файла в заголовок</td></tr><tr><td colspan=2>--alsologtostderr</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Логировать в стандартный поток ошибок, а также в файлы</td></tr><tr><td colspan=2>--application-metrics-count-limit int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: 100</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Максимальное количество сохраняемых метрик приложения (на каждый контейнер)</td></tr><tr><td colspan=2>--as string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Имя пользователя, от которого будет выполняться операция</td></tr><tr><td colspan=2>--as-group stringArray</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Группа, от которой будет выполняться операция, этот флаг можно использовать неоднократно, чтобы указать несколько групп.</td></tr><tr><td colspan=2>--azure-container-registry-config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Путь к файлу, который содержит информацию с конфигурацией реестра контейнера Azure.</td></tr><tr><td colspan=2>--boot-id-file string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "/proc/sys/kernel/random/boot_id"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Разделенный запятыми список файлов для проверки boot-id. Используйте первый существующий.</td></tr><tr><td colspan=2>--cache-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "$HOME/.kube/http-cache"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Директория HTTP-кеша по умолчанию</td></tr><tr><td colspan=2>--certificate-authority string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Путь к файлу сертификата для центра сертификации</td></tr><tr><td colspan=2>--client-certificate string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Путь к файлу клиентского сертификата для TLS</td></tr><tr><td colspan=2>--client-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Путь к файлу клиентского ключа для TLS</td></tr><tr><td colspan=2>--cloud-provider-gce-l7lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: 130.211.0.0/22,35.191.0.0/16</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Открыть CIDR в брандмауэре GCE для прокси трафика L7 LB и проверки работоспособности</td></tr><tr><td colspan=2>--cloud-provider-gce-lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: 130.211.0.0/22,209.85.152.0/22,209.85.204.0/22,35.191.0.0/16</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Открыть CIDR в брандмауэре GCE для прокси трафика L4 LB и проверки работоспособности</td></tr><tr><td colspan=2>--cluster string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Имя используемого кластера kubeconfig</td></tr><tr><td colspan=2>--container-hints string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "/etc/cadvisor/container_hints.json"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Путь к файлу подсказок контейнера</td></tr><tr><td colspan=2>--containerd string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "/run/containerd/containerd.sock"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Конечная точка containerd</td></tr><tr><td colspan=2>--containerd-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "k8s.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Пространство имени containerd</td></tr><tr><td colspan=2>--context string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Имя контекста kubeconfig</td></tr><tr><td colspan=2>--default-not-ready-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: 300</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Указывает tolerationSeconds для допущения notReady:NoExecute, которое по умолчанию добавляется к каждому поду, у которого не установлено такое допущение.</td></tr><tr><td colspan=2>--default-unreachable-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: 300</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Указывает tolerationSeconds для допущения unreachable:NoExecute, которое по умолчанию добавляется к каждому поду, у которого не установлено такое допущение.</td></tr><tr><td colspan=2>--disable-root-cgroup-stats</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Отключить сбор статистики корневой группы (Cgroup)</td></tr><tr><td colspan=2>--docker string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "unix:///var/run/docker.sock"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>docker endpoint</td></tr><tr><td colspan=2>--docker-env-metadata-whitelist string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Список ключей переменных окружения, разделенный запятыми, которые необходимо собрать для Docker-контейнеров</td></tr><tr><td colspan=2>--docker-only</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>В дополнение к корневой статистике уведомлять только о Docker-контейнерах</td></tr><tr><td colspan=2>--docker-root string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "/var/lib/docker"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>УСТАРЕЛО: корень docker считывается из информации docker (запасной вариант, по умолчанию: /var/lib/docker)</td></tr><tr><td colspan=2>--docker-tls</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Использовать TLS для подключения к Docker</td></tr><tr><td colspan=2>--docker-tls-ca string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "ca.pem"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Путь к доверенному CA</td></tr><tr><td colspan=2>--docker-tls-cert string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "cert.pem"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Путь к клиентскому сертификату</td></tr><tr><td colspan=2>--docker-tls-key string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "key.pem"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Путь к приватному ключу</td></tr><tr><td colspan=2>--enable-load-reader</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Включить считыватель нагрузки процессора</td></tr><tr><td colspan=2>--event-storage-age-limit string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "default=0"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Максимальный период времени для хранения события (по каждому типу). Значение флага — список из ключей и значений, разделенные запятыми, где ключи — это типы событий (например: создание, oom) либо "default", а значение — длительность. По умолчанию флаг применяется ко всем неуказанным типам событий</td></tr><tr><td colspan=2>--event-storage-event-limit string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "default=0"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Максимальное количество событий для хранения (по каждому типу). Значение флага — список из ключей и значений, разделенные запятыми, где ключи — это типы событий (например: создание, oom) либо "default", а значение — целое число. По умолчанию флаг применяется ко всем неуказанным типам событий</td></tr><tr><td colspan=2>--global-housekeeping-interval duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: 1m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Интервал между глобальными служебными операциями (housekeepings)</td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Получить справочную информацию по команде kubectl</td></tr><tr><td colspan=2>--housekeeping-interval duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: 10s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Интервал между служебными операциями (housekeepings) контейнера</td></tr><tr><td colspan=2>--insecure-skip-tls-verify</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Если true, значит сертификат сервера не будет проверяться на достоверность. Это сделает подключения через HTTPS небезопасными.</td></tr><tr><td colspan=2>--kubeconfig string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Путь к файлу kubeconfig для использования в CLI-запросах.</td></tr><tr><td colspan=2>--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: :0</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>При логировании указанной строки (file:N), сгенерировать трассировку стека</td></tr><tr><td colspan=2>--log-cadvisor-usage</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Записывать ли в журнал использование контейнера cAdvisor</td></tr><tr><td colspan=2>--log-dir string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Если указан, хранить лог-файлы в этой директории.</td></tr><tr><td colspan=2>--log-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Если указан, использовать этот лог-файл</td></tr><tr><td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: 1800</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Установить максимальный размер файла лог-файла (в Мб). Если значение равно 0, максимальный размер файла не ограничен.</td></tr><tr><td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: 5s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Максимальное количество секунд между очисткой лог-файлов</td></tr><tr><td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Вывод логов в стандартный поток ошибок вместо сохранения их в файлы</td></tr><tr><td colspan=2>--machine-id-file string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "/etc/machine-id,/var/lib/dbus/machine-id"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Список файлов, разделенных запятыми, для проверки machine-id. Используйте первый существующий.</td></tr><tr><td colspan=2>--match-server-version</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Убедиться, что версия сервера соответствует версии клиента</td></tr><tr><td colspan=2>-n, --namespace string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Указать область пространства имен для данного запроса CLI</td></tr><tr><td colspan=2>--password string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Пароль для базовой аутентификации на API-сервере</td></tr><tr><td colspan=2>--profile string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "none"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Имя профиля. Может быть одним из перечисленных значений: none|cpu|heap|goroutine|threadcreate|block|mutex</td></tr><tr><td colspan=2>--profile-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "profile.pprof"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Имя файла для записи профиля.</td></tr><tr><td colspan=2>--request-timeout string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "0"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Время ожидания перед тем, как перестать ожидать ответ от сервера. Значения должны содержать соответствующую единицу времени (например, 1s, 2m, 3h). Нулевое значение означает, что у запросов нет тайм-аута.</td></tr><tr><td colspan=2>-s, --server string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Адрес и порт API-сервера Kubernetes</td></tr><tr><td colspan=2>--skip-headers</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Если true, не отображать заголовки в сообщениях лога.</td></tr><tr><td colspan=2>--skip-log-headers</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Если true, не отображать заголовки при открытии лог-файлов.</td></tr><tr><td colspan=2>--stderrthreshold severity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: 2</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Логи указанного уровня серьёзности или выше выводить в поток stderr</td></tr><tr><td colspan=2>--storage-driver-buffer-duration duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: 1m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Буферизировать запись в драйвере хранилища в течение указанного времени, и сохранять в файловом хранилище в виде одной транзакции</td></tr><tr><td colspan=2>--storage-driver-db string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "cadvisor"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Имя базы данных</td></tr><tr><td colspan=2>--storage-driver-host string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "localhost:8086"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Хост и порт базы данных, записанный в формате host:port</td></tr><tr><td colspan=2>--storage-driver-password string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "root"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Пароль к базе данных</td></tr><tr><td colspan=2>--storage-driver-secure</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Использовать безопасное соединение с базой данных</td></tr><tr><td colspan=2>--storage-driver-table string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "stats"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Имя таблицы</td></tr><tr><td colspan=2>--storage-driver-user string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: "root"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Имя пользователя базы данных</td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Аутентификационный (bearer) токен для аутентификации на API-сервере</td></tr><tr><td colspan=2>--update-machine-info-interval duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию: 5m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Интервал между обновлениями информации о машине.</td></tr><tr><td colspan=2>--user string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Имя пользователя для kubeconfig</td></tr><tr><td colspan=2>--username string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Имя пользователя для базовой аутентификации на API-сервере</td></tr><tr><td colspan=2>-v, --v Level</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Номер уровня серьёзности логирования</td></tr><tr><td colspan=2>--version version[=true]</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Вывод версии команды</td></tr><tr><td colspan=2>--vmodule moduleSpec</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Список, разделённый запятыми, в виде настроек pattern=N для фильтрации лог-файлов</td></tr></tbody></table><h2 id=see-also>See Also</h2><ul><li><a href=/docs/reference/generated/kubectl/kubectl-commands#annotate>kubectl annotate</a> - Обновить аннотации ресурса.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-resources>kubectl api-resources</a> - Вывести доступные API-ресурсы на сервере.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-versions>kubectl api-versions</a> - Вывести доступные API-версии на сервере в виде "group/version".</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#apply>kubectl apply</a> - Внести изменения в конфигурацию ресурса из файла или потока stdin.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#attach>kubectl attach</a> - Присоединиться к запущенному контейнеру.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#auth>kubectl auth</a> - Проверить разрешение на выполнение определённых действий.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#autoscale>kubectl autoscale</a> - Автоматически масштабировать Deployment, ReplicaSet или ReplicationController.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#certificate>kubectl certificate</a> - Изменить сертификаты ресурсов.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#cluster-info>kubectl cluster-info</a> - Показать информацию по кластеру.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#completion>kubectl completion</a> - Вывод кода автодополнения указанной командной оболочки (bash или zsh).</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a> - Изменить файлы kubeconfig.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#convert>kubectl convert</a> - Конвертировать конфигурационные файлы в различные API-версии.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#cordon>kubectl cordon</a> - Отметить узел как неназначаемый.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#cp>kubectl cp</a> - Копировать файлы и директории в/из контейнеров.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#create>kubectl create</a> - Создать ресурс из файла или потока stdin.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#delete>kubectl delete</a> - Удалить ресурсы из файла, потока stdin, либо с помощью селекторов меток, имен, селекторов ресурсов или ресурсов.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#describe>kubectl describe</a> - Показать подробную информацию о конкретном ресурсе или группе ресурсов.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#diff>kubectl diff</a> - Сравнить действующую версию с новой (применяемой).</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#drain>kubectl drain</a> - Вытеснить узел для подготовки к эксплуатации.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#edit>kubectl edit</a> - Отредактировать ресурс на сервере.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#exec>kubectl exec</a> - Выполнить команду в контейнере.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#explain>kubectl explain</a> - Получить документацию ресурсов.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#expose>kubectl expose</a> - Создать новый сервис Kubernetes из контроллера репликации, сервиса, развёртывания или пода.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#get>kubectl get</a> - Вывести один или несколько ресурсов.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#kustomize>kubectl kustomize</a> - Собрать ресурсы kustomization из директории или URL-адреса.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#label>kubectl label</a> - Обновить метки ресурса.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#logs>kubectl logs</a> - Вывести логи контейнера в поде.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#options>kubectl options</a> - Вывести список флагов, применяемых ко всем командам.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#patch>kubectl patch</a> - Обновить один или несколько полей ресурса, используя стратегию слияния патча.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#plugin>kubectl plugin</a> - Команда для работы с плагинами.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#port-forward>kubectl port-forward</a> - Переадресовать один или несколько локальных портов в под.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#proxy>kubectl proxy</a> - Запустить прокси на API-сервер Kubernetes.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#replace>kubectl replace</a> - Заменить ресурс из определения в файле или потоке stdin.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#rollout>kubectl rollout</a> - Управление плавающим обновлением ресурса.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#run>kubectl run</a> - Запустить указанный образ в кластере.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#scale>kubectl scale</a> - Задать новый размер для Deployment, ReplicaSet или Replication Controller.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#set>kubectl set</a> - Конфигурировать ресурсы в объектах.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a> - Обновить ограничения для одного или нескольких узлов.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#top>kubectl top</a> - Показать информацию по использованию системных ресурсов (процессор, память, диск).</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#uncordon>kubectl uncordon</a> - Отметить узел как назначаемый.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#version>kubectl version</a> - Вывести информацию о версии клиента и сервера.</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#wait>kubectl wait</a> - Экспериментально: ожидать выполнения определенного условия в одном или нескольких ресурсах.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a7abc09192597e614b58f8b552b682f5>6.2.4 - kubectl для пользователей Docker</h1><p>Вы можете использовать инструмент командной строки kubectl в Kubernetes для работы с API-сервером. Если вы знакомы с инструментом командной строки Docker, то использование kubectl не составит проблем. Однако команды docker и kubectl отличаются. В следующих разделах показана подкоманда docker и приведена эквивалентная команда в kubectl.</p><h2 id=docker-run>docker run</h2><p>Для развёртывания nginx и открытия доступа к объекту Deployment используйте команду <a href=/docs/reference/generated/kubectl/kubectl-commands/#run>kubectl run</a>.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run -d --restart<span style=color:#666>=</span>always -e <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster --name nginx-app -p 80:80 nginx
</span></span></code></pre></div><pre tabindex=0><code>55c103fa129692154a7652490236fee9be47d70a8dd562281ae7d2f9a339a6db
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   9 seconds ago       Up 9 seconds        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># запустить под, в котором работает nginx</span>
</span></span><span style=display:flex><span>kubectl create deployment --image<span style=color:#666>=</span>nginx nginx-app
</span></span></code></pre></div><pre tabindex=0><code>deployment &#34;nginx-app&#34; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># add env to nginx-app</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> env deployment/nginx-app  <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster
</span></span></code></pre></div><pre tabindex=0><code>deployment.apps/nginx-app env updated
</code></pre><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Команды <code>kubectl</code> выводят тип и имя созданного или измененного ресурса, который затем может быть использован в последующих командах. После создания объекта Deployment можно открыть новый сервис Service.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># открыть порт, чтобы иметь доступ к сервису</span>
</span></span><span style=display:flex><span>kubectl expose deployment nginx-app --port<span style=color:#666>=</span><span style=color:#666>80</span> --name<span style=color:#666>=</span>nginx-http
</span></span></code></pre></div><pre tabindex=0><code>service &#34;nginx-http&#34; exposed
</code></pre><p>С помощью kubectl можно создать объект <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a>, чтобы убедиться, что N подов, запущены под nginx, где N — это количество реплик, указанных в спецификации (по умолчанию — 1).
Вы также можете создать <a href=/docs/concepts/services-networking/service/>сервис</a> с селектором, соответствующим меткам подов. Для получения дополнительной информации перейдите на страницу <a href=/docs/tasks/access-application-cluster/service-access-application-cluster>Use a Service to Access an Application in a Cluster</a>.</p><p>По умолчанию образы запускаются в фоновом режиме, аналогично команде <code>docker run -d ...</code>. Для запуска в центральном (интерактивном) режиме используйте команду ниже:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run <span style=color:#666>[</span>-i<span style=color:#666>]</span> <span style=color:#666>[</span>--tty<span style=color:#666>]</span> --attach &lt;name&gt; --image<span style=color:#666>=</span>&lt;image&gt;
</span></span></code></pre></div><p>В отличие от <code>docker run ...</code>, если вы укажете <code>--attach</code>, то присоедините <code>stdin</code>, <code>stdout</code> and <code>stderr</code>. Нельзя проконтролировать, какие потоки прикрепляются (<code>docker -a ...</code>).
Чтобы отсоединиться от контейнера, воспользуетесь комбинацией клавиш Ctrl+P, а затем Ctrl+Q.</p><p>Так как команда kubectl run запускает развёртывание для контейнера, то оно начнет перезапускаться, если завершить прикрепленный процесс по нажатию Ctrl+C, в отличие от команды <code>docker run -it</code>.
Для удаления объекта Deployment вместе с подами, необходимо выполнить команду <code>kubectl delete deployment &lt;name></code>.</p><h2 id=docker-ps>docker ps</h2><p>Посмотреть, что сейчас запущено можно с помощью команды <a href=/docs/reference/generated/kubectl/kubectl-commands/#get>kubectl get</a>.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps -a
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                     PORTS                NAMES
14636241935f        ubuntu:16.04        &#34;echo test&#34;              5 seconds ago        Exited (0) 5 seconds ago                        cocky_fermi
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   About a minute ago   Up About a minute          0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po
</span></span></code></pre></div><pre tabindex=0><code>NAME                        READY     STATUS      RESTARTS   AGE
nginx-app-8df569cb7-4gd89   1/1       Running     0          3m
ubuntu                      0/1       Completed   0          20s
</code></pre><h2 id=docker-attach>docker attach</h2><p>Чтобы присоединить процесс, который уже запущен в контейнере, используйте команду <a href=/docs/reference/generated/kubectl/kubectl-commands/#attach>kubectl attach</a>.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   5 minutes ago       Up 5 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker attach 55c103fa1296
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it nginx-app-5jyvm
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Для отсоединения его от контейнера используйте сочетания клавиш Ctrl+P и Ctrl+Q.</p><h2 id=docker-exec>docker exec</h2><p>Для выполнения команды в контейнере используйте команду <a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   6 minutes ago       Up 6 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker <span style=color:#a2f>exec</span> 55c103fa1296 cat /etc/hostname
</span></span></code></pre></div><pre tabindex=0><code>55c103fa1296
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po
</span></span></code></pre></div><pre tabindex=0><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> nginx-app-5jyvm -- cat /etc/hostname
</span></span></code></pre></div><pre tabindex=0><code>nginx-app-5jyvm
</code></pre><p>Примеры с командной оболочкой</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker <span style=color:#a2f>exec</span> -ti 55c103fa1296 /bin/sh
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># exit</span>
</span></span></code></pre></div><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -ti nginx-app-5jyvm -- /bin/sh
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># exit</span>
</span></span></code></pre></div><p>Для получения дополнительной информации обратитесь к странице <a href=/docs/tasks/debug-application-cluster/get-shell-running-container/>Get a Shell to a Running Container</a>.</p><h2 id=docker-logs>docker logs</h2><p>Для отслеживания логов в потоки stdout/stderr запущенного процесса используйте команду <a href=/docs/reference/generated/kubectl/kubectl-commands/#logs>kubectl logs</a>.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker logs -f a9e
</span></span></code></pre></div><pre tabindex=0><code>192.168.9.1 - - [14/Jul/2015:01:04:02 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.35.0&#34; &#34;-&#34;
192.168.9.1 - - [14/Jul/2015:01:04:03 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.35.0&#34; &#34;-&#34;
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs -f nginx-app-zibvs
</span></span></code></pre></div><pre tabindex=0><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
</code></pre><p>Есть небольшая разница между подами и контейнерами: по умолчанию поды не прекращают выполнение, если их процессы завершаются. Вместо этого поды перезапускают процесс. Это похоже на опцию <code>--restart=always</code> в Docker, только с одной большой разницей. В Docker вывод каждого вызова процесса объединяется, в отличие от Kubernetes, где каждый вызов является отдельным. Для просмотра вывода предыдущего запуска в Kubernetes, используйте команду ниже:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs --previous nginx-app-zibvs
</span></span></code></pre></div><pre tabindex=0><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
</code></pre><p>Для получения дополнительной информации обратитесь к странице <a href=/docs/concepts/cluster-administration/logging/>Logging Architecture</a>.</p><h2 id=docker-stop-и-docker-rm>docker stop и docker rm</h2><p>Для завершения и удаления запущенного процесса используйте команду <a href=/docs/reference/generated/kubectl/kubectl-commands/#delete>kubectl delete</a>.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMES
a9ec34d98787        nginx               &#34;nginx -g &#39;daemon of&#34;  22 hours ago        Up 22 hours         0.0.0.0:80-&gt;80/tcp, 443/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker stop a9ec34d98787
</span></span></code></pre></div><pre tabindex=0><code>a9ec34d98787
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker rm a9ec34d98787
</span></span></code></pre></div><pre tabindex=0><code>a9ec34d98787
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment nginx-app
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
nginx-app    1/1     1            1           2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
</span></span></code></pre></div><pre tabindex=0><code>NAME                         READY     STATUS    RESTARTS   AGE
nginx-app-2883164633-aklf7   1/1       Running   0          2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-app
</span></span></code></pre></div><pre tabindex=0><code>deployment &#34;nginx-app&#34; deleted
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Return nothing</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> При использовании kubectl удалить под напрямую не получится. Для этого сначала нужно удалить объект Deployment, которому принадлежит под. Если вы удалите под напрямую, то объект Deployment пересоздаст под.</div><h2 id=docker-login>docker login</h2><p>В kubectl нет прямого аналога команды <code>docker login</code>. Если вы планируете использовать Kubernetes с приватным реестром, изучите страницу <a href=/docs/concepts/containers/images/#using-a-private-registry>Using a Private Registry</a>.</p><h2 id=docker-version>docker version</h2><p>Для получения версии клиента и сервера используйте команду <a href=/docs/reference/generated/kubectl/kubectl-commands/#version>kubectl version</a>.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker version
</span></span></code></pre></div><pre tabindex=0><code>Client version: 1.7.0
Client API version: 1.19
Go version (client): go1.4.2
Git commit (client): 0baf609
OS/Arch (client): linux/amd64
Server version: 1.7.0
Server API version: 1.19
Go version (server): go1.4.2
Git commit (server): 0baf609
OS/Arch (server): linux/amd64
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl version
</span></span></code></pre></div><pre tabindex=0><code>Client Version: version.Info{Major:&#34;1&#34;, Minor:&#34;6&#34;, GitVersion:&#34;v1.6.9+a3d1dfa6f4335&#34;, GitCommit:&#34;9b77fed11a9843ce3780f70dd251e92901c43072&#34;, GitTreeState:&#34;dirty&#34;, BuildDate:&#34;2017-08-29T20:32:58Z&#34;, OpenPaasKubernetesVersion:&#34;v1.03.02&#34;, GoVersion:&#34;go1.7.5&#34;, Compiler:&#34;gc&#34;, Platform:&#34;linux/amd64&#34;}
Server Version: version.Info{Major:&#34;1&#34;, Minor:&#34;6&#34;, GitVersion:&#34;v1.6.9+a3d1dfa6f4335&#34;, GitCommit:&#34;9b77fed11a9843ce3780f70dd251e92901c43072&#34;, GitTreeState:&#34;dirty&#34;, BuildDate:&#34;2017-08-29T20:32:58Z&#34;, OpenPaasKubernetesVersion:&#34;v1.03.02&#34;, GoVersion:&#34;go1.7.5&#34;, Compiler:&#34;gc&#34;, Platform:&#34;linux/amd64&#34;}
</code></pre><h2 id=docker-info>docker info</h2><p>Для получения разной информации про окружение и конфигурации перейдите в раздел <a href=/docs/reference/generated/kubectl/kubectl-commands/#cluster-info>kubectl cluster-info</a>.</p><p>docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker info
</span></span></code></pre></div><pre tabindex=0><code>Containers: 40
Images: 168
Storage Driver: aufs
 Root Dir: /usr/local/google/docker/aufs
 Backing Filesystem: extfs
 Dirs: 248
 Dirperm1 Supported: false
Execution Driver: native-0.2
Logging Driver: json-file
Kernel Version: 3.13.0-53-generic
Operating System: Ubuntu 14.04.2 LTS
CPUs: 12
Total Memory: 31.32 GiB
Name: k8s-is-fun.mtv.corp.google.com
ID: ADUV:GCYR:B3VJ:HMPO:LNPQ:KD5S:YKFQ:76VN:IANZ:7TFV:ZBF4:BYJO
WARNING: No swap limit support
</code></pre><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><pre tabindex=0><code>Kubernetes master is running at https://203.0.113.141
KubeDNS is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/kube-dns/proxy
kubernetes-dashboard is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy
Grafana is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
Heapster is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
InfluxDB is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/monitoring-influxdb/proxy
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-d7ffbf04ffbefb241fd0722423b80f5a>6.2.5 - Команды kubectl</h1><p><a href=/docs/reference/generated/kubectl/kubectl-commands/>Справочник команд kubectl</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-8aba901ac13f124e5782b90ddb166ee2>6.2.6 - Шпаргалка по kubectl</h1><p>Смотрите также: <a href=/ru/docs/reference/kubectl/overview/>обзор Kubectl</a> и <a href=/ru/docs/reference/kubectl/jsonpath>руководство по JsonPath</a>.</p><p>Эта команда представляет собой обзор команды <code>kubectl</code>.</p><h1 id=kubectl-шпаргалка>kubectl - Шпаргалка</h1><h2 id=автодополнение-ввода-для-kubectl>Автодополнение ввода для Kubectl</h2><h3 id=bash>BASH</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion bash<span style=color:#666>)</span> <span style=color:#080;font-style:italic># настройка автодополнения в текущую сессию bash, предварительно должен быть установлен пакет bash-completion .</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;source &lt;(kubectl completion bash)&#34;</span> &gt;&gt; ~/.bashrc <span style=color:#080;font-style:italic># добавление автодополнения autocomplete постоянно в командную оболочку bash.</span>
</span></span></code></pre></div><p>Вы также можете использовать короткий псевдоним для <code>kubectl</code>, который можно интегрировать с автодополнениями:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>k</span><span style=color:#666>=</span>kubectl
</span></span><span style=display:flex><span><span style=color:#a2f>complete</span> -F __start_kubectl k
</span></span></code></pre></div><h3 id=zsh>ZSH</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>  <span style=color:#080;font-style:italic># настройка автодополнения в текущую сессию zsh</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;[[ </span><span style=color:#b8860b>$commands</span><span style=color:#b44>[kubectl] ]] &amp;&amp; source &lt;(kubectl completion zsh)&#34;</span> &gt;&gt; ~/.zshrc <span style=color:#080;font-style:italic># add autocomplete permanently to your zsh shell</span>
</span></span></code></pre></div><h2 id=контекст-и-конфигурация-kubectl>Контекст и конфигурация kubectl</h2><p>Установка того, с каким Kubernetes-кластером взаимодействует <code>kubectl</code> и изменяет конфигурационную информацию. Подробную информацию о конфигурационном файле смотрите на странице <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Authenticating Across Clusters with kubeconfig</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl config view <span style=color:#080;font-style:italic># показать объединённые настройки kubeconfig</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># использовать несколько файлов kubeconfig одновременно и посмотреть объединённую конфигурацию из этих файлов</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config:~/.kube/kubconfig2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config view
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># получить пароль для пользователя e2e</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[?(@.name == &#34;e2e&#34;)].user.password}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[].name}&#39;</span>    <span style=color:#080;font-style:italic># показать первого пользователя</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[*].name}&#39;</span>   <span style=color:#080;font-style:italic># получить список пользователей</span>
</span></span><span style=display:flex><span>kubectl config get-contexts                          <span style=color:#080;font-style:italic># показать список контекстов</span>
</span></span><span style=display:flex><span>kubectl config current-context                       <span style=color:#080;font-style:italic># показать текущий контекст (current-context)</span>
</span></span><span style=display:flex><span>kubectl config use-context my-cluster-name           <span style=color:#080;font-style:italic># установить my-cluster-name как контекст по умолчанию</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># добавить новую конфигурацию для кластера в kubeconf с базовой аутентификацией</span>
</span></span><span style=display:flex><span>kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span style=color:#666>=</span>kubeuser --password<span style=color:#666>=</span>kubepassword
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># сохранить пространство имен для всех последующих команд kubectl в этом контексте.</span>
</span></span><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>ggckad-s2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># установить контекст, используя имя пользователя и пространство имен.</span>
</span></span><span style=display:flex><span>kubectl config set-context gce --user<span style=color:#666>=</span>cluster-admin --namespace<span style=color:#666>=</span>foo <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl config use-context gce
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config <span style=color:#a2f>unset</span> users.foo                       <span style=color:#080;font-style:italic># удалить пользователя foo</span>
</span></span></code></pre></div><h2 id=apply>Apply</h2><p><code>apply</code> управляет приложениями с помощью файлов, которые определяют ресурсы Kubernetes. Выполните команду <code>kubectl apply</code> для создания и обновления ресурсов. Это рекомендуемый способ управления приложениями Kubernetes в промышленном окружении. Смотрите <a href=https://kubectl.docs.kubernetes.io>Kubectl Book</a>.</p><h2 id=создание-объектов>Создание объектов</h2><p>Манифесты Kubernetes могут быть определены в YAML или JSON. Можно использовать расширение файла <code>.yaml</code>, <code>.yml</code> и <code>.json</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f ./my-manifest.yaml            <span style=color:#080;font-style:italic># создать ресурсы</span>
</span></span><span style=display:flex><span>kubectl apply -f ./my1.yaml -f ./my2.yaml      <span style=color:#080;font-style:italic># создать ресурсы из нескольких файлов</span>
</span></span><span style=display:flex><span>kubectl apply -f ./dir                         <span style=color:#080;font-style:italic># создать ресурсы из всех файлов манифеста в директории</span>
</span></span><span style=display:flex><span>kubectl apply -f https://git.io/vPieo          <span style=color:#080;font-style:italic># создать ресурсы из URL-адреса</span>
</span></span><span style=display:flex><span>kubectl create deployment nginx --image<span style=color:#666>=</span>nginx  <span style=color:#080;font-style:italic># запустить один экземпляр nginx</span>
</span></span><span style=display:flex><span>kubectl explain pods                           <span style=color:#080;font-style:italic># посмотреть документацию по манифестам подов</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Создать несколько YAML-объектов из stdin</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: busybox-sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    args:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>    - &#34;1000000&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>---
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: busybox-sleep-less
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    args:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>    - &#34;1000&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Создать секрет с несколькими ключами</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: mysecret
</span></span></span><span style=display:flex><span><span style=color:#b44>type: Opaque
</span></span></span><span style=display:flex><span><span style=color:#b44>data:
</span></span></span><span style=display:flex><span><span style=color:#b44>  password: $(echo -n &#34;s33msi4&#34; | base64 -w0)
</span></span></span><span style=display:flex><span><span style=color:#b44>  username: $(echo -n &#34;jane&#34; | base64 -w0)
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><h2 id=просмотр-и-поиск-ресурсов>Просмотр и поиск ресурсов</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># Get-команды с основном выводом</span>
</span></span><span style=display:flex><span>kubectl get services                          <span style=color:#080;font-style:italic># Вывести все сервисы в пространстве имён</span>
</span></span><span style=display:flex><span>kubectl get pods --all-namespaces             <span style=color:#080;font-style:italic># Вывести все поды во всех пространств имён</span>
</span></span><span style=display:flex><span>kubectl get pods -o wide                      <span style=color:#080;font-style:italic># Вывести все поды в текущем пространстве имён с подробностями</span>
</span></span><span style=display:flex><span>kubectl get deployment my-dep                 <span style=color:#080;font-style:italic># Вывести определённое развёртывание</span>
</span></span><span style=display:flex><span>kubectl get pods                              <span style=color:#080;font-style:italic># Вывести все поды в пространстве имён</span>
</span></span><span style=display:flex><span>kubectl get pod my-pod -o yaml                <span style=color:#080;font-style:italic># Получить информацию по поду в формате YAML</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Посмотреть дополнительные сведения команды с многословным выводом</span>
</span></span><span style=display:flex><span>kubectl describe nodes my-node
</span></span><span style=display:flex><span>kubectl describe pods my-pod
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывести сервисы, отсортированные по имени</span>
</span></span><span style=display:flex><span>kubectl get services --sort-by<span style=color:#666>=</span>.metadata.name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывести поды, отсортированные по количеству перезагрузок</span>
</span></span><span style=display:flex><span>kubectl get pods --sort-by<span style=color:#666>=</span><span style=color:#b44>&#39;.status.containerStatuses[0].restartCount&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывести постоянные тома (PersistentVolumes), отсортированные по емкости</span>
</span></span><span style=display:flex><span>kubectl get pv --sort-by<span style=color:#666>=</span>.spec.capacity.storage
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Получить метку версии всех подов с меткой app=cassandra</span>
</span></span><span style=display:flex><span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra -o <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.labels.version}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Получить все рабочие узлы (с помощью селектора исключаем узлы с меткой &#39;node-role.kubernetes.io/master&#39;)</span>
</span></span><span style=display:flex><span>kubectl get node --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!node-role.kubernetes.io/master&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Получить все запущенные поды в пространстве имён</span>
</span></span><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase<span style=color:#666>=</span>Running
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Получить внешние IP-адреса (ExternalIP) всех узлов</span>
</span></span><span style=display:flex><span>kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].status.addresses[?(@.type==&#34;ExternalIP&#34;)].address}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывести имена подов, принадлежащие к определённому RC</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Использование команды &#34;jq&#34; помогает упросить поиск в jsonpath, подробнее смотрите на сайте https://stedolan.github.io/jq/</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>sel</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get rc my-rc --output<span style=color:#666>=</span>json | jq -j <span style=color:#b44>&#39;.spec.selector | to_entries | .[] | &#34;\(.key)=\(.value),&#34;&#39;</span><span style=color:#a2f;font-weight:700>)</span>%?<span style=color:#b68;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>$sel</span> --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Показать метки всех подов (или любого другого объекта Kubernetes, которым можно прикреплять метки)</span>
</span></span><span style=display:flex><span>kubectl get pods --show-labels
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Получить готовые узлы</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>JSONPATH</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span> <span style=color:#666>&amp;&amp;</span> kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$JSONPATH</span><span style=color:#b44>&#34;</span> | grep <span style=color:#b44>&#34;Ready=True&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывод декодированных секретов без внешних инструментов</span>
</span></span><span style=display:flex><span>kubectl get secret my-secret -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range $k,$v := .data}}{{&#34;### &#34;}}{{$k}}{{&#34;\n&#34;}}{{$v|base64decode}}{{&#34;\n\n&#34;}}{{end}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывести все секреты, используемые сейчас в поде.</span>
</span></span><span style=display:flex><span>kubectl get pods -o json | jq <span style=color:#b44>&#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39;</span> | grep -v null | sort | uniq
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывести все идентификаторы (containerID) контейнеров инициализации (initContainers) во всех подах.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Это полезно при очистке остановленных контейнеров, не удаляя при этом контейнеры инициализации.</span>
</span></span><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*].status.initContainerStatuses[*]}{.containerID}{&#34;\n&#34;}{end}&#39;</span> | cut -d/ -f3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Вывести события, отсортированные по временной метке</span>
</span></span><span style=display:flex><span>kubectl get events --sort-by<span style=color:#666>=</span>.metadata.creationTimestamp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Сравнить текущее состояние кластера с состоянием, в котором находился бы кластер в случае применения манифеста.</span>
</span></span><span style=display:flex><span>kubectl diff -f ./my-manifest.yaml
</span></span></code></pre></div><h2 id=обновление-ресурсов>Обновление ресурсов</h2><p>Начиная с версии 1.11 подкоманда <code>rolling-update</code> была удалена (см. <a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.11.md>CHANGELOG-1.11.md</a>), поэтому вместо неё используйте <code>rollout</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/frontend <span style=color:#b8860b>www</span><span style=color:#666>=</span>image:v2               <span style=color:#080;font-style:italic># Плавающее обновление контейнеров &#34;www&#34; развёртывания &#34;frontend&#34;, обновление образа</span>
</span></span><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment/frontend                      <span style=color:#080;font-style:italic># Проверить историю развёртывания, включая ревизии.</span>
</span></span><span style=display:flex><span>kubectl rollout undo deployment/frontend                         <span style=color:#080;font-style:italic># Откатиться к предыдущему развёртыванию</span>
</span></span><span style=display:flex><span>kubectl rollout undo deployment/frontend --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>         <span style=color:#080;font-style:italic># Откатиться к определённой ревизии</span>
</span></span><span style=display:flex><span>kubectl rollout status -w deployment/frontend                    <span style=color:#080;font-style:italic># Отслеживать статус плавающего развёртывания &#34;frontend&#34; до его завершения</span>
</span></span><span style=display:flex><span>kubectl rollout restart deployment/frontend                      <span style=color:#080;font-style:italic># Перезапуск плавающего развёртывания &#34;frontend&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Объявлено устаревшим, начиная с версии 1.11</span>
</span></span><span style=display:flex><span>kubectl rolling-update frontend-v1 -f frontend-v2.json           <span style=color:#080;font-style:italic># (устарело) Плавающее обновление подов frontend-v1</span>
</span></span><span style=display:flex><span>kubectl rolling-update frontend-v1 frontend-v2 --image<span style=color:#666>=</span>image:v2  <span style=color:#080;font-style:italic># (устарело) Изменить имя ресурса и обновить образ</span>
</span></span><span style=display:flex><span>kubectl rolling-update frontend --image<span style=color:#666>=</span>image:v2                 <span style=color:#080;font-style:italic># (устарело) Обновить образ подов frontend</span>
</span></span><span style=display:flex><span>kubectl rolling-update frontend-v1 frontend-v2 --rollback        <span style=color:#080;font-style:italic># (устарело) Отменить выполняющееся обновление</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat pod.json | kubectl replace -f -                              <span style=color:#080;font-style:italic># Заменить под из определения в JSON-файле, переданного в поток stdin</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Принудительно заменить, удалить, а затем пересоздать ресурс. Это приведет к простою приложения</span>
</span></span><span style=display:flex><span>kubectl replace --force -f ./pod.json
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Создать сервис с реплицированным nginx на порту 80, который подключается к контейнерам на порту 8000.</span>
</span></span><span style=display:flex><span>kubectl expose rc nginx --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Обновить версию (метку) образа пода из одного контейнера single до v4</span>
</span></span><span style=display:flex><span>kubectl get pod mypod -o yaml | sed <span style=color:#b44>&#39;s/\(image: myimage\):.*$/\1:v4/&#39;</span> | kubectl replace -f -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl label pods my-pod new-label<span style=color:#666>=</span>awesome                      <span style=color:#080;font-style:italic># Добавить метку</span>
</span></span><span style=display:flex><span>kubectl annotate pods my-pod icon-url<span style=color:#666>=</span>http://goo.gl/XXBTWq       <span style=color:#080;font-style:italic># Добавить аннотацию</span>
</span></span><span style=display:flex><span>kubectl autoscale deployment foo --min<span style=color:#666>=</span><span style=color:#666>2</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>                <span style=color:#080;font-style:italic># Автоматически масштабировать развёртывание &#34;foo&#34; в диапазоне от 2 до 10 подов</span>
</span></span></code></pre></div><h2 id=обновление-ресурсов-1>Обновление ресурсов</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># Обновить часть узла</span>
</span></span><span style=display:flex><span>kubectl patch node k8s-node-1 -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;unschedulable&#34;:true}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Обновить образ контейнера; необходимо указать spec.containers[*].name, чтобы произвести слияние</span>
</span></span><span style=display:flex><span>kubectl patch pod valid-pod -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;kubernetes-serve-hostname&#34;,&#34;image&#34;:&#34;new image&#34;}]}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Обновить образ контейнера через json-патч с позиционными массивами</span>
</span></span><span style=display:flex><span>kubectl patch pod valid-pod --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/containers/0/image&#34;, &#34;value&#34;:&#34;new image&#34;}]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Удалить развертывание livenessProbe через json-патч с позиционными массивами</span>
</span></span><span style=display:flex><span>kubectl patch deployment valid-deployment  --type json   -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/livenessProbe&#34;}]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Добавить нового элемента в позиционный массив</span>
</span></span><span style=display:flex><span>kubectl patch sa default --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/secrets/1&#34;, &#34;value&#34;: {&#34;name&#34;: &#34;whatever&#34; } }]&#39;</span>
</span></span></code></pre></div><h2 id=редактирование-ресурсов>Редактирование ресурсов</h2><p>Вы можете отредактировать API-ресурс в любом редакторе.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl edit svc/docker-registry                      <span style=color:#080;font-style:italic># Отредактировать сервис docker-registry</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBE_EDITOR</span><span style=color:#666>=</span><span style=color:#b44>&#34;nano&#34;</span> kubectl edit svc/docker-registry   <span style=color:#080;font-style:italic># Использовать другой редактор</span>
</span></span></code></pre></div><h2 id=масштабирование-ресурсов>Масштабирование ресурсов</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> rs/foo                                 <span style=color:#080;font-style:italic># Масштабирование набора реплик (replicaset) &#39;foo&#39; до 3</span>
</span></span><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> -f foo.yaml                            <span style=color:#080;font-style:italic># Масштабирование ресурса в &#34;foo.yaml&#34; до 3</span>
</span></span><span style=display:flex><span>kubectl scale --current-replicas<span style=color:#666>=</span><span style=color:#666>2</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span> deployment/mysql  <span style=color:#080;font-style:italic># Если количество реплик в развёртывании mysql равен 2, масштабировать его до 3</span>
</span></span><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>5</span> rc/foo rc/bar rc/baz                   <span style=color:#080;font-style:italic># Масштабирование нескольких контроллеров репликации до 5</span>
</span></span></code></pre></div><h2 id=удаление-ресурсов>Удаление ресурсов</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl delete -f ./pod.json                                              <span style=color:#080;font-style:italic># Удалить под по типу и имени в pod.json</span>
</span></span><span style=display:flex><span>kubectl delete pod,service baz foo                                        <span style=color:#080;font-style:italic># Удалить поды и сервисы с одноимёнными именам &#34;baz&#34; и &#34;foo&#34;</span>
</span></span><span style=display:flex><span>kubectl delete pods,services -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                              <span style=color:#080;font-style:italic># Удалить поды и сервисы с именем метки myLabel</span>
</span></span><span style=display:flex><span>kubectl -n my-ns delete pod,svc --all                                     <span style=color:#080;font-style:italic># Удалить все поды и сервисы в пространстве имен my-ns</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Удалить все поды, соответствующие pattern1 или pattern2 в awk</span>
</span></span><span style=display:flex><span>kubectl get pods  -n mynamespace --no-headers<span style=color:#666>=</span><span style=color:#a2f>true</span> | awk <span style=color:#b44>&#39;/pattern1|pattern2/{print $1}&#39;</span> | xargs  kubectl delete -n mynamespace pod
</span></span></code></pre></div><h2 id=работа-с-запущенными-подами>Работа с запущенными подами</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs my-pod                                 <span style=color:#080;font-style:italic># вывести логи пода (в stdout)</span>
</span></span><span style=display:flex><span>kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                        <span style=color:#080;font-style:italic># вывести логи пода с меткой myLabel (в stdout)</span>
</span></span><span style=display:flex><span>kubectl logs my-pod --previous                      <span style=color:#080;font-style:italic># вывести логи пода (в stdout) по предыдущему экземпляру контейнера</span>
</span></span><span style=display:flex><span>kubectl logs my-pod -c my-container                 <span style=color:#080;font-style:italic># вывести логи контейнера пода (в stdout, при работе с несколькими контейнерами)</span>
</span></span><span style=display:flex><span>kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel -c my-container        <span style=color:#080;font-style:italic># вывести логи пода с меткой myLabel (в stdout)</span>
</span></span><span style=display:flex><span>kubectl logs my-pod -c my-container --previous      <span style=color:#080;font-style:italic># вывести логи контейнера пода (в stdout, при работе с несколькими контейнерами) по предыдущему экземпляру контейнера</span>
</span></span><span style=display:flex><span>kubectl logs -f my-pod                              <span style=color:#080;font-style:italic># вывести логи пода в режиме реального времени (в stdout)</span>
</span></span><span style=display:flex><span>kubectl logs -f my-pod -c my-container              <span style=color:#080;font-style:italic># вывести логи контейнера пода в режиме реального времени (в stdout, при работе с несколькими контейнерами)</span>
</span></span><span style=display:flex><span>kubectl logs -f -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel --all-containers    <span style=color:#080;font-style:italic># вывести логи всех подов с меткой myLabel (в stdout)</span>
</span></span><span style=display:flex><span>kubectl run -i --tty busybox --image<span style=color:#666>=</span>busybox -- sh  <span style=color:#080;font-style:italic># запустить под как интерактивную оболочку</span>
</span></span><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --restart<span style=color:#666>=</span>Never -n
</span></span><span style=display:flex><span>mynamespace                                         <span style=color:#080;font-style:italic># Запустить под nginx в заданном пространстве имён</span>
</span></span><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --restart<span style=color:#666>=</span>Never     <span style=color:#080;font-style:italic># Запустить под nginx и записать его спецификацию в файл pod.yaml</span>
</span></span><span style=display:flex><span>--dry-run -o yaml &gt; pod.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl attach my-pod -i                            <span style=color:#080;font-style:italic># Прикрепить к запущенному контейнеру</span>
</span></span><span style=display:flex><span>kubectl port-forward my-pod 5000:6000               <span style=color:#080;font-style:italic># Переадресовать порт 5000 в локальной машине на порт 6000 в поде my-pod</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-pod -- ls /                         <span style=color:#080;font-style:italic># Выполнить команду в существующем поде (в случае одного контейнера).</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-pod -c my-container -- ls /         <span style=color:#080;font-style:italic># Выполнить команду в существующем поде (в случае нескольких контейнеров)</span>
</span></span><span style=display:flex><span>kubectl top pod POD_NAME --containers               <span style=color:#080;font-style:italic># Показать метрики по заданному поду вместе с его контейнерами</span>
</span></span></code></pre></div><h2 id=работа-с-узлами-и-кластером>Работа с узлами и кластером</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl cordon my-node                                                <span style=color:#080;font-style:italic># Отметить узел my-node как неназначаемый</span>
</span></span><span style=display:flex><span>kubectl drain my-node                                                 <span style=color:#080;font-style:italic># Вытеснить узел my-node, чтобы подготовиться к эксплуатации</span>
</span></span><span style=display:flex><span>kubectl uncordon my-node                                              <span style=color:#080;font-style:italic># Отметить узел my-node как назначаемый</span>
</span></span><span style=display:flex><span>kubectl top node my-node                                              <span style=color:#080;font-style:italic># Показать метрики по заданному узлу</span>
</span></span><span style=display:flex><span>kubectl cluster-info                                                  <span style=color:#080;font-style:italic># Показать адреса главного узла и сервисов</span>
</span></span><span style=display:flex><span>kubectl cluster-info dump                                             <span style=color:#080;font-style:italic># Вывести состояние текущего кластера в stdout</span>
</span></span><span style=display:flex><span>kubectl cluster-info dump --output-directory<span style=color:#666>=</span>/path/to/cluster-state   <span style=color:#080;font-style:italic># Вывести состояние текущего кластера в /path/to/cluster-state</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Если ограничение с заданным ключом и проявлением уже существует, его значение будет заменено указанным</span>
</span></span><span style=display:flex><span>kubectl taint nodes foo <span style=color:#b8860b>dedicated</span><span style=color:#666>=</span>special-user:NoSchedule
</span></span></code></pre></div><h3 id=типы-ресурсов>Типы ресурсов</h3><p>Вывести все поддерживаемые типы ресурсов, включая <a href=/docs/concepts/overview/kubernetes-api/#api-groups>API-группу</a>, флаг <a href=/docs/concepts/overview/working-with-objects/namespaces>namespaced</a> (организован ли ресурс в пространство имён или нет) и <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects>Kind</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl api-resources
</span></span></code></pre></div><p>Другие варианты команды для анализа API-ресурсов:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>      <span style=color:#080;font-style:italic># Все ресурсы с пространством имён</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>     <span style=color:#080;font-style:italic># Все ресурсы без пространства имён</span>
</span></span><span style=display:flex><span>kubectl api-resources -o name                <span style=color:#080;font-style:italic># Все ресурсы с простым выводом  (только имя ресурса)</span>
</span></span><span style=display:flex><span>kubectl api-resources -o wide                <span style=color:#080;font-style:italic># Все ресурсы с расширенным (с неограниченной длинной) выводом</span>
</span></span><span style=display:flex><span>kubectl api-resources --verbs<span style=color:#666>=</span>list,get       <span style=color:#080;font-style:italic># Все ресурсы, которые поддерживают глаголы запроса &#34;list&#34; и &#34;get&#34;</span>
</span></span><span style=display:flex><span>kubectl api-resources --api-group<span style=color:#666>=</span>extensions <span style=color:#080;font-style:italic># Все ресурсы в API-группе &#34;extensions&#34;</span>
</span></span></code></pre></div><h3 id=форматирование-вывода>Форматирование вывода</h3><p>Для вывода подробной информации в окно терминала в определенном формате, добавьте флаг <code>-o</code> (или <code>--output</code>) в команду <code>kubectl</code>, которая поддерживает форматирование.</p><table><thead><tr><th>Формат вывода</th><th>Описание</th></tr></thead><tbody><tr><td><code>-o=custom-columns=&lt;spec></code></td><td>Вывод таблицы из списка пользовательских столбцов через запятую</td></tr><tr><td><code>-o=custom-columns-file=&lt;filename></code></td><td>Вывод таблицы из списка пользовательских столбцов, определённых в файле <code>&lt;filename></code></td></tr><tr><td><code>-o=json</code></td><td>Вывод API-объекта в формате JSON</td></tr><tr><td><code>-o=jsonpath=&lt;template></code></td><td>Вывод полей, определённых в выражении <a href=/docs/reference/kubectl/jsonpath>jsonpath</a></td></tr><tr><td><code>-o=jsonpath-file=&lt;filename></code></td><td>Вывод полей, определённых в выражении <a href=/docs/reference/kubectl/jsonpath>jsonpath</a> из файла <code>&lt;filename></code></td></tr><tr><td><code>-o=name</code></td><td>Вывод только имена ресурсов</td></tr><tr><td><code>-o=wide</code></td><td>Вывод дополнительную информации в обычном текстовом формате, в случае подов отображается имя узла</td></tr><tr><td><code>-o=yaml</code></td><td>Вывод API-объекта в формате YAML</td></tr></tbody></table><h3 id=уровни-детальности-вывода-и-отладки-в-kubectl>Уровни детальности вывода и отладки в Kubectl</h3><p>Уровни детальности вывода Kubectl регулируются с помощью флагов <code>-v</code> или <code>--v</code>, за которыми следует целое число, представляющее уровни логирования. Общие соглашения по логированию Kubernetes и связанные с ними уровни описаны <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>здесь</a>.</p><table><thead><tr><th>Уровень детальности</th><th>Описание</th></tr></thead><tbody><tr><td><code>--v=0</code></td><td>Как правило, используется чтобы <em>всегда</em> видеть, что происходит</td></tr><tr><td><code>--v=1</code></td><td>Достаточный уровень логирования по умолчанию, если вам не нужна большая детальность.</td></tr><tr><td><code>--v=2</code></td><td>Полезная информация про стабильное состояние сервиса и важные сообщения логов, которые могут связаны со значительными изменениями в системе. Это рекомендуемый уровень логирования по умолчанию для большинства систем.</td></tr><tr><td><code>--v=3</code></td><td>Расширенная информация об изменениях.</td></tr><tr><td><code>--v=4</code></td><td>Уровень детальности для отладки.</td></tr><tr><td><code>--v=6</code></td><td>Показать запрашиваемые ресурсы.</td></tr><tr><td><code>--v=7</code></td><td>Показать заголовки HTTP-запросов.</td></tr><tr><td><code>--v=8</code></td><td>Показать содержимое HTTP-запросов.</td></tr><tr><td><code>--v=9</code></td><td>Показать содержимого HTTP-запроса в полном виде.</td></tr></tbody></table><h2 id=что-дальше>Что дальше</h2><ul><li><p>Подробнее о kubectl на странице <a href=/ru/docs/reference/kubectl/overview/>обзора</a>.</p></li><li><p>Посмотреть опции <a href=/ru/docs/reference/kubectl/kubectl/>kubectl</a>.</p></li><li><p>Ознакомиться с <a href=/docs/reference/kubectl/conventions/>соглашениями по использованию kubectl</a>, чтобы понять, как использовать его в повторно используемых скриптах.</p></li><li><p>Посмотреть <a href=https://github.com/dennyzhang/cheatsheet-kubernetes-A4>шпаргалки по kubectl</a> сообщества.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4985cb55ddfb184639d767ec54b9f0f7>7 - Участие в документации Kubernetes</h1><p>Если вы хотите внести свой вклад в документацию или сайт Kubernetes, мы будем рады вашей помощи! Любой может принять участие в проекте, независимо от того, знакомы ли вы с проектом или нет, кроме этого не имеет значения кто вы — разработчик, обычный пользователь или всего лишь тот, кто терпеть не может опечаток.</p><p>С деталями о содержании и стиле документации Kubernetes вы можете ознакомиться в <a href=/docs/contribute/style/>Documentation style overview</a>.</p><h2 id=типы-участников-документации>Типы участников документации</h2><ul><li><em>Член</em> организации Kubernetes, который <a href=/docs/contribute/start#sign-the-cla>подписал CLA</a>
и уже поработал в проекте определённое время. Перейдите на страницу
<a href=https://github.com/kubernetes/community/blob/master/community-membership.md>Членство в сообществе</a>, чтобы узнать что нужно для вступления в организацию.</li><li><em>Рецензент</em> документации SIG — член организации Kubernetes, который занимался проверкой пулреквестов в документацию и поэтому был добавлен в соответствующую группу на GitHub, и кроме того является ответственным за файлы, перечисленные в <code>OWNERS</code> в репозитории GitHub.</li><li><em>Утверждающий</em> документации SIG — участник с хорошей репутацией, который продемонстрировал неизменную приверженность проекту. Утверждающий может принимать пулреквесты и публиковать контент от имени организации Kubernetes.
Утверждающие также могут быть представителями документации SIG в более крупном сообществе Kubernetes. Некоторые из обязанностей утверждающего документации SIG, такие как организация нового выпуска, требуют огромного количество времени.</li></ul><h2 id=способы-участия-в-документации>Способы участия в документации</h2><p>Этот список разделен на то, что может делать каждый, что могут делать члены организации Kubernetes, и то, что требует более высокого уровня доступа и знания процессов документации SIG. Со временем постоянное участие в проекте поможет вам понять некоторые средства и организационные решения, которые уже были приняты.</p><p>Это не полный список способов поучаствовать в документации Kubernetes, зато он должен помочь вам начать работу.</p><ul><li><a href=/docs/contribute/start/>Любой человек</a><ul><li>Добавление реализуемых задач</li></ul></li><li><a href=/docs/contribute/start/>Член</a><ul><li>Улучшение существующей документации</li><li>Предложение идей по улучшению документации в <a href=http://slack.k8s.io/>Slack</a> или в <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs>списке рассылки документации SIG</a></li><li>Улучшение доступности документации</li><li>Составление рекомендаций к пулреквестам в документацию</li><li>Написание постов в блоге или примеров использования продукта</li></ul></li><li><a href=/docs/contribute/intermediate/>Рецензент</a><ul><li>Документирование новых функциональных возможностей</li><li>Сортировка и маркировка задач</li><li>Анализ пулреквестов</li><li>Создание диаграмм, графических ресурсов и встраиваемых скринкастов и/или видео</li><li>Локализация</li><li>Участие в других репозиториях в качестве представителя документации</li><li>Редактирование пользовательских строк в коде</li><li>Улучшение комментариев в коде, Godoc</li></ul></li><li><a href=/docs/contribute/advanced/>Утверждающий</a><ul><li>Публикация материалов участников, проверяя и объединяя пулреквесты</li><li>Участие в команде по выпуску новых версий Kubernetes в качестве представителя документации</li><li>Внесение предложений по улучшению руководства по стилю оформлению</li><li>Внесение предложений по улучшению в тесты документации</li><li>Внесение предложений по улучшению в сайт Kubernetes website или другие инструменты</li></ul></li></ul><h2 id=дополнительные-способы-участия>Дополнительные способы участия</h2><ul><li>Чтобы помочь сообществу Kubernetes с помощью онлайн-форумов, таких как Twitter или Stack Overflow, либо узнать о местных встречах и мероприятиях по Kubernetes, <a href=/community/>посетите страницу сообщества Kubernetes</a>.</li><li>Чтобы поучаствовать в разработке функциональности, ознакомьтесь со <a href=https://github.com/kubernetes/community/tree/master/contributors/guide/contributor-cheatsheet>шпаргалкой для участника</a>, чтобы начать.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3609b0e10614f1dc39ed781858319204>7.1 - Участие для начинающих</h1><p>Если вы хотите поучаствовать в работе над документацией Kubernetes, эта страница и связанные с ней темы могут помочь вам начать работу. Вам не нужно быть разработчиком или техническим писателем, чтобы внести вклад в документацию или улучшить сайт Kubernetes! Все, что вам нужно для тем на этой странице, это учетная запись на GitHub и браузер.</p><p>Если вы ищете информацию про участие в репозиториях, связанным с кодом Kubernetes, обратитесь к <a href=https://github.com/kubernetes/community/blob/master/governance.md>руководству сообщества Kubernetes</a>.</p><h2 id=основные-сведения-про-документацию>Основные сведения про документацию</h2><p>Документация Kubernetes написана на Markdown, обработана и развернута при помощи Hugo. Исходные файлы находятся на GitHub по адресу <a href=https://github.com/kubernetes/website>https://github.com/kubernetes/website</a>. Основная часть документации хранится в директории <code>/content/en/docs/</code>. Часть справочной документации автоматически генерируется из скриптов в директории <code>update-imported-docs/</code>.</p><p>Вы можете создавать новые задачи, редактировать содержимое и проверять изменения от других участников, — всё это доступно с сайта GitHub. Вы также можете использовать встроенный в GitHub поиск и историю коммитов.</p><p>Не все задачи могут быть выполнены с помощью интерфейса GitHub, но некоторые из них обсуждаются в руководствах для <a href=/ru/docs/contribute/intermediate/>продвинутых</a> и
<a href=/ru/docs/contribute/advanced/>опытных</a> участников.</p><h3 id=участие-в-документации-sig>Участие в документации SIG</h3><p>Документация Kubernetes поддерживается <a class=glossary-tooltip title='Community members who collectively manage an ongoing piece or aspect of the larger Kubernetes open source project.' data-toggle=tooltip data-placement=top href=https://github.com/kubernetes/community/blob/master/sig-list.md#special-interest-groups target=_blank aria-label='специальной группой'>специальной группой</a> (Special Interest Group, SIG) под названием SIG Docs. Мы <a href=#participate-in-sig-docs-discussions>общаемся</a> с помощью канала Slack, списка рассылки и еженедельных видеозвонков. Будем рады новым участникам. Для получения дополнительной информации обратитесь к странице <a href=ru/docs/contribute/participating/>Участие в SIG Docs</a>.</p><h3 id=руководящие-принципы-по-содержанию>Руководящие принципы по содержанию</h3><p>Сообщество SIG Docs разработало правила, которые касаются разрешенных видов контента в документации Kubernetes. Посмотрите <a href=/docs/contribute/style/content-guide/>руководство по содержанию документации</a> для определения того, допустим ли контент, который вы хотите добавить. Задать вопросы про допустимый контент можно в Slack-канале <a href=#participate-in-sig-docs-discussions>#sig-docs</a>.</p><h3 id=правила-оформления>Правила оформления</h3><p>Мы поддерживаем <a href=/docs/contribute/style/style-guide/>руководство по оформлению</a> с информацией о выборе, сделанном сообществом SIG Docs в отношении грамматики, синтаксиса, исходного форматирования и типографских соглашений. Прежде чем сделать свой первый вклад, просмотрите руководство по стилю и используйте его, когда у вас есть вопросы.</p><p>SIG Docs совместными усилиями вносит изменения в руководство по оформлению. Чтобы предложить изменение или дополнение, добавьте его в повестку дня предстоящей встречи SIG Docs и посетите её, чтобы принять участие в обсуждении. Смотрите руководство для <a href=/docs/contribute/advanced/>продвинутых участников</a>, чтобы получить дополнительную информацию.</p><h3 id=шаблоны-страниц>Шаблоны страниц</h3><p>Мы используем шаблоны страниц, чтобы управлять представление наших страниц документации. Разберитесь как работают эти шаблоны, ознакомившись с разделом <a href=/docs/contribute/style/page-templates/>Использование шаблонов страниц</a>.</p><h3 id=макрокоды-hugo>Макрокоды Hugo</h3><p>Документация Kubernetes с помощью Hugo конвертируется из формата разметки Markdown в HTML. Мы используем встроенные макрокоды Hugo, а также некоторые из своих собственных, созданных специально для документации Kubernetes. Посетите страницу <a href=/docs/contribute/style/hugo-shortcodes/>Нестандартные макрокоды Hugo</a>, чтобы узнать, как их использовать.</p><h3 id=мультиязычность>Мультиязычность</h3><p>Исходные файлы документации доступны на нескольких языках в директории <code>/content/</code>. Каждый язык имеет свою собственную директорию с двухбуквенным кодом, определенным стандартом<a href=https://www.loc.gov/standards/iso639-2/php/code_list.php>ISO 639-1 standard</a>. Например, исходники документации для английского языка хранится в директории <code>/content/en/docs/</code>.</p><p>Более подробную информацию про участие в работе над документацией на нескольких языках <a href=/docs/contribute/intermediate#localize-content>"Localize content"</a> в промежуточном руководстве по добавлению.</p><p>Если вы заинтересованы в переводе документации на новый язык, посмотрите раздел <a href=/ru/docs/contribute/localization/>"Локализация"</a>.</p><h2 id=создание-хороших-заявок>Создание хороших заявок</h2><p>Любой, у кого есть аккаунт на GitHub, может создать заявку (issue, или отчет об ошибке) в документации Kubernetes. Если вы заметили какую-либо какую-либо ошибку, даже если вы не знаете, как её исправить, <a href=#how-to-file-an-issue>откройте ишью</a>. Но не делайте этого, если нашли небольшую ошибку, например, опечатку, которую вы при желании можете исправить самостоятельно. В этом случае можете <a href=#improve-existing-content>исправить ее</a> вместо того, чтобы писать об этом.</p><h3 id=как-создать-заявку>Как создать заявку</h3><ul><li><p><strong>Для существующей страницы</strong></p><p>Если заметили проблему на существующей странице в <a href=/ru/docs/>документации Kubernetes</a>, перейдите в конец страницы и нажмите кнопку <strong>Create an Issue</strong>. Если вы ещё не авторизованы в GitHub, сделайте это. После этого откроется страница с форма для создания нового запроса в GitHub с уже предварительно заполненным полями.</p><p>При помощи разметки Markdown опишите как можно подробнее, что хотите. Там, где вы видите пустые квадратные скобки (<code>[ ]</code>), проставьте <code>x</code> между скобками. Если у вас есть предлагаемое решение проблемы, напишите его.</p></li><li><p><strong>Запросить новую страницу</strong></p><p>Если вы хотите добавить что-то новое, но вы не уверены, на какую страницу документации это сделать или считаете, что новая информация не вписывается в существующие страницы, всё равно создайте ишью. Вы можете либо перейти на страницу документации, куда, по вашему мнению, нужно добавить новую информацию и создать заявку прямо с этой страницы, либо перейти по адресу <a href=https://github.com/kubernetes/website/issues/new/>https://github.com/kubernetes/website/issues/new/</a> и написать что вы хотите там.</p></li></ul><h3 id=как-заполнить-хорошую-заявку>Как заполнить хорошую заявку</h3><p>Чтобы нам самим убедиться, что понимаем вас правильно, помните следующее:</p><ul><li>Используйте шаблон ишью и заполните его как можно подробнее.</li><li>Четко изложите суть вашего проблемы, как она сказывается на пользователях.</li><li>Как можно меньше ограничьте охват изменений в вашей заявке. Задачи с большим объемом работы разбейте на более мелкие.
Например, "Fix the security docs" не является проблемой, требующей немедленного решения, зато заявка с заголовком "Add details to the 'Restricting network access' topic", вероятно, такой является.</li><li>Если проблема связана с другой заявкой или пулреквестом, вы можете указать сослаться на них, либо по его полному URL-адресу, либо по их номеру с <code>#</code>. Например, <code>Introduced by #987654</code>.</li><li>Будьте уважительны и избегайте жалоб. Например, заголовок ишью "The docs about X suck" явно не несёт ничего полезного или чтобы на него реагировали.
<a href=/community/code-of-conduct/>Нормы поведения</a> также применяется к общению в GitHub-репозиториях Kubernetes.</li></ul><h2 id=участие-в-дискуссиях-sig-docs>Участие в дискуссиях SIG Docs</h2><p>Команда SIG Docs общается следующими способами:</p><ul><li><a href=http://slack.k8s.io/>Зарегистрируйтесь в Slack-канале Kubernetes</a>, а затем присоединитесь к каналу <code>#sig-docs</code>, где мы в режиме реального времени обсуждаем всё, что связано с документацией. И не забудьте представиться!</li><li><a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs>Подпишитесь на список рассылки <code>kubernetes-sig-docs</code></a>, где проходят более общие дискуссии и принимаются официальные решения.</li><li>Участвуйте в <a href=https://github.com/kubernetes/community/tree/master/sig-docs>еженедельной видеовстрече IG Docs</a>, которая анонсируется в Slack-канале и списке рассылки. В данный момент эти встречи проводятся в Zoom, поэтому вам необходимо загрузить клиент Zoom или позвонить по телефону.</li></ul><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Вы всегда можете узнать когда будет очередное еженедельное собрание SIG Docs в <a href="https://calendar.google.com/calendar/embed?src=cgnt364vd8s86hr2phapfjc6uk%40group.calendar.google.com&ctz=America/Los_Angeles">календаре собраний сообщества Kubernetes</a>.</div><h2 id=улучшение-существующего-текста>Улучшение существующего текста</h2><p>Чтобы улучшить текущее содержимое документации, вам нужно открыть <em>пулреквест (pull request, PR)</em> после того, как вы сделаете <em>копию (fork)</em> оригинального репозитория. Эти два термина <a href=https://help.github.com/categories/collaborating-with-issues-and-pull-requests/>относятся к GitHub</a>.
Для начала работы, которая показана в этом разделе, вам не нужно знать всё про эти понятия, так как вы всё можете делать в своём браузере. Когда вы перейдете к продвинутому руководству участника документации, тогда вам понадобиться пополнить свои знания Git.</p><p>Примечание. Разработчики кода Kubernetes. Если вы документируете новую функцию для предстоящего выпуска Kubernetes, ваш процесс будет немного другим. См. Документирование функции для руководства по процессу и информации о сроках.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> <strong>Для разработчиков кода Kubernetes</strong>: если вы документируете новую функциональность для новой версии Kubernetes, то процесс рассмотрения будет немного другим. Посетите страницу <a href=/ru/docs/contribute/intermediate/#%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D0%B8-%D0%B4%D0%BB%D1%8F-%D0%BD%D0%BE%D0%B2%D0%BE%D0%B9-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8>Документирование функциональности</a>, чтобы узнать про процесс и информацию о крайних сроках.</div><h3 id=sign-the-cla>Подписание CLA-соглашения CNCF</h3><p>Прежде чем внести вклад в код или документацию Kubernetes, вам <strong>обязательно</strong> следует прочитать <a href=https://github.com/kubernetes/community/blob/master/contributors/guide/README.md>руководство для участников</a> и <a href=https://github.com/kubernetes/community/blob/master/CLA.md>подписать лицензионное соглашение участника (Contributor License Agreement, CLA)</a>.
Не переживайте — подписание не займет много времени!</p><h3 id=поиск-задач-для-работы>Поиск задач для работы</h3><p>Если вы уже нашли что исправить, просто следуйте инструкциям ниже. Для этого вам не обязательно <a href=#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B8%D1%85-%D0%B7%D0%B0%D1%8F%D0%B2%D0%BE%D0%BA>создавать ишью</a> (хотя вы, безусловно, пойти этим путём).</p><p>Если вы хотите ещё не определились с тем, над чем хотите поработать, перейдите по адресу <a href=https://github.com/kubernetes/website/issues>https://github.com/kubernetes/website/issues</a> и найдите ишью с меткой <code>good first issue</code> (вы можете использовать <a href="https://github.com/kubernetes/website/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22">эту</a> ссылку для быстрого поиска). Прочитайте комментарии, чтобы убедиться что нет открытого пулреквеста для решения текущей ишью, а также, что никто другой не оставил комментарий, что он работает над этой задачей в последнее время (как правило, 3 дня). Добавьте комментарий, что вы хотели бы заняться решением этой задачи.</p><h3 id=выбор-правильной-ветки-в-git>Выбор правильной ветки в Git</h3><p>Самым важный момент в создании пулреквестов — это выбор нужной ветки для вашей работы. Используйте эти рекомендации, чтобы принять верное решение:</p><ul><li>Используйте ветку <code>master</code> для исправления ошибок в текущей документации, либо чтобы улучшить существующий текст.</li><li>Используйте ветку <code>master</code> для документирования функциональности в текущей версии Kubernetes, для которой отсутствовала документация. Прежде всего вам нужно написать документацию на английском языке, а затем команды по переводам подхватят это изменение, чтобы актуализировать перевод.</li><li>Если вы работаете над переводом, вам нужно следовать соглашению в этой конкретной локализации. Чтобы понять это, вы можете другие пулреквесты (подсказка: <code>is:pr is:merged label:language/xx</code>)<ul><li>Некоторые команды локализации работают с пулреквестами, которые ориентированы на ветку <code>master</code></li><li>Другие команды локализации работают с рядом долговечных веток, периодически сливая их в ветку <code>master</code>. Такая ветка именуется как dev-&lt;version>-&lt;language code>.&lt;team milestone>, например, <code>dev-release-1.25-ja.1</code>.</li></ul></li><li>Если вы пишете или обновляете документацию к выпуску грядущего изменения, то вам необходимо знать мажорную и минорную версию Kubernetes, в которой это изменение впервые появится.<ul><li>Например, если переключатель возможностей (feature gates) JustAnExample должен измениться с альфа-версии на бета-версию в следующей минорной версии, вам необходимо знать номер этой версии.</li><li>Найдите ветку выпуска, названную для этой версии. Например, функциональность, которая изменились в выпуске vrelease-1.25, будет документирована в ветке <code>dev-release-1.25</code>.</li></ul></li></ul><p>Если вы все еще не уверены, какую ветку выбрать, спросите в Slack-канале <code>#sig-docs</code> или посетите еженедельную встречу SIG Docs, чтобы внести ясность.</p><h3 id=отправка-пулреквеста>Отправка пулреквеста</h3><p>Следуйте описанным ниже шагам, чтобы создать пулреквест для улучшения документации Kubernetes.</p><ol><li><p>На странице, которую вы хотите отредактировать, щелкните на иконку карандаша в правом верхнем углу. Откроется новая страница на GitHub с небольшой подсказкой.</p></li><li><p>Если вы ранее не делали копию репозитория документации Kubernetes, вам будет предложено это сделать. Создайте копию репозитория под своим логином GitHub, а не в организации, в которой вы состоите. URL-адрес копии репозитория будет выглядит как <code>https://github.com/&lt;username>/website</code>, в случае у вас нет репозитория с таким же названием.</p><p>Поскольку у вас нет доступа к оригинальному репозиторию и соответственно вы не можете отправлять напрямую изменения в основную ветку, вам нужно сделать копию репозитория Kubernetes.</p></li><li><p>Откроется редактор GitHub для редактирования исходного файла в формате Markdown. Внесите свои изменения. Под редактором заполните форму <strong>Propose file change</strong>. Первое поле — краткое содержание вашего сообщения коммита, оно должно содержать не более 50 символов. Второе поле является необязательным, в нём вы можете подробно расписать суть ваших изменений.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Не ссылайте на другие ишью или пулреквесты на GitHub в сообщении коммита. Вы можете сослаться на них в тексте пулреквеста.</div><p>Нажмите на кнопку <strong>Propose file change</strong>. Изменения в файле записываются в виде коммита в новой ветке вашей копии репозитория, которая автоматически будет иметь имя что-то вроде <code>patch-1</code>.</p></li><li><p>На следующей странице вам будут показаны различия в вашей ветке (поля выбора <strong>head fork</strong> и <strong>compare</strong>) с текущим состоянием <strong>оригинального репозитория (base fork)</strong> в <strong>основной ветке (base)</strong> (по умолчанию ветка <code>master</code> в репозитории <code>kubernetes/website</code>). Вы можете выбрать другое значение в полях выбора, но не делайте этого сейчас. Сравните различия и если всё верно, нажмите кнопку <strong>Create pull request</strong>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Если вы не хотите создавать пулреквест в данный момент, это можно сделать позже, если перейти на страницу репозитория сайта Kubernetes или вашей копии репозитория. На сайте GitHub вам предложит открыть пулреквест, если он обнаружит новую ветку в вашей копии репозитория.</div></li><li><p>Отобразится форма с заголовком <strong>Open a pull request</strong>. Название пулреквеста будет содержать краткое описание из сообщения коммита, хотя вы можете изменить его при необходимости. В описании пулреквеста будет остальная информация из сообщения коммита (если оно есть) и небольшой шаблон с текстом. Прочитайте текст шаблона и сделайте то, что там описано, а затем удалите этот шаблонный текст. Если вы добавите в описание пулреквест <code>fixes #&lt;000000></code> или <code>closes #&lt;000000></code>, где <code>#&lt;000000></code> - номер связанной заявки, то GitHub автоматически закроет указанную заявку при слиянии пулреквеста. Оставьте флажок <strong>Allow edits from maintainers</strong> отмеченным. Нажмите на кнопку <strong>Create pull request</strong>.</p><p>Поздравляем! Ваш пулреквест добавлен в список <a href=https://github.com/kubernetes/website/pulls>пулреквестов</a>.</p><p>Через несколько минут вы сможете просмотреть версию сайта с изменениями в вашем пулреквесте. Перейдите в низ страницы пулреквеста на вкладке <strong>Conversation</strong> и там нажмите на ссылку <strong>Details</strong> рядом с проверкой <code>deploy/netlify</code>. По умолчанию она откроется в текущей вкладке.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Пожалуйста, открывайте пулреквест, изменения которого затрагивают только один язык. Например, если вам нужно одинаково изменить один и тот же пример кода в нескольких языках, откройте по отдельному пулреквесту для каждого языка.</div></li><li><p>Ожидайте, когда проверят ваш пулреквест. Как правило, рецензенты выбираются авматоматически ботом <code>k8s-ci-robot</code>. Если рецензент попросил изменить пулреквест, вы можете сделать это, если перейдёте на вкладку <strong>Files changed</strong> и щёлкните на иконку с карандашом на любом изменённом файле в вашем пулреквесте. Сохранение измененного файла оформляется в виде нового коммита в ветке, указанной в пулреквесте. Если вы ожидаете новую проверку изменений от рецензента, заранее попросите его об этом не более одного раза в 7 дней. Вы также можете зайти в Slack-канал #sig-docs — это хорошее место, где можно попросить проверку пулреквеста.</p></li><li><p>Если ваши изменения одобрены, то рецензент объединяет соответствующий пулреквест. Через несколько минут вы сможете сможете увидеть его в действии на сайте Kubernetes.</p></li></ol><p>Это только один из способов отправить пулреквест. Если вы уже опытный пользователь Git и GitHub, вы можете вносить изменения, используя локальный GUI-клиент или Git из терминала вместо того, чтобы использовать интерфейс GitHub для этого. Некоторые основы использования Git-клиента из командной строки обсуждаются в руководстве для <a href=/ru/docs/contribute/intermediate/>продвинутого участника</a>.</p><h2 id=просмотр-пулреквестов-в-документацию>Просмотр пулреквестов в документацию</h2><p>Новички документации могут обозревать пулреквесты. Вы можете изучить кодовую базу и завоевать доверие к себе со стороны коллег-участников. Документация на английском — это первоисточник содержимого. Мы общаемся на английском языке во время еженедельных встреч и в объявлениях сообщества. Владение английским языком может быть разным, поэтому используйте простой и прямой язык в своих обзорах пулреквестов. Полезные обзоры фокусируются как на мелких деталях, так и на потенциальном влиянии изменений.</p><p>Обзоры не носят «обязательный характер», это означает, что только ваша проверка не приведет к слиянию пулреквеста. Тем не менее, это не делает ваши обзоры бесполезными. Даже только просмотр изменений в пулреквеста поможет вам понять как происходит рабочий процесс, какие могут быть трудности и проблемы. Перед проверкой пулреквестов ознакомьтесь с <a href=/docs/contribute/style/content-guide/>руководством по содержанию</a> и <a href=/docs/contribute/style/style-guide/>руководством по оформлению</a>, чтобы узнать, каким должен быть содержимое и как оно должно быть оформлено..</p><h3 id=рекомендации>Рекомендации</h3><ul><li>Будьте вежливы, внимательны и помогайте другим</li><li>Не забывайте отмечать также положительные стороны пулреквеста</li><li>Будьте чутким и думайте, как ваши комментарии могут быть восприняты</li><li>Проявите добрые намерения и задавайте уточняющие вопросы</li><li>Опытным участникам: помогайте новым участникам, их работа требует глаз да глаз</li></ul><h3 id=поиск-и-проверка-пулреквеста>Поиск и проверка пулреквеста</h3><ol><li><p>Перейдите по URL-адресу <a href=https://github.com/kubernetes/website/pulls>https://github.com/kubernetes/website/pulls</a>. Вы увидите список всех пулреквестов в репозиторий сайта Kubernetes и его документации.</p></li><li><p>По умолчанию открываются открытые пулреквесты (статус <code>open</code>), поэтому вы не увидите закрытых или принятых пулреквестов. Рекомендуется добавить дополнительный фильтр <code>cncf-cla: yes</code>, а также для вашей первой проверки пулреквеста неплохо применить ещё и <code>size/S</code> и <code>size/XS</code>. Метка с размером назначается автоматически в зависимости от количества изменённых строк кода в пулреквесте. Вы можете применить фильтры, используя поля выбора в верхней части страницы, либо воспользоваться <a href="https://github.com/kubernetes/website/pulls?q=is%3Aopen+is%3Apr+label%3A%22cncf-cla%3A+yes%22+label%3Asize%2FS">этой ссылкой</a> для просмотра небольших пулреквестов. Все фильтры объединены в логическое <code>AND</code>, поэтому у вас не получиться искать по меткам <code>size/XS</code> и <code>size/S</code> одновременно.</p></li><li><p>Перейдите на вкладку <strong>Files changed</strong>. Посмотрите изменения, внесенные в PR, а также изучите любые связанные задачи (если есть). Если вы видите ошибку, неточность или хотите внести улучшение, то наведите курсор на строку и щелкните на появившийся символ <code>+</code>.</p><p>Вы можете написать комментарий, после чего нажать на кнопку <strong>Add single comment</strong> или <strong>Start a review</strong>. Как правило, лучше начать проверку (review), поскольку тогда вы сможете оставить несколько комментариев и уведомить автора PR только после завершения рецензирования, вместо того, чтобы упоминать его в каждом комментарии.</p></li><li><p>После окончания разбора пулреквеста, нажмите на кнопку <strong>Review changes</strong> вверху страницы. Вы можете подвести краткий итог своей проверки и выполнить одно из действий: просто прокомментировать, одобрить или запросить изменения. Новым участникам нужно всегда только комментировать (кнопка <strong>Comment</strong>) пулреквесты.</p></li></ol><p>Спасибо за обзор пулреквеста! Если вы новенький в проекте, рекомендуется попросить кого-нибудь оценить ваш обзор пулреквеста. Slack-канал <code>#sig-docs</code> — отличное место для этого.</p><h2 id=написание-постов-в-блоге>Написание постов в блоге</h2><p>Любой может написать пост в блоге и отправить его на рассмотрение. Посты блога не должны носит коммерческий характер и должны отражать опыт, который может широко применён в сообществе Kubernetes.</p><p>Чтобы заявить о посте вы можете отправить его, используя <a href=https://docs.google.com/forms/d/e/1FAIpQLSdMpMoSIrhte5omZbTE7nB84qcGBy8XnnXhDFoW0h7p2zwXrw/viewform>форму блога Kubernetes</a>, либо же выполнить следующие действия.</p><ol><li><a href=#sign-the-cla>Подпишите CLA</a>, если вы еще этого не сделали.</li><li>Изучите разметку Markdown у текущих постов блога в репозитории сайта.</li><li>Напишите свою статью в вашем любимом текстовом редакторе.</li><li>По ссылке из второго шага нажмите на кнопку <strong>Create new file</strong>. Скопируйте из своего редактора текст и вставьте в многострочное поле. Назовите файл так, чтобы он соответствовал предлагаемому заголовку статьи в блоге, но не указывайте дату в имени файла. Рецензенты блога будут работать с вами над окончательным именем файла и датой публикации записи.</li><li>Когда вы сохраните файл, начнётся описанный выше процесс принятия пулреквеста в GitHub.</li><li>Рецензент блога рассмотрит вашу статью и вместе с вами будет работать над ее улучшением. Когда запись в блоге будет одобрена, будет известна дата публикации вашей статьи.</li></ol><h2 id=отправка-примеров-использования>Отправка примеров использования</h2><p>В примерах использования показывается, как организации используют Kubernetes для решения собственных реальных проблем. Они написаны в сотрудничестве с маркетинговой командой Kubernetes, которой занимается <a class=glossary-tooltip title='Cloud Native Computing Foundation' data-toggle=tooltip data-placement=top href=https://cncf.io/ target=_blank aria-label=CNCF>CNCF</a>.</p><p>Ознакомьтесь с <a href=https://github.com/kubernetes/website/tree/master/content/en/case-studies>существующими примерами использования</a>. Воспользуйтесь <a href=https://www.cncf.io/people/end-user-community/>формой добавления нового примера использования Kubernetes</a>, чтобы поделиться своим опытом.</p><h2 id=что-дальше>Что дальше</h2><p>Если вы хорошо поняли темы, затронутые в этом разделе, но хотите глубже взаимодействовать с командой документации Kubernetes, прочитайте <a href=/docs/contribute/intermediate/>расширенное руководство по участию в документации</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9ff7ba6b379b0f8b652beaabf6e4f8d6>7.2 - Участие для продвинутых</h1><p>1</p><p>На этой странице предполагается, что вы изучили и понимаете задачи на странице <a href=/ru/docs/contribute/start/>Участие для начинающих</a> и теперь готовы узнать о других способах внести свой вклад.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Некоторые задачи требуют использование Git-клиента из командной строки и других инструментов.</div><p>Теперь, когда вы уже знаете кое-что и приняли участие в документации Kubernetes, как описано в теме <a href=/ru/docs/contribute/start/>Участие для начинающих</a>, вы можете пойти ещё дальше. Далее пойдут задачи, предусматривающие наличие и желание получить глубокие знания по следующим темам:</p><ul><li>Концепции Kubernetes</li><li>Рабочие процессы документации Kubernetes</li><li>Поиск нужной информации о будущих возможностях Kubernetes</li><li>Сильные аналитические навыки в целом</li></ul><p>Эти задачи не такие последовательные, как задачи для начинающих. Поэтому мы не ожидаем, что кто-то в одиночку будет постоянно заниматься всеми ими.</p><h2 id=знакомство-с-prow>Знакомство с Prow</h2><p><a href=https://github.com/kubernetes/test-infra/blob/master/prow/README.md>Prow</a> — это система CI/CD, использующая Kubernetes, которая выполняет задания с пулреквестами (PR). Prow с помощью команд, похожих на те, что есть в чатботах, даёт возможность обрабатывать действия в организации Kubernetes на GitHub. Вы можете выполнять целый ряд действий, такие как добавление и удаление меток, закрытие заявок и назначение утверждающего. Введите Prow-команду в поле для комментария в формате <code>/&lt;command-name></code>. Некоторые популярные команды:</p><ul><li><code>/lgtm</code> (looks good to me): добавляет метку <code>lgtm</code>, которая сообщает, что рецензент проверил PR</li><li><code>/approve</code>: одобряет PR так, чтобы он мог быть принят (эта команда работает только для утверждающих)</li><li><code>/assign</code>: назначает проверяющего на PR</li><li><code>/close</code>: закрывает ишью или PR</li><li><code>/hold</code>: добавляет метку <code>do-not-merge/hold</code>, которая означает, что PR не может быть автоматически принят</li><li><code>/hold cancel</code>: удаляет метку <code>do-not-merge/hold</code></li></ul><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Не все команды работают для каждого пользователя. Бот Prow сообщит вам, если вы пытаетесь выполнить команду, не разрешенную для вашего уровня.</div><p>Детально изучите <a href=https://prow.k8s.io/command-help>список команд Prow</a>, прежде чем начать проверять PR или сортировать ишью.</p><h2 id=проверка-пулреквестов>Проверка пулреквестов</h2><p>Каждую неделю утверждающий доброволец документации сортирует и просматривает <a href=#%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F-%D0%B8%D1%88%D1%8C%D1%8E>пулреквесты и заявки</a>. Такой человек называется "PR Wrangler" на неделю. Расписание ведется с помощью <a href=https://github.com/kubernetes/website/wiki/PR-Wranglers>планировщика PR Wrangler</a>. Чтобы поучаствовать в этом списке, посетите еженедельную встречу SIG Docs. Даже если вас не выбрали дежурным по PR на текущую неделю, вы все равно можете проверять пулреквесты (PR), которые еще не были детально просмотрены.</p><p>В дополнение к ротации автоматизированная система добавляет в каждый новый PR и предлагает рецензентов и утверждающих для него, основываясь на списке утверждающих и рецензентов в измененных файлах. Ожидается, что автор PR будет следовать указаниям бота, поэтому PR должен быть быстро проверить.</p><p>Мы хотим, чтобы пулреквесты принимались и публиковались как можно быстрее. Чтобы документация оставалась точной и актуальной, каждый PR должен проверяться людьми, понимающие суть темы, а также теми, кто имеет опыт написания отличной документации.</p><p>Рецензенты и утверждающие должны предоставить конкретную и конструктивную обратную связь, чтобы заинтересованные участники были вовлечены и помогали им улучшаться. Иногда, чтобы помочь новому участнику подготовить свой PR к слиянию, требуется больше времени, чем просто переписать его самостоятельно, но проект лучше в долгосрочной перспективе, когда у нас есть множество активных участников.</p><p>Прежде чем приступить к проверке PR, убедитесь, что вы знакомы с <a href=/docs/contribute/style/content-guide/>руководством по содержанию документации</a>, <a href=/docs/contribute/style/style-guide/>руководством по оформлению документации</a> и <a href=/community/code-of-conduct/>нормы поведения</a>.</p><h3 id=поиск-пулреквестов-для-проверки>Поиск пулреквестов для проверки</h3><p>Чтобы посмотреть все открытые пулреквесты, перейдите на вкладку <strong>Pull Requests</strong> в GitHub-репозитории.
PR можно проверять только, если он соответствует всем перечисленным ниже критериям:</p><ul><li>Имеет метку <code>cncf-cla:yes</code></li><li>Не содержит надписи WIP в описании</li><li>Не имеет тег с фразой <code>do-not-merge</code></li><li>Нет конфликтов для слияния</li><li>Сделан в правильную ветку (обычно это <code>master</code>, за исключением, если PR не относится к невыпущенной ещё функциональности)</li><li>Не проверялся ещё детально другим проверяющим документации (то же самое касается и остальных технических рецензентов), если только этот человек явно не обратился за вашей помощью. В частности, не рекомендуется добавлять много новых комментариев после других циклов рассмотрения PR.</li></ul><p>Если PR не имеет условия для проверки, можно оставить комментарий, чтобы сообщить автору о текущих проблемах и предложить помочь решить их. Если автор пулреквеста был оповещён о проблемах и не устранил их в течение нескольких недель или месяцев, то рано или поздно такой PR будет закрыт.</p><p>Если вы новичок в проверке пулреквестов или у вас недостаточно времени и возможностей, попробуйте поискать PR с тегом <code>size/XS</code> или <code>size/S</code>. Размер пулреквеста автоматически определяется по количеству изменённых строк в PR.</p><h4 id=рецензенты-и-утверждающие>Рецензенты и утверждающие</h4><p>В репозитории сайта Kubernetes работа построена иначе, чем в других репозиториях Kubernetes, когда речь идет о роли рецензентов и утверждающих. Для получения дополнительной информации об обязанностях рецензентов и утверждающих см. <a href=/ru/docs/contribute/participating/>Участие в SIG Docs</a>. Ниже вы найдете краткий обзор.</p><ul><li><p>Рецензент проверяет содержание пулреквеста для соблюдения технической точности. Рецензент даёт понять, что PR технически точен, оставляя комментарий с <code>/lgtm</code> к PR.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Не добавляйте <code>/lgtm</code>, если вы не уверены в технической точности документации, измененной или добавленной в PR.</div></li><li><p>Утверждающий проверяет содержание запроса на предмет качества и соответствия рекомендациям SIG Docs, приведенным в руководствах по содержанию и оформлению. Только люди, указанные в качестве утверждающих в файле <a href=https://github.com/kubernetes/website/blob/main/OWNERS><code>OWNERS</code></a>, могут одобрить PR. Чтобы одобрить PR, оставьте комментарий <code>/approve</code> к PR.</p></li></ul><p>PR объединяется, когда у него есть комментарий <code>/lgtm</code> от кого-либо из организации Kubernetes и комментарий <code>/approve</code> от утверждающего в группе <code>sig-docs-maintainers</code>, если он не удерживается, а автор PR подписал CLA.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Раздел <a href=/ru/docs/contribute/participating/#%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5>"Участие"</a> содержит больше информации для рецензентов и утверждающих, включая конкретные обязанности для утверждающих.</div><h3 id=проверка-pr>Проверка PR</h3><ol><li><p>Изучите описание PR вместе с указанными ишью и ссылками, если они есть. Кратковременные мимолетные обзоры иногда могут наносит больше вреда, чем пользы, поэтому убедитесь, что вы обладаете нужными знаниями, чтобы сделать содержательный обзор.</p></li><li><p>Если кто-то другой может лучше всего проверит определенный PR, упомяните этого человека, добавив комментарий <code>/assign @&lt;github-username></code>. Если вы обратились за технической проверкой к человеку, который не занимается документацией, но при этом вы хотите сами посмотреть PR как участник группы документации, то не стесняйтесь это делать.</p></li><li><p>Перейдите на вкладку <strong>Files changed</strong>. Посмотрите на все изменённые строки. Удалённый текст выделен красным, а строки с ним начинаются с символа <code>-</code>. Добавленный текст отмечен зелёным фоном, а строки с ним начинаются с символа <code>+</code>. Внутри строки фактически измененный контент имеет чуть более темный зеленый фон, чем остальная часть строки.</p><ul><li><p>В частности, если в PR есть сложное форматирование или он изменяет CSS, JavaScript или другие элементы сайта, вы можете просмотреть сайт, сгенерированный с этими изменениями в PR. Перейдите на вкладку <strong>Conversation</strong> и нажмите ссылку <strong>Details</strong> в проверке <code>deploy/netlify</code> в нижней части страницы. По умолчанию ссылка открывается в текущей вкладке браузера, поэтому чтобы потерять частичный отзыв, откройте ссылку в новой вкладке. Вернитесь на вкладку <strong>Files changed</strong>, чтобы продолжить проверку пулреквеста.</p></li><li><p>Убедитесь, что PR соответствует правилам содержания и оформления; если что-то не так, укажите на этом со ссылкой на раздел в руководстве.</p></li><li><p>Если у вас есть вопрос или вы хотите прокомментировать определённое изменение, наведите курсор мыши на строку и кликните на появившуюся сине-белую кнопку с иконкой <code>+</code>. Напишите свой комментарий и нажмите на кнопку <strong>Start a review</strong>.</p></li><li><p>Если вам нужно оставить больше одного комментария, сделайте это по аналогии с предыдущим шагом.</p></li><li><p>По соглашению, если вы видите небольшую проблему, не имеющей отношение к основному назначению PR, например, опечатку или лишний пробел, вы можете сообщить о ней, начав комментарий с <code>nit:</code>, чтобы автор знал, что это незначительная ошибка. Хотя это не означает, что автор пулреквеста может проигнорировать такие проблемы.</p></li><li><p>Когда вы всё проверили или у вас не осталось комментариев, прокрутите в верхнюю часть страницы и нажмите на кнопку <strong>Review changes</strong>. Далее кликните либо на <strong>Comment</strong> или <strong>Request Changes</strong>. Напишите краткий итог вашей проверки и добавьте соответствующие <a href=https://prow.k8s.io/command-help>Prow-команды</a> по одной на каждой строке в поле Review Summary. SIG Docs следует <a href=https://github.com/kubernetes/community/blob/master/contributors/guide/owners.md#the-code-review-process>процессу проверки кода Kubernetes</a>. Все ваши комментарии будут отправлены автору PR в виде одного уведомления.</p><ul><li><p>Если вы считаете, что PR в хорошем состоянии, чтобы его принять, добавьте команду <code>/approve</code> в резюме вашей проверки.</p></li><li><p>Если PR не нуждается в дополнительном техническом рассмотрении, добавьте ещё команду <code>/lgtm</code>.</p></li><li><p>Если PR <em>требуется</em> дополнительный технический обзор, добавьте команду <code>/assign</code> и после неё укажите логин человека на GitHub, который должен сделать технический анализ. Посмотрите на поле рецензентов во вступительной (фронтальной) части вверху данного Markdown-файла, чтобы выяснить, кто может провести технический разбор пулреквеста.</p></li><li><p>Чтобы заблокировать слияние PR, используйте команду <code>/hold</code>. Она добавит метку <code>do-not-merge/hold</code>.</p></li><li><p>Если в PR нет конфликтов и есть метки <code>lgtm</code> и <code>approve</code> (и нет метки <code>hold</code>), то он автоматически объединиться.</p></li><li><p>Если PR имеет метки <code>lgtm</code> и/или <code>approve</code>, и появляются новые изменения, эти метки будут автоматически удалены.</p><p>Посмотрите <a href=https://prow.k8s.io/command-help>список доступных команд</a>, которые можно использовать в PR.</p></li></ul></li><li><p>Если вы ранее выбрали нажали на <strong>Request changes</strong> и затем автор PR решил все указанные проблемы, вы можете обновить статус проверки либо на вкладке <strong>Files changed</strong>, либо в нижней части вкладки <strong>Conversation</strong>. Обязательно укажите команду <code>/approve</code> и при необходимости выберите технических рецензентов, чтобы можно было объединить PR.</p></li></ul></li></ol><h3 id=редактирование-pr-другого-человека>Редактирование PR другого человека</h3><p>Добавление комментариев в PR — полезное дело, но могут быть случаи, когда нужно сделать коммит в пулреквест другого человека, а не просто оставить свой отзыв.</p><p>Не поддавайтесь желанию выполнить работу за другого человека, если только он явно не попросит вас об этом или вы не захотите оживить давно заброшенный PR. Хотя это может быть быстрее в краткосрочной плане, но это лишает человека возможности внести собственный вклад.</p><p>Используемый процесс зависит от того, нужно ли вам отредактировать файл, который уже изменен в PR, либо вам нужно отредактировать файл, который в PR не участвовал.</p><p>Вы не можете отредактировать чужой PR, если выполняется одно из условий:</p><ul><li>Если автор PR отправил свою ветку непосредственно в репозиторий <a href=https://github.com/kubernetes/website/>https://github.com/kubernetes/website/</a>, то только рецензент с правом отправки изменений напрямую в репозиторий может вносить изменения в PR.
Авторам следует открыть PR из ветки в своей копии репозитория.</li><li>Если автор PR явно запретил редактирование утверждающими, вы не сможете внести изменения в его PR, пока он не изменит эту настройку.</li></ul><h4 id=если-файл-уже-изменён-в-pr>Если файл уже изменён в PR</h4><p>Этот метод использует интерфейс GitHub. Вы можете использовать командную строку, если вам комфортнее работать в ней, даже если вам нужно изменить файл, который ранее редактировался в PR.</p><ol><li>Перейдите на вкладку <strong>Files changed</strong>.</li><li>Прокрутите к блоку с файлом, который вы хотите отредактировать и нажмите на иконку с карандашом.</li><li>Внесите изменения, напишите сообщение коммита в соответствующем поле под текстовым редактором и нажмите <strong>Commit changes</strong>.</li></ol><p>После этого ваш коммит отправляется в ветку из PR (скорее всего, в копию репозитория автора), и теперь отображается в PR, а ваши изменения отражаются на вкладке <strong>Files changed</strong>. Оставьте комментарий, чтобы автор PR знал, что вы что-то сделали в PR.</p><p>Если автор использует командную строку, а не сайт GitHub для работы с этим PR, он должен получить изменения со своей копии репозитория и перебазировать свою локальную ветку на ветку своей копии, прежде чем заниматься своим PR.</p><h4 id=если-файл-ещё-не-был-изменён-в-pr>Если файл ещё не был изменён в PR</h4><p>Если необходимо внести изменения в файл, который не был отредактирован в рамках конкретного PR, нужно использовать командную строку. Вам придётся по душе такой метод, если вы предпочитаете использовать терминал вместо использования сайта GitHub.</p><ol><li><p>Узнайте URL-адрес копии репозитория автора пулреквеста. Вы можете найти его в нижней части вкладки <strong>Conversation</strong>. Найдите текст <strong>Add more commits by pushing to</strong>. Первая ссылка после этой надписи ведет на ветку, а вторая ссылка — на саму копию репозитория. Скопируйте вторую ссылку. Запомните название ветки, пригодится впоследствии.</p></li><li><p>Добавьте копию репозитория как новый удаленный репозиторий. В терминале перейдите в директорию своей копии репозитория. Придумайте имя для удаленного репозитория (например, по имени логина автора на GitHub) и добавьте его, используя следующую команду:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git remote add &lt;name&gt; &lt;url-of-fork&gt;
</span></span></code></pre></div></li><li><p>Получите информацию о добавленном удаленном репозитории. Это действие не затронет локальные файлы, а только загрузит в вашу копии репозитория информацию о другой копии (например, ветки и теги).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git remote fetch &lt;name&gt;
</span></span></code></pre></div></li><li><p>Перейдите в ветку, полученную с удаленного репозитория. Эта команда не получится, если у вас локально уже есть ветка с таким же именем.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout &lt;branch-from-PR&gt;
</span></span></code></pre></div></li><li><p>Внесите изменения и добавьте их через <code>git add</code>, а затем зафиксируйте их.</p></li><li><p>Отправьте изменения в удаленный репозиторий автора.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git push &lt;remote-name&gt; &lt;branch-name&gt;
</span></span></code></pre></div></li><li><p>Откройте снова сайт GitHub и обновите страницу PR. Вы увидите ваши изменения. Добавьте комментарий для автора, чтобы он был в курсе, что вы изменили его PR.</p></li></ol><p>Если автор использует командную строку, а не интерфейс на GitHub для работы над PR, ему нужно получить новые изменения из своей копии репозитоии и перебазировать свою локальную ветку на ветку своей копии репозитории, прежде чем снова заниматься собственным PR.</p><h2 id=работа-из-локальной-копии>Работа из локальной копии</h2><p>В случае изменений нескольких файлов, либо добавлением новых или перемещением старых, лучше работать из локальной копии Git-репозитория на компьютере, нежели чем использовать для этого GitHub. Следующие инструкции используют командую утилиту <code>git</code>, которая предполагается, что она уже установлена на вашем компьютере. Вы можете воспользоваться ими даже, если пользуетесь графическим Git-клиента.</p><h3 id=клонирование-репозитория>Клонирование репозитория</h3><p>Вам нужно только один раз клонировать репозиторий на каждом компьютере, на котором вы работаете с документацией Kubernetes.</p><ol><li><p>Создайте копию репозитория <code>kubernetes/website</code> на GitHub. В браузере перейдите по <a href=https://github.com/kubernetes/website>https://github.com/kubernetes/website</a> и нажмите на кнопку <strong>Fork</strong>. После нескольких секунд вы будете автоматически перенаправлены на URL-адрес вашей копии, которая будет иметь следующий вид: <code>https://github.com/&lt;github_username>/website</code>.</p></li><li><p>В окне термина используйте команду <code>git clone</code> для получения копии репозитория.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone git@github.com/&lt;github_username&gt;/website
</span></span></code></pre></div><p>После выполнения этой команды в текущей рабочей директории появится новая директория <code>website</code> с содержимым вашего репозитория на GitHub. В данном случае удаленный репозиторий <code>origin</code> будет ссылаться на вашу копию репозитория.</p></li><li><p>Перейдите в новую директорию <code>website</code>. Добавьте новый удалённый репозиторий <code>kubernetes/website</code> под именем <code>upstream</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>cd</span> website
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>git remote add upstream https://github.com/kubernetes/website.git
</span></span></code></pre></div></li><li><p>Проверьте ваши репозитории <code>origin</code> и <code>upstream</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git remote -v
</span></span></code></pre></div><p>Output is similar to:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>origin	git@github.com:&lt;github_username&gt;/website.git <span style=color:#666>(</span>fetch<span style=color:#666>)</span>
</span></span><span style=display:flex><span>origin	git@github.com:&lt;github_username&gt;/website.git <span style=color:#666>(</span>push<span style=color:#666>)</span>
</span></span><span style=display:flex><span>upstream	https://github.com/kubernetes/website.git <span style=color:#666>(</span>fetch<span style=color:#666>)</span>
</span></span><span style=display:flex><span>upstream	https://github.com/kubernetes/website.git <span style=color:#666>(</span>push<span style=color:#666>)</span>
</span></span></code></pre></div></li></ol><h3 id=работа-в-локальном-репозитории>Работа в локальном репозитории</h3><p>Прежде чем начать работать в локальном репозитории, вам нужно выяснить, из какой ветки будет основываться ваша работа. Ответ на этот вопрос зависит от того, что хотите сделать, но можно руководствоваться следующими правилами:</p><ul><li>Для общих улучшений существующего контента создайте собственную ветку от ветки <code>master</code>.</li><li>Для добавления нового контента про функциональность, которая уже есть в текущих версиях Kubernetes, начните с ветки <code>master</code>.</li><li>В случае большой и длительной работы, над которой будут трудиться несколько участников SIG Docs, например, реорганизация контента, создайте отдельную ветку, специально предназначенной для этого.</li><li>Для нового контента про будущие, но ещё не выпущенные версии Kubernetes, работайте в ветке предварительного выпуска, созданной специально для этой версии Kubernetes.</li></ul><p>Для получения дополнительной информации обратитесь к разделу <a href=/ru/docs/contribute/start/#%D0%B2%D1%8B%D0%B1%D0%BE%D1%80-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%B2%D0%B5%D1%82%D0%BA%D0%B8-%D0%B2-git>Выбор правильной ветки</a>.</p><p>После того, как вы определили, с какой ветви начать свою работу (или на какой ветке будет <em>базироваться</em> ваша работа, если говорить в терминологии Git), следуйте определённому ниже рабочему процессу, чтобы ваша работа оставалась актуальной.</p><ol><li><p>Когда вы работаете локально, есть три разные копии репозитория: <code>local</code>, <code>upstream</code> и <code>origin</code>. Получите данные по удалённым репозиториям <code>origin</code> и <code>upstream</code>. Эта команда очистит кеш удаленных репозиториях без фактического изменения каких-либо из копии.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git fetch origin
</span></span><span style=display:flex><span>git fetch upstream
</span></span></code></pre></div><p>Этот рабочий процесс отличается от того, который определен в <a href=https://github.com/kubernetes/community/blob/master/contributors/guide/github-workflow.md>сообществе GitHub</a>. Здесь вам не нужно объединять вашу локальную копию <code>master</code> из репозитория <code>upstream/master</code>, прежде чем отправлять изменения в вашу копию. Этот шаг не требуется в <code>kubernetes/website</code>, потому что ваша ветка базируется на репозитории upstream.</p></li><li><p>Создайте локальную рабочую ветку из наиболее подходящей ветки upstream-репозитория: <code>upstream/dev-1.xx</code> для разработчиков в конкретных версиях или <code>upstream/master</code> для всех остальных участников. В этом примере предполагается, что вы будете работать с ветки <code>upstream/master</code>. Так как ваша локальная ветка <code>master</code> не настроена для отслеживания изменений с <code>upstream/master</code> на предыдущем шаге, поэтому вам нужно явно создать свою ветку от <code>upstream/master</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git checkout -b &lt;my_new_branch&gt; upstream/master
</span></span></code></pre></div></li><li><p>После переключения на новую ветку можно начать в ней работать в текстовом редакторе. Используйте команду <code>git status</code> , чтобы посмотреть измененные файлы.</p></li><li><p>Когда вы закончите работу, зафиксируйте изменения. Сначала выполните команду <code>git status</code>, чтобы увидеть, какие изменения будут добавлены в коммит. В выводе этой команды есть две важные секции: <code>Changes staged for commit</code> и <code>Changes not staged for commit</code>. Файлы в последней секции, рядом с которыми есть надпись <code>modified</code> или <code>untracked</code>, необходимо добавить, если вы хотите, чтобы они попали в коммит. Для каждого файла, который нужно добавить, используйте команду <code>git add</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git add example-file.md
</span></span></code></pre></div><p>Когда все изменённые файлы добавлены, зафиксируйте их с помощью команды <code>git commit</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git commit -m <span style=color:#b44>&#34;Your commit message&#34;</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> В сообщении коммита не указывайте идентификатор или URL-адрес ишью или пулреквеста на GitHub. Если вы это сделаете, на странице ишью или пулреквеста будет показана информация о коммите всякий раз, когда коммит будет появляться в новой Git-ветке. Вы можете сослаться на ишью и пулреквесты позже на сайте GitHub.</div></li><li><p>При желании вы можете посмотреть, как ваши изменения будут выглядеть на сайте, если запустите сайт на вашей машине с помощью команды <code>hugo</code>. Посмотрите раздел <a href=#%D0%BF%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE>Просмотр ваших изменений локально</a>. Кроме этого, вы увидите свои изменения после создания пулреквеста.</p></li><li><p>Перед тем, как открывать пулреквест с вашими изменениями вам для начала отправить в ветку удаленного репозитория, чем в данном случае является <code>origin</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git push origin &lt;my_new_branch&gt;
</span></span></code></pre></div><p>Технически вы можете не указать имя ветки в команде <code>push</code>, но корректное выполнение команды в таком случае зависит от используемой версии Git. Результаты будут более ожидаемыми, если вы напишите название ветки.</p></li><li><p>Перейдите по адресу <a href=https://github.com/kubernetes/website>https://github.com/kubernetes/website</a> в вашем браузере. GitHub определит и укажет вам, что вы загрузили новую ветку в свою копию, и поэтому предложит создать пулреквест. Заполните шаблон запроса.</p><ul><li>Название должно быть не длиннее 50 символов и отражать краткий итог изменений.</li><li>Подробное описание должно содержать больше информации про исправление, включая строку типа <code>Fixes #12345</code>, если пулреквест решает проблему на GitHub. Это приведет к автоматическому закрытию указанной ишью после принятия пулреквеста.</li><li>Вы можете добавить метки или другие метаданные и назначить рецензентов. Смотрите страницу <a href=#%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F-%D0%B8%D1%88%D1%8C%D1%8E>Сортировка и классификация ишью</a>.</li></ul><p>Нажмите на кнопку <strong>Create pull request</strong>.</p></li><li><p>Начнут выполняться автоматические тесты в зависимости от состояния сайта с вашими изменениями. Если какой-либо из тестов завершился неудачно, нажмите на ссылку <strong>Details</strong> для получения дополнительной информации. Если тест Netlify прошёл успешно, по ссылке <strong>Details</strong> вы можете найти предварительную версию сайта Kubernetes с внесенными вашими изменениями. Именно на ней рецензенты будут проверять ваши изменения.</p></li><li><p>Если вам необходимо что-то дополнить, изменить пулреквест в соответствии с выполненной проверкой, либо изменить текст коммита, вы можете использовать команду ниже.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git commit -a --amend
</span></span></code></pre></div><ul><li><code>-a</code>: зафиксировать все изменения</li><li><code>--amend</code>: изменить предыдущий коммит вместо создания нового</li></ul><p>Откроется текстовый редактор, чтобы вы могли отредактировать сообщение коммита, если это нужно.</p><p>Если вы используете <code>git commit -m</code>, как в шаге 4, вы сделаете новый коммит, а не измените исходный (предыдущий) коммит. Создание нового коммита означает, что вам нужно объединить свои коммиты до того, прежде чем пулреквест может быть объединен.</p><p>Следуйте инструкциям в шаге 6, чтобы отправить новый коммит в удаленный репозиторий. После этого новое изменение отобразится в пулреквесте, а дальше снова запустятся тесты, а также произойдет новая сборка предварительной версии сайта на Netlify с последними изменениями.</p></li><li><p>Если рецензент изменяет файлы в вашем пулреквесте, вам нужно получить новые изменения в вашей локальной копии, до того как снова начать что-то делать. Используйте команды ниже, чтобы обновить свою ветку (предполагается, что ветка уже получена с вашей копии репозитория).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git fetch origin
</span></span><span style=display:flex><span>git rebase origin/&lt;your-branch-name&gt;
</span></span></code></pre></div><p>После перебазирования вам нужно добавить флаг <code>--force-with-lease</code>, чтобы принудительно отправить новые изменения в ветке на вашу копию.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git push --force-with-lease origin &lt;your-branch-name&gt;
</span></span></code></pre></div></li><li><p>Может возникнуть конфликт, если кто-то, как и вы, изменил те же части файла в ветке, из которой была создана ваша ветка. Если пулреквест показывает, что есть конфликты, которые нужно разрешить, вы можете сделать это либо на сайте GitHub, либо исправить их локально.</p><p>Сначала выполните шаг 10, чтобы актуализировать локальную ветку в соответствии с веткой в удаленном репозитории.</p><p>Затем обновите репозиторий <code>upstream</code> и перебазируйте вашу ветку на ту, с которой она была создана, в данном случае это <code>upstream/master</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git fetch upstream
</span></span><span style=display:flex><span>git rebase upstream/master
</span></span></code></pre></div><p>Если есть конфликты, которые Git не может разрешить автоматически, вы можете увидеть конфликтующие файлы с помощью команды <code>git status</code>. Отредактируйте каждый конфликтующий файл: найдите в них маркеры конфликта <code>>>></code>, <code>&lt;&lt;&lt;</code> и <code>===</code>. Разрешение конфликта происходит путём удаления указанных маркеров конфликта. После это нужно добавить измененные файлы с помощью команды <code>git add &lt;filename></code> и продолжить перебазирование ветки, используя команду <code>git rebase --continue</code>. Когда всё зафиксировано в репозитории и не осталось неразрешенных конфликтов, команда <code>git status</code> покажет, что вы вышли из состояния перебазирования ветки и нет изменений для фиксации. На этом этапе вам осталось принудительно отправить ветку в свою копию репозитория, после чего на странице пулреквеста не должны быть конфликты.</p></li><li><p>Если у вашего PR отображаются несколько сделанных коммитов после редактирования предыдущих коммитов, вам следует объединить эти несколько коммитов в один коммит, чтобы PR мог быть объединен. Проверить количество коммитов можно на вкладке <code>Commits</code> на странице PR или выполнив <code>git log</code> в терминале. Объединение коммитов (Squashing commits) — это одна из форм перебазирования.</p></li></ol><pre><code>```bash
git rebase -i HEAD~&lt;number_of_commits&gt;
```

Ключ `-i` сообщает git, что вы хотите сделать перебазирование в интерактивном режиме. В этом режиме вы сможете выбрать для git, какие коммиты нужно объединить в один. Например, в вашей ветке есть 3 коммита:

```
12345 commit 4 (2 minutes ago)
6789d commit 3 (30 minutes ago)
456df commit 2 (1 day ago)
```

Вам нужно объединить свои последние три коммита в один-единственный.

```
git rebase -i HEAD~3
```

Эта команда откроет редактор с таким содержимым:

```
pick 456df commit 2
pick 6789d commit 3
pick 12345 commit 4
```

Измените `pick` на `squash` у тех коммитов, которые вы хотите объединить, и проверьте, что коммит с выбранным `pick` находится сверху.

```
pick 456df commit 2
squash 6789d commit 3
squash 12345 commit 4
```

Сохраните и закройте редактор. Затем отправьте объединённый коммит в репозитории с помощью команды `git push --force-with-lease origin &lt;branch_name&gt;`.
</code></pre><p>Если у вас возникли проблемы с разрешением конфликтов или вы долго не можете что-то разрешить, что связано с вашим пулреквестом, обратитесь за помощью в Slack-канал <code>#sig-docs</code> или в <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs>список рассылки kubernetes-sig-docs</a>.</p><h3 id=просмотр-изменений-локально>Просмотр изменений локально</h3><ul class="nav nav-tabs" id=tab-with-hugo role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-with-hugo-0 role=tab aria-controls=tab-with-hugo-0 aria-selected=true>Hugo в контейнере</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-hugo-1 role=tab aria-controls=tab-with-hugo-1>Hugo на локальном компьютере</a></li></ul><div class=tab-content id=tab-with-hugo><div id=tab-with-hugo-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-with-hugo-0><p><p>Если вы ещё не готовы создать пулреквесты, но при этом хотите посмотреть, как будет выглядеть сайт с вашими изменениями, то можете собрать и запустить образ Docker, чтобы сгенерировать всю документацию и открыть ее на своем компьютере.</p><ol><li><p>Соберите образ локально:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>make docker-image
</span></span></code></pre></div></li><li><p>После того. как образ <code>kubernetes-hugo</code> собран, вы можете использовать его для запуска сайта:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>make docker-serve
</span></span></code></pre></div></li><li><p>В адресной строке браузера введите вставьте адрес <code>localhost:1313</code>. Hugo будет следить за изменениями файловой системы и пересобирать сайт по мере необходимости.</p></li><li><p>Чтобы остановить локальный сайт Hugo, откройте снова терминал и введите <code>Ctrl+C</code> или просто закройте окно с терминалом.</p></li></ol></div><div id=tab-with-hugo-1 class=tab-pane role=tabpanel aria-labelledby=tab-with-hugo-1><p><ol><li><p>Установите версию <a href=https://gohugo.io/getting-started/installing/>Hugo</a>, которая указана в файле <a href=https://raw.githubusercontent.com/kubernetes/website/master/netlify.toml><code>website/netlify.toml</code></a>.</p></li><li><p>В терминале перейдите в корневую директорию вашей копии документации Kubernetes и введите следующую команду:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>hugo server
</span></span></code></pre></div></li><li><p>В адресной строке браузера скопируйте <code>localhost:1313</code>.</p></li><li><p>Чтобы остановить локальный сайт Hugo, откройте снова терминал и введите <code>Ctrl+C</code> или просто закройте окно с терминалом.</p></li></ol></div></div><h2 id=сортировка-и-классификация-ишью>Сортировка и классификация ишью</h2><p>Люди в SIG Docs отвечают только за сортировку и классификацию ишью, связанных с документацией. Вопросы и проблемы общего характера также хранятся в репозитории <code>kubernetes/website</code>.</p><p>Что вы делаете, когда сортируете ишью:</p><ul><li>Проверить ишью<ul><li>Убедитесь, что ишью связана с документацией сайта. Некоторые заявки можно быстро закрыть, ответив на вопрос или указав автору на ресурс. Подробности смотрите в разделе <a href=#%D0%B7%D0%B0%D1%8F%D0%B2%D0%BA%D0%B8-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-%D0%B8%D0%BB%D0%B8-%D0%BE%D1%82%D1%87%D1%91%D1%82%D1%8B-%D0%BE%D0%B1-%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B5-%D0%B2-%D0%BA%D0%BE%D0%B4%D0%B5>Заявки с помощью или отчёты об ошибке в коде</a>.</li><li>Рассмотрите, насколько обоснованной является заявка. Добавьте метку <code>triage/needs-information</code>, если в ишью описано мало подробностей, чтобы ее можно было начать решать, либо если шаблон был неправильно заполнен.
Закройте заявку, если она имеет метки <code>lifecycle/stale</code> и <code>triage/needs-information</code>.</li></ul></li><li>Добавьте метку с приоритетом (см. <a href=https://github.com/kubernetes/community/blob/master/contributors/guide/issue-triage.md#define-priority>руководство по сортировке заявок</a>, где подробно определены метки)<ul><li><code>priority/critical-urgent</code> - заниматься нужно прямо сейчас</li><li><code>priority/important-soon</code> - нужно выполнить в течение 3 months</li><li><code>priority/important-longterm</code> - нужно сделать в течение 6 months</li><li><code>priority/backlog</code> - решение можно быть отложено на неопределенный срок indefinitely; самый низкий приоритет; делать, когда будут свободны ресурсы</li><li><code>priority/awaiting-more-evidence</code> - указание, что это возможно хорошая задача, которую нужно иметь на виду</li></ul></li><li>Дополнительно вы можете добавить метку <code>help</code> или <code>good first issue</code>, если определенная заявка может быть решена человеком, мало знакомым с Kubernetes или SIG Docs. В качестве руководства обратитесь к файлу <a href=https://github.com/kubernetes/community/blob/master/contributors/guide/help-wanted.md>Help Wanted and Good First Issue Labels</a>.</li><li>При желании примите сами участие в ишью и отправьте PR для ее решения (в частности если она может быстро разрешена или вы ранее выполняли нечто подобное).</li></ul><p>С помощью <a href="https://github.com/kubernetes/website/issues?q=is%3Aissue+is%3Aopen+-label%3Apriority%2Fbacklog+-label%3Apriority%2Fimportant-longterm+-label%3Apriority%2Fimportant-soon+-label%3Atriage%2Fneeds-information+-label%3Atriage%2Fsupport+sort%3Acreated-asc">этого фильтра</a> можно найти заявки, которые необходимо отсортировать.</p><p>Если у вас есть вопросы о про сортировку, спросите в Slack-канале <code>#sig-docs</code> или в <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs>списке рассылки kubernetes-sig-docs</a>.</p><h3 id=добавление-и-удаление-меток>Добавление и удаление меток</h3><p>Для добавления метки нужен комментарий, содержащий что-то вроде <code>/&lt;label-to-add></code> или <code>/&lt;label-category> &lt;label-to-add></code>. Метка уже должна быть создана в репозитории. Если вы попытаетесь добавить несуществующую метку, команда проигнорируется.</p><p>Примеры:</p><ul><li><code>/triage needs-information</code></li><li><code>/priority important-soon</code></li><li><code>/language ja</code></li><li><code>/help</code></li><li><code>/good-first-issue</code></li><li><code>/lifecycle frozen</code></li></ul><p>Для удаления метки нужен комментарий с <code>/remove-&lt;label-to-remove></code> или <code>/remove-&lt;label-category> &lt;label-to-remove></code>.</p><p>Примеры:</p><ul><li><code>/remove-triage needs-information</code></li><li><code>/remove-priority important-soon</code></li><li><code>/remove-language ja</code></li><li><code>/remove-help</code></li><li><code>/remove-good-first-issue</code></li><li><code>/remove-lifecycle frozen</code></li></ul><p>Список всех меток, используемых в Kubernetes, находится <a href=https://github.com/kubernetes/kubernetes/labels>здесь</a>. Не все метки используются группой SIG Docs.</p><h3 id=дополнительные-сведения-о-метках>Дополнительные сведения о метках</h3><ul><li>Ишью может иметь несколько ярлыков.</li><li>Некоторые метки в своём имени содержат слеш для группировки, это своего рода "подметки". Например, существует множество меток <code>sig/</code>, например, <code>sig/cli</code> и <code>sig/api-machinery</code> (<a href="https://github.com/kubernetes/website/labels?utf8=%E2%9C%93&q=sig%2F">полный список</a>).</li><li>Некоторые метки добавляются автоматически, в зависимости от метаданных файлов из ишью, либо от используемых в комментариях команд со слешем, а также от указанной информации в описании.</li><li>Новые метки могут добавляться вручную человеком, который сортировкой ишью (либо тем, кто создает ишью).<ul><li><code>kind/bug</code>, <code>kind/feature</code> и <code>kind/documentation</code>: баг (bug) — это проблема в текущем контенте или в функциональности, а возможность (feature) — запрос на добавление нового контента или функциональности.
Метка <code>kind/documentation</code> используется редко.</li><li>Метки <code>language/ja</code>, <code>language/ko</code> и похожие <a href="https://github.com/kubernetes/website/labels?utf8=%E2%9C%93&q=language">языковые метки</a> добавляются, если ишью относится к локализованному контенту.</li></ul></li></ul><h3 id=жизненный-цикл-ишью>Жизненный цикл ишью</h3><p>Ишью обычно открываются и закрываются в течение относительно короткого промежутка времени. Однако иногда решение заявки после ее создания может и не быть. Иногда ишью может оставаться открытой гораздо дольше, чем 90 дней.</p><p><code>lifecycle/stale</code>: после 90 дней бездействия ишью автоматически помечается как устаревшая (stale). Такая заявка будет автоматически закрыта, если эта метка не будет удалена с помощью команды <code>/remove-lifecycle stale</code>.</p><p><code>lifecycle/frozen</code>: заявка с данной меткой не будет считаться устаревшей после 90 дней отсутствия активности. Пользователь вручную добавляет эту метку к заявкам, которые должны оставаться открытыми значительно дольше 90 дней, например, у ишью с меткой <code>priority/important-longterm</code>.</p><h3 id=обработка-специальных-типов-ишью>Обработка специальных типов ишью</h3><p>Мы встречаем перечисленные ниже типы заявкой достаточно часто, поэтому расписали, как их обрабатывать.</p><h4 id=дублирование-заявок>Дублирование заявок</h4><p>Если для какой-нибудь проблемы есть одна или несколько открытых заявок, решение этой проблемы должно быть вынесено в одну заявку. Вам нужно решить, какую заявку оставить открытой (либо вовсе открыть новую ишью), перенести всю соответствующую информацию и указать связанные заявки. Затем для всех остальных похожих заявок добавьте метку с <code>triage/duplicate</code> и закройте их. Наличие только одной-единственной заявки поможет уменьшить путаницу и избежать дублирования работы над одной и той же проблемой.</p><h4 id=заявки-про-неработающие-ссылки>Заявки про неработающие ссылки</h4><p>В зависимости от того, где сообщается о неработающей ссылке, для решения этой проблемы требуются различные действия. Неработающие ссылки в API и документации Kubectl — это заявки, связанные с автоматизацией и поэтому их нужно отмечать меткой <code>/priority critical-urgent</code>, пока проблема не будет полностью проанализирована. Все остальные неработающие ссылки — это ишью, которым нужно заниматься вручную, поэтому им нужно добавить метку <code>/priority important-longterm</code>.</p><h4 id=заявки-связанные-с-блогом>Заявки, связанные с блогом</h4><p>Записи в <a href=https://kubernetes.io/blog/>блоге Kubernetes</a> будут терять актуальность со временем, поэтому мы поддерживаем записи, опубликованные в течение года. Если заявка сообщает о проблеме в записи блога, которой более одного года, ее следует закрыть без какого-либо исправления.</p><h4 id=заявки-с-помощью-или-отчёты-об-ошибке-в-коде>Заявки с помощью или отчёты об ошибке в коде</h4><p>Некоторые открытые заявки — это проблемы с основным кодом или просьбы с помощью, когда что-то (например, учебное руководство) не работает. Для заявок, не имеющих отношение к документации, закройте её, проставив метку <code>kind/support</code> и добавив комментарий с ресурсами, где можно найти помощь (Slack, Stack Overflow) и при необходимости укажите, где нужно открыть заявку, чтобы сообщить об ошибке в функциональности (вероятно, репозиторий kubernetes/kubernetes отлично подойдет для этого).</p><p>Пример ответа на запрос о помощи:</p><pre tabindex=0><code class=language-none data-lang=none>This issue sounds more like a request for support and less
like an issue specifically for docs. I encourage you to bring
your question to the `#kubernetes-users` channel in
[Kubernetes slack](http://slack.k8s.io/). You can also search
resources like
[Stack Overflow](http://stackoverflow.com/questions/tagged/kubernetes)
for answers to similar questions.

You can also open issues for Kubernetes functionality in
 https://github.com/kubernetes/kubernetes.

If this is a documentation issue, please re-open this issue.
</code></pre><p>Пример ответа на сообщение об ошибке в коде:</p><pre tabindex=0><code class=language-none data-lang=none>This sounds more like an issue with the code than an issue with
the documentation. Please open an issue at
https://github.com/kubernetes/kubernetes/issues.

If this is a documentation issue, please re-open this issue.
</code></pre><h2 id=добавление-документации-для-новой-функциональности>Добавление документации для новой функциональности</h2><p>Каждый мажорный выпуск Kubernetes несет в себе новую функциональность, для большей части из которой нужно написать хоть краткую документацию, чтобы показать людям, как её использовать.</p><p>Зачастую SIG-группа, ответственная за новую функциональность, представляют черновик документацию в виде пулреквеста в соответствующую ветку выпуска в репозитории <code>kubernetes/website</code>, а кто-то из команды SIG Docs могут сделать вычитку или отредактировать черновик напрямую.</p><h3 id=поиск-информации-о-новой-функциональности>Поиск информации о новой функциональности</h3><p>Чтобы узнать о будущей функциональности, посетите еженедельную встречу sig-release (см. страницу <a href=https://kubernetes.io/community/>Сообщество</a>, чтобы быть в курсе предстоящих собраний) и отслеживайте документацию к новому релизу в репозитории <a href=https://github.com/kubernetes/sig-release/>kubernetes/sig-release</a>. Каждый выпуск имеет поддиректорию в директории <a href=https://github.com/kubernetes/sig-release/tree/master/releases>/sig-release/tree/master/releases/</a>. Каждая директорию содержит график выхода новой версии, черновик с примечаниями к выпуску, а также документ, в котором перечислена команда, занимающаяся новым выпуском.</p><ul><li><p>График выпуска содержит ссылки на все другие документы, встречи, протоколы собраний и этапы, связанные с выпуском. Он также содержит информацию о целях и сроках выпуска, а также о любых специальных процессах, используемых этом выпуске. В нижней части документа определены несколько терминов, связанных с выпуском.</p><p>Этот документ также содержит ссылку на <strong>лист отслеживания функциональности</strong> — это "официальный" способ узнать про новую функциональность, запланированной в выпуске.</p></li><li><p>В документе команды выпуска указано, кто какую роль занимает. Если непонятно, с кем можно поговорить об определенной функциональности или вы хотите что-то спросить, то либо посетите встречу по этому выпуску, чтобы задать свой вопрос, либо обратитесь к руководителю.</p></li><li><p>Черновик примечаний к выпуску — хорошая отправная точка, где можно узнать чуть больше о конкретной функциональности, изменениях, устаревших возможностях и в целом что-то ещё о выпуске. Содержимое может обновляться до конца цикла выпуска, поэтому будьте начеку.</p></li></ul><h4 id=лист-отслеживания-функциональности>Лист отслеживания функциональности</h4><p>В списке отслеживания функциональности <a href=https://github.com/kubernetes/sig-release/tree/master/releases>для данного выпуска Kubernetes</a> перечислена вся функциональность, запланированная для выпуска. Каждая строка содержит название возможности, ссылку на основную заявку GitHub, уровень стабильности (Alpha, Beta или Stable), группу SIG и ответственного лица за её реализацию, информацию про документацию, черновик примечания для выпуска, а также указание, была ли функциональность уже принята. Имейте в виду следующее:</p><ul><li>Функциональность в состоянии Beta и Stable обычно имеет более высокий приоритет по сравнению с версией Alpha.</li><li>Трудно протестировать (и, следовательно, написать документацию) функциональности, которая не ещё принята или,по крайней мере, считается полнофункциональной в своем PR.</li><li>Определение, нужна ли документировать функциональности, производится вручную, и даже если у функциональности нет метки, что ей нужна документация, это не означает, это действительно так.</li></ul><h3 id=документирование-функциональности>Документирование функциональности</h3><p>Как отмечалось выше, черновик документации для новой функциональности обычно предлагается SIG-группой, ответственной за реализацию новой функциональности. Это означает, вы в данном случае будете больше наблюдающим (куратором) в данной функциональности, нежели чем полноценным автором документации для неё.</p><p>После того, как вы выбрали функциональность для документирования/наблюдения, заявите об этом в Slack-канале <code>#sig-docs</code>, на еженедельной встрече sig-docs или напрямую в PR, отправленном SIG. Если вам дали добро, вы можете редактировать PR, используя один из способов, указанных в разделе <a href=#%D1%80%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-PR-%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%B3%D0%BE-%D1%87%D0%B5%D0%BB%D0%BE%D0%B2%D0%B5%D0%BA%D0%B0>Редактирование PR другого человека</a>.</p><p>Если вам нужно написать новую тему, полезны следующие ссылки:</p><ul><li><a href=/docs/contribute/style/write-new-topic/>Написание новых тем</a></li><li><a href=/docs/contribute/style/page-templates/>Использование шаблонов страниц</a></li><li><a href=/docs/contribute/style/style-guide/>Руководство по оформлению документации</a></li><li><a href=/docs/contribute/style/content-guide/>Руководство по содержанию документации</a></li></ul><h3 id=члены-sig-участвующие-в-документировании-новой-функциональности>Члены SIG, участвующие в документировании новой функциональности</h3><p>Если вы участник SIG-группы, кто разрабатывает новую функциональность для Kubernetes, вам нужно работать с документацией SIG, чтобы убедиться, что на момент новой версии написана документация для этой функциональности. Проверьте <a href=https://github.com/kubernetes/sig-release/tree/master/releases>электронную таблицу с отслеживанием функциональности</a> или присоединитесь в Slack-канал #sig-release, чтобы узнать информацию о сроках выхода. Некоторые крайние сроки касательно документации:</p><ul><li><strong>Docs deadline - Open placeholder PRs</strong>: откройте пулреквест в ветку <code>release-X.Y</code> в репозитории <code>kubernetes/website</code> с небольшим коммитом, который вы позже измените. Используйте команду Prow <code>/milestone X.Y</code>, чтобы назначить PR соответствующему этапу. Это уведомляет человека, который занимается документацией и ответственный за этот выпуск, что выходит документация для новой функциональности. Если функциональность не нуждается в каких-либо изменениях документации, убедитесь, что команда sig-release знает об этом, написав им сообщение в Slack-канале #sig-release. Если для функциональности нужна документация, но PR для этого ещё не создан, функциональность может быть удалена из этапа.</li><li><strong>Docs deadline - PRs ready for review</strong>: теперь ваш PR должен содержать первый черновик документации для вашей функциональности. Не беспокойтесь о форматировании или всяких улучшениях. Просто опишите, что делает эта функциональность и как ее использовать. Участник из группы документации, управляющий выпуском новой версии, будет работать вместе с вами, чтобы подготовить контент для публикации. Если вашей функциональности нужна документация и первого черновика с документацией до сих пор нет, эта функциональность может быть удалена из этапа.</li><li><strong>Docs complete - All PRs reviewed and ready to merge</strong>: если ваш PR еще не был объединен в ветку <code>release-X.Y</code> к заданному крайнему сроку, обратитесь за помощью к человеку, ответственному за выпуск новой версии. Если вашей функциональности требуется документация, но она ещё не сделана, функциональность может быть удалена из этапа.</li></ul><p>Если ваша функциональность находится в альфа-версии и ее не нельзя отключить, убедитесь, что вы добавили ее к <a href=/docs/reference/command-line-tools-reference/feature-gates/>переключателем возможностей</a> в вашем пулреквесте. Если ваша функциональность переходит из альфа-версии, обязательно удалите ее из этого файла.</p><h2 id=участие-к-других-репозиториях>Участие к других репозиториях</h2><p>В <a href=https://github.com/kubernetes>проекте Kubernetes</a> более 50 самостоятельных репозиториев. Многие из этих репозиториев хранят код или контент, который можно рассматривать как документацию, например, справочный текст для пользователях, сообщения об ошибках, пользовательский текст в справочниках API или даже комментарии кода.</p><p>Если вы видите текст и не знаете, откуда он берётся, вы можете использовать поиск GitHub по репозиториям организации Kubernetes, чтобы выяснить, где встречается этот текст. Это поможет вам определиться с тем, куда создать заявку или PR.</p><p>У каждого репозитория могут быть определены собственные процессы и правила. До того как открыть проблему или отправить PR, изучите файлы <code>README.md</code>, <code>CONTRIBUTING.md</code> и <code>code-of-conduct.md</code> в репозитории, если они есть.</p><p>Большинство репозиториев используют шаблоны для заявок и PR. Просмотрите некоторые открытые заявки и PR, чтобы понять, как устроена работа. Обязательно как можно более подробно заполните шаблоны при открытии заявок или PR.</p><h2 id=локализация-контента>Локализация контента</h2><p>Английский является основным языком документации Kubernetes, однако мы хотим, чтобы у людей была возможность читать документацию на своём родном языке. Если вам комфортно писать на другом языке, особенно в теме программного обеспечения, вы можете помочь перевести документацию Kubernetes или помочь с существующим переводом. Посмотрите страницу <a href=/ru/docs/contribute/localization/>Локализация</a> и задайте вопрос в <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs>списке рассылки kubernetes-sig-docs</a> или в канале <code>#sig-docs</code> на Slack, если вы хотите помочь.</p><h3 id=работа-с-локализованным-контентом>Работа с локализованным контентом</h3><p>Старайтесь соблюдать эти рекомендации по работе с переведенным контентом:</p><ul><li><p>В PR должны быть изменения касающиеся только одного языка.</p><p>В каждом языке есть собственные рецензенты и утверждающие.</p></li><li><p>Рецензентам: убедитесь, что PR содержат изменения только на одном языке.</p><p>Если PR изменяет файлы на нескольких языках, попросите автора открыть отдельные PR для каждого языка.</p></li></ul><h2 id=что-дальше>Что дальше</h2><p>Если вы хорошо осознали все задачи, затронутые в этом разделе, и хотите более тесно работать с командой документации Kubernetes, переходите к изучению <a href=/ru/docs/contribute/advanced/>руководства для опытного участника</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-8111429863728051b460e1f3a75b6fea>7.3 - Существенный вклад</h1><p>На этой странице предполагается, что вы изучили темы <a href=/ru/docs/contribute/start/>Участие для начинающих</a> и <a href=/ru/docs/contribute/intermediate/>Участие для опытных</a> и теперь хотите узнать ещё больше про то, как можно помочь проекту. Для решения некоторых задач вам потребуется использовать Git из командной строки и прочие другие инструменты.</p><h2 id=дежурный-по-pr-на-неделю>Дежурный по PR на неделю</h2><p><a href=/ru/docs/contribute/participating/#%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5>Утверждающие</a> группы SIG Docs регулярно по очереди становятся дежурными по PR в репозитории и поэтому участвуют в <a href=https://github.com/kubernetes/website/wiki/PR-Wranglers#2019-schedule-q1q2>графике ротации PR-дежурного</a> на неделю.</p><p>В обязанности дежурного по PR входят:</p><ul><li>Ежедневно проверять <a href=https://github.com/kubernetes/website/pulls>открытые пулреквесты</a> для контроля качества и соблюдения рекомендаций по <a href=/docs/contribute/style/style-guide/>оформлению</a> и <a href=/docs/contribute/style/content-guide/>содержимому</a>.<ul><li>В первую очередь просматривайте самые маленькие пулреквесты (<code>size/XS</code>), и только потом беритесь за самые большие (<code>size/XXL</code>).</li><li>Проверяйте столько пулреквестов, сколько сможете.</li></ul></li><li>Проследите, что CLA подписан каждым участником.<ul><li>Помогайте новым участникам подписать <a href=https://github.com/kubernetes/community/blob/master/CLA.md>CLA</a>.</li><li>Используйте <a href=https://github.com/zparnold/k8s-docs-pr-botherer>этот</a> скрипт, чтобы автоматически напомнить участникам, не подписавшим CLA, подписать его.</li></ul></li><li>Оставить свое мнение о предложенных изменениях и поспособствовать в проведении технического обзора от членов других SIG-групп.<ul><li>Предложить исправления для измененного контента в PR.</li><li>Если вы хотите убедиться в правильности контента, прокомментируйте PR и задайте уточняющие вопросы.</li><li>Добавьте нужные метки с <code>sig/</code>.</li><li>Если нужно, то назначьте рецензентов из секции <code>reviewers:</code> в верхней части файла.</li><li>Добавьте метки <code>Docs Review</code> и <code>Tech Review</code> для установки статуса проверки PR.</li><li>Добавьте метку <code>Needs Doc Review</code> или <code>Needs Tech Review</code> для пулреквестов, которые ещё не были проверены.</li><li>Добавьте метку <code>Doc Review: Open Issues</code> или <code>Tech Review: Open Issues</code> для пулреквестов, которые были проверены и требуют дополнительную информацию и выполнение действия перед слиянием.</li><li>Добавьте метки <code>/lgtm</code> и <code>/approve</code> для пулреквестов, которые могут быть приняты.</li></ul></li><li>Объедините пулреквесты, если они готовы, либо закройте те, которые не могут быть приняты.</li><li>Ежедневно отсортируйте и пометьте новые заявки. Обратитесь к странице <a href=/ru/docs/contribute/intermediate/>Участие для опытных</a> для получения информации по использованию метаданных SIG Docs.</li></ul><h3 id=полезные-ссылки-на-github-для-дежурных>Полезные ссылки на GitHub для дежурных</h3><p>Следующие ссылки помогут при дежурстве. После обработки заявок по трём первым ссылкам, как правило, список пулреквестов для проверки сократится. По указанным ссылкам вы найдете PR только в английскую версию, предназначенные для слияния в ветку <code>master</code> (кроме последней ссылки).</p><ul><li><a href="https://github.com/kubernetes/website/pulls?q=is%3Aopen+is%3Apr+label%3A%22cncf-cla%3A+no%22+-label%3Ado-not-merge+label%3Alanguage%2Fen">Нет CLA, нет права на слияние</a>: напомните участнику подписать CLA. Если об этом уже напомнил и бот, и человек, то закройте PR и напишите автору, что он может открыть свой PR после подписания CLA.
<strong>Не проверяйте PR, если их авторы не подписали CLA!</strong></li><li><a href="https://github.com/kubernetes/website/pulls?utf8=%E2%9C%93&q=is%3Aopen+is%3Apr+-label%3Ado-not-merge+label%3Alanguage%2Fen+-label%3Algtm+">Требуется LGTM</a>: если нужна проверка с технической точки зрения, попросите её провести одного из рецензентов, которого предложил бот. Если требуется просмотр пулреквеста со стороны группы документации или вычитка, то предложите изменения, либо сами измените PR, чтобы ускорить процесс принятия пулреквеста.</li><li><a href="https://github.com/kubernetes/website/pulls?q=is%3Aopen+is%3Apr+-label%3Ado-not-merge+label%3Alanguage%2Fen+label%3Algtm">Имеет LGTM, нужно одобрение со стороны группы документации</a>: выясните, нужно ли внести какие-либо дополнительные изменения или обновления, чтобы принять PR. Если по вашему мнению PR готов к слиянию, оставьте комментарий с текстом <code>/approve</code>.</li><li><a href="https://github.com/kubernetes/website/pulls?utf8=%E2%9C%93&q=is%3Apr+is%3Aopen+base%3Amaster+-label%3A%22do-not-merge%2Fwork-in-progress%22+-label%3A%22do-not-merge%2Fhold%22+label%3A%22cncf-cla%3A+yes%22+label%3A%22size%2FXS%22+label%3A%22language%2Fen%22+">Быстрые результаты</a>: если маленький PR направлен в основную ветку и не имеет условий для объединения (поменяйте "XS" в метке с размером при работе с другими пулреквестами [XS, S, M, L, XL, XXL]).</li><li><a href="https://github.com/kubernetes/website/pulls?utf8=%E2%9C%93&q=is%3Aopen+is%3Apr+-label%3Ado-not-merge+label%3Alanguage%2Fen+-base%3Amaster">Вне основной ветки</a>: если PR отправлен в ветку <code>dev-</code>, значит он предназначается для будущего выпуска. Убедитесь, что <a href=https://github.com/kubernetes/sig-release/tree/master/release-team>release meister</a> знает об этом, добавив комментарий с <code>/assign @&lt;meister's_github-username></code>. Если он направлен в старую ветку, помогите автору PR изменить на более подходящую ветку.</li></ul><h3 id=когда-закрывать-пулреквесты>Когда закрывать пулреквесты</h3><p>Обзоры и одобрения — это только один из способов, позволяющих держать список PR коротким и актуальным. Закрытие пулреквестов — альтернативный метод для этого.</p><ul><li><p>Можете закрыть любой PR, если CLA-соглашение не было подписано в течение двух недель.
Авторы PR могут повторно открыть PR после подписания CLA, так что это безопасный способ убедиться, что ничто не будет объединено без подписанного CLA.</p></li><li><p>Закройте любой PR, если автор не отреагировал на комментарии или проверки в течение 2 или более недель.</p></li></ul><p>Не бойтесь закрывать пулреквесты. Участники с лёгкостью могут открыть и возобновить незаконченную работу. Зачастую уведомление о закрытии стимулирует автора возобновить и завершить свою работу до конца.</p><p>Чтобы закрыть пулреквест, оставьте комментарий <code>/close</code> в PR.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Бот <a href=https://github.com/k8s-ci-robot><code>k8s-ci-robot</code></a> автоматически помечает заявки как устаревшие после 90 дней отсутствия активности, а затем закрывает их после ещё 30 дней простоя, когда они становятся тухлыми. Дежурные по PR должны закрывать заявки после 14-30 дней бездействия.</div><h2 id=внесение-улучшений>Внесение улучшений</h2><p><a href=/ru/docs/contribute/participating/#%D1%87%D0%BB%D0%B5%D0%BD%D1%8B>Члены</a> SIG Docs могут предлагать улучшения.</p><p>Если вы давно начали работать над документацией Kubernetes, у вас наверняка появились какие-нибудь идеи по улучшению <a href=/docs/contribute/style/style-guide/>руководства по оформлению</a>, <a href=/docs/contribute/style/content-guide/>руководства по содержанию</a>, набору инструментов, который используется для создания документации, стилизации сайта, процессов проверки и объединения пулреквестов. Для максимальной открытости подобные типы предложений по улучшению должны обсуждаться на встречи SIG Docs или в <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs>списке рассылки kubernetes-sig-docs</a>.
Помимо этого, это поможет разъяснить, как всё устроено в данный момент, и объяснить, почему так было принято, прежде чем предлагать радикальные изменения. Самый быстрый способ узнать ответы на вопросы о том, как в настоящее время работает документация, это задать их в канале <code>#sig-docs</code> в <a href=https://kubernetes.slack.com>официальном Slack</a>.</p><p>Когда обсуждение состоялось, а SIG-группа согласилась с желаемым результатом, вы можете работать над предлагаемыми изменениями наиболее приемлемым способом. Например, обновление руководства по оформлению или функциональности сайта может включать открытие пулреквеста, а изменение, связанное с тестированием документации, может предполагать взаимодействие с sig-testing.</p><h2 id=координация-документации-по-выпуску-kubernetes>Координация документации по выпуску Kubernetes</h2><p><a href=/ru/docs/contribute/participating/#%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5>Утверждающие</a> SIG Docs могут координировать документацию для выпуска Kubernetes.</p><p>Каждый выпуск Kubernetes координируется командой людей, участвующих в специальной группе (Special Interest Group, SIG) sig-release. Другие члены команды в данном выпуске включают в себя общего руководителя выпуском, а также представителей sig-pm, sig-testing и др. Чтобы узнать больше о процессах выпуска версий Kubernetes, обратитесь к <a href=https://github.com/kubernetes/sig-release>https://github.com/kubernetes/sig-release</a>.</p><p>Представитель SIG Docs для данного выпуска координирует следующие задачи:</p><ul><li>Мониторинг электронной таблицы с отслеживанием функциональности на наличие новых или измененных возможностей, затрагивающих документацию. Если документация для определенной функциональности не будет готова к выпуску, возможно, она не попадет в выпуск.</li><li>Регулярное посещение встречи sig-release и обновление информации о статусе документации к выпуску.</li><li>Проверка и вычитка документации по функциональности, подготовленной SIG-группой, ответственной за реализацию этой функциональности.</li><li>Объединение связанных с выпуском пулреквестов и поддержка Git-ветки выпуска.</li><li>Консультирование других участников SIG Docs, которые хотят научиться выполнять эту роль в будущем. Это называется сопровождение (shadowing).</li><li>Публикация изменений в документации, связанные с выпуском при размещении артефактов.</li></ul><p>Координация выпуска обычно занимает 3-4 месяца, а обязанности распределяются между утверждающими SIG Docs.</p><h2 id=амбассадор-нового-участника>Амбассадор нового участника</h2><p><a href=/ru/docs/contribute/participating/#%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5>Утверждающие</a> SIG Docs могут выступать в качестве амбассадоров новых участников.</p><p>Амбассадоры новых участников работают бок о бок, чтобы поприветствовать новых участников SIG Docs, предлагать PR новым участникам и консультировать новых участников в их собственных PR.</p><p>Обязанности амбассадоров новых участников включают в себя:</p><ul><li>Отвечать на вопросы новых участников в <a href=https://kubernetes.slack.com>Slack-канале Kubernetes #sig-docs</a>.</li><li>Совместно работать с дежурным по PR, чтобы определять заявки, которые подойдут для решения новыми участниками.</li><li>Консультировать новых участников в их PR.</li><li>Помогать новым участникам в создании более сложных PR, чтобы они могли стать членами Kubernetes.</li><li><a href=/ru/docs/contribute/advanced/#%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0-%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D1%83%D1%87%D0%B0%D1%81%D1%82%D0%BD%D0%B8%D0%BA%D0%B0>Оказывать содействие участникам</a> на их пути становления членом в Kubernetes.</li></ul><p>Текущие амбассадоры новых участников объявляются на каждом собрании SIG Docs и на канале <a href=https://kubernetes.slack.com>#sig-docs в Kubernetes</a>.</p><h2 id=поддержка-нового-участника>Поддержка нового участника</h2><p><a href=/ru/docs/contribute/participating/#%D1%80%D0%B5%D1%86%D0%B5%D0%BD%D0%B7%D0%B5%D0%BD%D1%82%D1%8B>Рецензенты</a> SIG Docs могут содействовать новым участникам в членстве организации.</p><p>Если участник сделал 5 значительных пулреквестов в один или несколько репозиториев Kubernetes, он имеет право на <a href=/ru/docs/contribute/participating#%D1%87%D0%BB%D0%B5%D0%BD%D1%8B>членство</a> в организации Kubernetes. Членство участника должно быть поддержано двумя спонсорами, которые уже являются рецензентами.</p><p>Новые участники документации могут найти спонсоров в канале #sig-docs <a href=https://kubernetes.slack.com>в Slack Kubernetes</a> или в <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs>списке рассылки SIG Docs</a>. Если вы осознали полезность работы автора заявки на членство, вы добровольно можете поддержать (спонсировать) его. Когда они подадут заявку на членство, отреагируйте на заявку "+1" и напишите подробный комментарий о том, почему вы считаете, что кандидат отлично вписывается в члены организации Kubernetes.</p><h2 id=сопредседатель-sig>Сопредседатель SIG</h2><p><a href=/ru/docs/contribute/participating/#%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5>Утверждающие</a> SIG Docs могут быть сопредседателями SIG Docs.</p><h3 id=требования>Требования</h3><p>Сопредседатели должны соответствовать следующим требованиям:</p><ul><li>Быть утверждающими SIG Docs не меньше 6 месяцев.</li><li><a href=/docs/contribute/advanced/#coordinate-docs-for-a-kubernetes-release>Руководить выпуском документации Kubernetes</a> или сопроводить два выпуска.</li><li>Понимать рабочие процессы и инструменты SIG Docs: git, Hugo, локализация, блог.</li><li>Понимать, как другие SIG-группы и репозитории Kubernetes влияют на рабочий процесс SIG Docs, включая: <a href=https://github.com/kubernetes/org/blob/master/config/kubernetes/sig-docs/teams.yaml>команды в k/org</a>, <a href=https://github.com/kubernetes/community/tree/master/sig-docs>процессы в k/community</a>, плагины в <a href=https://github.com/kubernetes/test-infra/>k/test-infra</a> и роль <a href=https://github.com/kubernetes/community/tree/master/sig-architecture>SIG Architecture</a>.</li><li>Уделять не менее 5 часов в неделю (но зачастую больше) в течение как минимум 6 месяцев для выполнения обязанностей.</li></ul><h3 id=обязанности>Обязанности</h3><p>Роль сопредседателя посвящена в основном одной из задач: сопредседатели управляют процессом и политикой, планируют и проводят собрания, назначают дежурных по PR и, как правило, делают то, что никто больше не хочет делать, для увеличения количества участников.</p><p>Обязанности включают в себя:</p><ul><li>Сосредоточить группу SIG Docs на достижении максимального счастья для разработчиков через отличную документацию.</li><li>Быть примером соблюдения <a href=https://github.com/cncf/foundation/blob/master/code-of-conduct.md>норм поведения сообщества</a> и контролировать их выполнение членами SIG.</li><li>Изучать и внедрять передовые практики для SIG-группы, обновляя рекомендации по участию.</li><li>Планировать и проверять встречи SIG: еженедельные обновления информации, ежеквартальные ретроспективные/плановые совещания и многое другое.</li><li>Планирование и проведение спринтов по документации на мероприятиях KubeCon и других конференциях.</li><li>Набирать персонал и выступать в поддержку <a class=glossary-tooltip title='Cloud Native Computing Foundation' data-toggle=tooltip data-placement=top href=https://cncf.io/ target=_blank aria-label=CNCF>CNCF</a> и его платиновых партнеров, включая Google, Oracle, Azure, IBM и Huawei.</li><li>Поддерживать нормальную работу SIG.</li></ul><h3 id=проведение-продуктивных-встреч>Проведение продуктивных встреч</h3><p>Для планирования и проведения результативных встреч мы составили рекомендации, которые показывают и объясняют, как лучше всего их подготовить.</p><p><strong>Соблюдайте <a href=https://github.com/cncf/foundation/blob/master/code-of-conduct.md>нормы поведения сообщества</a></strong>:</p><ul><li>Привлекайте самый широкий круг участников к дискуссии и уважительно общайтесь между собой, стараясь никого не обидеть.</li></ul><p><strong>Сформулируйте четкую повестку дня</strong>:</p><ul><li>Определите конкретную цель встречи.</li><li>Опубликуйте программу дня заранее.</li></ul><p>Для еженедельных встреч скопируйте примечания из предыдущей недели в раздел "Past meetings".</p><p><strong>Работайте вместе для создания точных примечания</strong>:</p><ul><li>Запишите обсуждение встречи.</li><li>Подумайте над тем, чтобы делегировать роль стенографиста кому-нибудь другому.</li></ul><p><strong>Определяйте решения по пунктам повестки четко и точно</strong>:</p><ul><li>Записывайте решения по пунктам, кто будет ими заниматься и ожидаемую дату завершения.</li></ul><p><strong>Руководите обсуждением, когда это необходимо</strong>:</p><ul><li>Если обсуждение выходит за пределы повестки дня, снова обратите внимание участников на обсуждаемую тему.</li><li>Найдите место для различных стилей ведения обсуждения, не отвлекаясь от темы обсуждения и уважая время людей.</li></ul><p><strong>Уважайте время людей</strong>:</p><ul><li>Начинайте и заканчивайте встречи своевременно.</li></ul><p><strong>Используйте Zoom эффективно</strong>:</p><ul><li>Ознакомьтесь с <a href=https://github.com/kubernetes/community/blob/master/communication/zoom-guidelines.md>рекомендациями Zoom для Kubernetes</a>.</li><li>Попробуйте попроситься быть ведущим в самом начале встречи, введя ключ ведущего.</li></ul><img src=/images/docs/contribute/claim-host.png width=75% alt="Исполнение роли ведущего в Zoom"><h3 id=запись-встреч-на-zoom>Запись встреч на Zoom</h3><p>Когда вам потребуется начать запись, нажмите пункт с надписью Record to Cloud.</p><p>Если нужно остановить запись, нажмите на кнопку Stop.</p><p>Запись автоматически загрузится на YouTube.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a2d946282df02cdeb47d9f54dfef198e>7.4 - Обзор оформления документации</h1><p>Темы в этом разделе содержат рекомендации по написанию, форматированию и организации контента, а также охватывают настройку Hugo в контексте документации Kubernetes.</p></div><div class=td-content><h1 id=pg-75de610057816ac48210db20ec633217>7.4.1 - Руководство по оформлению документации</h1><p>На этой странице вы найдёте рекомендации по оформлению написания документации Kubernetes. Это рекомендации, а не правила. Используйте здравый смысл и не стесняйтесь предлагать изменения в этот документ в виде пулреквеста.</p><p>Для получения подробной информации о создании нового контента в документацию Kubernetes посмотрите <a href=/ru/docs/contribute/style/content-guide/>руководство по контенту документации</a>, а также следуйте инструкциям по <a href=/ru/docs/contribute/style/page-templates/>использованию шаблонов страниц</a> и <a href=/ru/docs/contribute/start/#%D1%83%D0%BB%D1%83%D1%87%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%89%D0%B5%D0%B3%D0%BE-%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0>открытию пулревеста в документацию</a>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> В документации Kubernetes используется <a href=https://github.com/russross/blackfriday>Blackfriday Markdown Renderer</a> вместе с несколькими <a href=/docs/home/contribute/includes/>макрокодами Hugo</a> для добавления поддержки записей глоссария, вкладок и отображения состояний функциональностей.</div><h2 id=язык>Язык</h2><p>Документация Kubernetes была переведена на несколько языков (см. <a href=https://github.com/kubernetes/website/blob/main/README.md#localization-readmemds>README-файлы локализаций</a>).</p><p>Процесс локализации документации на другие языки описан в <a href=/ru/docs/contribute/localization/>соответствующей странице по локализации</a>.</p><h2 id=правила-форматирования-документации>Правила форматирования документации</h2><h3 id=используйте-верблюжью-нотацию-для-написания-объектов-api>Используйте верблюжью нотацию для написания объектов API</h3><p>Когда вы указываете имя API-объекта, используйте те же самые прописные и строчные буквы так, как они записаны в имени объекта. Как правило, имена объектов API написаны с использованием <a href=https://ru.wikipedia.org/wiki/Camel_case>верблюжьей нотации</a>.</p><p>Не разделяйте имя объекта API на отдельные слова. Например, пишите PodTemplateList, а не Pod Template List.</p><p>Указывая имена API-объектов, не добавляйте к ним слово "объект", за исключением случаев, когда это только ухудшает читаемость.</p><table><caption style=display:none>Можно делать и нельзя - Объекты API</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>В Pod два контейнера.</td><td style=text-align:left>В поде два контейнера.</td></tr><tr><td style=text-align:left>Deployment отвечает за ...</td><td style=text-align:left>Объект Deployment отвечает за ...</td></tr><tr><td style=text-align:left>PodList — это список Pod.</td><td style=text-align:left>Pod List — это список подов.</td></tr><tr><td style=text-align:left>Два ContainerPorts ...</td><td style=text-align:left>Два объекта ContainerPort ...</td></tr><tr><td style=text-align:left>Два объекта ContainerStateTerminated ...</td><td style=text-align:left>Два ContainerStateTerminated ...</td></tr></tbody></table><h3 id=используйте-угловые-скобки-для-заполнителей>Используйте угловые скобки для заполнителей</h3><p>Используйте угловые скобки для заполнителей. Сообщите читателю, что означает заполнитель.</p><ol><li><p>Отобразить информацию о Pod:</p><pre><code> kubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt;
</code></pre><p>Если пространство имён пода равняется <code>default</code>, вы можете опустить параметр '-n'.</p></li></ol><h3 id=используйте-полужирное-начертание-для-элементов-пользовательского-интерфейса>Используйте полужирное начертание для элементов пользовательского интерфейса</h3><table><caption style=display:none>Можно делать и нельзя - Элементы интерфейса в полужирном начертании</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Нажмите на <strong>Fork</strong>.</td><td style=text-align:left>Нажмите на "Fork".</td></tr><tr><td style=text-align:left>Выберите <strong>Other</strong>.</td><td style=text-align:left>Выберите "Other".</td></tr></tbody></table><h3 id=используйте-курсивное-начертание-для-определения-или-включения-новых-терминов>Используйте курсивное начертание для определения или включения новых терминов</h3><table><caption style=display:none>Можно делать и нельзя - Используйте курсивное начертание для новых терминов</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left><em>Кластер</em> — это набор узлов ...</td><td style=text-align:left>"Кластер" — это набор узлов ...</td></tr><tr><td style=text-align:left>Эти компоненты формируют <em>плоскость управления</em>.</td><td style=text-align:left>Эти компоненты формируют <strong>плоскость управления</strong>.</td></tr></tbody></table><h3 id=оформляйте-как-код-имена-файлов-директории-и-пути>Оформляйте как код имена файлов, директории и пути</h3><table><caption style=display:none>Можно делать и нельзя - Оформляйте как код имена файлов, директории и пути</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Откройте файл <code>envars.yaml</code>.</td><td style=text-align:left>Откройте файл envars.yaml.</td></tr><tr><td style=text-align:left>Перейдите в директорию <code>/docs/tutorials</code>.</td><td style=text-align:left>Перейдите в директорию /docs/tutorials.</td></tr><tr><td style=text-align:left>Откройте файл <code>/_data/concepts.yaml</code> file.</td><td style=text-align:left>Откройте файл /_data/concepts.yaml.</td></tr></tbody></table><h3 id=используйте-международные-правила-для-пунктуации-внутри-кавычек>Используйте международные правила для пунктуации внутри кавычек</h3><table><caption style=display:none>Можно делать и нельзя - Используйте международные правила для пунктуации внутри кавычек</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>события записываются с соответствующей "стадией".</td><td style=text-align:left>события записываются с соответствующей "стадией."</td></tr><tr><td style=text-align:left>Копия называется "fork".</td><td style=text-align:left>Копия называется "fork."</td></tr></tbody></table><h2 id=форматирование-с-использованием-однострочного-кода>Форматирование с использованием однострочного кода</h2><h3 id=используйте-оформление-кода-для-встроенного-кода-и-команд>Используйте оформление кода для встроенного кода и команд</h3><p>Для однострочного (встроенного) блока кода в HTML-документе используйте тег <code>&lt;code></code>. В файле Markdown используйте обратную кавычку (`).</p><table><caption style=display:none>Можно делать и нельзя - Use code style for inline code and commands</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Команда <code>kubectl run</code> создает Deployment.</td><td style=text-align:left>Команда "kubectl run" создает Deployment.</td></tr><tr><td style=text-align:left>Для декларативного управления используйте <code>kubectl apply</code>.</td><td style=text-align:left>Для декларативного управления используйте "kubectl apply".</td></tr><tr><td style=text-align:left>Заключите примеры кода в тройные обратные кавычки. <code>(```)</code></td><td style=text-align:left>Заключите примеры кода с использованием любого другого синтаксиса.</td></tr><tr><td style=text-align:left>Используйте одинарные обратные кавычки для выделения встроенного кода. Например, <code>var example = true</code>.</td><td style=text-align:left>Используйте две звездочки (**) или подчёркивание (_) для выделения встроенного кода. Например, <strong>var example = true</strong>.</td></tr><tr><td style=text-align:left>Используйте тройные обратные кавычки до и после многострочного блока кода для отдельных блоков кода.</td><td style=text-align:left>Используйте многострочные блоки кода для создания диаграмм, блок-схем или т.д.</td></tr><tr><td style=text-align:left>Используйте понятные имена переменных с соответствующим контекстом.</td><td style=text-align:left>Используйте имена переменных, такие как 'foo', 'bar' и 'baz', которые не имеют смысла и которым не хватает контекста.</td></tr><tr><td style=text-align:left>Удаляйте завершающие пробелы в коде.</td><td style=text-align:left>Добавляйте конечные пробелы в код там, где они необходимо, поскольку программа для чтения с экрана также будет зачитывать пробелы.</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> На сайте включена подсветка синтаксиса для примеров кода, хотя указывать язык необязательно. Подсветка синтаксиса в блоке кода должна соответствовать <a href="https://www.w3.org/WAI/WCAG21/quickref/?versions=2.0&showtechniques=141%2C143#contrast-minimum">рекомендациям по контрастности</a>.</div><h3 id=имена-полей-объектов-и-пространства-имён-оформляйте-как-код>Имена полей объектов и пространства имён оформляйте как код</h3><table><caption style=display:none>Можно делать и нельзя - Имена полей объектов и пространства имён оформляйте как код</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Задайте значение для поля <code>replicas</code> в конфигурационном файле.</td><td style=text-align:left>Задайте значение для поля "replicas" в конфигурационном файле.</td></tr><tr><td style=text-align:left>Значением поля <code>exec</code> является объект ExecAction.</td><td style=text-align:left>Значением поля "exec" является объект ExecAction.</td></tr><tr><td style=text-align:left>Запустите процесс как Daemonset в пространстве имен <code>kube-system</code>.</td><td style=text-align:left>Запустите процесс как Daemonset в пространстве имен kube-system.</td></tr></tbody></table><h3 id=имена-компонентов-и-командного-инструмента-оформляйте-как-код>Имена компонентов и командного инструмента оформляйте как код</h3><table><caption style=display:none>Можно делать и нельзя - Имена компонентов и командного инструмента оформляйте как код</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>kubelet сохраняет стабильность узла.</td><td style=text-align:left><code>kubelet</code> сохраняет стабильность узла.</td></tr><tr><td style=text-align:left><code>kubectl</code> обрабатывает поиск и аутентификацию на сервере API.</td><td style=text-align:left>kubectl обрабатывает поиск и аутентификацию на apiserver.</td></tr><tr><td style=text-align:left>Запустите процесс с использованием сертификата <code>kube-apiserver --client-ca-file=FILENAME</code>.</td><td style=text-align:left>Запустите процесс с использованием сертификата kube-apiserver --client-ca-file=FILENAME.</td></tr></tbody></table><h3 id=начинайте-предложение-с-имени-инструмента-или-компонента>Начинайте предложение с имени инструмента или компонента</h3><table><caption style=display:none>Можно делать и нельзя - Начинайте предложение с имени инструмента или компонента</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>The <code>kubeadm</code> tool bootstraps and provisions machines in a cluster.</td><td style=text-align:left><code>kubeadm</code> tool bootstraps and provisions machines in a cluster.</td></tr><tr><td style=text-align:left>The kube-scheduler is the default scheduler for Kubernetes.</td><td style=text-align:left>kube-scheduler is the default scheduler for Kubernetes.</td></tr></tbody></table><h3 id=используйте-общее-описание-вместо-имени-компонента>Используйте общее описание вместо имени компонента</h3><table><caption style=display:none>Можно делать и нельзя - Используйте общее описание вместо имени компонента</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Сервер Kubernetes API следует спецификации OpenAPI.</td><td style=text-align:left>apiserver следует спецификации OpenAPI.</td></tr><tr><td style=text-align:left>Агрегированные API-интерфейсы — вспомогательные API-серверы.</td><td style=text-align:left>Агрегированные API-интерфейсы — вспомогательные APIServers.</td></tr></tbody></table><h3 id=cтроковые-и-целочисленные-значения-полей-пишите-в-обычном-стиле>Cтроковые и целочисленные значения полей пишите в обычном стиле</h3><p>Для значений полей типа string или integer используйте обычный стиль без кавычек.</p><table><caption style=display:none>Можно делать и нельзя - Cтроковые и целочисленные значения полей пишите в обычном стиле</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Задайте значение для поля <code>imagePullPolicy</code> как Always.</td><td style=text-align:left>Задайте значение для поля <code>imagePullPolicy</code> как "Always".</td></tr><tr><td style=text-align:left>Задайте значение для поля <code>image</code> как nginx:1.8.</td><td style=text-align:left>Задайте значение для поля<code>image</code> как <code>nginx:1.8</code>.</td></tr><tr><td style=text-align:left>Задайте значение для поля <code>replicas</code> как 2.</td><td style=text-align:left>Задайте значение для поля <code>replicas</code> как <code>2</code>.</td></tr></tbody></table><h2 id=форматирование-фрагментов-кода>Форматирование фрагментов кода</h2><h3 id=не-добавляйте-символ-приглашения-командной-строки>Не добавляйте символ приглашения командной строки</h3><table><caption style=display:none>Можно делать и нельзя - Не добавляйте символ приглашения командной строки</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>kubectl get pods</td><td style=text-align:left>$ kubectl get pods</td></tr></tbody></table><h3 id=отделяйте-команды-от-вывода>Отделяйте команды от вывода</h3><p>Убедитесь, что Pod работает на выбранном вами узле:</p><pre><code>kubectl get pods --output=wide
</code></pre><p>Вывод будет примерно таким:</p><pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre><h3 id=версионирование-примеров-kubernetes>Версионирование примеров Kubernetes</h3><p>Примеры кода и примеры конфигурации, которые включают информацию о версии, должны согласовываться с относящемуся к нему тексту.</p><p>Если информация зависит от версии, необходимо определить версию Kubernetes в секции <code>prerequisites</code> <a href=/ru/docs/contribute/style/page-templates/#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8>шаблона задачи</a> или <a href=/ru/docs/contribute/style/page-templates/#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%B0>шаблона руководства</a>. После сохранения страницы секция <code>prerequisites</code> отобразится в отдельном блоке с заголовком <strong>Подготовка к работе</strong>.</p><p>Для указания версии Kubernetes для страницы задачи или руководства в фронтальную часть файла добавьте поле <code>min-kubernetes-server-version</code>.</p><p>Если YAML-пример определён в отдельном файле, поищите и просмотрите темы, которые ссылаются на него.
Убедитесь, что темы с подключённым YAML-файлом содержат соответствующую информацию о версии.
Если ни одна из тем не использует какой-либо YAML-файл подумайте над тем, чтобы удалить его вместо того, чтобы обновления.</p><p>Например, если вы пишете руководство, предназначенное для использования с версией Kubernetes 1.8, фронтальная часть вашего Markdown-файла должен выглядеть примерно так:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>title</span>:<span style=color:#bbb> </span>&lt;your tutorial title here&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>min-kubernetes-server-version</span>:<span style=color:#bbb> </span>v1.8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>В примерах кода и конфигурации не добавляйте комментарии про альтернативные версии.
Убедитесь в том, чтобы в комментариях ваших примеров не содержались некорректные сведения, такие как ниже:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># в более ранних версиях...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=словарь-kubernetes-io>Словарь Kubernetes.io</h2><p>Список специфичных для Kubernetes терминов и слов, которые будут регулярно встречаться по всему сайту.</p><table><caption style=display:none>Словарь Kubernetes.io</caption><thead><tr><th style=text-align:left>Термин</th><th style=text-align:left>Пример использования</th></tr></thead><tbody><tr><td style=text-align:left>Kubernetes</td><td style=text-align:left>Kubernetes всегда должен начинаться с заглавной буквы.</td></tr><tr><td style=text-align:left>Docker</td><td style=text-align:left>Docker всегда должен начинаться с заглавной буквы.</td></tr><tr><td style=text-align:left>SIG Docs</td><td style=text-align:left>SIG Docs, а не SIG-DOCS или другие варианты.</td></tr><tr><td style=text-align:left>On-premises</td><td style=text-align:left>On-premises or On-prem rather than On-premise or other variations.</td></tr></tbody></table><h2 id=макрокоды>Макрокоды</h2><p><a href=https://gohugo.io/content-management/shortcodes>Макрокоды Hugo</a> помогают создавать разного рода обращений к читателю. Наша документация поддерживает три разных макрокода для этого: <strong>примечание</strong> {{&lt; note >}}, <strong>предостережение</strong> {{&lt; caution >}} и <strong>предупреждение</strong> {{&lt; warning >}}.</p><ol><li><p>Заключите текст в открывающий и закрывающий макрокод.</p></li><li><p>Используйте следующий синтаксис для определения стиля:</p><pre tabindex=0><code>{{&lt; note &gt;}}
Вам не нужно указывать надпись; макрокод автоматически добавит её. (Примечание:, Предостережение:, и т.д.)
{{&lt; /note &gt;}}
</code></pre></li></ol><p>Результат:</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Надпись блока будет такой же, как и имя тега.</div><h3 id=примечание>Примечание</h3><p>Используйте {{&lt; note >}} для выделения подсказки или части информации, которая может быть полезна для ознакомления.</p><p>Например:</p><pre tabindex=0><code>{{&lt; note &gt;}}
Вы _также_ можете использовать Markdown внутри этих выносок.
{{&lt; /note &gt;}}
</code></pre><p>Результат:</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Вы <em>также</em> можете использовать Markdown внутри этих выносок.</div><p>Вы можете использовать {{&lt; note >}} в списке:</p><pre tabindex=0><code>1. Используйте макрокод примечания в списке

1. Второй пункт с добавленным блоком примечания

   {{&lt; note &gt;}}
   Макрокоды предупреждения, предостережения и примечания, добавленные в списки, должны содержать отступ в четыре пробела. Смотрите раздел [Распространённые проблемы с шорткодами](#распространённые-проблемы-с-шорткодами).
   {{&lt; /note &gt;}}

1. Третий пункт в списке

1. Четвертый пункт в списке
</code></pre><p>Результат:</p><ol><li><p>Используйте макрокод примечания в списке</p></li><li><p>Второй пункт с добавленным блоком примечания</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Макрокоды предупреждения, предостережения и примечания, добавленные в списки, должны содержать отступ в четыре пробела. Смотрите раздел <a href=#%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%91%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B-%D1%81-%D1%88%D0%BE%D1%80%D1%82%D0%BA%D0%BE%D0%B4%D0%B0%D0%BC%D0%B8>Распространённые проблемы с шорткодами</a>.</div></li><li><p>Третий пункт в списке</p></li><li><p>Четвертый пункт в списке</p></li></ol><h3 id=предостережение>Предостережение</h3><p>Используйте {{&lt; caution >}}, чтобы обратить внимание к важной информации, которая поможет избежать подводных камней.</p><p>Например:</p><pre tabindex=0><code>{{&lt; caution &gt;}}
Оформление выноски применяется только к строке, следующей после тега выше.
{{&lt; /caution &gt;}}
</code></pre><p>Результат:</p><div class="alert alert-warning caution callout" role=alert><strong>Внимание:</strong> Оформление выноски применяется только к строке, следующей после тега выше.</div><h3 id=предупреждение>Предупреждение</h3><p>Используйте {{&lt; warning >}} для обозначения предупреждающей информации или такой, которую чрезвычайно важно соблюдать.</p><p>Например:</p><pre tabindex=0><code>{{&lt; warning &gt;}}
Острожно.
{{&lt; /warning &gt;}}
</code></pre><p>Результат:</p><div class="alert alert-danger warning callout" role=alert><strong>Предупреждение:</strong> Острожно.</div><h3 id=встраиваемая-среда-выполнения-katacoda>Встраиваемая среда выполнения Katacoda</h3><p>С помощью этой кнопки пользователи могут запустить Minikube в своём браузере с помощью <a href=https://www.katacoda.com/embed/panel>терминала Katacoda</a>.
Таким образом снижается порог входа, позволяя пользователям попробовать Minikube с помощью одного щелчка мыши, вместо того, чтобы устанавливать Minikube и Kubectl локально.</p><p>Встроенная среда выполнения сконфигурирована для выполнения команды <code>minikube start</code> и позволяет пользователям пройти руководство в той же самой вкладке, что и документация.</p><div class="alert alert-warning caution callout" role=alert><strong>Внимание:</strong> Сессия ограничена 15 минутами.</div><p>Например:</p><pre tabindex=0><code>{{&lt; kat-button &gt;}}
</code></pre><p>Результат:</p><script defer src=https://katacoda.com/embed.js></script>
<button class=button onclick=window.katacoda.init()>Launch Terminal</button><h2 id=распространённые-проблемы-с-шорткодами>Распространённые проблемы с шорткодами</h2><h3 id=упорядоченные-списки>Упорядоченные списки</h3><p>Макрокоды сбросят нумерацию в нумерованных списках, если вы не добавите отступ в четыре пробела перед уведомлением и тегом.</p><p>Например:</p><pre><code>1. Разогреть духовку до 350˚F

1. Подготовить тесто и вылить её в формочку для выпечки.
   {{&lt; note &gt;}}Для лучшего результата смажьте формочку.{{&lt; /note &gt;}}

1. Выпекать 20-25 minutes или пока тесто не зарумянится.
</code></pre><p>Результат:</p><ol><li><p>Разогреть духовку до 350˚F</p></li><li><p>Подготовить тесто и вылить её в формочку для выпечки.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Для лучшего результата смажьте формочку.</div></li><li><p>Выпекать 20-25 minutes или пока тесто не зарумянится.</p></li></ol><h3 id=выражения-для-вставок>Выражения для вставок</h3><p>Макрокоды внутри include-выражений нарушит процесс сборки. Поэтому они должны быть вставлены в родительский документ до и после вызова include. Например:</p><pre tabindex=0><code>{{&lt; note &gt;}}
{{&lt; include &#34;task-tutorial-prereqs.md&#34; &gt;}}
{{&lt; /note &gt;}}
</code></pre><h2 id=элементы-markdown>Элементы Markdown</h2><h3 id=переносы-строк>Переносы строк</h3><p>Добавляйте одну новую строку для разделения содержимого таких блоков, как заголовки, списки, изображения, многострочный код и т.д. Исключение составляют заголовки второго уровня, которые должны быть разделены двумя переводами строки. Заголовки второго уровня следуют за первым уровнем (или названием страницы). Две пустые строки помогает лучше наглядно представить общую структуру содержимого в редакторе кода.</p><h3 id=заголовки>Заголовки</h3><p>Люди, просматривающие документацию, могут использовать программу чтения с экрана или другую вспомогательную технологию (Assistive technologies, AT). <a href=https://ru.wikipedia.org/wiki/%D0%AD%D0%BA%D1%80%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D1%81%D1%87%D0%B8%D1%82%D1%8B%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B5_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%BE>Программы чтения с экрана</a> — устройства вывода, которые выводят элементы на странице по очереди. Если на странице много текста, вы можете использовать заголовки, чтобы придать странице внутреннюю структуру. Хорошая структура страницы помогает всем читателям легко перемещаться по странице или выбрать интересующие темы.</p><table><caption style=display:none>Можно делать и нельзя - Заголовки</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Обновите заголовок в фронтальной части страницы или записи блога.</td><td style=text-align:left>Используйте заголовок первого уровня, так как Hugo автоматически преобразует название страницы в фронтальной части в заголовок первого уровня.</td></tr><tr><td style=text-align:left>Используйте упорядоченные заголовки, чтобы сформировать общее представление о содержании страницы.</td><td style=text-align:left>Используйте заголовки с уровня 4 по 6, если только это только в этом нет необходимости. Если текст настолько подробный, возможно, его нужно разделить на отдельные статьи.</td></tr><tr><td style=text-align:left>Используйте знак решётки или хеша (#) для всех видов контента, кроме записей блога.</td><td style=text-align:left>Используйте подчеркивание (--- или ===) для обозначения заголовков первого уровня.</td></tr><tr><td style=text-align:left>Начинайте с большой буквы только первое слово в заголовке. Например, <strong>Расширение kubectl с помощью плагинов</strong></td><td style=text-align:left>Пишите с заглавной буквы все слова в заголовке. Например, <strong>Расширение Kubectl С Помощью Плагинов</strong></td></tr></tbody></table><h3 id=параграфы>Параграфы</h3><table><caption style=display:none>Можно делать и нельзя - Параграфы</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Проследите за тем, чтобы в одном абзаце было не более 6 предложений.</td><td style=text-align:left>Добавить к первом абзацу отступ с пробелами. Например, ⋅⋅⋅Три пробела перед абзацем образуют отступ.</td></tr><tr><td style=text-align:left>Используйте три дефиса (---) для создания горизонтальной черты. Используйте горизонтальные линии для обозначения конца в содержании абзаца. Например, смена места в истории или переход темы в разделе.</td><td style=text-align:left>Используйте горизонтальные линии для оформления.</td></tr></tbody></table><h3 id=ссылки>Ссылки</h3><table><caption style=display:none>Можно делать и нельзя - Ссылки</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Указывайте ссылки, которые передают суть содержания, на который они ссылаются. Например: "Некоторые порты открыты на ваших машинах. Смотрите раздел <a href=#check-required-ports>Проверка необходимых портов</a>, чтобы получить дополнительную информацию".</td><td style=text-align:left>Используйте двусмысленные термины, такие как "нажмите сюда". Например: Некоторые порты открыты на ваших машинах. Смотрите <a href=#check-required-ports>этот раздел</a>, чтобы получить дополнительную информацию".</td></tr><tr><td style=text-align:left>Указывайте ссылки в стиле Markdown: <code>[текст ссылки](URL)</code>. Например: <code>[Макрокоды Hugo](/docs/contribute/style/hugo-shortcodes/#table-captions)</code> отобразится как <a href=/docs/contribute/style/hugo-shortcodes/#table-captions>Макрокоды Hugo</a>.</td><td style=text-align:left>Указывайте ссылки в формате HTML: <code>&lt;a href="/media/examples/link-element-example.css" target="_blank">Ознакомьтесь с нашим руководством!&lt;/a></code> или добавляйте ссылки, которые открываются в новых вкладках или окнах. Например: <code>[example website](https://example.com){target="_blank"}</code></td></tr></tbody></table><h3 id=списки>Списки</h3><p>Сгруппируйте пункты в списке так, чтобы они были связаны друг с другом и следовали в определённом порядке, либо чтобы они сохраняли взаимосвязь между несколькими элементами. Когда программа чтения с экрана встречает нумерованный или неупорядоченный список, пользователю будет проинформирован, что существует группа из элементов списка. Затем пользователь может использовать клавиши-стрелки для перемещения между разными элементами в списке.
Навигационные ссылки по сайту также могут быть помечены как элементы списка; в конечном счёте, все они просто группа связанных ссылок.</p><ul><li><p>Заканчивайте каждый элемент в списке точкой, если один или несколько элементов в списке являются законченными предложениями. Как правило, для согласованности либо все элементы должны быть целыми предложениями, либо ни один из них.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Упорядоченные списки, которые являются частью неполного вступительного предложения, могут быть написаны в нижнем регистре и оканчиваться на точку, как если бы каждый элемент был составляющей вступительного предложения.</div></li><li><p>Используйте цифру один (1.) для упорядоченных списков.</p></li><li><p>Используйте (+), (*) или (-) для неупорядоченных списков.</p></li><li><p>Добавьте пустую строку после каждого списка.</p></li><li><p>Во вложенных списках добавьте отступ в четыре пробела (например, ⋅⋅⋅⋅).</p></li><li><p>Элементы списка могут содержать несколько абзацев. Каждый последующий абзац в элементе списка должен иметь отступ в четыре пробела или один символ табуляции.</p></li></ul><h3 id=таблицы>Таблицы</h3><p>Семантическая цель таблицы данных состоит в представлении данных в табличном виде. Пользователи с нормальным зрением могут бегло просмотреть таблицу, однако программа для чтения с экрана сканирует таблицу построчно. Заголовок таблицы используется для создания информативного заголовка для табличных данных. Инструменты вспомогательных технологий (Assistive technologies, AT) используют элемент заголовка HTML-таблицы, чтобы идентифицировать для пользователей, какие на странице есть таблицы.</p><ul><li>Добавьте подписи к таблицам с помощью соответствующих <a href=/docs/contribute/style/hugo-shortcodes/#table-captions>макрокодов Hugo</a>.</li></ul><h2 id=рекомендации-по-написанию-контента>Рекомендации по написанию контента</h2><p>В этом разделе перечислены рекомендации для написания ясного, лаконичного и единообразного текста документации.</p><h3 id=используйте-настоящее-время>Используйте настоящее время</h3><table><caption style=display:none>Можно делать и нельзя - Используйте настоящее время</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Эта команда запускает прокси.</td><td style=text-align:left>Эта команда запустит прокси.</td></tr></tbody></table><p>Исключение: используйте будущее или прошедшее время, если требуется передать правильный смысл.</p><h3 id=используйте-действительный-залог>Используйте действительный залог</h3><table><caption style=display:none>Можно делать и нельзя - Используйте действительный залог</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Вы можете изучить API с помощью браузера.</td><td style=text-align:left>API можно изучить с помощью браузера.</td></tr><tr><td style=text-align:left>В файле YAML определяется количество реплик.</td><td style=text-align:left>Количество реплик определяется в файле YAML.</td></tr></tbody></table><p>Исключение: используйте страдательный залог, если в действительном залоге получается неудачная формулировка.</p><h3 id=используйте-простой-и-понятный-язык>Используйте простой и понятный язык</h3><p>Используйте простой и доступный язык. Избегайте использования ненужных фраз, например, "пожалуйста".</p><table><caption style=display:none>Можно делать и нельзя - Используйте простой и понятный язык</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Чтобы создать ReplicaSet, ...</td><td style=text-align:left>Для того чтобы создать a ReplicaSet, ...</td></tr><tr><td style=text-align:left>Смотрите конфигурационный файл.</td><td style=text-align:left>Пожалуйста, смотрите конфигурационный файл.</td></tr><tr><td style=text-align:left>Посмотрите Pods.</td><td style=text-align:left>С помощью следующей команды мы посмотрим Pods.</td></tr></tbody></table><h3 id=обращайтесь-к-читателю-на-вы>Обращайтесь к читателю на "вы"</h3><table><caption style=display:none>Можно делать и нельзя - Обращайтесь к читателю на вы</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Вы можете создать Deployment с помощью ...</td><td style=text-align:left>Мы создадим Deployment с помощью ...</td></tr><tr><td style=text-align:left>В предыдущем выводе вы можете увидеть ...</td><td style=text-align:left>В предыдущем выводе мы можем увидеть ...</td></tr></tbody></table><h3 id=избегайте-использования-латинских-фраз>Избегайте использования латинских фраз</h3><p>Вместо латинских аббревиатур используйте соответствующие выражения на английском.</p><table><caption style=display:none>Можно делать и нельзя - Избегайте использования латинских фраз</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>For example, ...</td><td style=text-align:left>e.g., ...</td></tr><tr><td style=text-align:left>That is, ...</td><td style=text-align:left>i.e., ...</td></tr></tbody></table><p>Исключение: используйте "etc." вместо "et cetera".</p><h2 id=ошибки-которые-следует-избегать>Ошибки, которые следует избегать</h2><h3 id=избегайте-использования-мы>Избегайте использования "мы"</h3><p>Использование "мы" в предложении может сбить с толку, так так неясно, кто под этим "мы" подразумевается (имеется ли в виду сам читатель при этом).</p><table><caption style=display:none>Можно делать и нельзя - Избегайте использования мы</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Версия 1.4 включает в себя ...</td><td style=text-align:left>В версии 1.4 мы добавили ...</td></tr><tr><td style=text-align:left>Kubernetes представляет новую возможность для ...</td><td style=text-align:left>Мы представляем новую возможность ...</td></tr><tr><td style=text-align:left>На этой странице вы узнаете, как использовать Pods.</td><td style=text-align:left>На этой странице мы познакомимся с Pods.</td></tr></tbody></table><h3 id=избегайте-жаргона-и-идиомы>Избегайте жаргона и идиомы</h3><p>Некоторые читатели говорят на английском как на втором языке. Избегайте жаргона и идиом, чтобы облегчить им понимание.</p><table><caption style=display:none>Можно делать и нельзя - Избегайте жаргона и идиомы</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>Internally, ...</td><td style=text-align:left>Under the hood, ...</td></tr><tr><td style=text-align:left>Create a new cluster.</td><td style=text-align:left>Turn up a new cluster.</td></tr></tbody></table><h3 id=избегайте-выражений-о-будущем>Избегайте выражений о будущем</h3><p>Не давайте обещаний или намеков на будущее. Если вам нужно рассказать про функциональность в альфа-версии, под соответствующем заголовком напишите поясняющий текст, что информация относится к альфа-версии.</p><h3 id=избегайте-выражений-которые-могут-потерять-актуальность>Избегайте выражений, которые могут потерять актуальность</h3><p>Избегайте таких слов, как "в настоящее время" и "новый". Новая функциональность в настоящее время не будет таковой через несколько месяцев.</p><table><caption style=display:none>Можно делать и нельзя - Избегайте выражений, которые могут потерять актуальность</caption><thead><tr><th style=text-align:left>Можно</th><th style=text-align:left>Нельзя</th></tr></thead><tbody><tr><td style=text-align:left>В версии 1.4 ...</td><td style=text-align:left>В текущей версии ...</td></tr><tr><td style=text-align:left>Функциональность Federation предоставляет ...</td><td style=text-align:left>Новая функциональность Federation предоставляет ...</td></tr></tbody></table><h2 id=что-дальше>Что дальше</h2><ul><li>Подробнее про <a href=/ru/docs/contribute/style/write-new-topic/>написание новой темы</a>.</li><li>Подробнее про <a href=/ru/docs/contribute/style/page-templates/>использование шаблонов страниц</a>.</li><li>Подробнее про <a href=/ru/docs/contribute/start/#%D0%BE%D1%82%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0-%D0%BF%D1%83%D0%BB%D1%80%D0%B5%D0%BA%D0%B2%D0%B5%D1%81%D1%82%D0%B0>создание пулреквеста</a>).</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3b9549b1c8f5ef9d6ae0a841cc99c180>7.4.2 - Руководство по содержанию документации</h1><p>Эта страница содержит рекомендации по добавлению контента в документацию Kubernetes.
Если у вас есть вопросы по поводу допустимого контента, обратитесь к каналу #sig-docs в <a href=http://slack.k8s.io/>Slack Kubernetes</a> и задайте свои вопросы! Поступайте на своё усмотрение и не стесняйтесь вносить изменения в этот документ через пулреквест.</p><p>Для получения дополнительной информации о создании нового контента для документации Kubernetes следуйте инструкциям в <a href=/ru/docs/contribute/style/style-guide>руководстве по оформлению</a>.</p><h2 id=участие-в-контенте>Участие в контенте</h2><p>Документация Kubernetes включает содержимое из оригинального репозитория <a href=https://github.com/kubernetes/website>kubernetes/website</a>. Документация Kubernetes находится в директории <code>kubernetes/website/content/&lt;language_code>/docs</code>, большая часть которой относится к <a href=https://github.com/kubernetes/kubernetes>проекту Kubernetes</a>. Документация Kubernetes может также включать содержимое их проектов в GitHub-организациях <a href=https://github.com/kubernetes>kubernetes</a> и <a href=https://github.com/kubernetes-sigs>kubernetes-sigs</a>, если у этих проектов нет собственной документации. Всегда можно ссылаться на действующие проекты kubernetes, kubernetes-sigs и (<a class=glossary-tooltip title='Cloud Native Computing Foundation' data-toggle=tooltip data-placement=top href=https://cncf.io/ target=_blank aria-label=CNCF>CNCF</a>) в документации Kubernetes, но перелинковка с продуктами определённого разработчика не допускается. Проверьте списки проектов CNCF (<a href=https://www.cncf.io/projects/>Graduated/Incubating</a>, <a href=https://www.cncf.io/sandbox-projects/>Sandbox</a>, <a href=https://www.cncf.io/archived-projects/>Archived</a>), если вы не уверены в статусе CNCF проекта</p><h3 id=контент-полученный-из-двух-источников>Контент, полученный из двух источников</h3><p>Документация Kubernetes не содержит дублированный контент, полученный из разных мест (так называемый <strong>контент из двух источников</strong>). Контент из двух источников требует дублирования работы со стороны мейнтейнеров проекта и к тому же быстро теряет актуальность.
Перед добавлением контента, задайте себе вопрос:</p><ul><li>Новая информация относится к действующему проекту CNCF или проекту в организациях на GitHub kubernetes или kubernetes-sigs?<ul><li>Если да, то:<ul><li>У этого проекта есть собственная документация?<ul><li>если да, то укажите ссылку на документацию проекта в документации Kubernetes.</li><li>если нет, добавьте информацию в репозиторий проекта (если это возможно), а затем укажите ссылку на неё в документации Kubernetes.</li></ul></li></ul></li><li>Если нет, то:<ul><li>Остановитесь!<ul><li>Добавление информации о продуктах от других разработчиков не допускается.</li><li>Не разрешено ссылаться на документацию и сайты сторонних разработчиков.</li></ul></li></ul></li></ul></li></ul><h3 id=разрешенная-и-запрещённая-информация>Разрешенная и запрещённая информация</h3><p>Есть несколько условий, когда в документации Kubernetes может быть информация, относящиеся не к проектам Kubernetes.
Ниже перечислены основные категории по содержанию проектов, не касающихся Kubernetes, а также приведены рекомендации о том, что разрешено, а что нет:</p><ol><li><p>Инструкции по установке или эксплуатации Kubernetes, которые не связаны с проектами Kubernetes.</p><ul><li>Разрешено:<ul><li>Ссылаться на документацию CNCF-проекта или на проект в GitHub-организациях kubernetes или kubernetes-sigs.<ul><li>Пример: для установки Kubernetes в процессе обучения нужно обязательно установить и настроить minikube, а также сослаться на соответствующую документацию minikube.</li></ul></li><li>Добавление инструкций для проектов в организации kubernetes или kubernetes-sigs, если по ним нет инструкций.<ul><li>Пример: добавление инструкций по установке и решению неполадок <a href=https://github.com/kubernetes/kubeadm>kubeadm</a>.</li></ul></li></ul></li><li>Запрещено:<ul><li>Добавление информации, которая дублирует документацию в другом репозитории.<ul><li>Примеры:<ul><li>Добавление инструкций по установке и настройке minikube; Minikube имеет собственную <a href=https://minikube.sigs.k8s.io/docs/>документацию</a>, которая включают эти инструкции.</li><li>Добавление инструкций по установке Docker, CRI-O, containerd и других окружений для выполнения контейнеров в разных операционных системах.</li><li>Добавление инструкций по установке Kubernetes в промышленных окружениях, используя разные проекты:<ul><li>Kubernetes Rebar Integrated Bootstrap (KRIB) — это проект стороннего разработчика, поэтому всё содержимое находится в репозитории разработчика.</li><li>У проекта <a href=https://github.com/kubernetes/kops>Kubernetes Operations (kops)</a> есть инструкции по установке и руководства в GitHub-репозитории.</li><li>У проекта <a href=https://kubespray.io>Kubespray</a> есть собственная документация.</li></ul></li></ul></li></ul></li><li>Добавление руководства, в котором объясняется, как выполнить задачу с использованием продукта определенного разработчика или проекта с открытым исходным кодом, не являющиеся CNCF-проектами или проектом в GitHub-организациях kubernetes, или kubernetes-sigs.</li><li>Добавление руководства по использованию CNCF-проекта или проекта в GitHub-организациях kubernetes или kubernetes-sigs, если у проекта есть собственная документация.</li></ul></li></ul></li><li><p>Подробное описание технических аспектов по использованию стороннего проекта (не Kubernetes) или как этот проект разработан.</p><p>Добавление такого типа информации в документацию Kubernetes не допускается.</p></li><li><p>Информация стороннему проекту.</p><ul><li>Разрешено:<ul><li>Добавление краткого введения о CNCF-проекте или проекте в GitHub-организациях kubernetes или kubernetes-sigs; этот абзац может содержать ссылки на проект.</li></ul></li><li>Запрещено:<ul><li>Добавление информации по продукту определённого разработчика.</li><li>Добавление информации по проекту с открытым исходным кодом, который не является CNCF-проектом или проектом в GitHub-организациях kubernetes или kubernetes-sigs.</li><li>Добавление информации, дублирующего документацию из другого проекта, независимо от оригинального репозитория.<ul><li>Пример: добавление документации для проекта <a href=https://kind.sigs.k8s.io>Kubernetes in Docker (KinD)</a> в документацию Kubernetes.</li></ul></li></ul></li></ul></li><li><p>Только ссылки на сторонний проект.</p><ul><li>Разрешено:<ul><li>Ссылаться на проекты в GitHub-организациях kubernetes и kubernetes-sigs.<ul><li>Пример: добавление ссылок на <a href=https://kind.sigs.k8s.io/docs/user/quick-start>документацию</a> проекта Kubernetes in Docker (KinD), который находится в GitHub-организации kubernetes-sigs.</li></ul></li><li>Добавление ссылок на действующие CNCF-проекты.<ul><li>Пример: добавление ссылок на <a href=https://prometheus.io/docs/introduction/overview/>документацию</a> проекта Prometheus; Prometheus — это действующий проект CNCF.</li></ul></li></ul></li><li>Запрещено:<ul><li>Ссылаться на продукты стороннего разработчика.</li><li>Ссылаться на прекращенные проекты CNCF.</li><li>Ссылаться на недействующие проекты в организациях GitHub в kubernetes и kubernetes-sigs.</li><li>Ссылаться на проекты с открытым исходным кодом, которые не являются проектами CNCF или не находятся в организациях GitHub kubernetes, или kubernetes-sigs.</li></ul></li></ul></li><li><p>Содержание учебных курсов.</p><ul><li>Разрешено:<ul><li>Ссылаться на независимые от разработчиков учебные курсы Kubernetes, предлагаемыми <a href=https://www.cncf.io/>CNCF</a>, <a href=https://www.linuxfoundation.org/>Linux Foundation</a> и <a href=https://linuxacademy.com/>Linux Academy</a> (партнер Linux Foundation).<ul><li>Пример: добавление ссылок на курсы Linux Academy, такие как <a href=https://linuxacademy.com/course/kubernetes-quick-start/>Kubernetes Quick Start</a> и <a href=https://linuxacademy.com/course/kubernetes-security/>Kubernetes Security</a>.</li></ul></li></ul></li><li>Запрещено:<ul><li>Ссылаться на учебные онлайн-курсы, не относящиеся к CNCF, Linux Foundation или Linux Academy; документация Kubernetes не содержит ссылок на сторонний контент.<ul><li>Пример: добавление ссылок на учебные руководства или курсы Kubernetes на Medium, KodeKloud, Udacity, Coursera, learnk8s и т.д.</li></ul></li><li>Ссылаться на руководства определённых разработчиков вне зависимости от обучающей организации.<ul><li>Пример: добавление ссылок на такие курсы Linux Academy, как <a href=https://linuxacademy.com/google-cloud-platform/training/course/name/google-kubernetes-engine-deep-dive>Google Kubernetes Engine Deep Dive</a> и <a href=https://linuxacademy.com/course/amazon-eks-deep-dive/>Amazon EKS Deep Dive</a></li></ul></li></ul></li></ul></li></ol><p>Если у вас есть вопросы по поводу допустимого контента, присоединяйтесь к каналу #sig-docs в <a href=http://slack.k8s.io/>Slack Kubernetes</a>!</p><h2 id=что-дальше>Что дальше</h2><ul><li>Прочитайте <a href=/ru/docs/contribute/style/style-guide>руководство по оформлению</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4f09c4b708d2dd4ac9eac1080dab6728>7.4.3 - Написание новой темы</h1><p>На этой странице показано, как создать новую тему для документации Kubernetes.</p><h2 id=подготовка-к-работе>Подготовка к работе</h2><p>Создайте копию репозитория документации Kubernetes, как описано в разделе <a href=/ru/docs/contribute/start/>Участие для начинающих</a>.</p><h2 id=выбор-типы-страницы>Выбор типы страницы</h2><p>Перед написанием новой темы, выберите тип страницы, который бы лучше всего подходил под ваш текст:</p><table><caption style=display:none>Правила выбора типа страницы</caption><thead><tr><th style=text-align:left>Тип</th><th style=text-align:left>Описание</th></tr></thead><tbody><tr><td style=text-align:left>Концепция</td><td style=text-align:left>Страница концепции объясняет некоторые аспекты Kubernetes. Например, страницы концепции может описывать объект Deployment в Kubernetes и разъяснить, какую роль он играет после развертывания, масштабирования и обновления приложения. Как правило, страницы концепций не включают последовательности шагов, а вместо этого содержат ссылки на задачи или руководства. В качестве примера концептуальной темы посмотрите страницу <a href=/docs/concepts/architecture/nodes/>Nodes</a>.</td></tr><tr><td style=text-align:left>Задача</td><td style=text-align:left>На странице задачи показывается, как сделать что-то одно конкретное, главным образом с помощью короткой последовательности шагов. Страница задачи может быть короткой или длинной, если она остаётся сконцентрированной на одном аспекте. На странице задач можно сочетать краткие объяснения с необходимыми шагами для выполнения, однако если вам нужно дать подробное пояснение, вам следует сделать это в концептуальной теме. Смежные задачи и концептуальные темы должны быть связаны друг с другом. В качестве примера короткой страницы задачи посмотрите <a href=/docs/tasks/configure-pod-container/configure-volume-storage/>Configure a Pod to Use a Volume for Storage</a>. Пример длинной страницы задачи смотрите <a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>Configure Liveness and Readiness Probes</a></td></tr><tr><td style=text-align:left>Руководство</td><td style=text-align:left>На странице руководства показано, как сделать что-то более крупнее одной-единственной задачи. В руководстве может быть несколько последовательностей шагов, которые читатели могут реально выполнить по ходу чтения страницы. Либо на странице руководства могут приведены объяснения связанных частей кода. Например, руководство может содержать разбор примера кода. Руководство может включать в себя краткие объяснения связанной функциональности Kubernetes, но при они этом должны ссылаться на сопутствующие концептуальные темы, где можно узнать подробнее про конкретные возможности.</td></tr></tbody></table><p>Используйте шаблон для каждой новой страницы. Каждый тип страницы использует определённый <a href=/docs/contribute/style/page-templates/>шаблон</a>, поэтому при написании собственных тем вам следует выбрать свой шаблон. Использование шаблонов помогает поддерживать единообразие в темах конкретного типа.</p><h2 id=выбор-заголовка-и-имени-файла-a-title-and-filename>Выбор заголовка и имени файла a title and filename</h2><p>Подберите заголовок, содержащий такие ключевые слова, по которым вы могли его найти в поисковике.
Имя файла должно создаваться из слов в заголовке, написанных через дефис.
Например, для темы с заголовком <a href=/docs/tasks/access-kubernetes-api/http-proxy-access-api/>Using an HTTP Proxy to Access the Kubernetes API</a> имя файла будет <code>http-proxy-access-api.md</code>. Вам не нужно указывать "kubernetes" в имени файла, потому что слово "kubernetes" уже есть в полном URL-адресе темы, например:</p><pre><code>   /docs/tasks/access-kubernetes-api/http-proxy-access-api/
</code></pre><h2 id=добавление-заголовка-темы-в-фронтальную-часть>Добавление заголовка темы в фронтальную часть</h2><p>В <a href=https://gohugo.io/content-management/front-matter/>фронтальную часть</a> файла вашей темы поместите поле заголовка <code>title</code>. Фронтальная часть — YAML-блок, который находится тремя дефисами в самом верху страницы. Например:</p><pre><code>---
title: Using an HTTP Proxy to Access the Kubernetes API
---
</code></pre><h2 id=выбор-директории>Выбор директории</h2><p>В зависимости от типа вашей страницы поместите новый файл в одну из следующую поддиректорию:</p><ul><li>/content/en/docs/tasks/</li><li>/content/en/docs/tutorials/</li><li>/content/en/docs/concepts/</li></ul><p>Вы можете поместить файл в имеющуюся поддиректорию либо создать новую.</p><h2 id=добавление-темы-в-оглавлении>Добавление темы в оглавлении</h2><p>Оглавление динамически генерируется исходя из структуры директорий документации. Корневые директории в <code>/content/en/docs/</code> создают навигацию с основными ссылками, где у каждой поддиректории есть записи в оглавлении.</p><p>В каждой поддиректории есть файл <code>_index.md</code>, представляющий собой "главную" страницу всего содержимого этой поддиректории. В файле <code>_index.md</code> не нужно применять шаблон. В нём находится обзор содержания тем в поддиректории.</p><p>Другие файлы в директории по умолчанию сортируются в алфавитном порядке. Такой порядок сортировки редко устраивает. Для управления такой относительной сортировкой тем в поддиректории, определите ключ <code>weight:</code> с целым числом в фронтальной части файла. Как правило, мы используем значения, кратные 10, чтобы оставить про запас для будущих страниц. Например, тема с весом <code>10</code> будет отображаться перед темой с весом <code>20</code>.</p><h2 id=вставка-кода-в-тему>Вставка кода в тему</h2><p>Если вы хотите добавить код в тему, вы можете встроить код из файла напрямую, используя синтаксис блока кода в Markdown. Такой способ рекомендуется использовать в следующих случаев (это не исчерпывающий список):</p><ul><li>В вашем коде показывается вывод такой команды, как <code>kubectl get deploy mydeployment -o json | jq '.status'</code>.</li><li>Ваш код недостаточно универсален, чтобы пользователи могли его попробовать сами. В качестве примера можно привести пример YAML-файла для создания Pod, который зависит от конкретной реализации <a href=/docs/concepts/storage/volumes#flexvolume>FlexVolume</a>.</li><li>Ваш код — это не готовый пример, потому что он предзначен для выделения части большего файла. Например, при описании способов настройки <a href=/docs/tasks/administer-cluster/sysctl-cluster/#podsecuritypolicy>PodSecurityPolicy</a> по определённым причинам вы можете включить небольшой фрагмент напрямую в файле темы.</li><li>Ваш код по разным причинам не подходит для тестирования пользователями. Например, если вы описываете, как новый атрибут должен добавляться к ресурсу с помощью команды <code>kubectl edit</code>, то вы можете добавить короткий пример, показывающий только добавляемый атрибут.</li></ul><h2 id=добавление-кода-из-другого-файла>Добавление кода из другого файла</h2><p>Другой способ добавить код в вашу тему — создать новый полноценный файл с примером (или группу файлов примеров), а затем из вашей темы подключить этот пример.
Используйте этот метод, чтобы включить универсальный и повторно используемый пример YAML-файла, который читатель может проверить сам.</p><p>При добавлении нового отдельного файла примера, например, в формате YAML, поместите код в одну из директорий <code>&lt;LANG>/examples/</code>, где <code>&lt;LANG></code> — язык темы. В вашем файле темы используйте макрокод <code>codenew</code>:</p><pre tabindex=0><code class=language-none data-lang=none>{{&lt; codenew file=&#34;&lt;RELPATH&gt;/my-example-yaml&gt;&#34; &gt;}}
</code></pre><p>где <code>&lt;RELPATH></code> — это путь к включаемому файлу относительно директории <code>examples</code>. Следующий макрокод Hugo ссылается на YAML-файл по пути <code>/content/en/examples/pods/storage/gce-volume.yaml</code>.</p><pre tabindex=0><code class=language-none data-lang=none>{{&lt; codenew file=&#34;pods/storage/gce-volume.yaml&#34; &gt;}}
</code></pre><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Чтобы отобразить Hugo-макрокоды в исходном виде, как в приведенном выше примере, поместите их в комментарии в стиле языка Си между <code>&lt;</code> и <code>></code>. Для примера посмотрите исходный код этой страницы.</div><h2 id=демонстрация-создания-api-объекта-из-конфигурационного-файла>Демонстрация создания API-объекта из конфигурационного файла</h2><p>Если вам нужно показать, как создать объект API из файла конфигурации, поместите файл конфигурации в одну из директорий в <code>&lt;LANG>/examples</code>.</p><p>В вашей теме укажите эту команду:</p><pre tabindex=0><code>kubectl create -f https://k8s.io/examples/pods/storage/gce-volume.yaml
</code></pre><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> При добавлении новых YAML-файлов в директорию <code>&lt;LANG>/examples</code>, убедитесь, что этот файл перечислен в файле <code>&lt;LANG>/examples_test.go</code>. Подключённый к сайту Travis CI автоматически выполнит этот тестовый сценарий при отправке PR, чтобы проверить все примеры.</div><p>В качестве примера темы, в которой используется этот метод, смотрите <a href=/docs/tutorials/stateful-application/run-stateful-application/>Running a Single-Instance Stateful Application</a>.</p><h2 id=добавление-изображений-в-тему>Добавление изображений в тему</h2><p>Поместите файлы изображений в директорию <code>/images</code>. Предпочтительный формат изображения — SVG.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Подробнее про <a href=/ru/docs/contribute/style/page-templates/>использование шаблонов страниц</a>.</li><li>Подробнее про <a href=/ru/docs/contribute/start/#%D0%BE%D1%82%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0-%D0%BF%D1%83%D0%BB%D1%80%D0%B5%D0%BA%D0%B2%D0%B5%D1%81%D1%82%D0%B0>создание пулреквеста</a>).</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6d95158118c9a27343edd2e6e23f0247>7.4.4 - Использование шаблонов страниц</h1><p>При добавлении новых тем воспользуйтесь одним из перечисленных ниже шаблонов.
Это регламентирует пользовательское восприятие определённой страницы.</p><p>Шаблоны страниц находятся в директории <a href=https://git.k8s.io/website/layouts/partials/templates><code>layouts/partials/templates</code></a> репозитория <a href=https://github.com/kubernetes/website><code>kubernetes/website</code></a>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Каждая новая тема должна использовать шаблон. Если вы не уверены, какой шаблон использовать для новой темы, начните с <a href=#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D0%BA%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%86%D0%B8%D0%B8>шаблона концепции</a>.</div><h2 id=шаблон-концепции>Шаблон концепции</h2><p>Страница концепции объясняет некоторые аспекты Kubernetes. Например, страницы концепции может описывать объект Deployment в Kubernetes и разъяснить какую роль он играет после развертывания, масштабирования и обновления приложения. Как правило, страницы концепций не включают последовательности шагов, и вместо этого содержат ссылки на задачи или руководства.</p><p>Для написания новой страницы концепции в директории <code>/content/en/docs/concepts</code> создайте поддиректорию с Markdown-файлом со следующим требованиями:</p><ul><li><p>Во фронтальной части YAML этой страницы определите поле <code>content_type: concept</code>.</p></li><li><p>В теле страницы укажите переменные <code>capture</code> и любые другие, которые вы хотите включить:</p><table><thead><tr><th>Переменная</th><th>Обязательна?</th></tr></thead><tbody><tr><td>overview</td><td>да</td></tr><tr><td>body</td><td>да</td></tr><tr><td>whatsnext</td><td>нет</td></tr></tbody></table><p>Тело страницы будет выглядеть следующим образом (удалите все необязательные capture-блоки, если они вам не понадобятся):</p><pre tabindex=0><code>{{% capture overview %}}

{{% /capture %}}

{{% capture body %}}

{{% /capture %}}

{{% capture whatsnext %}}

{{% /capture %}}
</code></pre></li><li><p>Заполните каждый раздел информацией. Следуйте этим рекомендациям:</p><ul><li>Структурируйте контент с помощью заголовков H2 и H3.</li><li>В блоке <code>overview</code> одним абзацем сформируйте контекст темы.</li><li>В блоке <code>body</code> объясните суть концепции.</li><li>В блоке <code>whatsnext</code> сформируйте ненумерованный список тем (до 5), к которым нужно обратиться, чтобы получить дополнительную информацию о концепции.</li></ul></li></ul><p><a href=/docs/concepts/overview/working-with-objects/annotations/>Annotations</a> — это готовый пример шаблона концепции. Кстати, текущая страница использует шаблон концепции.</p><h2 id=шаблон-задачи>Шаблон задачи</h2><p>На странице задачи показывается, как сделать что-то одно конкретное, главным образом с помощью короткой последовательности шагов. В страницах задач очень короткое объяснение, хотя они часто ссылаются на концептуальные темы, где уже можно найти соответствующую справочную информацию и ресурсы.</p><p>Для написания новой страницы задачи в директории <code>/content/en/docs/tasks</code> создайте поддиректорию с Markdown-файлом со следующим требованиями:</p><ul><li><p>Во фронтальной части YAML этой страницы определите поле <code>content_type: task</code>.</p></li><li><p>В теле страницы укажите переменные <code>capture</code> и любые другие, которые вы хотите включить:</p><table><thead><tr><th>Переменная</th><th>Обязательна?</th></tr></thead><tbody><tr><td>overview</td><td>да</td></tr><tr><td>prerequisites</td><td>да</td></tr><tr><td>steps</td><td>нет</td></tr><tr><td>discussion</td><td>нет</td></tr><tr><td>whatsnext</td><td>нет</td></tr></tbody></table><p>Тело страницы будет выглядеть следующим образом (удалите все необязательные capture-блоки, если они вам не нужны):</p><pre tabindex=0><code>{{% capture overview %}}

{{% /capture %}}

{{% capture prerequisites %}}

{{&lt; include &#34;task-tutorial-prereqs.md&#34; &gt;}} {{&lt; version-check &gt;}}

{{% /capture %}}

{{% capture steps %}}

{{% /capture %}}

{{% capture discussion %}}

{{% /capture %}}

{{% capture whatsnext %}}

{{% /capture %}}
</code></pre></li><li><p>Заполните каждый блок информацией. Следуйте этим рекомендациям:</p><ul><li>Используйте по минимуму заголовков H2 (с двумя ведущими символами <code>#</code>). У самих разделов заголовок формируется автоматически по заданному шаблону.</li><li>В блоке <code>overview</code> обозначьте контекст для всей темы.</li><li>В блоке <code>prerequisites</code> используйте ненумерованные списки, где это возможно. Добавьте дополнительные предварительные условия ниже <code>include</code>. Предварительные условия по умолчанию содержат пункт про наличие работающего кластера.</li><li>В блоке <code>steps</code> используйте нумерованные списки.</li><li>В блоке <code>discussion</code> подробно распишите информацию, описанную в разделе <code>steps</code>.</li><li>В блоке <code>whatsnext</code> сформируйте ненумерованный список тем (до 5), которые могут быть интересны читателю в качестве дополнительного чтения.</li></ul></li></ul><p>Пример готовой темы, в которой используется шаблон задачи — <a href=/docs/tasks/access-kubernetes-api/http-proxy-access-api>Using an HTTP proxy to access the Kubernetes API</a>.</p><h2 id=шаблон-руководства>Шаблон руководства</h2><p>На странице руководства показывается, как выполнить что-то более крупнее одной-единственной задачи. Как правило, страницы руководства поделена на несколько разделов, в каждом из которых есть последовательность шагов. Например, руководство может включать анализ примера кода, демонстрирующий определенную возможность Kubernetes. Руководства могут содержать поверхностные объяснения и одновременно включать ссылки на соответствующие концептуальные темы для получения углубленных знаний.</p><p>Для написания новой страницы задачи в директории <code>/content/en/docs/tutorials</code> создайте поддиректорию с Markdown-файлом со следующим требованиями:</p><ul><li><p>Во фронтальной части YAML этой страницы определите поле <code>content_type: tutorial</code>.</p></li><li><p>В теле страницы укажите переменные <code>capture</code> и любые другие, которые вы хотите включить:</p><table><thead><tr><th>Переменная</th><th>Обязательна?</th></tr></thead><tbody><tr><td>overview</td><td>да</td></tr><tr><td>prerequisites</td><td>да</td></tr><tr><td>objectives</td><td>да</td></tr><tr><td>lessoncontent</td><td>да</td></tr><tr><td>cleanup</td><td>нет</td></tr><tr><td>whatsnext</td><td>нет</td></tr></tbody></table><p>Тело страницы будет выглядеть следующим образом (удалите все необязательные capture-блоки, если они вам не понадобятся):</p><pre tabindex=0><code>{{% capture overview %}}

{{% /capture %}}

{{% capture prerequisites %}}

{{&lt; include &#34;task-tutorial-prereqs.md&#34; &gt;}} {{&lt; version-check &gt;}}

{{% /capture %}}

{{% capture objectives %}}

{{% /capture %}}

{{% capture lessoncontent %}}

{{% /capture %}}

{{% capture cleanup %}}

{{% /capture %}}

{{% capture whatsnext %}}

{{% /capture %}}
</code></pre></li><li><p>Заполните каждый блок информацией. Следуйте этим рекомендациям:</p><ul><li>Используйте по минимуму заголовков H2 (с двумя ведущими символами <code>#</code>). У самих разделов заголовок формируется автоматически по заданному шаблону.</li><li>В блоке <code>overview</code> обозначьте контекст для всей темы.</li><li>В блоке <code>prerequisites</code> используйте ненумерованные списки, где это возможно. Добавьте дополнительные предварительные условия ниже <code>include</code>. Предварительные условия по умолчанию содержат пункт про наличие работающего кластера.</li><li>В блоке <code>objectives</code> используйте ненумерованные списки.</li><li>В блоке <code>lessoncontent</code> целесообразно используйте совместно нумерованные списки и повествовательное содержание.</li><li>В блоке <code>cleanup</code> используйте нумерованные списки для описания шагов для очистки состояния кластера после выполнения задачи.</li><li>В блоке <code>whatsnext</code> сформируйте ненумерованный список тем (до 5), которые могут быть интересны читателю в качестве дополнительного чтения.</li></ul></li></ul><p>Пример завершенной темы, в которой используется шаблон руководства — <a href=/docs/tutorials/stateless-application/run-stateless-application-deployment/>Running a Stateless Application Using a Deployment</a>.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Подробнее про <a href=/ru/docs/contribute/style/style-guide/>оформление документации</a></li><li>Подробнее про <a href=/ru/docs/contribute/style/content-guide/>содержание документации</a></li><li>Подробнее про <a href=/ru/docs/contribute/style/content-organization/>организацию контента</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-357f2ddd61035f18c2aa63fe86203f9c>7.4.5 - Организация контента</h1><p>Этот сайт использует Hugo. В Hugo <a href=https://gohugo.io/content-management/organization/>организация контента</a> — основная концепция.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> <strong>Подсказка:</strong> при редактировании контента используйте команду <code>hugo server --navigateToChanged</code>, чтобы запустить Hugo.</div><h2 id=списки-страниц>Списки страниц</h2><h3 id=порядок-страницы>Порядок страницы</h3><p>Меню в сайдбаре, каталог страниц документации используют стандартный порядок перечисления Hugo, который сортирует элементы по весу (от 1), дате (начиная с самых новых) и затем по заголовку ссылки.</p><p>Таким образом, если вам нужно поднять страницу или раздел, определите её вес в фронтальной части:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>title</span>:<span style=color:#bbb> </span>Моя страница<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Для значений веса страниц лучше не использовать привычный порядок 1, 2, 3..., а предпочесть другой интервал, например, 10, 20, 30... В будущем это позволит вставить последующие страницы в желаемую позицию.</div><h3 id=главное-меню-документации>Главное меню документации</h3><p>Главное меню <code>Документация</code> состоит из разделов по пути <code>docs/</code> с установленным флагом <code>main_menu</code> в фронтальной части файла раздела <code>_index.md</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>main_menu</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Обратите внимание, что текст ссылки берётся из переменной <code>linkTitle</code>, поэтому, если вы хотите, чтобы он отличался от заголовка страницы, измените его в файле:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>main_menu</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>title</span>:<span style=color:#bbb> </span>Название страницы<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>linkTitle</span>:<span style=color:#bbb> </span>Название, которое будет использоваться в ссылках<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Перечисленные выше переменные должны быть определены для каждого перевода. Если вы не видите созданный вами раздел в меню, скорее всего, это может быть связано с тем, что Hugo не определил его как раздел. Создайте файл <code>_index.md</code> в директории раздела.</div><h3 id=документация-в-боковом-меню>Документация в боковом меню</h3><p>Меню сайдбара в документации собирается из <em>текущего дерева разделов</em> по пути <code>docs/</code>.</p><p>Оно отобразит все разделы и их страницы.</p><p>Если вы хотите, чтобы раздел или страница не отображались в меню, установите для флага <code>toc_hide</code> значение <code>true</code> в фронтальной части файла:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>toc_hide</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>При переходе к непустому разделу будет отображаться указанный раздел или страница (например, <code>_index.md</code>). В противном случае выводиться первая страница в этом разделе.</p><h3 id=каталог-документации>Каталог документации</h3><p>Каталог страниц на главной странице документации сгенерирован с учётом всех разделов и страниц документации.</p><p>Если вы хотите скрыть раздел или страницу, установите для флага <code>toc_hide</code> значение <code>true</code> в фронтальной части файла:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>toc_hide</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=главное-меню>Главное меню</h3><p>Ссылки сайта в верхнем правом меню, а также в футере, создаются посредством сканирования страниц. Этот процесс гарантирует, что страница действительно существует на сайте. Поэтому, если раздела <code>case-studies</code> на сайте (или в переводе) не существует, ссылка не появится.</p><h2 id=пакеты-страниц>Пакеты страниц</h2><p>В дополнение к отдельным страницам с контентом (Markdown-файлам), Hugo поддерживает <a href=https://gohugo.io/content-management/page-bundles/>пакеты страниц (page bundles)</a>.</p><p>К примеру, <a href=/docs/contribute/style/hugo-shortcodes/>пользовательские макрокоды Hugo</a> — узел пакета (<code>leaf bundle</code>). Все, что находится в директории, включая <code>index.md</code>, будет частью пакета. Сюда также относятся относительные ссылки на страницы, изображения, которые могут быть обработаны и т.д.:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>en/docs/home/contribute/includes
</span></span><span style=display:flex><span>├── example1.md
</span></span><span style=display:flex><span>├── example2.md
</span></span><span style=display:flex><span>├── index.md
</span></span><span style=display:flex><span>└── podtemplate.json
</span></span></code></pre></div><p>Другой распространённый пример — это пакет <code>includes</code>. Он устанавливает переменную <code>headless: true</code>, которая означает, что файл не будет доступен по собственному URL-адресу. Вместо этого он будет использоваться в других страницах как вставляемый файл.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>en/includes
</span></span><span style=display:flex><span>├── default-storage-class-prereqs.md
</span></span><span style=display:flex><span>├── federated-task-tutorial-prereqs.md
</span></span><span style=display:flex><span>├── index.md
</span></span><span style=display:flex><span>├── partner-script.js
</span></span><span style=display:flex><span>├── partner-style.css
</span></span><span style=display:flex><span>├── task-tutorial-prereqs.md
</span></span><span style=display:flex><span>├── user-guide-content-moved.md
</span></span><span style=display:flex><span>└── user-guide-migration-notice.md
</span></span></code></pre></div><p>Необходимо отметить следующие особенности файлов в пакетах:</p><ul><li>Для переведенных пакетов любые отсутствующие файлы будут унаследованы от файлов на оригинальном (английском) языке. Это позволяет избежать дублирования.</li><li>Все файлы в пакете — в Hugo называются ресурсы (<code>Resources</code>), в которых вы можете определить метаданные, зависимые от языка, например, параметры и заголовок, даже если они не поддерживают в фронтальной части (YAML-файлы и т.д.). Смотрите <a href=https://gohugo.io/content-management/page-resources/#page-resources-metadata>Метаданные ресурсов страницы</a> для получения дополнительной информации.</li><li>Значение, которое вы получаете через <code>.RelPermalink</code> в <code>Resource</code> будет отличаться в зависимости от страницы. Смотрите <a href=https://gohugo.io/content-management/urls/#permalinks>Постоянные ссылки</a> для получения дополнительной информации.</li></ul><h2 id=стилизация>Стилизация</h2><p>Исходные файлы стилей в формате <a href=https://sass-lang.com/>SASS</a> находятся в директории <code>assets/sass</code> и автоматически собираются Hugo.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Подробнее про <a href=/ru/docs/contribute/style/hugo-shortcodes/>пользовательские макрокоды Hugo</a></li><li>Подробнее про <a href=/ru/docs/contribute/style/style-guide>оформление документации</a></li><li>Подробнее про <a href=/ru/docs/contribute/style/content-guide>содержание документации</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6d76d18115f82583d526bdaf5d05edbc>7.4.6 - Пользовательские макрокоды Hugo</h1><p>На этой странице объясняются пользовательские макрокоды Hugo, которые можно использовать в Markdown-файлах документации Kubernetes.</p><p>Узнать подробнее про макрокоды можно в <a href=https://gohugo.io/content-management/shortcodes>документации Hugo</a>.</p><h2 id=состояние-функциональности>Состояние функциональности</h2><p>В Markdown странице (файл с расширением <code>.md</code>) вы можете добавить макрокод, чтобы отобразить версию и состояние документированной функциональной возможности.</p><h3 id=демонстрация-состояния-функциональности>Демонстрация состояния функциональности</h3><p>Ниже показан фрагмент кода для вывода состояния функциональности, который сообщает о функциональности в стабильной версии Kubernetes 1.10.</p><pre tabindex=0><code>{{&lt; feature-state for_k8s_version=&#34;v1.10&#34; state=&#34;stable&#34; &gt;}}
</code></pre><p>Результат:</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.10 [stable]</code></div><p>Допустимые значения для <code>state</code>:</p><ul><li>alpha</li><li>beta</li><li>deprecated</li><li>stable</li></ul><h3 id=код-состояния-функциональности>Код состояния функциональности</h3><p>По умолчанию отображается версия Kubernetes, соответствующая версии страницы или сайта. Это значение можно переопределить, передав параметр макрокода <code>for_k8s_version</code>.</p><pre tabindex=0><code>{{&lt; feature-state for_k8s_version=&#34;v1.10&#34; state=&#34;stable&#34; &gt;}}
</code></pre><p>Результат:</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.10 [stable]</code></div><h4 id=функциональность-в-альфа-версии>Функциональность в альфа-версии</h4><pre tabindex=0><code>{{&lt; feature-state state=&#34;alpha&#34; &gt;}}
</code></pre><p>Результат:</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [alpha]</code></div><h4 id=функциональность-в-бета-версии>Функциональность в бета-версии</h4><pre tabindex=0><code>{{&lt; feature-state state=&#34;beta&#34; &gt;}}
</code></pre><p>Результат:</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [beta]</code></div><h4 id=функциональность-в-стабильной-версии>Функциональность в стабильной версии</h4><pre tabindex=0><code>{{&lt; feature-state state=&#34;stable&#34; &gt;}}
</code></pre><p>Результат:</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [stable]</code></div><h4 id=устаревшая-функциональность>Устаревшая функциональность</h4><pre tabindex=0><code>{{&lt; feature-state state=&#34;deprecated&#34; &gt;}}
</code></pre><p>Результат:</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [deprecated]</code></div><h2 id=глоссарий>Глоссарий</h2><p>Вы можете сослаться на термины из <a href=/docs/reference/glossary/>глоссария</a> в виде всплывающей (при наведении мыши) подсказки, что удобно при чтении документации через интернет.</p><p>Исходные файлы терминов глоссария хранятся в отдельной директории по URL-адресу <a href=https://github.com/kubernetes/website/tree/master/content/en/docs/reference/glossary>https://github.com/kubernetes/website/tree/master/content/en/docs/reference/glossary</a>.</p><h3 id=демонстрация-глоссария>Демонстрация глоссария</h3><p>Например, следующий фрагмент кода в Markdown будет отображен в виде всплывающей подсказки — <a class=glossary-tooltip title='Набор машин, так называемые узлы, которые запускают контейнеризированные приложения. Кластер имеет как минимум один рабочий узел.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=cluster>cluster</a>:</p><pre tabindex=0><code class=language-liquid data-lang=liquid>{{&lt; glossary_tooltip text=&#34;cluster&#34; term_id=&#34;cluster&#34; &gt;}}
</code></pre><h2 id=заголовки-таблиц>Заголовки таблиц</h2><p>Для улучшения доступности таблиц для программ для чтения с экрана, добавьте заголовок к таблице. Чтобы добавить <a href=https://www.w3schools.com/tags/tag_caption.asp>заголовок</a> таблицы, поместите таблицу в макрокод <code>table</code> и определите значение заголовка в параметре<code> caption</code>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Заголовки таблиц предназначены только для программ чтения с экрана, поэтому в браузере они не будут отображаться.</div><p>Пример:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go-html-template data-lang=go-html-template><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span>table<span style=color:#bbb> </span>caption<span style=color:#666>=</span><span style=color:#b44>&#34;Конфигурационные параметры&#34;</span><span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span>Параметр | Описание | Значение по умолчанию
</span></span><span style=display:flex><span>:---------|:------------|:-------
</span></span><span style=display:flex><span>`timeout` | Тайм-аут для запросов | `30s`
</span></span><span style=display:flex><span>`logLevel` | Уровень логирования | `INFO`
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span><span>/</span>table<span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span></code></pre></div><p>Результат:</p><p>{{&lt; table caption="Конфигурационные параметры" >}}</p><table><thead><tr><th style=text-align:left>Параметр</th><th style=text-align:left>Описание</th><th style=text-align:left>Значение по умолчанию</th></tr></thead><tbody><tr><td style=text-align:left><code>timeout</code></td><td style=text-align:left>Тайм-аут для запросов</td><td style=text-align:left><code>30s</code></td></tr><tr><td style=text-align:left><code>logLevel</code></td><td style=text-align:left>Уровень логирования</td><td style=text-align:left><code>INFO</code></td></tr><tr><td style=text-align:left>{{&lt; /table >}}</td><td></td><td></td></tr></tbody></table><p>Если вы изучите HTML-код таблицы, вы заметите следующий ниже элемент сразу после открывающего элемента <code>&lt;table></code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:green;font-weight:700>caption</span> <span style=color:#b44>style</span><span style=color:#666>=</span><span style=color:#b44>&#34;display: none;&#34;</span>&gt;&lt;/<span style=color:green;font-weight:700>caption</span>&gt;
</span></span></code></pre></div><h2 id=вкладки>Вкладки</h2><p>Страница в формате Markdown (файл с расширением <code>.md</code>) на этом сайте может содержать набор вкладок для отображения нескольких разновидностей определённого решения.</p><p>Макрокод <code>tabs</code> принимает следующие параметры:</p><ul><li><code>name</code>: имя, отображаемое на вкладке.</li><li><code>codelang</code>: если вы указываете встроенный контент для макрокода <code>tab</code>, вы можете сообщить Hugo, какой язык использовать для подсветки синтаксиса.</li><li><code>include</code>: включаемый файл в вкладку. Если вкладка находится в <a href=https://gohugo.io/content-management/page-bundles/#leaf-bundles>узле пакета (leaf bundle)</a> Hugo, то файл (может быть любым MIME-типом, который поддерживает Hugo) ищется в самом пакете. Если нет, то включаемое содержимое ищется относительно текущей страницы. Обратите внимание, что при использовании <code>include</code> вам следует использовать самозакрывающийся синтаксис. Например, <code>{{&lt;/* tab name="Content File #1" include="example1" />}}</code>. Язык может быть указан в <code>codelang</code>, в противном случае язык определяется из имени файла.</li><li>Если содержимое вкладки это Markdown, вам нужно использовать символ <code>%</code>. Например, <code>{{% tab name="Вкладка 1" %}}This is **markdown**{{% /tab %}}</code></li><li>Вы можете совместно использовать перечисленные выше параметры.
Ниже приведена демонстрация шорткода вкладок.</li></ul><p>Ниже приведены примеры вкладок.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> <strong>Имя</strong> вкладки в элементе <code>tabs</code> должно быть уникальным на странице.</div><h3 id=демонстрация-вкладок-подсветка-синтаксиса-в-блоках-кода>Демонстрация вкладок: подсветка синтаксиса в блоках кода</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go-text-template data-lang=go-text-template><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span>tabs<span style=color:#bbb> </span>name<span style=color:#666>=</span><span style=color:#b44>&#34;tab_with_code&#34;</span><span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>{&lt;</span><span style=color:#bbb> </span>tab<span style=color:#bbb> </span>name<span style=color:#666>=</span><span style=color:#b44>&#34;Вкладка 1&#34;</span><span style=color:#bbb> </span>codelang<span style=color:#666>=</span><span style=color:#b44>&#34;bash&#34;</span><span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span>echo &#34;Это вкладка 1.&#34;
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span><span>/</span>tab<span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span>tab<span style=color:#bbb> </span>name<span style=color:#666>=</span><span style=color:#b44>&#34;Вкладка 2&#34;</span><span style=color:#bbb> </span>codelang<span style=color:#666>=</span><span style=color:#b44>&#34;go&#34;</span><span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span>println &#34;Это вкладка 2.&#34;
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span><span>/</span>tab<span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>}
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span><span>/</span>tabs<span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span></code></pre></div><p>Результат:</p><ul class="nav nav-tabs" id=tab-with-code role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-with-code-0 role=tab aria-controls=tab-with-code-0 aria-selected=true>Вкладка 1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-code-1 role=tab aria-controls=tab-with-code-1>Вкладка 2</a></li></ul><div class=tab-content id=tab-with-code><div id=tab-with-code-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-with-code-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Это вкладка 1.&#34;</span>
</span></span></code></pre></div></div><div id=tab-with-code-1 class=tab-pane role=tabpanel aria-labelledby=tab-with-code-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span>println <span style=color:#b44>&#34;Это вкладка 2.&#34;</span>
</span></span></code></pre></div></div></div><h3 id=демонстрация-вкладок-встроенный-markdown-и-html>Демонстрация вкладок: встроенный Markdown и HTML</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go-html-template data-lang=go-html-template><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span>tabs<span style=color:#bbb> </span>name<span style=color:#666>=</span><span style=color:#b44>&#34;tab_with_md&#34;</span><span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>%</span><span style=color:#bbb> </span>tab<span style=color:#bbb> </span>name<span style=color:#666>=</span><span style=color:#b44>&#34;Markdown&#34;</span><span style=color:#bbb> </span><span>%</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span>Это **разметка Markdown.**
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span>note<span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span>Также можно использовать макрокоды.
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span><span>/</span>note<span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>%</span><span style=color:#bbb> </span><span>/</span>tab<span style=color:#bbb> </span><span>%</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span>tab<span style=color:#bbb> </span>name<span style=color:#666>=</span><span style=color:#b44>&#34;HTML&#34;</span><span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span>&lt;<span style=color:green;font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:green;font-weight:700>h3</span>&gt;Обычный HTML&lt;/<span style=color:green;font-weight:700>h3</span>&gt;
</span></span><span style=display:flex><span>	&lt;<span style=color:green;font-weight:700>p</span>&gt;Это &lt;<span style=color:green;font-weight:700>i</span>&gt;обычный&lt;/<span style=color:green;font-weight:700>i</span>&gt; HTML.&lt;/<span style=color:green;font-weight:700>p</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:green;font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span><span>/</span>tab<span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span><span>/</span>tabs<span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span></code></pre></div><p>Результат:</p><ul class="nav nav-tabs" id=tab-with-md role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-with-md-0 role=tab aria-controls=tab-with-md-0 aria-selected=true>Markdown</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-md-1 role=tab aria-controls=tab-with-md-1>HTML</a></li></ul><div class=tab-content id=tab-with-md><div id=tab-with-md-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-with-md-0><p><p>Это <strong>разметка Markdown.</strong></p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Также можно использовать макрокоды.</div></div><div id=tab-with-md-1 class=tab-pane role=tabpanel aria-labelledby=tab-with-md-1><p><div><h3>Обычный HTML</h3><p>Это <i>обычный</i> HTML.</p></div></div></div><h3 id=демонстрация-вкладок-включение-файлов>Демонстрация вкладок: включение файлов</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go-text-template data-lang=go-text-template><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span>tabs<span style=color:#bbb> </span>name<span style=color:#666>=</span><span style=color:#b44>&#34;tab_with_file_include&#34;</span><span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span>tab<span style=color:#bbb> </span>name<span style=color:#666>=</span><span style=color:#b44>&#34;Content File #1&#34;</span><span style=color:#bbb> </span>include<span style=color:#666>=</span><span style=color:#b44>&#34;example1&#34;</span><span style=color:#bbb> </span><span>/&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span>tab<span style=color:#bbb> </span>name<span style=color:#666>=</span><span style=color:#b44>&#34;Content File #2&#34;</span><span style=color:#bbb> </span>include<span style=color:#666>=</span><span style=color:#b44>&#34;example2&#34;</span><span style=color:#bbb> </span><span>/&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span>tab<span style=color:#bbb> </span>name<span style=color:#666>=</span><span style=color:#b44>&#34;JSON File&#34;</span><span style=color:#bbb> </span>include<span style=color:#666>=</span><span style=color:#b44>&#34;podtemplate&#34;</span><span style=color:#bbb> </span><span>/&gt;</span><span style=color:#080>}}</span>
</span></span><span style=display:flex><span><span style=color:#080>{{</span><span>&lt;</span><span style=color:#bbb> </span><span>/</span>tabs<span style=color:#bbb> </span><span>&gt;</span><span style=color:#080>}}</span>
</span></span></code></pre></div><p>Результат:</p><ul class="nav nav-tabs" id=tab-with-file-include role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-with-file-include-0 role=tab aria-controls=tab-with-file-include-0 aria-selected=true>Content File #1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-file-include-1 role=tab aria-controls=tab-with-file-include-1>Content File #2</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-file-include-2 role=tab aria-controls=tab-with-file-include-2>JSON File</a></li></ul><div class=tab-content id=tab-with-file-include><div id=tab-with-file-include-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-with-file-include-0><p><p>Это <strong>пример</strong> содержимого в файле внутри пакета узла <strong>includes</strong>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Подключаемые файлы также могут содержать макрокоды.</div></div><div id=tab-with-file-include-1 class=tab-pane role=tabpanel aria-labelledby=tab-with-file-include-1><p><p>Это другой <strong>пример</strong> содержимого в файле внутри пакета узла <strong>includes</strong>.</p></div><div id=tab-with-file-include-2 class=tab-pane role=tabpanel aria-labelledby=tab-with-file-include-2><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;PodTemplate&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;template&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx&#34;</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;generateName&#34;</span>: <span style=color:#b44>&#34;nginx-&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;containers&#34;</span>: [{
</span></span><span style=display:flex><span>           <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx&#34;</span>,
</span></span><span style=display:flex><span>           <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;dockerfile/nginx&#34;</span>,
</span></span><span style=display:flex><span>           <span style=color:green;font-weight:700>&#34;ports&#34;</span>: [{<span style=color:green;font-weight:700>&#34;containerPort&#34;</span>: <span style=color:#666>80</span>}]
</span></span><span style=display:flex><span>         }]
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div></div></div><h2 id=что-дальше>Что дальше</h2><ul><li>Подробнее про <a href=https://gohugo.io/>Hugo</a>.</li><li>Подробнее про <a href=/ru/docs/contribute/style/write-new-topic/>написание новой темы</a>.</li><li>Подробнее про <a href=/ru/docs/contribute/style/page-templates/>использование шаблонов страниц</a>.</li><li>Подробнее про <a href=/ru/docs/contribute/start/#%D0%BE%D1%82%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0-%D0%BF%D1%83%D0%BB%D1%80%D0%B5%D0%BA%D0%B2%D0%B5%D1%81%D1%82%D0%B0>создание пулреквеста</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-29765496ca296ad24e34e5c0cd42a63f>7.5 - Обзор справочной документации</h1><p>Темы в этом разделе описывают, как генерировать справочные руководства Kubernetes.</p><p>Для сборки справочной документации посмотрите следующий ресурс:</p><ul><li><a href=/docs/contribute/generate-ref-docs/quickstart/>Краткое руководство по генерации справочной документации</a></li></ul></div><div class=td-content><h1 id=pg-a5eac5b2b794f16aa703a2fa212d7c39>7.5.1 - Участие в основном коде Kubernetes</h1><p>На этой странице показано, как поучаствовать в основном содержимом проекта <code>kubernetes/kubernetes</code>.
Вы можете исправить баги, найденные в документации по API Kubernetes или содержимом таких компонентов Kubernetes, как <code>kubeadm</code>, <code>kube-apiserver</code> и <code>kube-controller-manager</code>.</p><p>Если вместо этого вы хотите перегенерировать справочную документацию для API Kubernetes или компонентов с именем <code>kube-*</code> в основном коде, изучите следующие инструкции:</p><ul><li><a href=/ru/docs/contribute/generate-ref-docs/kubernetes-api/>Генерация справочной документации для API Kubernetes</a></li><li><a href=/ru/docs/contribute/generate-ref-docs/kubernetes-components/>Генерация справочной документации для компонентов и инструментов Kubernetes</a></li></ul><h2 id=подготовка-к-работе>Подготовка к работе</h2><ul><li><p>Установленные инструменты:</p><ul><li><a href=https://git-scm.com/book/en/v2/Getting-Started-Installing-Git>Git</a></li><li><a href=https://golang.org/doc/install>Golang</a> версии 1.13+</li><li><a href=https://docs.docker.com/engine/installation/>Docker</a></li><li><a href=https://github.com/coreos/etcd/>etcd</a></li><li><a href=https://www.gnu.org/software/make/>make</a></li><li><a href=https://gcc.gnu.org/>gcc compiler/linker</a></li></ul></li><li><p>Созданная переменная окружения <code>GOPATH</code>, а путь к <code>etcd</code> должен быть прописан в переменной окружения <code>PATH</code>.</p></li><li><p>Вам необходимо знать, как создать пулреквест в репозитории на GitHub.
Это обычно предполагает создание копии репозитория.
Для получения дополнительной информации смотрите страницы <a href=https://help.github.com/articles/creating-a-pull-request/>Создание пулреквеста</a> и <a href=https://gist.github.com/Chaser324/ce0505fbed06b947d962>Стандартный рабочий процесс в GitHub по работе с копией и пулреквестом</a>.</p></li></ul><h2 id=рассмотрение-процесса-в-целом>Рассмотрение процесса в целом</h2><p>Справочная документация для API Kubernetes и таких компонентов с <code>kube-*</code>, как <code>kube-apiserver</code>, <code>kube-controller-manager</code>, автоматически генерируются из исходного кода в <a href=https://github.com/kubernetes/kubernetes/>основном репозитории Kubernetes</a>.</p><p>Если вы заметили баги в сгенерированной документации, попробуйте его исправить через пулреквест в основной проект.</p><h2 id=клонирование-репозитория-kubernetes>Клонирование репозитория Kubernetes</h2><p>Если вы ещё не склонировали репозиторий kubernetes/kubernetes, сделайте это:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir <span style=color:#b8860b>$GOPATH</span>/src
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> <span style=color:#b8860b>$GOPATH</span>/src
</span></span><span style=display:flex><span>go get github.com/kubernetes/kubernetes
</span></span></code></pre></div><p>Определите базовую директорию вашей копии репозитория <a href=https://github.com/kubernetes/kubernetes>kubernetes/kubernetes</a>.
Например, если вы выполнили предыдущий шаг, чтобы получить репозиторий, вашей базовой директорией будет <code>$GOPATH/src/github.com/kubernetes/kubernetes</code>.
В остальных команд базовая директория будет именоваться как <code>&lt;k8s-base></code>.</p><p>Определите базовую директорию вашей копии репозитория <a href=https://github.com/kubernetes-sigs/reference-docs>kubernetes-sigs/reference-docs</a>. Например, если вы выполнили предыдущий шаг, чтобы получить репозиторий, вашей базовой директорией будет <code>$GOPATH/src/github.com/kubernetes-sigs/reference-docs</code>.
В остальных команд базовая директория будет именоваться как <code>&lt;rdocs-base></code>.</p><h2 id=редактирование-исходного-кода-kubernetes>Редактирование исходного кода Kubernetes</h2><p>Справочная документация API Kubernetes генерируется автоматически из спецификации OpenAPI в исходном коде Kubernetes. Если вы хотите изменить справочную документацию API, сначала нужно изменить один или несколько комментариев в исходном коде Kubernetes.</p><p>Документация для компонентов <code>kube-*</code> также генерируется из основного исходного кода. Для изменения генерируемой документации вам нужно изменить соответствующий код компонента.</p><h3 id=внесение-изменений-в-основной-исходный-код>Внесение изменений в основной исходный код</h3><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Следующие шаги служат примером, а не общим порядком действий. Детали могут отличаться в вашей ситуации.</div><p>Рассмотрим пример редактирования комментария в исходном коде Kubernetes.</p><p>В вашем локальном репозитории kubernetes/kubernetes переключитесь на ветку master и проверьте, что она актуальна:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> &lt;k8s-base&gt;
</span></span><span style=display:flex><span>git checkout master
</span></span><span style=display:flex><span>git pull https://github.com/kubernetes/kubernetes master
</span></span></code></pre></div><p>Предположим, что в исходном файле в ветке master есть опечатка "atmost":</p><p><a href=https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/api/apps/v1/types.go>kubernetes/kubernetes/staging/src/k8s.io/api/apps/v1/types.go</a></p><p>В вашем локальном окружении откройте <code>types.go</code> и измените "atmost" на "at most".</p><p>Убедитесь, что вы изменили файл:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>git status
</span></span></code></pre></div><p>Вывод этой команды покажет, что вы находитесь в ветке master и был изменён исходный файл <code>types.go</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>On branch master
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>    modified:   staging/src/k8s.io/api/apps/v1/types.go
</span></span></code></pre></div><h3 id=фиксация-отредактированного-файла>Фиксация отредактированного файла</h3><p>Выполните команду <code>git add</code> и <code>git commit</code>, чтобы зафиксировать внесенные вами изменения. На следующем шаге вы сделаете второй коммит. Следует отметить, что ваши изменения должны быть разделены на коммита.</p><h3 id=генерация-спецификации-openapi-и-сопутствующих-файлов>Генерация спецификации OpenAPI и сопутствующих файлов</h3><p>Перейдите в директорию <code>&lt;k8s-base></code> и выполните следующие скрипты:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>hack/update-generated-swagger-docs.sh
</span></span><span style=display:flex><span>hack/update-openapi-spec.sh
</span></span><span style=display:flex><span>hack/update-generated-protobuf.sh
</span></span></code></pre></div><p>Выполните команду <code>git status</code>, чтобы посмотреть, какие файлы изменились.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>On branch master
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>    modified:   api/openapi-spec/swagger.json
</span></span><span style=display:flex><span>    modified:   api/openapi-spec/v3/apis__apps__v1_openapi.json
</span></span><span style=display:flex><span>    modified:   pkg/generated/openapi/zz_generated.openapi.go
</span></span><span style=display:flex><span>    modified:   staging/src/k8s.io/api/apps/v1/generated.proto
</span></span><span style=display:flex><span>    modified:   staging/src/k8s.io/api/apps/v1/types_swagger_doc_generated.go
</span></span></code></pre></div><p>Изучите содержимое файла <code>api/openapi-spec/swagger.json</code>, чтобы убедиться в том, что опечатка была исправлена.
Например, для этого вы можете выполнить команду <code>git diff -a api/openapi-spec/swagger.json</code>.
Это важно, потому что изменённый файл <code>swagger.json</code> является результатом второй стадии процесса генерации документации.</p><p>Выполните команду <code>git add</code> и <code>git commit</code> для фиксации ваших изменения. Теперь вы можете увидеть два новых коммита:
первый содержит отредактированный файл <code>types.go</code>, а второй — сгенерированную спецификацию OpenAPI и сопутствующие файлы. Оформляйте эти изменения в виде двух отдельных коммитов. Это означает, что не нужно объединять коммиты.</p><p>Отправьте свои изменения как <a href=https://help.github.com/articles/creating-a-pull-request/>пулреквест</a> в ветку master репозитория <a href=https://github.com/kubernetes/kubernetes>kubernetes/kubernetes</a>.
Отслеживайте пулреквест и по мере необходимости отвечайте на комментарии рецензента. Не забывайте отслеживать активность в пулреквест до тех пор, пока он не будет принят.</p><p><a href=https://github.com/kubernetes/kubernetes/pull/57758>PR 57758</a> — пример пулреквеста, который исправляет опечатку в исходном коде Kubernetes.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Не всегда легко правильно определить, какой исходный файл нужно изменить. В предыдущем примере нужный исходный файл находится в директории <code>staging</code> в репозитории <code>kubernetes/kubernetes</code>. Однако в вашей ситуации файл для изменения может находится в другом месте, нежели чем в директории <code>staging</code>. Для получения помощи изучите файлы <code>README</code> в репозитории <a href=https://github.com/kubernetes/kubernetes/tree/master/staging>kubernetes/kubernetes</a> и в смежных репозиториях, например, <a href=https://github.com/kubernetes/apiserver/blob/master/README.md>kubernetes/apiserver</a>.</div><h3 id=применение-вашего-коммита-в-ветку-выпуска>Применение вашего коммита в ветку выпуска</h3><p>В предыдущем разделе вы отредактировали файл в ветке master, а затем запустили скрипты для генерации спецификации OpenAPI и смежных файлов. Затем вы отправили свои изменения в виде пулреквеста в ветку master репозитория kubernetes/kubernetes. Теперь представим, что вам нужно бэкпортировать изменения в ветку выпуска. К примеру, ветка master используется для разработки Kubernetes версии 1.10, а вы хотите применить ваши изменения в ветке release-1.9.</p><p>Напомним, что в вашем пулреквесте есть два коммита: первый для редактирования <code>types.go</code>, а второй — для файлов, сгенерированных скриптами. Следующий шаг — применить сделанный вами первый коммит в ветку release-1.9. Суть в том, чтобы выбрать коммит, который изменяет файл <code>types.go</code>, а не коммит с результатами выполнения скриптов. За инструкциями обратитесь к странице <a href=https://git.k8s.io/community/contributors/devel/sig-release/cherry-picks.md>Propose a Cherry Pick</a>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Применение коммита требует наличия возможности добавить метку и этап в вашем пулреквесте. Если у вас нет таких разрешений, вам нужно переговорить с кем-то, кто может сделать это для вас.</div><p>Когда в вашем пулреквесте есть определённый коммит, который нужно применить в ветке release-1.9, вам нужно запустить перечисленные ниже скрипты в этой вете из вашего локального окружения.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>hack/update-generated-swagger-docs.sh
</span></span><span style=display:flex><span>hack/update-openapi-spec.sh
</span></span><span style=display:flex><span>hack/update-generated-protobuf.sh
</span></span><span style=display:flex><span>hack/update-api-reference-docs.sh
</span></span></code></pre></div><p>Теперь зафиксируйте изменения в вашем пулреквесте с применённым коммитом, теперь там будет сгенерированная спецификация OpenAPI и связанные с ней файлы. Отслеживайте этот пулреквест до тех пор, пока он не будет объединен в ветке release-1.9.</p><p>Сейчас у вас и в ветке master, и в ветке release-1.9 есть обновленный файл <code>types.go</code> вместе с множеством сгенерированных файлов, в которых отражаются изменения, внесенные вами в <code>types.go</code>. Обратите внимание, что сгенерированная спецификация OpenAPI и другие сгенерированные файлы в ветке release-1.9 не обязательно совпадают с сгенерированными файлами в ветке master. Сгенерированные файлы в ветке release-1.9 содержат элементы API только из Kubernetes 1.9. Сгенерированные файлы в ветке master могут содержать элементы API не только для версии 1.9, но и для 1.10, которая ещё находится в разработке.</p><h2 id=генерация-справочной-документации>Генерация справочной документации</h2><p>В предыдущем разделе было показано, как отредактировать исходный файл, а затем сгенерировать несколько файлов, включая <code>api/openapi-spec/swagger.json</code> в репозитории <code>kubernetes/kubernetes</code>.
Файл <code>swagger.json</code> — это файл определения OpenAPI, который используется для генерации справочной документации API.</p><p>Теперь вы можете приступить к изучению руководству <a href=/ru/docs/contribute/generate-ref-docs/kubernetes-api/>Генерация справочной документации для API Kubernetes</a>, чтобы создать <a href=/docs/reference/generated/kubernetes-api/v1.25/>справочную документацию API Kubernetes</a>.</p><h2 id=что-дальше>Что дальше</h2><ul><li><a href=/ru/docs/contribute/generate-ref-docs/kubernetes-api/>Генерация справочной документации для API Kubernetes</a></li><li><a href=/ru/docs/contribute/generate-ref-docs/kubernetes-components/>Генерация справочной документации для компонентов и инструментов Kubernetes</a></li><li><a href=/ru/docs/contribute/generate-ref-docs/kubectl/>Генерация справочной документации для команд kubectl</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f4f605fa4c2e23622d56b067ef56c239>7.5.2 - Руководство по быстрому старту</h1><p>На этой странице показано, как использовать скрипт <code>update-imported-docs</code> для генерации справочной документации Kubernetes. Скрипт автоматизирует настройку сборки и генерирует справочную документацию для выпуска.</p><h2 id=подготовка-к-работе>Подготовка к работе</h2><h3 id=требования>Требования:</h3><ul><li><p>Наличие компьютера под управлением ОС Linux или macOS.</p></li><li><p>Установленные следующие инструменты:</p><ul><li><a href=https://www.python.org/downloads/>Python</a> версии 3.7.x</li><li><a href=https://git-scm.com/book/en/v2/Getting-Started-Installing-Git>Git</a></li><li><a href=https://golang.org/doc/install>Golang</a> версии 1.13+</li><li><a href=https://pypi.org/project/pip/>Pip</a>, который потребуется для установки PyYAML</li><li><a href=https://pyyaml.org/>PyYAML</a> версии 5.1.2</li><li><a href=https://www.gnu.org/software/make/>make</a></li><li><a href=https://gcc.gnu.org/>gcc compiler/linker</a></li><li><a href=https://docs.docker.com/engine/installation/>Docker</a> (требуется только для справочника команды <code>kubectl</code>)</li></ul></li><li><p>В переменной окружении <code>PATH</code> должны прописаны пути до необходимых инструментов сборки, таких как <code>Go</code> и <code>python</code>.</p></li><li><p>Вам нужно знать, как создать пулреквест в репозитории на GitHub.
Для этого нужно создание собственной копии репозитория. Для получения дополнительной информации смотрите раздел <a href=/ru/docs/contribute/intermediate/#%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D0%B8%D0%B7-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%BA%D0%BE%D0%BF%D0%B8%D0%B8>Работа из локальной копии</a>.</p></li></ul><h2 id=получение-репозитория-документации>Получение репозитория документации</h2><p>Убедитесь, что ваша копия репозитория <code>website</code> обновлена в соответствии с оригинальным репозиторием <code>kubernetes/website</code>, а затем склонируйте вашу копию <code>website</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir github.com
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> github.com
</span></span><span style=display:flex><span>git clone git@github.com:&lt;your_github_username&gt;/website.git
</span></span></code></pre></div><p>Определите базовую директорию вашей копии. Например, при выполнении предыдущего блока команд, то базовой директорией будет <code>website</code>. Далее в этом руководстве базовая директория в командах будет обозначаться <code>&lt;web-base></code>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Если вы хотите изменить контент инструментов компонента и справочник API, посмотрите <a href=/docs/contribute/generate-ref-docs/contribute-upstream>руководство по участию в оригинальной документации</a>.</div><h2 id=краткий-обзор-update-imported-docs>Краткий обзор update-imported-docs</h2><p>Скрипт <code>update-imported-docs</code> находится в директории <code>&lt;web-base>/update-imported-docs/</code>.</p><p>Этот скрипт генерирует следующие справочники:</p><ul><li>Справочные страницы для компонентов и инструментов</li><li>Справочник команды <code>kubectl</code></li><li>API-справочник Kubernetes</li></ul><p>Скрипт <code>update-imported-docs</code> генерирует справочную документацию Kubernetes из исходного кода Kubernetes. Скрипт создает временную директорию <code>/tmp</code> на вашем компьютере и клонирует необходимые репозитории в эту директорию: <code>kubernetes/kubernetes</code> и <code>kubernetes-sigs/reference-docs</code>.
Скрипт добавляет путь временной директории в переменную окружения <code>GOPATH</code>.
Кроме этого определяются три дополнительные переменные среды:</p><ul><li><code>K8S_RELEASE</code></li><li><code>K8S_ROOT</code></li><li><code>K8S_WEBROOT</code></li></ul><p>Для успешного выполнения скрипта нужно передать два аргумента:</p><ul><li>Конфигурационный файл в формате YAML (<code>reference.yml</code>)</li><li>Версия выпуска, например, <code>1.17</code></li></ul><p>Конфигурационный файл содержит поле <code>generate-command</code>.
Поле <code>generate-command</code> определяет ряд инструкций для сборки из <code>kubernetes-sigs/reference-docs/Makefile</code>. Переменная <code>K8S_RELEASE</code> определяет версию выпуска.</p><p>Скрипт <code>update-imported-docs</code> выполняет следующие шаги:</p><ol><li>Клонирует репозитории, указанные в конфигурационном файле. Для генерации справочной документации клонируемым репозиторием по умолчанию является <code>kubernetes-sigs/reference-docs</code>.</li><li>Запускает команды в клонированных репозиториях для подготовки генератора документации, а затем генерирует файлы HTML и Markdown.</li><li>Копирует сгенерированные файлы HTML и Markdown в локальную копию репозитория <code>&lt;web-base></code> в директории, указанные в конфигурационном файле.</li><li>Обновляет ссылки на команды <code>kubectl</code> из <code>kubectl</code>.md, ссылаясь на разделы в справочнике по команде <code>kubectl</code>.
.
Когда сгенерированные файлы находятся в вашем локальной копии репозитория <code>&lt;web-base></code>, вы можете отправить их в виде <a href=/ru/docs/contribute/start/>пулреквеста</a> в оригинальный репозиторий <code>&lt;web-base></code>.</li></ol><h2 id=формат-конфигурационного-файла>Формат конфигурационного файла</h2><p>Каждый конфигурационный файл может содержать несколько репозиториев, которые будут импортированы вместе. При необходимости вы можете вручную изменить конфигурационный файл. Вы можете создавать новые конфигурационные файлы для импорта других групп документации.
Ниже приведен пример файла конфигурации в формате YAML:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>repos</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>community<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>remote</span>:<span style=color:#bbb> </span>https://github.com/kubernetes/community.git<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>branch</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>files</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>src</span>:<span style=color:#bbb> </span>contributors/devel/README.md<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>dst</span>:<span style=color:#bbb> </span>docs/imported/community/devel.md<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>src</span>:<span style=color:#bbb> </span>contributors/guide/README.md<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>dst</span>:<span style=color:#bbb> </span>docs/imported/community/guide.md<span style=color:#bbb>
</span></span></span></code></pre></div><p>Каждый Markdown-файл документации, импортированный инструментом, должен соответствовать <a href=/docs/contribute/style/style-guide/>руководству по оформлению документации</a>.</p><h2 id=настройка-reference-yml>Настройка reference.yml</h2><p>Откройте файл <code>&lt;web-base>/update-imported-docs/reference.yml</code> для редактирования.
Не изменяйте значение в поле <code>generate-command</code>, если не понимаете, как эта команда используется для сборки справочников.
Вам нет необходимости править файл <code>reference.yml</code>. В некоторых случаях изменения в исходном коде основного репозитория могут потребовать внесения изменений в конфигурационный файл (например, зависимости версий golang и изменения сторонних библиотек).
Если у вас возникли проблемы со сборкой, обратитесь за помощью к команде SIG-Docs на канале <a href=https://kubernetes.slack.com>#sig-docs в Slack Kubernetes</a>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Команда <code>generate-command</code> является необязательной, её можно использовать для выполнения указанной команды или небольшого скрипта, чтобы сгенерировать документацию из репозитория.</div><p>В файле <code>reference.yml</code> секция <code>files</code> содержат список полей <code>src</code> и <code>dst</code>.
В поле <code>src</code> хранится путь к сгенерированному Markdown-файлу в клонированной директории сборки <code>kubernetes-sigs/reference-docs</code>, а поле <code>dst</code> определяет, куда скопировать этот файл в клонированном репозитории <code>kubernetes/website</code>.
Например:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>repos</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>reference-docs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>remote</span>:<span style=color:#bbb> </span>https://github.com/kubernetes-sigs/reference-docs.git<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>files</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>src</span>:<span style=color:#bbb> </span>gen-compdocs/build/kube-apiserver.md<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>dst</span>:<span style=color:#bbb> </span>content/en/docs/reference/command-line-tools-reference/kube-apiserver.md<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>Обратите внимание, что в случае наличия множества файлов, которые нужно скопировать из одной директории в другую, то для это можете воспользоваться подстановочными знаки в поле <code>src</code>. Вам нужно указать имя директории в поле <code>dst</code>.
Например:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>files</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>src</span>:<span style=color:#bbb> </span>gen-compdocs/build/kubeadm*.md<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>dst</span>:<span style=color:#bbb> </span>content/en/docs/reference/setup-tools/kubeadm/generated/<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=запуск-инструмента-update-imported-docs>Запуск инструмента update-imported-docs</h2><p>Вы можете запустить инструмент <code>update-imported-docs</code> следующим образом:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> &lt;web-base&gt;/update-imported-docs
</span></span><span style=display:flex><span>./update-imported-docs &lt;configuration-file.yml&gt; &lt;release-version&gt;
</span></span></code></pre></div><p>Например:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>./update-imported-docs reference.yml 1.17
</span></span></code></pre></div><h2 id=исправление-ссылок>Исправление ссылок</h2><p>Конфигурационный файл <code>release.yml</code> содержит инструкции по исправлению относительных ссылок
Для исправления относительных ссылок в импортированных файлах, установите для свойство <code>gen-absolute-links</code> в значение <code>true</code>. В качестве примера можете посмотреть файл <a href=https://github.com/kubernetes/website/blob/main/update-imported-docs/release.yml><code>release.yml</code></a>.</p><h2 id=внесение-изменений-в-kubernetes-website>Внесение изменений в kubernetes/website</h2><p>Список сгенерированных и скопированных файлов в <code>&lt;web-base></code> можно узнать, как показано ниже:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> &lt;web-base&gt;
</span></span><span style=display:flex><span>git status
</span></span></code></pre></div><p>В выводе команды будут показаны новые и измененные файлы. Полученный вывод может отличаться в зависимости от изменений основного исходного кода.</p><h3 id=сгенерированные-файлы-инструментом>Сгенерированные файлы инструментом</h3><pre tabindex=0><code>content/en/docs/reference/command-line-tools-reference/cloud-controller-manager.md
content/en/docs/reference/command-line-tools-reference/kube-apiserver.md
content/en/docs/reference/command-line-tools-reference/kube-controller-manager.md
content/en/docs/reference/command-line-tools-reference/kube-proxy.md
content/en/docs/reference/command-line-tools-reference/kube-scheduler.md
content/en/docs/reference/setup-tools/kubeadm/generated/kubeadm.md
content/en/docs/reference/kubectl/kubectl.md
</code></pre><h3 id=сгенерированные-справочные-файлы-для-команды-kubectl>Сгенерированные справочные файлы для команды kubectl</h3><pre tabindex=0><code>static/docs/reference/generated/kubectl/kubectl-commands.html
static/docs/reference/generated/kubectl/navData.js
static/docs/reference/generated/kubectl/scroll.js
static/docs/reference/generated/kubectl/stylesheet.css
static/docs/reference/generated/kubectl/tabvisibility.js
static/docs/reference/generated/kubectl/node_modules/bootstrap/dist/css/bootstrap.min.css
static/docs/reference/generated/kubectl/node_modules/highlight.js/styles/default.css
static/docs/reference/generated/kubectl/node_modules/jquery.scrollto/jquery.scrollTo.min.js
static/docs/reference/generated/kubectl/node_modules/jquery/dist/jquery.min.js
static/docs/reference/generated/kubectl/css/font-awesome.min.css
</code></pre><h3 id=сгенерированные-файлы-и-директории-для-справочника-api-kubernetes>Сгенерированные файлы и директории для справочника API Kubernetes</h3><pre tabindex=0><code>static/docs/reference/generated/kubernetes-api/v1.17/index.html
static/docs/reference/generated/kubernetes-api/v1.17/js/navData.js
static/docs/reference/generated/kubernetes-api/v1.17/js/scroll.js
static/docs/reference/generated/kubernetes-api/v1.17/js/query.scrollTo.min.js
static/docs/reference/generated/kubernetes-api/v1.17/css/font-awesome.min.css
static/docs/reference/generated/kubernetes-api/v1.17/css/bootstrap.min.css
static/docs/reference/generated/kubernetes-api/v1.17/css/stylesheet.css
static/docs/reference/generated/kubernetes-api/v1.17/fonts/FontAwesome.otf
static/docs/reference/generated/kubernetes-api/v1.17/fonts/fontawesome-webfont.eot
static/docs/reference/generated/kubernetes-api/v1.17/fonts/fontawesome-webfont.svg
static/docs/reference/generated/kubernetes-api/v1.17/fonts/fontawesome-webfont.ttf
static/docs/reference/generated/kubernetes-api/v1.17/fonts/fontawesome-webfont.woff
static/docs/reference/generated/kubernetes-api/v1.17/fonts/fontawesome-webfont.woff2
</code></pre><p>Выполните <code>git add</code> и <code>git commit</code>, чтобы зафиксировать файлы в репозитории.</p><h2 id=создание-пулреквеста>Создание пулреквеста</h2><p>Создайте пулреквест в репозиторий <code>kubernetes/website</code>. Отслеживайте свой пулреквест и при необходимости отвечайте на комментарии. Не забывайте отслеживать активность в собственном пулреквесте до тех пор, пока он не будет принят.</p><p>Спустя несколько минут после принятия вашего пулреквеста, обновленные темы справочника будут отображены в <a href=/ru/docs/home/>документации</a>.</p><h2 id=что-дальше>Что дальше</h2><p>Для генерации отдельной взятой справочной документации путём ручной настройки необходимых репозиториев сборки и выполнении скриптов сборки обратитесь к следующим руководствам:</p><ul><li><a href=/ru/docs/contribute/generate-ref-docs/kubernetes-components/>Генерация справочной документации для компонентов и инструментов Kubernetes</a></li><li><a href=/ru/docs/contribute/generate-ref-docs/kubectl/>Генерация справочной документации для команд kubectl</a></li><li><a href=/ru/docs/contribute/generate-ref-docs/kubernetes-api/>Генерация справочной документации для API Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6e4e78f20e40bac9bcad59941e974af6>7.5.3 - Генерация справочной документации для API Kubernetes</h1><p>На этой странице рассказывается про обновление справочной документации по API Kubernetes.</p><p>Справочная документация по API Kubernetes собирается из <a href=https://github.com/kubernetes/kubernetes/blob/master/api/openapi-spec/swagger.json>спецификации OpenAPI Kubernetes</a> с использованием инструмента генерации <a href=https://github.com/kubernetes-sigs/reference-docs>kubernetes-sigs/reference-docs</a>.</p><p>Если вы нашли баги в сгенерированной документации, то можете <a href=/docs/contribute/generate-ref-docs/contribute-upstream/>исправить их в основном коде</a>.</p><p>Продолжайте чтение данной странице, если вы хотите перегенерировать справочную документацию из спецификации <a href=https://github.com/OAI/OpenAPI-Specification>OpenAPI</a>.</p><h2 id=подготовка-к-работе>Подготовка к работе</h2><h3 id=требования>Требования:</h3><ul><li><p>Наличие компьютера под управлением ОС Linux или macOS.</p></li><li><p>Установленные следующие инструменты:</p><ul><li><a href=https://www.python.org/downloads/>Python</a> версии 3.7.x</li><li><a href=https://git-scm.com/book/en/v2/Getting-Started-Installing-Git>Git</a></li><li><a href=https://golang.org/doc/install>Golang</a> версии 1.13+</li><li><a href=https://pypi.org/project/pip/>Pip</a>, который потребуется для установки PyYAML</li><li><a href=https://pyyaml.org/>PyYAML</a> версии 5.1.2</li><li><a href=https://www.gnu.org/software/make/>make</a></li><li><a href=https://gcc.gnu.org/>gcc compiler/linker</a></li><li><a href=https://docs.docker.com/engine/installation/>Docker</a> (требуется только для справочника команды <code>kubectl</code>)</li></ul></li><li><p>В переменной окружении <code>PATH</code> должны прописаны пути до необходимых инструментов сборки, таких как <code>Go</code> и <code>python</code>.</p></li><li><p>Вам нужно знать, как создать пулреквест в репозитории на GitHub.
Для этого нужно создание собственной копии репозитория. Для получения дополнительной информации смотрите раздел <a href=/ru/docs/contribute/intermediate/#%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D0%B8%D0%B7-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%BA%D0%BE%D0%BF%D0%B8%D0%B8>Работа из локальной копии</a>.</p></li></ul><h2 id=настройка-локальных-репозиториев>Настройка локальных репозиториев</h2><p>Создайте рабочую область и определите переменную окружения <code>GOPATH</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir -p <span style=color:#b8860b>$HOME</span>/&lt;workspace&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>GOPATH</span><span style=color:#666>=</span><span style=color:#b8860b>$HOME</span>/&lt;workspace&gt;
</span></span></code></pre></div><p>Загрузите локальные копии следующих репозиториев:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go get -u github.com/kubernetes-sigs/reference-docs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>go get -u github.com/go-openapi/loads
</span></span><span style=display:flex><span>go get -u github.com/go-openapi/spec
</span></span></code></pre></div><p>Если у вас ещё нет копии репозитория kubernetes/website, клонируйте её на свой компьютер:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>git clone https://github.com/&lt;your-username&gt;/website <span style=color:#b8860b>$GOPATH</span>/src/github.com/&lt;your-username&gt;/website
</span></span></code></pre></div><p>Склонируйте репозиторий kubernetes/kubernetes по пути k8s.io/kubernetes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>git clone https://github.com/kubernetes/kubernetes <span style=color:#b8860b>$GOPATH</span>/src/k8s.io/kubernetes
</span></span></code></pre></div><ul><li><p>Определите базовую директорию вашей копии репозитория <a href=https://github.com/kubernetes/kubernetes>kubernetes/kubernetes</a>.
Например, если вы выполнили предыдущий шаг, чтобы получить репозиторий, вашей базовой директорией будет <code>$GOPATH/src/k8s.io/kubernetes</code>.
В остальных командах базовая директория будет именоваться как <code>&lt;k8s-base></code>.</p></li><li><p>Определите базовую директорию вашей копии репозитория <a href=https://github.com/kubernetes/website>kubernetes/website</a>.
Например, если вы выполнили предыдущий шаг, чтобы получить репозиторий, вашей базовой директорией будет <code>$GOPATH/src/github.com/&lt;your-username>/website</code>.
В остальных командах базовая директория будет именоваться как <code>&lt;web-base></code>.</p></li><li><p>Определите базовую директорию вашей копии репозитория <a href=https://github.com/kubernetes-sigs/reference-docs>kubernetes-sigs/reference-docs</a>.
Например, если вы выполнили предыдущий шаг, чтобы получить репозиторий, вашей базовой директорией будет <code>$GOPATH/src/github.com/kubernetes-sigs/reference-docs</code>.
В остальных командах базовая директория будет именоваться как <code>&lt;rdocs-base></code>.</p></li></ul><h2 id=генерация-справочной-документации-api>Генерация справочной документации API</h2><p>Далее в этом разделе рассматривается генерация <a href=/docs/reference/generated/kubernetes-api/v1.25/>справочной документации по API Kubernetes</a>.</p><h3 id=настройка-переменных-для-сборки>Настройка переменных для сборки</h3><ul><li><code>K8S_ROOT</code> со значением <code>&lt;k8s-base></code>.</li><li><code>K8S_WEBROOT</code> со значением <code>&lt;web-base></code>.</li><li><code>K8S_RELEASE</code> со значением нужной версии документации.
Например, если вы хотите собрать документацию для Kubernetes версии 1.17.0, определите переменную окружения <code>K8S_RELEASE</code> со значением 1.17.0.</li></ul><p>Примеры:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>K8S_WEBROOT</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>GOPATH</span><span style=color:#b68;font-weight:700>}</span>/src/github.com/&lt;your-username&gt;/website
</span></span><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>K8S_ROOT</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>GOPATH</span><span style=color:#b68;font-weight:700>}</span>/src/k8s.io/kubernetes
</span></span><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>K8S_RELEASE</span><span style=color:#666>=</span>1.17.0
</span></span></code></pre></div><h3 id=создание-версионированной-директории-и-получение-open-api-spec>Создание версионированной директории и получение Open API spec</h3><p>Скрипт сборки <code>updateapispec</code> создает версионированную директорию для сборки.
После создания директории спецификация Open API генерируется из репозитория <code>&lt;k8s-base></code>. Таким образом версия конфигурационных файлов и спецификация Kubernetes Open API будут совпадать с версией выпуска.
Имя версионированной директории имеет следующий вид: <code>v&lt;major>_&lt;minor></code>.</p><p>В директории <code>&lt;rdocs-base></code> выполните следующий скрипт сборки:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> &lt;rdocs-base&gt;
</span></span><span style=display:flex><span>make updateapispec
</span></span></code></pre></div><h3 id=сборка-справочной-документации-api>Сборка справочной документации API</h3><p>Скрипт сборки <code>copyapi</code> создает справочник API и копирует генерированные файлы в каталоги в <code>&lt;web-base></code>.
Выполните следующую команду в <code>&lt;rdocs-base></code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> &lt;rdocs-base&gt;
</span></span><span style=display:flex><span>make copyapi
</span></span></code></pre></div><p>Убедитесь в том, что перечисленные ниже два файлы были сгенерированы:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#666>[</span> -e <span style=color:#b44>&#34;&lt;rdocs-base&gt;/gen-apidocs/build/index.html&#34;</span> <span style=color:#666>]</span> <span style=color:#666>&amp;&amp;</span> <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;index.html built&#34;</span> <span style=color:#666>||</span> <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;no index.html&#34;</span>
</span></span><span style=display:flex><span><span style=color:#666>[</span> -e <span style=color:#b44>&#34;&lt;rdocs-base&gt;/gen-apidocs/build/navData.js&#34;</span> <span style=color:#666>]</span> <span style=color:#666>&amp;&amp;</span> <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;navData.js built&#34;</span> <span style=color:#666>||</span> <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;no navData.js&#34;</span>
</span></span></code></pre></div><p>Перейдите в корень директории <code>&lt;web-base></code> и посмотрите, какие файлы были изменены:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> &lt;web-base&gt;
</span></span><span style=display:flex><span>git status
</span></span></code></pre></div><p>Вывод команды будет примерно следующим:</p><pre tabindex=0><code>static/docs/reference/generated/kubernetes-api/v1.17/css/bootstrap.min.css
static/docs/reference/generated/kubernetes-api/v1.17/css/font-awesome.min.css
static/docs/reference/generated/kubernetes-api/v1.17/css/stylesheet.css
static/docs/reference/generated/kubernetes-api/v1.17/fonts/FontAwesome.otf
static/docs/reference/generated/kubernetes-api/v1.17/fonts/fontawesome-webfont.eot
static/docs/reference/generated/kubernetes-api/v1.17/fonts/fontawesome-webfont.svg
static/docs/reference/generated/kubernetes-api/v1.17/fonts/fontawesome-webfont.ttf
static/docs/reference/generated/kubernetes-api/v1.17/fonts/fontawesome-webfont.woff
static/docs/reference/generated/kubernetes-api/v1.17/fonts/fontawesome-webfont.woff2
static/docs/reference/generated/kubernetes-api/v1.17/index.html
static/docs/reference/generated/kubernetes-api/v1.17/js/jquery.scrollTo.min.js
static/docs/reference/generated/kubernetes-api/v1.17/js/navData.js
static/docs/reference/generated/kubernetes-api/v1.17/js/scroll.js
</code></pre><h2 id=обновление-указателя-api-справочника>Обновление указателя API-справочника</h2><p>При генерации справочной документации для нового выпуска в файле <code>&lt;web-base>/content/en/docs/reference/kubernetes-api/api-index.md</code> нужно прописать номер предстоящей версии.</p><ul><li><p>Откройте файл <code>&lt;web-base>/content/en/docs/reference/kubernetes-api/api-index.md</code> и обновите номер версии справочника API. Например:</p><pre tabindex=0><code>---
title: v1.17
---

[Kubernetes API v1.17](/docs/reference/generated/kubernetes-api/v1.17/)
</code></pre></li><li><p>Откройте файл <code>&lt;web-base>/content/en/docs/reference/_index.md</code> и добавьте ссылку на последний справочник API. Удалите самую старую версию справочника API.
В этом файле должно быть 5 ссылок на новейшие API-справочники.</p></li></ul><h2 id=тестирование-справочника-api-локально>Тестирование справочника API локально</h2><p>Соберите обновлённую версию API-справочника на своём компьютере.
Проверьте ваши изменения на <a href=http://localhost:1313/docs/reference/generated/kubernetes-api/v1.17/>локальной предварительной версии сайта</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> &lt;web-base&gt;
</span></span><span style=display:flex><span>make docker-serve
</span></span></code></pre></div><h2 id=фиксация-изменений>Фиксация изменений</h2><p>В директории <code>&lt;web-base></code> выполните команду <code>git add</code> и <code>git commit</code> для фиксации изменений в репозитории.</p><p>Создайте пулреквест в репозиторий <code>kubernetes/website</code>. Отслеживайте свой пулреквест и при необходимости отвечайте на комментарии. Не забывайте отслеживать активность в собственном пулреквесте до тех пор, пока он не будет принят.</p><p>Отправьте свои изменения в виде <a href=/ru/docs/contribute/start/>пулреквеста</a> в репозиторий <a href=https://github.com/kubernetes/kubernetes>kubernetes/kubernetes</a>.
Отслеживайте изменения в пулреквесте и по мере необходимости отвечайте на комментарии рецензента. Не забывайте проверять пулреквест до тех пор, пока он не будет принят.</p><h2 id=что-дальше>Что дальше</h2><ul><li><a href=/ru/docs/contribute/generate-ref-docs/quickstart/>Руководство по быстрому старту генерации справочной документации</a></li><li><a href=/ru/docs/contribute/generate-ref-docs/kubernetes-components/>Генерация справочной документации для компонентов и инструментов Kubernetes</a></li><li><a href=/ru/docs/contribute/generate-ref-docs/kubectl/>Генерация справочной документации для команд kubectl</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-03de26b330a5cfdb26672f6bc75dcc04>7.5.4 - Генерация справочной документации для команд kubectl</h1><p>На этой странице показано, как сгенерировать справочник для команды <code>kubectl</code>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> На этой странице показывается, как сгенерировать справочную документацию для таких <a href=/ru/docs/reference/generated/kubectl/kubectl-commands>команд kubectl</a>, как <a href=/ru/docs/reference/generated/kubectl/kubectl-commands#apply>kubectl apply</a> и <a href=/ru/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a>.
Этот раздел не рассматривает генерацию справочной страницы для опций <a href=/ru/docs/reference/generated/kubectl/kubectl/>kubectl</a>. Инструкции по генерации справочной страницы опций kubectl смотрите в разделе <a href=/ru/docs/contribute/generate-ref-docs/kubernetes-components/>Генерация справочной документации для компонентов и инструментов Kubernetes</a>.</div><h2 id=подготовка-к-работе>Подготовка к работе</h2><h3 id=требования>Требования:</h3><ul><li><p>Наличие компьютера под управлением ОС Linux или macOS.</p></li><li><p>Установленные следующие инструменты:</p><ul><li><a href=https://www.python.org/downloads/>Python</a> версии 3.7.x</li><li><a href=https://git-scm.com/book/en/v2/Getting-Started-Installing-Git>Git</a></li><li><a href=https://golang.org/doc/install>Golang</a> версии 1.13+</li><li><a href=https://pypi.org/project/pip/>Pip</a>, который потребуется для установки PyYAML</li><li><a href=https://pyyaml.org/>PyYAML</a> версии 5.1.2</li><li><a href=https://www.gnu.org/software/make/>make</a></li><li><a href=https://gcc.gnu.org/>gcc compiler/linker</a></li><li><a href=https://docs.docker.com/engine/installation/>Docker</a> (требуется только для справочника команды <code>kubectl</code>)</li></ul></li><li><p>В переменной окружении <code>PATH</code> должны прописаны пути до необходимых инструментов сборки, таких как <code>Go</code> и <code>python</code>.</p></li><li><p>Вам нужно знать, как создать пулреквест в репозитории на GitHub.
Для этого нужно создание собственной копии репозитория. Для получения дополнительной информации смотрите раздел <a href=/ru/docs/contribute/intermediate/#%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D0%B8%D0%B7-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%BA%D0%BE%D0%BF%D0%B8%D0%B8>Работа из локальной копии</a>.</p></li></ul><h2 id=настройка-локальных-репозиториев>Настройка локальных репозиториев</h2><p>Создайте рабочую область и определите переменную окружения <code>GOPATH</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir -p <span style=color:#b8860b>$HOME</span>/&lt;workspace&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>GOPATH</span><span style=color:#666>=</span><span style=color:#b8860b>$HOME</span>/&lt;workspace&gt;
</span></span></code></pre></div><p>Загрузите локальные копии следующих репозиториев:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go get -u github.com/spf13/pflag
</span></span><span style=display:flex><span>go get -u github.com/spf13/cobra
</span></span><span style=display:flex><span>go get -u gopkg.in/yaml.v2
</span></span><span style=display:flex><span>go get -u kubernetes-sigs/reference-docs
</span></span></code></pre></div><p>Если у вас ещё нет копии репозитория kubernetes/website, клонируйте её на свой компьютер:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>git clone https://github.com/&lt;your-username&gt;/website <span style=color:#b8860b>$GOPATH</span>/src/github.com/&lt;your-username&gt;/website
</span></span></code></pre></div><p>Склонируйте репозиторий kubernetes/kubernetes по пути k8s.io/kubernetes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>git clone https://github.com/kubernetes/kubernetes <span style=color:#b8860b>$GOPATH</span>/src/k8s.io/kubernetes
</span></span></code></pre></div><p>Удалите пакет spf13 в <code>$GOPATH/src/k8s.io/kubernetes/vendor/github.com</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>rm -rf <span style=color:#b8860b>$GOPATH</span>/src/k8s.io/kubernetes/vendor/github.com/spf13
</span></span></code></pre></div><p>В репозитории kubernetes/kubernetes использует исходный код <code>kubectl</code> и <code>kustomize</code>.</p><ul><li><p>Определите базовую директорию вашей копии репозитория <a href=https://github.com/kubernetes/kubernetes>kubernetes/kubernetes</a>.
Например, если вы выполнили предыдущий шаг, чтобы получить репозиторий, вашей базовой директорией будет <code>$GOPATH/src/k8s.io/kubernetes</code>.
В остальных командах базовая директория будет именоваться как <code>&lt;k8s-base></code>.</p></li><li><p>Определите базовую директорию вашей копии репозитория <a href=https://github.com/kubernetes/website>kubernetes/website</a>.
Например, если вы выполнили предыдущий шаг, чтобы получить репозиторий, вашей базовой директорией будет <code>$GOPATH/src/github.com/&lt;your-username>/website</code>.
В остальных команд базовая директория будет именоваться как <code>&lt;web-base></code>.</p></li><li><p>Определите базовую директорию вашей копии репозитория <a href=https://github.com/kubernetes-sigs/reference-docs>kubernetes-sigs/reference-docs</a>.
Например, если вы выполнили предыдущий шаг, чтобы получить репозиторий, вашей базовой директорией будет <code>$GOPATH/src/github.com/kubernetes-sigs/reference-docs</code>.
В остальных команд базовая директория будет именоваться как <code>&lt;rdocs-base></code>.</p></li></ul><p>В вашем локальном репозитории k8s.io/kubernetes переключитесь в нужную вам ветку и убедитесь, что она в актуальном состоянии. Например, если вам нужно сгенерировать документацию для Kubernetes 1.17, вы можете использовать эти команды:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> &lt;k8s-base&gt;
</span></span><span style=display:flex><span>git checkout v1.17.0
</span></span><span style=display:flex><span>git pull https://github.com/kubernetes/kubernetes v1.17.0
</span></span></code></pre></div><p>Если вам не нужно изменять исходный код <code>kubectl</code>, следуйте инструкциям по <a href=#%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D0%B4%D0%BB%D1%8F-%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B8>определению переменных сборки</a>.</p><h2 id=редактирование-исходного-кода-kubectl>Редактирование исходного кода kubectl</h2><p>Справочная документация по команде kubectl генерируется автоматически из исходного кода kubectl. Если вы хотите изменить справочную документацию, сначала измените один или несколько комментариев в исходном коде kubectl. Сделайте изменения в локальный репозиторий kubernetes/kubernetes, а затем отправьте пулреквест в ветку master репозитория <a href=https://github.com/kubernetes/kubernetes>github.com/kubernetes/kubernetes</a>.</p><p><a href=https://github.com/kubernetes/kubernetes/pull/56673/files>PR 56673</a> — пример пулреквеста, который исправляет опечатку в исходном коде kubectl.</p><p>Отслеживайте пулреквест и по мере необходимости отвечайте на комментарии рецензента. Не забывайте отслеживать активность в пулреквест до тех пор, пока он не будет принят в ветку master репозитория kubernetes/kubernetes.</p><h2 id=применение-вашего-изменения-в-ветку-выпуска>Применение вашего изменения в ветку выпуска</h2><p>Теперь ваше изменение в ветке master, которая используется для разработки следующего выпуска Kubernetes. Если вы хотите добавить ваше изменение в документацию для уже выпущенной версии Kubernetes, вам нужно применить коммит с соответствующим изменением в нужную ветку выпуска.</p><p>Например, предположим, что ветка master используется для разработки Kubernetes 1.10, а вам нужно бэкпортировать ваше изменение в ветку release-1.15. За инструкциями обратитесь к странице <a href=https://git.k8s.io/community/contributors/devel/sig-release/cherry-picks.md>Propose a Cherry Pick</a>.</p><p>Отслеживайте ваш пулреквест с применённым изменением до тех пор, пока он не будет объединён в ветку выпуска.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Применение коммита требует наличия возможности добавить метку и этап в вашем пулреквесте. Если у вас нет таких разрешений, вам нужно переговорить с кем-то, кто может сделать это для вас.</div><h2 id=настройка-переменных-для-сборки>Настройка переменных для сборки</h2><p>Перейдите на <code>&lt;rdocs-base></code>. В командной строке установите следующие переменные окружения.</p><ul><li><code>K8S_ROOT</code> со значением <code>&lt;k8s-base></code>.</li><li><code>WEB_ROOT</code> со значением <code>&lt;web-base></code>.</li><li><code>K8S_RELEASE</code> со значением нужной версии документации.
Например, если вы хотите собрать документацию для Kubernetes версии 1.17, определите переменную окружения <code>K8S_RELEASE</code> со значением 1.17.</li></ul><p>Примеры:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>WEB_ROOT</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>GOPATH<span style=color:#a2f;font-weight:700>)</span>/src/github.com/&lt;your-username&gt;/website
</span></span><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>K8S_ROOT</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>GOPATH<span style=color:#a2f;font-weight:700>)</span>/src/k8s.io/kubernetes
</span></span><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>K8S_RELEASE</span><span style=color:#666>=</span>1.17
</span></span></code></pre></div><h2 id=создание-версионированной-директории>Создание версионированной директории</h2><p>Скрипт сборки <code>createversiondirs</code> создаёт версионированную директорию и копирует туда конфигурационные файлы справочника kubectl.
Имя версионированной директории имеет следующий вид: <code>v&lt;major>_&lt;minor></code>.</p><p>В директории <code>&lt;rdocs-base></code> выполнение следующий скрипт сборки:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> &lt;rdocs-base&gt;
</span></span><span style=display:flex><span>make createversiondirs
</span></span></code></pre></div><h2 id=переход-в-тег-выпуска-в-k8s-io-kubernetes>Переход в тег выпуска в k8s.io/kubernetes</h2><p>В вашем локальном репозитории <code>&lt;k8s-base></code> перейдите в ветку с версией Kubernetes, для которой вы хотите получить документацию. Например, если вы хотите сгенерировать документацию для Kubernetes 1.17, перейдите в тег <code>v1.17.0</code>. Убедитесь, что ваша локальная ветка содержит актуальные изменения.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> &lt;k8s-base&gt;
</span></span><span style=display:flex><span>git checkout v1.17.0
</span></span><span style=display:flex><span>git pull https://github.com/kubernetes/kubernetes v1.17.0
</span></span></code></pre></div><h2 id=выполнение-кода-для-генерации-документации>Выполнение кода для генерации документации</h2><p>В вашей локальной директории <code>&lt;rdocs-base></code> запустите скрипт сборки <code>copycli</code>. Команда выполняется от пользователя <code>root</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> &lt;rdocs-base&gt;
</span></span><span style=display:flex><span>make copycli
</span></span></code></pre></div><p>Команда <code>copycli</code> удаляет временную директорию сборки, генерирует файлы команды kubectl и копирует полученную HTML-страницу справочника команде kubectl и ресурсы в <code>&lt;web-base></code>.</p><h2 id=проверка-сгенерированных-файлов>Проверка сгенерированных файлов</h2><p>Убедитесь в том, что перечисленные ниже два файлы были сгенерированы:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#666>[</span> -e <span style=color:#b44>&#34;&lt;rdocs-base&gt;/gen-kubectldocs/generators/build/index.html&#34;</span> <span style=color:#666>]</span> <span style=color:#666>&amp;&amp;</span> <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;index.html built&#34;</span> <span style=color:#666>||</span> <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;no index.html&#34;</span>
</span></span><span style=display:flex><span><span style=color:#666>[</span> -e <span style=color:#b44>&#34;&lt;rdocs-base&gt;/gen-kubectldocs/generators/build/navData.js&#34;</span> <span style=color:#666>]</span> <span style=color:#666>&amp;&amp;</span> <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;navData.js built&#34;</span> <span style=color:#666>||</span> <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;no navData.js&#34;</span>
</span></span></code></pre></div><h2 id=проверка-скопированных-файлов>Проверка скопированных файлов</h2><p>Убедитесь в том, все сгенерированные файлы были скопированы в вашу директорию <code>&lt;web-base></code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> &lt;web-base&gt;
</span></span><span style=display:flex><span>git status
</span></span></code></pre></div><p>В выводе должны перечислены изменённые файлы:</p><pre tabindex=0><code>static/docs/reference/generated/kubectl/kubectl-commands.html
static/docs/reference/generated/kubectl/navData.js
</code></pre><p>Также в выводе должно быть:</p><pre tabindex=0><code>static/docs/reference/generated/kubectl/scroll.js
static/docs/reference/generated/kubectl/stylesheet.css
static/docs/reference/generated/kubectl/tabvisibility.js
static/docs/reference/generated/kubectl/node_modules/bootstrap/dist/css/bootstrap.min.css
static/docs/reference/generated/kubectl/node_modules/highlight.js/styles/default.css
static/docs/reference/generated/kubectl/node_modules/jquery.scrollto/jquery.scrollTo.min.js
static/docs/reference/generated/kubectl/node_modules/jquery/dist/jquery.min.js
static/docs/reference/generated/kubectl/node_modules/font-awesome/css/font-awesome.min.css
</code></pre><h2 id=проверка-документации-локально>Проверка документации локально</h2><p>Соберите документацию Kubernetes в вашей директории <code>&lt;web-base></code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> &lt;web-base&gt;
</span></span><span style=display:flex><span>make docker-serve
</span></span></code></pre></div><p>Посмотрите <a href=https://localhost:1313/docs/reference/generated/kubectl/kubectl-commands/>локальную предварительную версию сайта</a>.</p><h2 id=добавление-и-фиксация-изменений-в-kubernetes-website>Добавление и фиксация изменений в kubernetes/website</h2><p>Выполните команду <code>git add</code> и <code>git commit</code> для фиксации файлов.</p><h2 id=создание-пулреквеста>Создание пулреквеста</h2><p>Создайте пулреквест в репозиторий <code>kubernetes/website</code>. Отслеживайте изменения в пулреквесте и по мере необходимости отвечайте на комментарии рецензента. Не забывайте проверять пулреквест до тех пор, пока он не будет принят.</p><p>Спустя несколько минут после принятия вашего пулреквеста, обновленные темы справочника будут отображены в <a href=/ru/docs/home/>документации</a>.</p><h2 id=что-дальше>Что дальше</h2><ul><li><a href=/ru/docs/contribute/generate-ref-docs/quickstart/>Руководство по быстрому старту генерации справочной документации</a></li><li><a href=/ru/docs/contribute/generate-ref-docs/kubernetes-components/>Генерация справочной документации для компонентов и инструментов Kubernetes</a></li><li><a href=/ru/docs/contribute/generate-ref-docs/kubernetes-api/>Генерация справочной документации для API Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-28fc50a0072b0b2b444aa24e552d2e60>7.5.5 - Генерация справочных страниц для компонентов и инструментов Kubernetes</h1><p>На этой странице показывается, как собирать справочные страницы компонентов и инструментов Kubernetes.</p><h2 id=подготовка-к-работе>Подготовка к работе</h2><p>Начните с <a href=/ru/docs/contribute/generate-ref-docs/quickstart/#%D0%BF%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B0-%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5>раздела с требованиями</a> в руководстве по быстрому старту.</p><p>Для генерации справочных страниц компонентов и инструментов Kubernetes изучите страницу <a href=/docs/contribute/generate-ref-docs/quickstart/>руководство по быстрому старту в справочной документации</a>.</p><h2 id=что-дальше>Что дальше</h2><ul><li><a href=/ru/docs/contribute/generate-ref-docs/quickstart/>Краткое руководство по генерации справочной документации</a></li><li><a href=/ru/docs/contribute/generate-ref-docs/kubectl/>Генерация справочной документации для команд kubectl</a></li><li><a href=/ru/docs/contribute/generate-ref-docs/kubernetes-api/>Генерация справочной документации для API Kubernetes</a></li><li><a href=/ru/docs/contribute/generate-ref-docs/contribute-upstream/>Участие в документации основного кода проекта Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-849a2fdb87779db1c212fe5a9f88ff0d>7.6 - Локализация документации Kubernetes</h1><p>На этой странице рассказывается, как <a href=https://blog.mozilla.org/l10n/2011/12/14/i18n-vs-l10n-whats-the-diff/>локализовать</a> документацию на разные языки.</p><h2 id=начало-работы>Начало работы</h2><p>Из-за того, что участники не могут одобрять собственные пулреквесты, нужно как минимум два участника для инициализации локализацию.</p><p>Все команды по локализации должны быть самодостаточными. Это означает, что мы с радостью разместим вашу работу, но мы не можем сделать перевод за вас.</p><h3 id=определение-двухбуквенного-кода-языка>Определение двухбуквенного кода языка</h3><p>Первым делом ознакомьтесь со <a href=https://www.loc.gov/standards/iso639-2/php/code_list.php>стандартом ISO 639-1</a>, чтобы найти двухбуквенный код страны для вашей локализации. Например, двухбуквенный код для корейского языка будет <code>ko</code>.</p><h3 id=создание-копии-репозитория>Создание копии репозитория</h3><p>Для начала <a href=/ru/docs/contribute/start/#%D1%83%D0%BB%D1%83%D1%87%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%89%D0%B5%D0%B3%D0%BE-%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0>создайте собственную копию репозитория</a> оригинального репозитория <a href=https://github.com/kubernetes/website>kubernetes/website</a>.</p><p>Затем клонируйте свою копию репозитория и перейдите в неё с помощью команды <code>cd</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>git clone https://github.com/&lt;username&gt;/website
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> website
</span></span></code></pre></div><h3 id=создание-пулреквеста>Создание пулреквеста</h3><p>Далее <a href=/ru/docs/contribute/start/#%D0%BE%D1%82%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0-%D0%BF%D1%83%D0%BB%D1%80%D0%B5%D0%BA%D0%B2%D0%B5%D1%81%D1%82%D0%B0>откройте пулреквест</a> (PR) с локализацией в репозиторий <code>kubernetes/website</code>.</p><p>Для того, чтобы ваш пулреквест был одобрен, он должен содержать <a href=#%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D1%8B%D0%B9-%D0%BC%D0%B8%D0%BD%D0%B8%D0%BC%D1%83%D0%BC-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BD%D1%82%D0%B0>необходимый минимум контента</a>.</p><p>В качестве примера добавления новой локализации, изучите PR, который добавляет <a href=https://github.com/kubernetes/website/pull/12548>документацию на французском</a>.</p><h3 id=вступление-в-github-организацию-kubernetes>Вступление в GitHub-организацию Kubernetes</h3><p>Как только, как вы открыли PR с локализацией, вы можете стать членом организации Kubernetes на GitHub. Каждый член команды должен подать <a href=https://github.com/kubernetes/org/issues/new/choose>запрос на членство в организации</a> в репозитории <code>kubernetes/org</code>.</p><h3 id=добавление-команды-локализации-на-github>Добавление команды локализации на GitHub</h3><p>Теперь нужно добавить вашу команду локализации Kubernetes в файл <a href=https://github.com/kubernetes/org/blob/master/config/kubernetes/sig-docs/teams.yaml><code>sig-docs/teams.yaml</code></a>. Для примера добавления команды локализации можете посмотреть PR, добавляющий <a href=https://github.com/kubernetes/org/pull/685>испанскую команду локализации</a>.</p><p>Члены <code>@kubernetes/sig-docs-**-owners</code> — могут одобрять PR, которые изменяют файлы внутри (и только там) директории с локализацией: <code>/content/**/</code>.</p><p>Для каждой локализации группа <code>@kubernetes/sig-docs-**-reviews</code> служит для автоматизации выбора проверяющих новых PR.</p><p>Члены <code>@kubernetes/website-maintainers</code> могут создавать новые ветки для координации работ по переводу.</p><p>Члены <code>@kubernetes/website-milestone-maintainers</code> могут использовать <a href=https://prow.k8s.io/command-help>Prow-команду</a> <code>/milestone</code> для контрольных точек для ишью или PR.</p><h3 id=настройка-рабочего-процесса>Настройка рабочего процесса</h3><p>Затем добавьте собственную GitHub-метку для вашей локализации в репозиторий <code>kubernetes/test-infra</code>. Метка позволяет фильтровать ишью и пулреквесты по конкретному языку.</p><p>Смотрите пример добавления <a href=https://github.com/kubernetes/test-infra/pull/11316>метки для итальянского языка</a>.</p><h3 id=поиск-сообщества>Поиск сообщества</h3><p>Сообщите участниками группы Kubernetes SIG Docs о вашем намерении перевода документации! Подключайтесь к <a href=https://kubernetes.slack.com/messages/C1J0BPD2M/>Slack-каналу SIG Docs</a>. Остальные команды по локализации с радостью помогут вам начать и ответят на любые вопросы.</p><p>Вы также можете создать Slack-канал для своей локализации в репозитории <code>kubernetes/community</code>. Для примера посмотрите PR с <a href=https://github.com/kubernetes/community/pull/3605>добавлением Slack-канала для индонезийского и португальского языков</a>.</p><h2 id=необходимый-минимум-контента>Необходимый минимум контента</h2><h3 id=изменение-конфигурации-сайта>Изменение конфигурации сайта</h3><p>Сайт Kubernetes использует использует фреймворк Hugo. Конфигурация сайта у Hugo находится в файле <a href=https://github.com/kubernetes/website/tree/master/config.toml><code>config.toml</code></a>. Для поддержки новой локализации вам нужно отредактировать файл <code>config.toml</code>.</p><p>Добавьте блок с конфигурацией для нового языка в <code>config.toml</code> после существующего блока <code>[languages]</code>. Например, конфигурация для немецкой локализации будет выглядить так:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[languages.de]
</span></span><span style=display:flex><span>title = <span style=color:#b44>&#34;Kubernetes&#34;</span>
</span></span><span style=display:flex><span>description = <span style=color:#b44>&#34;Produktionsreife Container-Verwaltung&#34;</span>
</span></span><span style=display:flex><span>languageName = <span style=color:#b44>&#34;Deutsch&#34;</span>
</span></span><span style=display:flex><span>contentDir = <span style=color:#b44>&#34;content/de&#34;</span>
</span></span><span style=display:flex><span>weight = <span style=color:#666>3</span>
</span></span></code></pre></div><p>При выбора значения для параметра <code>weight</code> в блока найдите языковой блок с наибольшим значением и прибавьте к нему 1.</p><p>Для получения дополнительной информации о многоязычной поддержке в Hugo посмотрите страницу "<a href=https://gohugo.io/content-management/multilingual/>Multilingual Mode</a>".</p><h3 id=добавление-директории-для-локализации>Добавление директории для локализации</h3><p>Добавьте директорию для вашего языка в директорию <a href=https://github.com/kubernetes/website/tree/master/content><code>content</code></a> репозитория. Например, двухбуквенный код для немецкого будет <code>de</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir content/de
</span></span></code></pre></div><h3 id=перевод-норм-поведения-сообщества>Перевод норм поведения сообщества</h3><p>Откройте PR в репозитории <a href=https://github.com/cncf/foundation/tree/master/code-of-conduct-languages><code>cncf/foundation</code></a> и добавьте перевод норм поведения на своём языке.</p><h3 id=добавление-перевода-для-файла-readme>Добавление перевода для файла README</h3><p>Чтобы помочь другим участников локализации добавьте новый файл <a href=https://help.github.com/articles/about-readmes/><code>README-**.md</code></a> в корневую директорию k/website, где <code>**</code> означает двухбуквенный код языка. Например, немецкий файл README будет именоваться как <code>README-de.md</code>.</p><p>Подготовьте рекомендации для участников в файле для конкретной локализации <code>README-**.md</code>. В этом файле должна быть точно такая же информация, что и в оригинальном README.md ту же информацию, включая также:</p><ul><li>Контактное лицо проекта локализации</li><li>Любая другая информация, относящаяся к локализации</li></ul><p>После создания перевода файла README добавьте ссылку на файл в основной английский файл <code>README.md</code> и добавьте контактную информацию на английском языке. Вы можете указать логин на GitHub, адрес электронной почты, Slack-канал или какой-нибудь способ связи. Вам также нужно добавить ссылку на перевод норм поведения в сообществе.</p><h3 id=настройка-файлов-owners>Настройка файлов OWNERS</h3><p>Для определения роли каждого пользователя, участвующего в локализации, создайте файл <code>OWNERS</code> в директории языка, указав в нём следующие секции:</p><ul><li><strong>reviewers</strong>: список Kubernetes-команд с ролями рецензентов, в данном случае команда <code>sig-docs-**-reviews</code> будет создана в разделе <a href=#%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BD%D0%B0-github>Добавление команды локализации на GitHub</a>.</li><li><strong>approvers</strong>: список Kubernetes-команд с ролями утверждающих, в данном случае команда <code>sig-docs-**-owners</code> будет создана в разделе <a href=#%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BD%D0%B0-github>Добавление команды локализации на GitHub</a>.</li><li><strong>labels</strong>: список GitHub-меток, которые будут автоматически добавляться к PR, в данном случае метка языка будет создана в разделе <a href=#%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D1%80%D0%B0%D0%B1%D0%BE%D1%87%D0%B5%D0%B3%D0%BE-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0>Настройка рабочего процесса</a>.</li></ul><p>Дополнительную информацию о файле <code>OWNERS</code> вы можете получить по ссылке <a href=https://go.k8s.io/owners>go.k8s.io/owners</a>.</p><p><a href=https://git.k8s.io/website/content/es/OWNERS>Испанский файл OWNERS</a> с кодом языка <code>es</code> выглядит следующим образом:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># See the OWNERS docs at https://go.k8s.io/owners</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># This is the localization project for Spanish.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Teams and members are visible at https://github.com/orgs/kubernetes/teams.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>reviewers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- sig-docs-es-reviews<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>approvers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- sig-docs-es-owners<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- language/es<span style=color:#bbb>
</span></span></span></code></pre></div><p>После добавления файла <code>OWNERS</code> в определенном языке нужно обновить <a href=https://git.k8s.io/website/OWNERS_ALIASES>корневой файл <code>OWNERS_ALIASES</code></a>, добавив новые команды локализации Kubernetes — <code>sig-docs-**-owners</code> и <code>sig-docs-**-reviews</code>.</p><p>Для каждой команды добавьте список GitHub-пользователей из раздела <a href=#%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BD%D0%B0-github>Добавление команды локализации на GitHub</a>, перечислите их в алфавитном порядке.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a00000>--- a/OWNERS_ALIASES
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+++ b/OWNERS_ALIASES
</span></span></span><span style=display:flex><span><span style=color:#00a000></span><span style=color:purple;font-weight:700>@@ -48,6 +48,14 @@ aliases:
</span></span></span><span style=display:flex><span><span style=color:purple;font-weight:700></span>     - stewart-yu
</span></span><span style=display:flex><span>     - xiangpengzhao
</span></span><span style=display:flex><span>     - zhangxiaoyu-zidif
</span></span><span style=display:flex><span><span style=color:#00a000>+  sig-docs-es-owners: # Admins for Spanish content
</span></span></span><span style=display:flex><span><span style=color:#00a000>+    - alexbrand
</span></span></span><span style=display:flex><span><span style=color:#00a000>+    - raelga
</span></span></span><span style=display:flex><span><span style=color:#00a000>+  sig-docs-es-reviews: # PR reviews for Spanish content
</span></span></span><span style=display:flex><span><span style=color:#00a000>+    - alexbrand
</span></span></span><span style=display:flex><span><span style=color:#00a000>+    - electrocucaracha
</span></span></span><span style=display:flex><span><span style=color:#00a000>+    - glo-pena
</span></span></span><span style=display:flex><span><span style=color:#00a000>+    - raelga
</span></span></span><span style=display:flex><span><span style=color:#00a000></span>   sig-docs-fr-owners: # Admins for French content
</span></span><span style=display:flex><span>     - perriea
</span></span><span style=display:flex><span>     - remyleone
</span></span></code></pre></div><h2 id=перевод-контента>Перевод контента</h2><p>Локализация <em>всей</em> документации Kubernetes — колоссальная задача. Вполне нормально начать переводить что-то небольшое, а затем со временем делать перевод больших страниц.</p><p>Как минимум, все локализации должны включать:</p><table><thead><tr><th>Описание</th><th>URL-адреса</th></tr></thead><tbody><tr><td>Главная</td><td><a href=/ru/docs/home/>Все заголовки и подзаголовки URL-адресов</a></td></tr><tr><td>Установка</td><td><a href=/ru/docs/setup/>Все заголовки и подзаголовки URL-адресов</a></td></tr><tr><td>Руководства</td><td><a href=/ru/docs/tutorials/kubernetes-basics/>Основы Kubernetes</a>, <a href=/ru/docs/tutorials/stateless-application/hello-minikube/>Привет, Minikube</a></td></tr><tr><td>Надписи на сайте</td><td><a href=https://github.com/kubernetes/website/tree/master/i18n>Все надписи сайта в собственном TOML-файле</a></td></tr></tbody></table><p>Переведенные файлы должны находиться в собственной директории <code>content/**/</code>, но в во всём остальном должны быть такие, как и оригинал на английском. Например, чтобы подготовить <a href=/ru/docs/tutorials/kubernetes-basics/>Основы Kubernetes</a> для перевода на немецкий язык, создайте поддиректорию в директории <code>content/de/</code> и скопируйте туда оригинальный английский файл:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir -p content/de/docs/tutorials
</span></span><span style=display:flex><span>cp content/en/docs/tutorials/kubernetes-basics.md content/de/docs/tutorials/kubernetes-basics.md
</span></span></code></pre></div><p>С помощью соответствующих инструментов можно ускорить процесс перевода. Например, у некоторых редакторов есть плагины для быстрого перевода текста.</p><div class="alert alert-warning caution callout" role=alert><strong>Внимание:</strong> Использование только машинного перевода не будет соответствовать минимальному уровню качества и поэтому такой перевод требует тщательного ручного рассмотрения для соблюдения стандарта качества.</div><p>To ensure accuracy in grammar and meaning, members of your localization team should carefully review all machine-generated translations before publishing.</p><h3 id=исходные-файлы>Исходные файлы</h3><p>Локализация должна исходить из самой последней версии оригинальной документации — v1.25.</p><p>Для того, чтобы получить исходные файлы последней версии:</p><ol><li>Перейдите в репозиторий сайта Kubernetes по адресу <a href=https://github.com/kubernetes/website>https://github.com/kubernetes/website</a>.</li><li>Выберите ветку <code>release-1.X</code> самой последней версии.</li></ol><p>Текущая последняя версия v1.25, поэтому веткой для этого релиза будет <a href=https://github.com/kubernetes/website/tree/release-1.25><code>release-1.25</code></a>.</p><h3 id=сообщения-на-сайте-в-i18n>Сообщения на сайте в i18n/</h3><p>Локализации должны включать содержимое файла <a href=https://github.com/kubernetes/website/blob/main/i18n/en.toml><code>i18n/en.toml</code></a> в новый языковой файл. В качестве примера рассмотрим немецкую локализацию: <code>i18n/de.toml</code>.</p><p>Добавьте новый файл локализации в <code>i18n/</code>. Например, для немецкой локализации (<code>de</code>):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cp i18n/en.toml i18n/de.toml
</span></span></code></pre></div><p>Затем переведите значение каждого сообщения:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-TOML data-lang=TOML><span style=display:flex><span>[docs_label_i_am]
</span></span><span style=display:flex><span>other = <span style=color:#b44>&#34;ICH BIN...&#34;</span>
</span></span></code></pre></div><p>Локализация сообщений сайта позволяет изменить сообщения, используемые на всём сайте, к примеру, текст авторских прав в футере на каждой странице.</p><h3 id=глоссарий-и-руководство-по-оформления-для-языка>Глоссарий и руководство по оформления для языка</h3><p>У некоторых языковых команд есть собственные руководства по оформлению и глоссарий. Например, посмотрите <a href=/ko/docs/contribute/localization_ko/>руководство корейской локализации</a>.</p><h2 id=стратегия-работы-с-ветками>Стратегия работы с ветками</h2><p>Работа в проектах локализации осуществляется посредством совместных усилий, поэтому мы приветствуем решение команды работать в общих ветках разработки.</p><p>Совместная работа в рабочих ветках может быть организована следующим образом:</p><ol><li><p>Член команды <a href=https://github.com/orgs/kubernetes/teams/website-maintainers>@kubernetes/website-maintainers</a> создает ветку из оригинальной ветки на <a href=https://github.com/kubernetes/website>https://github.com/kubernetes/website</a>.</p><p>После того, как вы <a href=#%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BD%D0%B0-github>добавите свою команду локализации</a> в репозиторий <a href=https://github.com/kubernetes/org><code>kubernetes/org</code></a>, ваши утверждающие из группы будет присоединены к команде <code>@kubernetes/website-maintainers</code>.</p><p>Мы рекомендуем следующую схему именования веток:</p><p><code>dev-&lt;оригинальная версия>-&lt;код языка>.&lt;контрольная точка команды></code></p><p>Например, утверждающий в немецкой группе локализации открывает рабочую ветку <code>dev-1.12-de.1</code> непосредственно в репозитории kubernetes/website из ветки для Kubernetes v1.12.</p></li><li><p>Остальные участники создают новые ветки с изменениями на основе рабочей ветки.</p><p>Например, участник немецкой группы локализации открывает пулреквест с изменениями в <code>kubernetes:dev-1.12-de.1</code> из <code>username:local-branch-name</code>.</p></li><li><p>Утверждающий проверяет изменения и объединяют ветки в рабочую веткой.</p></li><li><p>Периодически утверждающий объединяет рабочую ветку в оригинальную ветку, открывая и принимая новый пулреквест. Не забудьте объединить (squash) коммиты перед слиянием пулреквеста.</p></li></ol><p>Повторяйте шаги 1-4 до тех пор, пока не будет завершена локализация. Например, по мере работы над немецким переводом, рабочие ветки будут меняться: <code>dev-1.12-de.2</code>, <code>dev-1.12-de.3</code> и т.д.</p><p>Команды должны объединять переведённый контент в ту же ветку выпуска, из которой она была создана. Например, рабочая ветка, созданная из версии release-1.25, должна сливаться с веткой версии 1.17.</p><p>Утверждающему следует поддерживать рабочую веку в актуальном состоянии в соответствии с оригинальной веткой, разрешая конфликты при слиянии. Чем дольше существует рабочая ветки, тем больше потребуется сил для ее поддержки. Поэтому лучше как можно быстрее сливать рабочую ветку и открывать новую, а не поддерживать только одну-единственную в течение длительного времени.</p><p>В начале каждой контрольной точки команды полезно открыть ишью для сравнения изменений между предыдущей веткой и текущей рабочей веткой.</p><p>Хотя только утверждающие могут открывать новую рабочую ветку и сливать пулреквесты, но любой может открыть пулреквест с новой веткой, которая может быть рабочей для команды. Никаких специальных разрешений для этого не требуется.</p><p>Для получения дополнительной информации о работе с копиями или непосредственно с оригинальным репозиторией смотрите раздел по <a href=#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BF%D0%B8%D0%B8-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F>созданию и клонированию копии репозитория</a>.</p><h2 id=участие-в-работе-над-оригинальным-контентом>Участие в работе над оригинальным контентом</h2><p>SIG Docs приветствует <a href=/ru/docs/contribute/intermediate#%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BD%D1%82%D0%B0>участие и дополнения</a> в английскую документацию.</p><h2 id=помощь-для-существующей-локализации>Помощь для существующей локализации</h2><p>Вы также можете добавлять или улучшать контент в уже существующей локализации. Обратитесь к соответствующему <a href=https://kubernetes.slack.com/messages/C1J0BPD2M/>Slack-каналу</a> для этого и начинайте помогать через PR.</p><h2 id=что-дальше>Что дальше</h2><p>Как только локализация будет соответствовать требованиям установленного рабочего процесса и содержать требуемый минимум контента, группа SIG Docs:</p><ul><li>Добавит язык на сайт</li><li>Сообщит о новой локализации на каналах <a href=https://www.cncf.io/about/>Cloud Native Computing Foundation</a> (CNCF), включая <a href=https://kubernetes.io/blog/>блог Kubernetes</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e1098d3fca853af3d9dd514e4309cbba>7.7 - Участие в SIG Docs</h1><p>SIG Docs — это одна из <a href=https://github.com/kubernetes/community/blob/master/sig-list.md>специальных групп</a> в проекте Kubernetes, которая занимается написанием, обновлением и поддержкой документации Kubernetes в целом. Перейдите на страницу про <a href=https://github.com/kubernetes/community/tree/master/sig-docs>SIG Docs в GitHub-репозитории</a>, чтобы узнать подробную информацию об этой группе.</p><p>SIG Docs активно принимает правки и дополнения в документацию, так и отзывы от всех участников. Любой может открыть пулреквест (PR), либо сообщить про ошибки в тексте или просто прокомментировать выполняемые пулреквесты.</p><p>Вы также можете стать <a href=#%D1%87%D0%BB%D0%B5%D0%BD%D1%8B>членом</a>, <a href=#%D1%80%D0%B5%D1%86%D0%B5%D0%BD%D0%B7%D0%B5%D0%BD%D1%82%D1%8B>рецензентом</a> или <a href=#%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5>утверждающим</a>. Эти роли расширяют ваши возможности, но и предлагают выполнение определенных обязанностей по рассмотрению и принятию изменений. Изучите содержимого файла <a href=https://github.com/kubernetes/community/blob/master/community-membership.md>community-membership</a> в директории сообщества репозитория, чтобы узнать про членство в сообществе Kubernetes. В остальной части этой страницы кратко рассматривается функционирование ролей в группе SIG Docs, которая в совокупности отвечает за поддержание одного из самой публичной части Kubernetes — сайта и документации Kubernetes.</p><h2 id=роли-и-обязанности>Роли и обязанности</h2><ul><li><strong>Любой</strong> может поучаствовать в документацию Kubernetes. Для этого вам нужно только <a href=/ru/docs/contribute/start#sign-the-cla>подписать CLA</a> и иметь аккаунт на GitHub.</li><li><strong>Члены</strong> организации Kubernetes — участники, которые активно занимаются пректом Kubernetes, как правило, открывая пулреквесты с принятыми изменениями. Посмотрите файл <a href=https://github.com/kubernetes/community/blob/master/community-membership.md>Членство в сообществе</a>, чтобы узнать про необходимые условия для членства.</li><li><strong>Рецензент</strong> SIG Docs — член организации Kubernetes, который занимается проверкой пулреквестов и поэтому был добавлен в соответствующую группу на GitHub и в файлы <code>OWNERS</code> в GitHub-репозитории.</li><li><strong>Утверждающий</strong> SIG Docs — член организации с хорошей репутацией, который подтвердил неизменную приверженность проекту. Утверждающий может принимать пулреквесты и публиковаться от имени организации Kubernetes. Утверждающие также могут представлять группу SIG Docs в более крупном сообществе Kubernetes. Некоторые из задач утверждающего SIG Docs, например, координация новой версии, требуют значительных затрат по времени.</li></ul><h2 id=любой>Любой</h2><p>Кто угодно может сделать следующее:</p><ul><li>Открыть ишью на GitHub в любую часть Kubernetes, включая документацию.</li><li>Дать рекомендацию или предложить улучшение в пулреквесте.</li><li>Предложить идею по улучшению в Slack](<a href=http://slack.k8s.io/>http://slack.k8s.io/</a>) или в <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs>список рассылки SIG Docs</a>.</li><li>Использовать команду <code>/lgtm</code> (сокращение от "looks good to me") бота Prow, чтобы одобрить изменения в пулреквесте.<div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Если вы не входите в организацию Kubernetes, то команда <code>/lgtm</code> не проставил автоматически соответствующую метку.</div></li></ul><p>После <a href=/ru/docs/contribute/start#sign-the-cla>подписания CLA</a> каждый также может:</p><ul><li>Открыть пулреквест, чтобы улучшить существующий текст, либо что-то новое, или написать запись в блоге или описать пример использования.</li></ul><h2 id=члены>Члены</h2><p>Члены — это участники проекта Kubernetes, которые удовлетворяют <a href=https://github.com/kubernetes/community/blob/master/community-membership.md#member>критериям членства</a>. SIG Docs ценит участие всех членов сообщества Kubernetes и часто просит дать обратную связь от членов других SIG-групп для соблюдения технической точности.</p><p>Любой член <a href=https://github.com/kubernetes>организации Kubernetes</a> может сделать следующее:</p><ul><li>Всё то же самое, что и <a href=#%D0%BB%D1%8E%D0%B1%D0%BE%D0%B9>любой другой участник</a></li><li>Использовать команду <code>/lgtm</code> в комментарии для автоматического добавления метки LGTM (looks good to me) для пулреквеста.</li><li>Использовать команду <code>/hold</code> в комментарии для блокировки слияния пулреквеста, если он имеет метку LGTM и другие утверждающие метки.</li><li>Использовать команду <code>/assign</code> в комментарии, чтобы назначить рецензента, который будет проверят пулреквест.</li></ul><h3 id=членство>Членство</h3><p>После того, как вы успешно отправили не менее 5 содержательных пулреквестов, вы можете стать <a href=https://github.com/kubernetes/community/blob/master/community-membership.md#member>членом</a> организации Kubernetes. Следуйте нижеперечисленным шагам:</p><ol><li><p>Найдите двух рецензентов или утверждающих, которые <a href=/ru/docs/contribute/advanced#%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0-%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D1%83%D1%87%D0%B0%D1%81%D1%82%D0%BD%D0%B8%D0%BA%D0%B0>поддержат</a> ваше членство.</p><p>Запросите спонсорство в канале <a href=https://kubernetes.slack.com>#sig-docs Kubernetes Slack</a> или в <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs>списке рассылки SIG Docs</a>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Не отправляйте электронное письмо и не пишите личное сообщение в Slack кому-либо из участников SIG Docs.</div></li><li><p>Создайте ишью в репозитории <code>kubernetes/org</code>, чтобы запросить членство.
Заполните шаблон, предварительно изучив правила <a href=https://github.com/kubernetes/community/blob/master/community-membership.md>членства в сообществе</a>.</p></li><li><p>Сообщите вашим спонсорам про вашу заявку на GitHub, упомянув их в ней на GitHub (добавив комментарий в форме <code>@&lt;GitHub-username></code>), либо отправив им ссылку напрямую, чтобы они могли добавить проголосовать ( <code>+1</code>).</p></li><li><p>Когда ваше членство будет одобрено, член административной команды на GitHub, назначенный для обработки вашего пулреквеста, обновит ишью на GitHub, чтобы показать одобрение, а затем закроет проблему GitHub.
Поздравляем, теперь вы член организации!</p></li></ol><p>Если ваша заявка на членство не была одобрена, членский комитет даст уточнения или перечислит шаги, которые необходимо выполнить, прежде чем снова подать заявку.</p><h2 id=рецензенты>Рецензенты</h2><p>Рецензенты — это члены GitHub-группы <a href=https://github.com/orgs/kubernetes/teams/sig-docs-pr-reviews>@kubernetes/sig-docs-pr-reviews</a>. Рецензенты проверяют пулреквесты документации и оставлять обратную связь по предлагаемым изменениях. Рецензенты могут:</p><ul><li>Делать всё то, что и <a href=#%D0%BB%D1%8E%D0%B1%D0%BE%D0%B9>любой участник</a> и <a href=#%D1%87%D0%BB%D0%B5%D0%BD%D1%8B>члены</a></li><li>Писать документацию для новой функциональности</li><li>Назначать метки и классифицировать ишью</li><li>Проверять пулреквесты и оставлять обязательные для выполнения рекомендации</li><li>Создавайте диаграммы, графику и встраиваемые скринкасты и видеоролики</li><li>Заниматься локализацией</li><li>Редактировать строки в коде, относящиеся к интерфейсу пользователя</li><li>Улучшать комментарии к коду</li></ul><h3 id=выбор-рецензентов-для-проверки-пулреквестов>Выбор рецензентов для проверки пулреквестов</h3><p>Процесс выбора рецензентов для проверки пулреквестов автоматизирован. Вы можете попросить проверку у определенного рецензента, написав комментарий в пулреквесте: <code>/assign [@_github_handle]</code>. Чтобы показать, что пулреквест является правильным с технической точки зрения и не требует дополнительных изменений, рецензент добавляет комментарий с командой <code>/lgtm</code>.</p><p>Если назначенный рецензент еще не просмотрел содержимое пулреквеста, может присоединиться другой проверяющий. Кроме того, вы можете назначить технических рецензентов и подождать их одобрение через комментарий с <code>/lgtm</code>.</p><p>Также для совсем небольшого изменения, или такого, которое не требует технического рассмотрения, <a href=#%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5>утверждающие</a> SIG Docs одобрить его через комментарий с <code>/lgtm</code>.</p><p>Комментарий с <code>/approve</code> от рецензента игнорируется ботом и поэтому соответствующая метка не добавится к пулреквесту.</p><h3 id=как-стать-рецензентом>Как стать рецензентом</h3><p>Если вы соответствуете <a href=https://github.com/kubernetes/community/blob/master/community-membership.md#reviewer>требованием</a>, то можете стать рецензентом SIG Docs. Рецензенты в других SIG-группах должны подать новую заявку для получения статуса рецензента в SIG Docs.</p><p>Для отправки заявки откройте пулреквест с добавлением самого себя в секцию <code>reviewers</code> <a href=https://github.com/kubernetes/website/blob/main/OWNERS>корневого файла OWNERS</a> в репозитории <code>kubernetes/website</code>. Запросите проверку вашего пулреквеста одному или нескольким текущим утверждающим в группе SIG Docs.</p><p>Если ваш пулреквест одобрен, вы становитесь рецензентом SIG Docs. Теперь бот <a href=https://github.com/kubernetes/test-infra/tree/master/prow#bots-home>K8s-ci-robot</a> будет назначать и предлагать вас в качестве рецензента для проверки новых пулреквестов.</p><p>После того, как ваша кандидатура будет одобрена, попросите текущего утверждающего SIG Docs добавить вас в GitHub-группу <a href=https://github.com/orgs/kubernetes/teams/sig-docs-pr-reviews>@kubernetes/sig-docs-pr-reviews</a>. Только члены GitHub-группы <code>kubernetes-website-admins</code> могут добавлять новых членов в какую-либо другую группу.</p><h2 id=утверждающие>Утверждающие</h2><p>Утверждающие — члены GitHub-группы <a href=https://github.com/orgs/kubernetes/teams/sig-docs-maintainers>@kubernetes/sig-docs-maintainers</a>. Перейдите в раздел <a href=#teams-and-groups-within-sig-docs>Команды и группы в SIG Docs</a> для получения дополнительной информации.</p><p>Утверждающие могут делать следующее:</p><ul><li>Все то же, что и <a href=#%D0%BB%D1%8E%D0%B1%D0%BE%D0%B9>обычные участники</a>, <a href=#%D1%87%D0%BB%D0%B5%D0%BD%D1%8B>члены</a> и <a href=#%D1%80%D0%B5%D1%86%D0%B5%D0%BD%D0%B7%D0%B5%D0%BD%D1%82%D1%8B>рецензенты</a></li><li>Публиковать изменения от других участников путём одобрения и слияния пулреквестов с помощью комментария с командой <code>/approve</code>.
Если кто-то оставляет комментарий, не являясь при этом официальным рецензентом, бот проигнорирует такой одобряющий комментарий.</li><li>Примите участие в работе команды выпуска новых версий Kubernetes как представитель документации</li><li>Предлагать улучшения в руководстве по оформлению</li><li>Предлагать улучшения для тестов документации</li><li>Предлагать улучшения для сайта Kubernetes или других инструментов</li></ul><p>Если у PR есть метка <code>/lgtm</code>, или если утверждающий оставляет комментарий с командной с <code>/lgtm</code>, PR автоматически сливается. Утверждающий SIG Docs должен оставлять комментарий с <code>/lgtm</code> только для тех изменений, которые не нуждаются в дополнительном техническом обзоре.</p><h3 id=как-стать-утверждающим>Как стать утверждающим</h3><p>Если вы соответствуете <a href=https://github.com/kubernetes/community/blob/master/community-membership.md#approver>требованием</a>, вы можете стать утверждающим SIG Docs. Утверждающие в других SIG-группах должны подать новую заявку для получения статуса утверждающего в SIG Docs.</p><p>Для отправки заявки откройте пулреквест с добавлением самого себя в секцию <code>approvers</code> <a href=https://github.com/kubernetes/website/blob/main/OWNERS>корневого файла OWNERS</a> в репозитории <code>kubernetes/website</code>. Запросите проверку вашего пулреквеста одному или нескольким текущим утверждающим в группе SIG Docs.</p><p>Если ваш пулреквест одобрен, вы становитесь утверждающим SIG Docs. Теперь бот <a href=https://github.com/kubernetes/test-infra/tree/master/prow#bots-home>K8s-ci-robot</a> будет назначать и предлагать вас в качестве рецензента для проверки новых пулреквестов.</p><p>После того, как ваша кандидатура будет одобрена, попросите текущего утверждающего SIG Docs добавить вас в GitHub-группу<a href=https://github.com/orgs/kubernetes/teams/sig-docs-maintainers>@kubernetes/sig-docs-maintainers</a>. Только члены GitHub-группы <code>kubernetes-website-admins</code> могут добавлять новых членов в какую-либо другую группу.</p><h3 id=обязанности-утверждающего>Обязанности утверждающего</h3><p>Утверждающие улучшают документацию, проверяя и сливая пулреквесты в репозитории сайта. Из-за того, эта роль предусматривает дополнительные привилегии, на утверждающих возлагаются дополнительные обязанности:</p><ul><li><p>Утверждающие могут использовать команду <code>/approve</code>, которая сливает PR в репозиторий.</p><p>Невнимательное слияние может нарушить работу сайта, поэтому имейте это в виду, когда объединяете какой-либо пулреквест.</p></li><li><p>Убедитесь, что предлагаемые изменения соответствуют <a href=/docs/contribute/style/content-guide/#contributing-content>правилам по содержанию</a>.</p><p>Если вы сомневаетесь или вы не уверены в чем-либо, не стесняйтесь обращаться для дополнительной проверки.</p></li><li><p>Проверьте, что тесты на Netlify пройдены успешно, перед тем как написать комментарий с <code>/approve</code> в PR.</p><img src=/images/docs/contribute/netlify-pass.png width=75% alt="Netlify tests must pass before approving"></li><li><p>Перед одобрением пулреквеста перейдите на предварительный просмотр сайта на Netlify для сделанных изменений в PR, и убедитесь, что всё содержимое выглядит хорошо.</p></li><li><p>Участвуйте в <a href=https://github.com/kubernetes/website/wiki/PR-Wranglers>графике дежурства смотрителя PR</a>, чтобы вас назначили дежурным проверяющим на неделю. SIG Docs ожидает, что все утверждающие примут участие в этом графике. За подробностям обратитесь к странице <a href=/ru/docs/contribute/advanced#%D0%B4%D0%B5%D0%B6%D1%83%D1%80%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE-pr-%D0%BD%D0%B0-%D0%BD%D0%B5%D0%B4%D0%B5%D0%BB%D1%8E>Be the PR Wrangler for a week</a>.</p></li></ul><h2 id=председатель-sig-docs>Председатель SIG Docs</h2><p>Каждая SIG-группа, включая SIG Docs, выбирает одного или нескольких членов из своей SIG-группы в качестве председателей. Это координаторы между SIG Docs и другими подразделениями в организации Kubernetes. От таких людей требуются обширные знания о структуре проекта Kubernetes в целом и как функционирует группа SIG Docs внутри неё. Смотрите раздел <a href=https://github.com/kubernetes/community/tree/master/sig-docs#leadership>Руководство</a>, чтобы узнать текущий список председателей.</p><h2 id=команды-sig-docs-и-автоматизация>Команды SIG Docs и автоматизация</h2><p>Автоматизация в SIG Docs основывается на двух разных механизмах:
группы GitHub и файлы OWNERS.</p><h3 id=github-группы>GitHub-группы</h3><p>Группа SIG Docs представлена двумя командами на GitHub:</p><ul><li><a href=https://github.com/orgs/kubernetes/teams/sig-docs-maintainers>@kubernetes/sig-docs-maintainers</a></li><li><a href=https://github.com/orgs/kubernetes/teams/sig-docs-pr-reviews>@kubernetes/sig-docs-pr-reviews</a></li></ul><p>На каждую из них можно сослаться по имени (<code>@name</code>) в комментариях на GitHub, чтобы общаться со всеми участниками в этой группе.</p><p>Эти команды пересекаются, но назначение у них разное. Для назначения людей на ишью, пулреквестов и поддержки одобрений в PR бот использует информацию из файлов OWNERS.</p><h3 id=файлы-owners-и-вступительная-часть>Файлы OWNERS и вступительная часть</h3><p>Проект Kubernetes использует инструмент автоматизации под названием prow, чтобы автоматизировать процесс, связанный с ишью и пулреквестами на GitHub. <a href=https://github.com/kubernetes/website>Репозиторий сайта Kubernetes</a> использует два <a href=https://github.com/kubernetes/test-infra/tree/master/prow/plugins>плагина prow</a>:</p><ul><li>blunderbuss</li><li>approve</li></ul><p>Все эти плагины используют файлы <a href=https://github.com/kubernetes/website/blob/main/OWNERS>OWNERS</a> и <a href=https://github.com/kubernetes/website/blob/main/OWNERS_ALIASES>OWNERS_ALIASES</a> в корневой директории GitHub-репозитория <code>kubernetes/website</code>, чтобы контролировать работу prow по всему репозиторию.</p><p>Файл OWNERS содержит список людей, которые являются рецензентами и утверждающими в SIG Docs. Файлы OWNERS также может быть в поддиректориях и могут переопределять тех, кто может выступать в качестве рецензента или утверждающего в изменениях файлов этой директории и её поддиректорий. Для получения дополнительной информации о файлах OWNERS в целом, перейдите в <a href=https://github.com/kubernetes/community/blob/master/contributors/guide/owners.md>OWNERS</a>.</p><p>Кроме того, в каждом Markdown-файле могут быть указаны рецензенты и утверждающие в так называемой вступительной части (front-matter) в виде логинов участников или имён групп на GitHub.</p><p>Таким образом файлы OWNERS и вступительная часть в Markdown-файлах определяет своего рода рекомендацию для бота, чтобы он знал, к кому обращаться за технической и редакционной проверкой каждого PR.</p><h2 id=как-происходит-слияние>Как происходит слияние</h2><p>Когда пулреквест сливается в действующую ветку сайта (в данный момент это <code>master</code>), содержимое публикуется и становится общедоступным. Для обеспечения высокого качества публикуемого нами контента, мы доверяем слияние пулреквестов утверждающим SIG Docs. Ниже описан этот процесс.</p><ul><li>Когда пулреквест имеет метки <code>lgtm</code> и <code>approve</code>, при этом у него нет метки <code>hold</code>, и то же время все тесты успешно проходят, то пулреквест автоматически сливается.</li><li>Члены организации Kubernetes и утверждающие SIG Docs могут оставлять комментарии со специальными командами, которые блокирует автоматическое объединение пулреквеста (добавление комментарий с текстом <code>/hold</code> или удаление ранее установленной метки <code>/lgtm</code>).</li><li>Любой участник Kubernetes может добавить метку <code>lgtm</code>, добавив комментарий, включающий в себя <code>/lgtm</code>.</li><li>Только утверждающие SIG Docs могут слить пулреквест путём добавления комментария с <code>/approve</code>. Некоторые утверждающие также играют дополнительные роли, например, <a href=#pr-wrangler>дежурного по PR</a> или <a href=#%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D0%B5%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C-sig-docs>председателя SIG Docs</a>.</li></ul><h2 id=что-дальше>Что дальше</h2><p>Для получения дополнительной информации про участие в документации Kubernetes, посмотрите следующие страницы:</p><ul><li><a href=/ru/docs/contribute/start/>Участие для начинающих</a></li><li><a href=/ru/docs/contribute/style/>Правила оформления документации</a></li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ru/docs/home/>Главная</a>
<a class=text-white href=/ru/community/>Сообщество</a>
<a class=text-white href=/ru/case-studies/>Примеры использования</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Авторы Kubernetes | Документация распространяется под лицензией <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. Все права защищены. The Linux Foundation является зарегистрированной торговой маркой. Список торговых марок The Linux Foundation приведен на странице <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>использования торговых марок</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>