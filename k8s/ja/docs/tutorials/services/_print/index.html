<!doctype html><html lang=ja class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/tutorials/services/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/tutorials/services/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tutorials/services/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tutorials/services/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tutorials/services/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/tutorials/services/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Service | Kubernetes</title><meta property="og:title" content="Service"><meta property="og:description" content="プロダクショングレードのコンテナ管理基盤"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ja/docs/tutorials/services/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Service"><meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary"><meta name=twitter:title content="Service"><meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/ja/docs/tutorials/services/"><meta property="og:title" content="Service"><meta name=twitter:title content="Service"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ja/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ja/docs/>ドキュメント</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/blog/>Blogs</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/training/>トレーニング</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/partners/>パートナー</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/community/>コミュニティ</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/case-studies/>ケーススタディ</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>バージョン</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ja/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/tutorials/services/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/tutorials/services/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/tutorials/services/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/tutorials/services/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ja/docs/tutorials/services/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語 (Japanese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/tutorials/services/>English</a>
<a class=dropdown-item href=/zh-cn/docs/tutorials/services/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/tutorials/services/>한국어 (Korean)</a>
<a class=dropdown-item href=/fr/docs/tutorials/services/>Français (French)</a>
<a class=dropdown-item href=/es/docs/tutorials/services/>Español (Spanish)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.</p><p><a href=/ja/docs/tutorials/services/>このページの通常のビューに戻る</a>.</p></div><h1 class=title>Service</h1><ul><li>1: <a href=#pg-5642e8c51749e4fe2e6a2ccc207f1fab>送信元IPを使用する</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-5642e8c51749e4fe2e6a2ccc207f1fab>1 - 送信元IPを使用する</h1><p>Kubernetesクラスター内で実行されているアプリケーションは、Serviceという抽象化を経由して、他のアプリケーションや外の世界との発見や通信を行います。このドキュメントでは、異なる種類のServiceに送られたパケットの送信元IPに何が起こるのか、そして必要に応じてこの振る舞いを切り替える方法について説明します。</p><h2 id=始める前に>始める前に</h2><h3 id=用語>用語</h3><p>このドキュメントでは、以下の用語を使用します。</p><dl><dt><a href=https://ja.wikipedia.org/wiki/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E5%A4%89%E6%8F%9B>NAT</a></dt><dd>ネットワークアドレス変換(network address translation)</dd><dt><a href=https://en.wikipedia.org/wiki/Network_address_translation#SNAT>送信元NAT</a></dt><dd>パケットの送信元のIPを置換します。このページでは、通常ノードのIPアドレスを置換することを意味します。</dd><dt><a href=https://en.wikipedia.org/wiki/Network_address_translation#DNAT>送信先NAT</a></dt><dd>パケットの送信先のIPを置換します。このページでは、通常<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>のIPアドレスを置換することを意味します。</dd><dt><a href=/ja/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>VIP</a></dt><dd>Kubernetes内のすべての<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>などに割り当てられる仮想IPアドレス(virtual IP address)です。</dd><dt><a href=/ja/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>kube-proxy</a></dt><dd>すべてのノード上でServiceのVIPを管理するネットワークデーモンです。</dd></dl><h3 id=前提条件>前提条件</h3><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><p>以下の例では、HTTPヘッダー経由で受け取ったリクエストの送信元IPをエコーバックする、小さなnginxウェブサーバーを使用します。次のコマンドでウェブサーバーを作成できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment source-ip-app --image<span style=color:#666>=</span>k8s.gcr.io/echoserver:1.4
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>deployment.apps/source-ip-app created
</code></pre><h2 id=目標>目標</h2><ul><li>単純なアプリケーションを様々な種類のService経由で公開する</li><li>それぞれの種類のServiceがどのように送信元IPのNATを扱うかを理解する</li><li>送信元IPを保持することに関わるトレードオフを理解する</li></ul><h2 id=type-clusterip-を使用したserviceでの送信元ip><code>Type=ClusterIP</code>を使用したServiceでの送信元IP</h2><p>kube-proxyが<a href=/ja/docs/concepts/services-networking/service/#proxy-mode-iptables>iptablesモード</a>(デフォルト)で実行されている場合、クラスター内部からClusterIPに送られたパケットに送信元のNATが行われることは決してありません。kube-proxyが実行されているノード上で<code>http://localhost:10249/proxyMode</code>にリクエストを送って、kube-proxyのモードを問い合わせてみましょう。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl get nodes
</span></span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>NAME                           STATUS     ROLES    AGE     VERSION
kubernetes-node-6jst   Ready      &lt;none&gt;   2h      v1.13.0
kubernetes-node-cx31   Ready      &lt;none&gt;   2h      v1.13.0
kubernetes-node-jj1t   Ready      &lt;none&gt;   2h      v1.13.0
</code></pre><p>これらのノードの1つでproxyモードを取得します(kube-proxyはポート10249をlistenしています)。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># このコマンドは、問い合わせを行いたいノード上のシェルで実行してください。</span>
</span></span><span style=display:flex><span>curl http://localhost:10249/proxyMode
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>iptables
</code></pre><p>source IPアプリのServiceを作成することで、送信元IPが保持されているかテストできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment source-ip-app --name<span style=color:#666>=</span>clusterip --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>service/clusterip exposed
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get svc clusterip
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE
clusterip    ClusterIP   10.0.170.92   &lt;none&gt;        80/TCP    51s
</code></pre><p>そして、同じクラスター上のPodから<code>ClusterIP</code>にアクセスします。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run busybox -it --image<span style=color:#666>=</span>busybox --restart<span style=color:#666>=</span>Never --rm
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>Waiting for pod default/busybox to be running, status is Pending, pod ready: false
If you don&#39;t see a command prompt, try pressing enter.
</code></pre><p>これで、Podの内部でコマンドが実行できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># このコマンドは、&#34;kubectl run&#34; のターミナルの内部で実行してください</span>
</span></span><span style=display:flex><span>ip addr
</span></span></code></pre></div><pre tabindex=0><code>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
3: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1460 qdisc noqueue
    link/ether 0a:58:0a:f4:03:08 brd ff:ff:ff:ff:ff:ff
    inet 10.244.3.8/24 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::188a:84ff:feb0:26a5/64 scope link
       valid_lft forever preferred_lft forever
</code></pre><p>そして、<code>wget</code>を使用してローカルのウェブサーバーに問い合わせます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;10.0.170.92&#34; の部分をService名が&#34;clusterip&#34;のIPv4アドレスに置き換えてください</span>
</span></span><span style=display:flex><span>wget -qO - 10.0.170.92
</span></span></code></pre></div><pre tabindex=0><code>CLIENT VALUES:
client_address=10.244.3.8
command=GET
...
</code></pre><p><code>client_address</code>は常にクライアントのPodのIPアドレスになります。これは、クライアントのPodとサーバーのPodが同じノード内にあっても異なるノードにあっても変わりません。</p><h2 id=type-nodeport-を使用したserviceでの送信元ip><code>Type=NodePort</code>を使用したServiceでの送信元IP</h2><p><a href=/ja/docs/concepts/services-networking/service/#nodeport><code>Type=NodePort</code></a>を使用したServiceに送られたパケットは、デフォルトで送信元のNATが行われます。<code>NodePort</code> Serviceを作ることでテストできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment source-ip-app --name<span style=color:#666>=</span>nodeport --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8080</span> --type<span style=color:#666>=</span>NodePort
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>service/nodeport exposed
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>NODEPORT</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.spec.ports[0].nodePort}&#34;</span> services nodeport<span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>NODES</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{ $.items[*].status.addresses[?(@.type==&#34;InternalIP&#34;)].address }&#39;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span></code></pre></div><p>クラウドプロバイダーで実行する場合、上に示した<code>nodes:nodeport</code>に対してファイアウォールのルールを作成する必要があるかもしれません。それでは、上で割り当てたノードポート経由で、クラスターの外部からServiceにアクセスしてみましょう。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> node in <span style=color:#b8860b>$NODES</span>; <span style=color:#a2f;font-weight:700>do</span> curl -s <span style=color:#b8860b>$node</span>:<span style=color:#b8860b>$NODEPORT</span> | grep -i client_address; <span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>client_address=10.180.1.1
client_address=10.240.0.5
client_address=10.240.0.3
</code></pre><p>これらは正しいクライアントIPではなく、クラスターのinternal IPであることがわかります。ここでは、次のようなことが起こっています。</p><ul><li>クライアントがパケットを<code>node2:nodePort</code>に送信する</li><li><code>node2</code>は、パケット内の送信元IPアドレスを自ノードのIPアドレスに置換する(SNAT)</li><li><code>node2</code>は、パケット内の送信先IPアドレスをPodのIPアドレスに置換する</li><li>パケットはnode1にルーティングされ、endpointにルーティングされる</li><li>Podからの応答がnode2にルーティングされて戻ってくる</li><li>Podからの応答がクライアントに送り返される</li></ul><p>図で表すと次のようになります。</p><figure><div class=mermaid>graph LR;
client(client)-->node2[Node 2];
node2-->client;
node2-. SNAT .->node1[Node 1];
node1-. SNAT .->node2;
node1-->endpoint(Endpoint);
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
class node1,node2,endpoint k8s;
class client plain;</div></figure><noscript><div class="alert alert-secondary callout" role=alert><em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em></div></noscript><p>クライアントのIPが失われることを回避するために、Kubernetesには<a href=/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip>クライアントの送信元IPを保持する</a>機能があります。<code>service.spec.externalTrafficPolicy</code>の値を<code>Local</code>に設定すると、kube-proxyはローカルに存在するエンドポイントへのプロキシーリクエストだけをプロキシーし、他のノードへはトラフィックを転送しなくなります。このアプローチでは、オリジナルの送信元IPアドレスが保持されます。ローカルにエンドポイントが存在しない場合には、そのノードに送信されたパケットは損失します。そのため、エンドポイントに到達するパケットに適用する可能性のあるパケット処理ルールでは、送信元IPが正しいことを信頼できます。</p><p>次のようにして<code>service.spec.externalTrafficPolicy</code>フィールドを設定します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch svc nodeport -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;externalTrafficPolicy&#34;:&#34;Local&#34;}}&#39;</span>
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>service/nodeport patched
</code></pre><p>そして、再度テストしてみます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> node in <span style=color:#b8860b>$NODES</span>; <span style=color:#a2f;font-weight:700>do</span> curl --connect-timeout <span style=color:#666>1</span> -s <span style=color:#b8860b>$node</span>:<span style=color:#b8860b>$NODEPORT</span> | grep -i client_address; <span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>client_address=198.51.100.79
</code></pre><p>今度は、<em>正しい</em>クライアントIPが含まれる応答が1つだけ得られました。これは、エンドポイントのPodが実行されているノードから来たものです。</p><p>ここでは、次のようなことが起こっています。</p><ul><li>クライアントがパケットをエンドポイントが存在しない<code>node2:nodePort</code>に送信する</li><li>パケットが損失する</li><li>クライアントがパケットをエンドポイントが<em>存在する</em><code>node1:nodePort</code>に送信する</li><li>node1は、正しい送信元IPを持つパケットをエンドポイントにルーティングする</li></ul><p>図で表すと次のようになります。</p><figure><div class=mermaid>graph TD;
client --> node1[Node 1];
client(client) --x node2[Node 2];
node1 --> endpoint(endpoint);
endpoint --> node1;
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
class node1,node2,endpoint k8s;
class client plain;</div></figure><noscript><div class="alert alert-secondary callout" role=alert><em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em></div></noscript><h2 id=type-loadbalancer-を使用したserviceでの送信元ip><code>Type=LoadBalancer</code>を使用したServiceでの送信元IP</h2><p><a href=/ja/docs/concepts/services-networking/service/#loadbalancer><code>Type=LoadBalancer</code></a>を使用したServiceに送られたパケットは、デフォルトで送信元のNATが行われます。<code>Ready</code>状態にあるすべてのスケジュール可能なKubernetesのNodeは、ロードバランサーからのトラフィックを受付可能であるためです。そのため、エンドポイントが存在しないノードにパケットが到達した場合、システムはエンドポイントが<em>存在する</em>ノードにパケットをプロシキーします。このとき、(前のセクションで説明したように)パケットの送信元IPがノードのIPに置換されます。</p><p>ロードバランサー経由でsource-ip-appを公開することで、これをテストできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment source-ip-app --name<span style=color:#666>=</span>loadbalancer --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8080</span> --type<span style=color:#666>=</span>LoadBalancer
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>service/loadbalancer exposed
</code></pre><p>ServiceのIPアドレスを表示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl get svc loadbalancer
</span></span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>NAME           TYPE           CLUSTER-IP    EXTERNAL-IP       PORT(S)   AGE
loadbalancer   LoadBalancer   10.0.65.118   203.0.113.140     80/TCP    5m
</code></pre><p>次に、Serviceのexternal-ipにリクエストを送信します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl 203.0.113.140
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>CLIENT VALUES:
client_address=10.240.0.5
...
</code></pre><p>しかし、Google Kubernetes EngineやGCE上で実行している場合、同じ<code>service.spec.externalTrafficPolicy</code>フィールドを<code>Local</code>に設定すると、ロードバランサーからのトラフィックを受け付け可能なノードのリストから、Serviceエンドポイントが<em>存在しない</em>ノードが強制的に削除されます。この動作は、ヘルスチェックを意図的に失敗させることによって実現されています。</p><p>図で表すと次のようになります。</p><p><img src=/images/docs/sourceip-externaltrafficpolicy.svg alt="Source IP with externalTrafficPolicy"></p><p>アノテーションを設定することで動作をテストできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch svc loadbalancer -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;externalTrafficPolicy&#34;:&#34;Local&#34;}}&#39;</span>
</span></span></code></pre></div><p>Kubernetesにより割り当てられた<code>service.spec.healthCheckNodePort</code>フィールドをすぐに確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get svc loadbalancer -o yaml | grep -i healthCheckNodePort
</span></span></code></pre></div><p>出力は次のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>healthCheckNodePort</span>:<span style=color:#bbb> </span><span style=color:#666>32122</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>service.spec.healthCheckNodePort</code>フィールドは、<code>/healthz</code>でhealth checkを配信しているすべてのノード上のポートを指しています。次のコマンドでテストできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -o wide -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>source-ip-app
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>NAME                            READY     STATUS    RESTARTS   AGE       IP             NODE
source-ip-app-826191075-qehz4   1/1       Running   0          20h       10.180.1.136   kubernetes-node-6jst
</code></pre><p><code>curl</code>を使用して、さまざまなノード上の<code>/healthz</code>エンドポイントからデータを取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># このコマンドは選んだノードのローカル上で実行してください</span>
</span></span><span style=display:flex><span>curl localhost:32122/healthz
</span></span></code></pre></div><pre tabindex=0><code>1 Service Endpoints found
</code></pre><p>ノードが異なると、得られる結果も異なる可能性があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># このコマンドは、選んだノード上でローカルに実行してください</span>
</span></span><span style=display:flex><span>curl localhost:32122/healthz
</span></span></code></pre></div><pre tabindex=0><code>No Service Endpoints Found
</code></pre><p><a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>上で実行中のコントローラーは、クラウドのロードバランサーを割り当てる責任があります。同じコントローラーは、各ノード上のポートやパスを指すHTTPのヘルスチェックも割り当てます。エンドポイントが存在しない2つのノードがヘルスチェックに失敗するまで約10秒待った後、<code>curl</code>を使用してロードバランサーのIPv4アドレスに問い合わせます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl 203.0.113.140
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>CLIENT VALUES:
client_address=198.51.100.79
...
</code></pre><h2 id=クロスプラットフォームのサポート>クロスプラットフォームのサポート</h2><p><code>Type=LoadBalancer</code>を使用したServiceで送信元IPを保持する機能を提供しているのは一部のクラウドプロバイダだけです。実行しているクラウドプロバイダによっては、以下のように異なる方法でリクエストを満たす場合があります。</p><ol><li><p>クライアントとのコネクションをプロキシーが終端し、ノードやエンドポイントとの接続には新しいコネクションが開かれる。このような場合、送信元IPは常にクラウドのロードバランサーのものになり、クライアントのIPにはなりません。</p></li><li><p>クライアントからロードバランサーのVIPに送信されたリクエストが、中間のプロキシーではなく、クライアントの送信元IPとともにノードまで到達するようなパケット転送が使用される。</p></li></ol><p>1つめのカテゴリーのロードバランサーの場合、真のクライアントIPと通信するために、 HTTPの<a href=https://tools.ietf.org/html/rfc7239#section-5.2>Forwarded</a>ヘッダーや<a href=https://ja.wikipedia.org/wiki/X-Forwarded-For>X-FORWARDED-FOR</a>ヘッダー、<a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>proxy protocol</a>などの、ロードバランサーとバックエンドの間で合意されたプロトコルを使用する必要があります。2つ目のカテゴリーのロードバランサーの場合、Serviceの<code>service.spec.healthCheckNodePort</code>フィールドに保存されたポートを指すHTTPのヘルスチェックを作成することで、上記の機能を活用できます。</p><h2 id=クリーンアップ>クリーンアップ</h2><p>Serviceを削除します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete svc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>source-ip-app
</span></span></code></pre></div><p>Deployment、ReplicaSet、Podを削除します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment source-ip-app
</span></span></code></pre></div><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>Service経由でアプリケーションに接続する</a>方法についてさらに学ぶ。</li><li><a href=/docs/tasks/access-application-cluster/create-external-load-balancer/>External Load Balancerを作成する</a>方法について学ぶ。</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>