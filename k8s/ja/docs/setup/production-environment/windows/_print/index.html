<!doctype html><html lang=ja class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/setup/production-environment/windows/><link rel=alternate hreflang=hi href=https://kubernetes.io/hi/docs/setup/production-environment/windows/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/setup/production-environment/windows/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Windows in Kubernetes | Kubernetes</title><meta property="og:title" content="Windows in Kubernetes"><meta property="og:description" content="プロダクショングレードのコンテナ管理基盤"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ja/docs/setup/production-environment/windows/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Windows in Kubernetes"><meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary"><meta name=twitter:title content="Windows in Kubernetes"><meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/ja/docs/setup/production-environment/windows/"><meta property="og:title" content="Windows in Kubernetes"><meta name=twitter:title content="Windows in Kubernetes"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ja/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ja/docs/>ドキュメント</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/blog/>Blogs</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/training/>トレーニング</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/partners/>パートナー</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/community/>コミュニティ</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/case-studies/>ケーススタディ</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>バージョン</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ja/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/setup/production-environment/windows/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/setup/production-environment/windows/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/setup/production-environment/windows/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/setup/production-environment/windows/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ja/docs/setup/production-environment/windows/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語 (Japanese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/fr/docs/setup/production-environment/windows/>Français (French)</a>
<a class=dropdown-item href=/hi/docs/setup/production-environment/windows/>हिन्दी (Hindi)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.</p><p><a href=/ja/docs/setup/production-environment/windows/>このページの通常のビューに戻る</a>.</p></div><h1 class=title>Windows in Kubernetes</h1><ul><li>1: <a href=#pg-a307d413f1f7430fced233023087e2a1>KubernetesのWindowsサポート概要</a></li><li>2: <a href=#pg-3a51e66c5de55f9093a8dc55742006d3>KubernetesでWindowsコンテナをスケジュールするためのガイド</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-a307d413f1f7430fced233023087e2a1>1 - KubernetesのWindowsサポート概要</h1><p>Windowsアプリケーションは、多くの組織で実行されているサービスやアプリケーションの大部分を占めています。<a href=https://aka.ms/windowscontainers>Windowsコンテナ</a>は、プロセスとパッケージの依存関係を一つにまとめる最新の方法を提供し、DevOpsプラクティスの使用とWindowsアプリケーションのクラウドネイティブパターンの追求を容易にします。Kubernetesは事実上、標準的なコンテナオーケストレータになりました。Kubernetes 1.14のリリースでは、Kubernetesクラスター内のWindowsノードでWindowsコンテナをスケジューリングする本番環境サポートが含まれたので、Windowsアプリケーションの広大なエコシステムにおいて、Kubernetesを有効的に活用できます。WindowsベースのアプリケーションとLinuxベースのアプリケーションに投資している組織は、ワークロードを管理する個別のオーケストレーターが不要となるため、オペレーティングシステムに関係なくアプリケーション全体の運用効率が向上します。</p><h2 id=kubernetesのwindowsコンテナ>KubernetesのWindowsコンテナ</h2><p>KubernetesでWindowsコンテナのオーケストレーションを有効にする方法は、既存のLinuxクラスターにWindowsノードを含めるだけです。Kubernetesの<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>でWindowsコンテナをスケジュールすることは、Linuxベースのコンテナをスケジュールするのと同じくらいシンプルで簡単です。</p><p>Windowsコンテナを実行するには、Kubernetesクラスターに複数のオペレーティングシステムを含める必要があります。コントロールプレーンノードはLinux、ワーカーノードはワークロードのニーズに応じてWindowsまたはLinuxで実行します。Windows Server 2019は、サポートされている唯一のWindowsオペレーティングシステムであり、Windows (kubelet、<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/containerd>コンテナランタイム</a>、kube-proxyを含む)で<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Kubernetesノード</a>を有効にします。Windowsディストリビューションチャンネルの詳細については、<a href=https://docs.microsoft.com/en-us/windows-server/get-started/servicing-channels-comparison>Microsoftのドキュメント</a>を参照してください。</p><p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <a href=/ja/docs/concepts/overview/components/>マスターコンポーネント</a>を含むKubernetesコントロールプレーンは、Linuxで実行し続けます。WindowsのみのKubernetesクラスターを導入する計画はありません。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> このドキュメントでは、Windowsコンテナについて説明する場合、プロセス分離のWindowsコンテナを意味します。<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container>Hyper-V分離</a>のWindowsコンテナは、将来リリースが計画されています。</div></p><h2 id=サポートされている機能と制限>サポートされている機能と制限</h2><h3 id=サポートされている機能>サポートされている機能</h3><h4 id=コンピュート>コンピュート</h4><p>APIとkubectlの観点から見ると、WindowsコンテナはLinuxベースのコンテナとほとんど同じように動作します。ただし、制限セクションで概説されている主要な機能には、いくつかの顕著な違いがあります。</p><p>オペレーティングシステムのバージョンから始めましょう。KubernetesのWindowsオペレーティングシステムのサポートについては、次の表を参照してください。単一の混成Kubernetesクラスターは、WindowsとLinuxの両方のワーカーノードを持つことができます。WindowsコンテナはWindowsノードで、LinuxコンテナはLinuxノードでスケジュールする必要があります。</p><table><thead><tr><th>Kubernetes バージョン</th><th>ホストOS バージョン (Kubernetes ノード)</th><th></th><th></th></tr></thead><tbody><tr><td></td><td><em>Windows Server 1709</em></td><td><em>Windows Server 1803</em></td><td><em>Windows Server 1809/Windows Server 2019</em></td></tr><tr><td><em>Kubernetes v1.14</em></td><td>サポートされていません</td><td>サポートされていません</td><td>Windows Server containers Builds 17763.* と Docker EE-basic 18.09 がサポートされています</td></tr></tbody></table><p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> すべてのWindowsユーザーがアプリのオペレーティングシステムを頻繁に更新することは望んでいません。アプリケーションのアップグレードは、クラスターに新しいノードをアップグレードまたは導入することを要求する必要があります。Kubernetesで実行されているコンテナのオペレーティングシステムをアップグレードすることを選択したユーザーには、新しいオペレーティングシステムバージョンのサポート追加時に、ガイダンスと段階的な指示を提供します。このガイダンスには、クラスターノードと共にアプリケーションをアップグレードするための推奨アップグレード手順が含まれます。Windowsノードは、現在のLinuxノードと同じように、Kubernetes<a href=/ja/docs/setup/release/version-skew-policy/>バージョンスキューポリシー</a>(ノードからコントロールプレーンのバージョン管理)に準拠しています。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Windows Serverホストオペレーティングシステムには、<a href=https://www.microsoft.com/en-us/cloud-platform/windows-server-pricing>Windows Server</a>ライセンスが適用されます。Windowsコンテナイメージには、<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/images-eula>Windowsコンテナの追加ライセンス条項</a>ライセンスが提供されます。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> プロセス分離のWindowsコンテナには、<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/version-compatibility>ホストOSのバージョンはコンテナのベースイメージのOSバージョンと一致する必要がある</a>という厳格な互換性ルールがあります。KubernetesでHyper-V分離のWindowsコンテナをサポートする際には、制限と互換性ルールが変更されます。</div></p><p>Kubernetesの主要な要素は、WindowsでもLinuxと同じように機能します。このセクションでは、主要なワークロードイネーブラーのいくつかと、それらがWindowsにどのようにマップされるかについて説明します。</p><ul><li><p><a href=/ja/docs/concepts/workloads/pods/>Pods</a></p><p>Podは、Kubernetesにおける最も基本的な構成要素です。人間が作成またはデプロイするKubernetesオブジェクトモデルの中で最小かつ最もシンプルな単位です。WindowsとLinuxのコンテナを同じPodにデプロイすることはできません。Pod内のすべてのコンテナは、各ノードが特定のプラットフォームとアーキテクチャを表す単一のノードにスケジュールされます。次のPod機能、プロパティ、およびイベントがWindowsコンテナでサポートされています。:</p><ul><li>プロセス分離とボリューム共有を備えたPodごとの単一または複数のコンテナ</li><li>Podステータスフィールド</li><li>ReadinessとLiveness Probe</li><li>postStartとpreStopコンテナのライフサイクルイベント</li><li>環境変数またはボリュームとしてのConfigMap、 Secrets</li><li>EmptyDir</li><li>名前付きパイプホストマウント</li><li>リソース制限</li></ul></li><li><p><a href=/ja/docs/concepts/workloads/controllers/>Controllers</a></p><p>Kubernetesコントローラは、Podの望ましい状態を処理します。次のワークロードコントローラーは、Windowsコンテナでサポートされています。:</p><ul><li>ReplicaSet</li><li>ReplicationController</li><li>Deployments</li><li>StatefulSets</li><li>DaemonSet</li><li>Job</li><li>CronJob</li></ul></li><li><p><a href=/ja/docs/concepts/services-networking/service/>Services</a></p><p>Kubernetes Serviceは、Podの論理セットとPodにアクセスするためのポリシーを定義する抽象概念です。マイクロサービスと呼ばれることもあります。オペレーティングシステム間の接続にServiceを使用できます。WindowsでのServiceは、次のタイプ、プロパティと機能を利用できます。:</p><ul><li>サービス環境変数</li><li>NodePort</li><li>ClusterIP</li><li>LoadBalancer</li><li>ExternalName</li><li>Headless services</li></ul></li></ul><p>Pod、Controller、Serviceは、KubernetesでWindowsワークロードを管理するための重要な要素です。ただし、それだけでは、動的なクラウドネイティブ環境でWindowsワークロードの適切なライフサイクル管理を可能にするのに十分ではありません。次の機能のサポートを追加しました：</p><ul><li>Podとコンテナのメトリクス</li><li>Horizontal Pod Autoscalerサポート</li><li>kubectl Exec</li><li>リソースクォータ</li><li>Schedulerのプリエンプション</li></ul><h4 id=コンテナランタイム>コンテナランタイム</h4><h5 id=docker-ee>Docker EE</h5><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code></div><p>Docker EE-basic 18.09+は、Kubernetesを実行しているWindows Server 2019 / 1809ノードに推奨されるコンテナランタイムです。kubeletに含まれるdockershimコードで動作します。</p><h5 id=cri-containerd>CRI-ContainerD</h5><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [alpha]</code></div><p>ContainerDはLinux上のKubernetesで動作するOCI準拠のランタイムです。Kubernetes v1.18では、Windows上での<a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=ContainerD>ContainerD</a>のサポートが追加されています。Windows上でのContainerDの進捗状況は<a href=https://github.com/kubernetes/enhancements/issues/1001>enhancements#1001</a>で確認できます。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong><p>Kubernetes v1.18におけるWindows上でのContainerDは以下の既知の欠点があります:</p><ul><li>ContainerDは公式リリースではWindowsをサポートしていません。すなわち、Kubernetesでのすべての開発はアクティブなContainerD開発ブランチに対して行われています。本番環境へのデプロイは常に、完全にテストされセキュリティ修正をサポートした公式リリースを利用するべきです。</li><li>ContainerDを利用した場合、Group Managed Service Accountsは実装されていません。詳細は<a href=https://github.com/containerd/cri/issues/1276>containerd/cri#1276</a>を参照してください。</li></ul></div><h4 id=永続ストレージ>永続ストレージ</h4><p>Kubernetes<a href=/docs/concepts/storage/volumes/>ボリューム</a>を使用すると、データの永続性とPodボリュームの共有要件を備えた複雑なアプリケーションをKubernetesにデプロイできます。特定のストレージバックエンドまたはプロトコルに関連付けられた永続ボリュームの管理には、ボリュームのプロビジョニング/プロビジョニング解除/サイズ変更、Kubernetesノードへのボリュームのアタッチ/デタッチ、およびデータを永続化する必要があるPod内の個別のコンテナへのボリュームのマウント/マウント解除などのアクションが含まれます。特定のストレージバックエンドまたはプロトコルに対してこれらのボリューム管理アクションを実装するコードは、Kubernetesボリューム<a href=/docs/concepts/storage/volumes/#types-of-volumes>プラグイン</a>の形式で出荷されます。次の幅広いクラスのKubernetesボリュームプラグインがWindowsでサポートされています。:</p><h5 id=in-treeボリュームプラグイン>In-treeボリュームプラグイン</h5><p>In-treeボリュームプラグインに関連付けられたコードは、コアKubernetesコードベースの一部として提供されます。In-treeボリュームプラグインのデプロイでは、追加のスクリプトをインストールしたり、個別のコンテナ化されたプラグインコンポーネントをデプロイしたりする必要はありません。これらのプラグインは、ストレージバックエンドでのボリュームのプロビジョニング/プロビジョニング解除とサイズ変更、Kubernetesノードへのボリュームのアタッチ/アタッチ解除、Pod内の個々のコンテナーへのボリュームのマウント/マウント解除を処理できます。次のIn-treeプラグインは、Windowsノードをサポートしています。:</p><ul><li><a href=/docs/concepts/storage/volumes/#awselasticblockstore>awsElasticBlockStore</a></li><li><a href=/docs/concepts/storage/volumes/#azuredisk>azureDisk</a></li><li><a href=/docs/concepts/storage/volumes/#azurefile>azureFile</a></li><li><a href=/docs/concepts/storage/volumes/#gcepersistentdisk>gcePersistentDisk</a></li><li><a href=/docs/concepts/storage/volumes/#vspherevolume>vsphereVolume</a></li></ul><h5 id=flexvolume-plugins>FlexVolume Plugins</h5><p><a href=/docs/concepts/storage/volumes/#flexVolume>FlexVolume</a>プラグインに関連付けられたコードは、ホストに直接デプロイする必要があるout-of-treeのスクリプトまたはバイナリとして出荷されます。FlexVolumeプラグインは、Kubernetesノードとの間のボリュームのアタッチ/デタッチ、およびPod内の個々のコンテナとの間のボリュームのマウント/マウント解除を処理します。FlexVolumeプラグインに関連付けられた永続ボリュームのプロビジョニング/プロビジョニング解除は、通常FlexVolumeプラグインとは別の外部プロビジョニング担当者を通じて処理できます。次のFlexVolume<a href=https://github.com/Microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows>プラグイン</a>は、Powershellスクリプトとしてホストにデプロイされ、Windowsノードをサポートします:</p><ul><li><a href=https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~smb.cmd>SMB</a></li><li><a href=https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~iscsi.cmd>iSCSI</a></li></ul><h5 id=csiプラグイン>CSIプラグイン</h5><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>プラグインに関連付けられたコードは、通常、コンテナイメージとして配布され、DaemonSetやStatefulSetなどの標準のKubernetesコンポーネントを使用してデプロイされるout-of-treeのスクリプトおよびバイナリとして出荷されます。CSIプラグインは、ボリュームのプロビジョニング/プロビジョニング解除/サイズ変更、Kubernetesノードへのボリュームのアタッチ/ボリュームからのデタッチ、Pod内の個々のコンテナへのボリュームのマウント/マウント解除、バックアップ/スナップショットとクローニングを使用した永続データのバックアップ/リストアといった、Kubernetesの幅広いボリューム管理アクションを処理します。CSIプラグインは通常、ノードプラグイン（各ノードでDaemonSetとして実行される）とコントローラープラグインで構成されます。</p><p>CSIノードプラグイン（特に、ブロックデバイスまたは共有ファイルシステムとして公開された永続ボリュームに関連付けられているプラ​​グイン）は、ディスクデバイスのスキャン、ファイルシステムのマウントなど、さまざまな特権操作を実行する必要があります。これらの操作は、ホストオペレーティングシステムごとに異なります。Linuxワーカーノードの場合、コンテナ化されたCSIノードプラグインは通常、特権コンテナとしてデプロイされます。Windowsワーカーノードの場合、コンテナ化されたCSIノードプラグインの特権操作は、<a href=https://github.com/kubernetes-csi/csi-proxy>csi-proxy</a>を使用してサポートされます。各Windowsノードにプリインストールされている。詳細については、展開するCSIプラグインの展開ガイドを参照してください。</p><h4 id=ネットワーキング>ネットワーキング</h4><p>Windowsコンテナのネットワークは、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>CNIプラグイン</a>を通じて公開されます。Windowsコンテナは、ネットワークに関して仮想マシンと同様に機能します。各コンテナには、Hyper-V仮想スイッチ(vSwitch)に接続されている仮想ネットワークアダプター(vNIC)があります。Host Network Service(HNS)とHost Compute Service(HCS)は連携してコンテナを作成し、コンテナvNICをネットワークに接続します。HCSはコンテナの管理を担当するのに対し、HNSは次のようなネットワークリソースの管理を担当します。:</p><ul><li>仮想ネットワーク(vSwitchの作成を含む)</li><li>エンドポイント/vNIC</li><li>名前空間</li><li>ポリシー(パケットのカプセル化、負荷分散ルール、ACL、NATルールなど)</li></ul><p>次のServiceタイプがサポートされています。:</p><ul><li>NodePort</li><li>ClusterIP</li><li>LoadBalancer</li><li>ExternalName</li></ul><p>Windowsは、L2bridge、L2tunnel、Overlay、Transparent、NATの5つの異なるネットワークドライバー/モードをサポートしています。WindowsとLinuxのワーカーノードを持つ異種クラスターでは、WindowsとLinuxの両方で互換性のあるネットワークソリューションを選択する必要があります。以下のツリー外プラグインがWindowsでサポートされており、各CNIをいつ使用するかに関する推奨事項があります。:</p><table><thead><tr><th>ネットワークドライバー</th><th>説明</th><th>コンテナパケットの変更</th><th>ネットワークプラグイン</th><th>ネットワークプラグインの特性</th></tr></thead><tbody><tr><td>L2bridge</td><td>コンテナは外部のvSwitchに接続されます。コンテナはアンダーレイネットワークに接続されますが、物理ネットワークはコンテナのMACを上り/下りで書き換えるため、MACを学習する必要はありません。コンテナ間トラフィックは、コンテナホスト内でブリッジされます。</td><td>MACはホストのMACに書き換えられ、IPは変わりません。</td><td><a href=https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-bridge>win-bridge</a>、<a href=https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md>Azure-CNI</a>、Flannelホストゲートウェイは、win-bridgeを使用します。</td><td>win-bridgeはL2bridgeネットワークモードを使用して、コンテナをホストのアンダーレイに接続して、最高のパフォーマンスを提供します。ノード間接続にはユーザー定義ルート(UDR)が必要です。</td></tr><tr><td>L2Tunnel</td><td>これはl2bridgeの特殊なケースですが、Azureでのみ使用されます。すべてのパケットは、SDNポリシーが適用されている仮想化ホストに送信されます。</td><td>MACが書き換えられ、IPがアンダーレイネットワークで表示されます。</td><td><a href=https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md>Azure-CNI</a></td><td>Azure-CNIを使用すると、コンテナをAzure vNETと統合し、<a href=https://azure.microsoft.com/en-us/services/virtual-network/>Azure Virtual Networkが提供</a>する一連の機能を活用できます。たとえば、Azureサービスに安全に接続するか、Azure NSGを使用します。<a href=https://docs.microsoft.com/en-us/azure/aks/concepts-network#azure-cni-advanced-networking>azure-cniのいくつかの例</a>を参照してください。</td></tr><tr><td>オーバーレイ(KubernetesのWindows用のオーバーレイネットワークは <em>アルファ</em> 段階です)</td><td>コンテナには、外部のvSwitchに接続されたvNICが付与されます。各オーバーレイネットワークは、カスタムIPプレフィックスで定義された独自のIPサブネットを取得します。オーバーレイネットワークドライバーは、VXLANを使用してカプセル化します。</td><td>外部ヘッダーでカプセル化されます。</td><td><a href=https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-overlay>Win-overlay</a>、Flannel VXLAN (win-overlayを使用)</td><td>win-overlayは、仮想コンテナーネットワークをホストのアンダーレイから分離する必要がある場合に使用する必要があります(セキュリティ上の理由など)。データセンター内のIPが制限されている場合に、(異なるVNIDタグを持つ)異なるオーバーレイネットワークでIPを再利用できるようにします。このオプションには、Windows Server 2019で<a href=https://support.microsoft.com/help/4489899>KB4489899</a>が必要です。</td></tr><tr><td>透過的(<a href=https://github.com/openvswitch/ovn-kubernetes>ovn-kubernetes</a>の特別な使用例)</td><td>外部のvSwitchが必要です。コンテナは外部のvSwitchに接続され、論理ネットワーク(論理スイッチおよびルーター)を介したPod内通信を可能にします。</td><td>パケットは、<a href=https://datatracker.ietf.org/doc/draft-gross-geneve/>GENEVE</a>または<a href=https://datatracker.ietf.org/doc/draft-davie-stt/>STT</a>トンネリングを介してカプセル化され、同じホスト上にないポッドに到達します。パケットは、ovnネットワークコントローラーによって提供されるトンネルメタデータ情報を介して転送またはドロップされます。NATは南北通信のために行われます。</td><td><a href=https://github.com/openvswitch/ovn-kubernetes>ovn-kubernetes</a></td><td><a href=https://github.com/openvswitch/ovn-kubernetes/tree/master/contrib>ansible経由でデプロイ</a>します。分散ACLは、Kubernetesポリシーを介して適用できます。 IPAMをサポートします。負荷分散は、kube-proxyなしで実現できます。 NATは、ip​​tables/netshを使用せずに行われます。</td></tr><tr><td>NAT(<em>Kubernetesでは使用されません</em>)</td><td>コンテナには、内部のvSwitchに接続されたvNICが付与されます。DNS/DHCPは、<a href=https://blogs.technet.microsoft.com/virtualization/2016/05/25/windows-nat-winnat-capabilities-and-limitations/>WinNAT</a>と呼ばれる内部コンポーネントを使用して提供されます。</td><td>MACおよびIPはホストMAC/IPに書き換えられます。</td><td><a href=https://github.com/Microsoft/windows-container-networking/tree/master/plugins/nat>nat</a></td><td>完全を期すためにここに含まれています。</td></tr></tbody></table><p>上で概説したように、<a href=https://github.com/coreos/flannel>Flannel</a> CNI<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel>メタプラグイン</a>は、<a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan>VXLANネットワークバックエンド</a>(<strong>アルファサポート</strong>、win-overlayへのデリゲート)および<a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#host-gw>ホストゲートウェイネットワークバックエンド</a>(安定したサポート、win-bridgeへのデリゲート)を介して<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel#windows-support-experimental>Windows</a>でもサポートされます。このプラグインは、参照CNIプラグイン(win-overlay、win-bridge)の1つへの委任をサポートし、WindowsのFlannelデーモン(Flanneld)と連携して、ノードのサブネットリースの自動割り当てとHNSネットワークの作成を行います。このプラグインは、独自の構成ファイル(cni.conf)を読み取り、FlannelDで生成されたsubnet.envファイルからの環境変数と統合します。次に、ネットワークプラミング用の参照CNIプラグインの1つに委任し、ノード割り当てサブネットを含む正しい構成をIPAMプラグイン(ホストローカルなど)に送信します。</p><p>Node、Pod、およびServiceオブジェクトの場合、TCP/UDPトラフィックに対して次のネットワークフローがサポートされます。:</p><ul><li>Pod -> Pod (IP)</li><li>Pod -> Pod (Name)</li><li>Pod -> Service (Cluster IP)</li><li>Pod -> Service (PQDN、ただし、「.」がない場合のみ)</li><li>Pod -> Service (FQDN)</li><li>Pod -> External (IP)</li><li>Pod -> External (DNS)</li><li>Node -> Pod</li><li>Pod -> Node</li></ul><p>Windowsでは、次のIPAMオプションがサポートされています。</p><ul><li><a href=https://github.com/containernetworking/plugins/tree/master/plugins/ipam/host-local>ホストローカル</a></li><li>HNS IPAM (受信トレイプラットフォームIPAM、これはIPAMが設定されていない場合のフォールバック)</li><li><a href=https://github.com/Azure/azure-container-networking/blob/master/docs/ipam.md>Azure-vnet-ipam</a>(azure-cniのみ)</li></ul><h3 id=制限>制限</h3><h4 id=コントロールプレーン>コントロールプレーン</h4><p>Windowsは、Kubernetesアーキテクチャとコンポーネントマトリックスのワーカーノードとしてのみサポートされています。つまり、Kubernetesクラスタには常にLinuxマスターノード、0以上のLinuxワーカーノード、0以上のWindowsワーカーノードが含まれている必要があります。</p><h4 id=コンピュート-1>コンピュート</h4><h5 id=リソース管理とプロセス分離>リソース管理とプロセス分離</h5><p>Linux cgroupsは、Linuxのリソースを制御するPodの境界として使用されます。コンテナは、ネットワーク、プロセス、およびファイルシステムを分離するのために、その境界内に作成されます。cgroups APIを使用して、cpu/io/memoryの統計を収集できます。対照的に、Windowsはシステムネームスペースフィルターを備えたコンテナごとのジョブオブジェクトを使用して、コンテナ内のすべてのプロセスを格納し、ホストからの論理的な分離を提供します。ネームスペースフィルタリングを行わずにWindowsコンテナを実行する方法はありません。これは、ホストの環境ではシステム特権を主張できないため、Windowsでは特権コンテナを使用できないことを意味します。セキュリティアカウントマネージャー(SAM)が独立しているため、コンテナはホストからIDを引き受けることができません。</p><h5 id=オペレーティングシステムの制限>オペレーティングシステムの制限</h5><p>Windowsには厳密な互換性ルールがあり、ホストOSのバージョンとコンテナのベースイメージOSのバージョンは、一致する必要があります。Windows Server 2019のコンテナオペレーティングシステムを備えたWindowsコンテナのみがサポートされます。Hyper-V分離のコンテナは、Windowsコンテナのイメージバージョンに下位互換性を持たせることは、将来のリリースで計画されています。</p><h5 id=機能制限>機能制限</h5><ul><li>TerminationGracePeriod：実装されていません</li><li>単一ファイルのマッピング：CRI-ContainerDで実装されます</li><li>終了メッセージ：CRI-ContainerDで実装されます</li><li>特権コンテナ：現在Windowsコンテナではサポートされていません</li><li>HugePages：現在Windowsコンテナではサポートされていません</li><li>既存のノード問題を検出する機能はLinux専用であり、特権コンテナが必要です。一般的に、特権コンテナはサポートされていないため、これがWindowsで使用されることは想定していません。</li><li>ネームスペース共有については、すべての機能がサポートされているわけではありません（詳細については、APIセクションを参照してください）</li></ul><h5 id=メモリ予約と処理>メモリ予約と処理</h5><p>Windowsには、Linuxのようなメモリ不足のプロセスキラーはありません。Windowsは常に全ユーザーモードのメモリ割り当てを仮想として扱い、ページファイルは必須です。正味の効果は、WindowsはLinuxのようなメモリ不足の状態にはならず、メモリ不足（OOM）終了の影響を受ける代わりにページをディスクに処理します。メモリが過剰にプロビジョニングされ、物理メモリのすべてが使い果たされると、ページングによってパフォーマンスが低下する可能性があります。</p><p>2ステップのプロセスで、メモリ使用量を妥当な範囲内に保つことが可能です。まず、kubeletパラメータ<code>--kubelet-reserve</code>や<code>--system-reserve</code>を使用して、ノード（コンテナ外）でのメモリ使用量を明確にします。これにより、<a href=/ja/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>NodeAllocatable</a>)が削減されます。ワークロードをデプロイするときは、コンテナにリソース制限をかけます（制限のみを設定するか、制限が要求と等しくなければなりません）。これにより、NodeAllocatableも差し引かれ、ノードのリソースがフルな状態になるとSchedulerがPodを追加できなくなります。</p><p>過剰なプロビジョニングを回避するためのベストプラクティスは、Windows、Docker、およびKubernetesのプロセスに対応するために、最低2GBのメモリを予約したシステムでkubeletを構成することです。</p><p>フラグの振舞いについては、次のような異なる動作をします。:</p><ul><li><code>--kubelet-reserve</code>、<code>--system-reserve</code>、および<code>--eviction-hard</code>フラグはノードの割り当て可能数を更新します</li><li><code>--enforce-node-allocable</code>を使用した排除は実装されていません</li><li><code>--eviction-hard</code>および<code>--eviction-soft</code>を使用した排除は実装されていません</li><li>MemoryPressureの制約は実装されていません</li><li>kubeletによって実行されるOOMを排除することはありません</li><li>Windowsノードで実行されているKubeletにはメモリ制限がありません。<code>--kubelet-reserve</code>と<code>--system-reserve</code>は、ホストで実行されているkubeletまたはプロセスに制限を設定しません。これは、ホスト上のkubeletまたはプロセスが、NodeAllocatableとSchedulerの外でメモリリソース不足を引き起こす可能性があることを意味します。</li></ul><h4 id=ストレージ>ストレージ</h4><p>Windowsには、コンテナレイヤーをマウントして、NTFSに基づいて複製されたファイルシステムを作るためのレイヤー構造のファイルシステムドライバーがあります。コンテナ内のすべてのファイルパスは、そのコンテナの環境内だけで決められます。</p><ul><li>ボリュームマウントは、コンテナ内のディレクトリのみを対象にすることができ、個別のファイルは対象にできません</li><li>ボリュームマウントは、ファイルまたはディレクトリをホストファイルシステムに投影することはできません</li><li>WindowsレジストリとSAMデータベースには常に書き込みアクセスが必要であるため、読み取り専用ファイルシステムはサポートされていません。ただし、読み取り専用ボリュームはサポートされています</li><li>ボリュームのユーザーマスクと権限は使用できません。SAMはホストとコンテナ間で共有されないため、それらの間のマッピングはありません。すべての権限はコンテナの環境内で決められます</li></ul><p>その結果、次のストレージ機能はWindowsノードではサポートされません。</p><ul><li>ボリュームサブパスのマウント。Windowsコンテナにマウントできるのはボリューム全体だけです。</li><li>シークレットのサブパスボリュームのマウント</li><li>ホストマウントプロジェクション</li><li>DefaultMode（UID/GID依存関係による）</li><li>読み取り専用のルートファイルシステム。マップされたボリュームは引き続き読み取り専用をサポートします</li><li>ブロックデバイスマッピング</li><li>記憶媒体としてのメモリ</li><li>uui/guid、ユーザーごとのLinuxファイルシステム権限などのファイルシステム機能</li><li>NFSベースのストレージ/ボリュームのサポート</li><li>マウントされたボリュームの拡張（resizefs）</li></ul><h4 id=ネットワーキング-1>ネットワーキング</h4><p>Windowsコンテナネットワーキングは、Linuxネットワーキングとはいくつかの重要な実装方法の違いがあります。<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/architecture>Microsoft documentation for Windows Container Networking</a>には、追加の詳細と背景があります。</p><p>Windowsホストネットワーキングサービスと仮想スイッチはネームスペースを実装して、Podまたはコンテナの必要に応じて仮想NICを作成できます。ただし、DNS、ルート、メトリックなどの多くの構成は、Linuxのような/etc/...ファイルではなく、Windowsレジストリデータベースに保存されます。コンテナのWindowsレジストリはホストのレジストリとは別であるため、ホストからコンテナへの/etc/resolv.confのマッピングなどの概念は、Linuxの場合と同じ効果をもたらしません。これらは、そのコンテナの環境で実行されるWindows APIを使用して構成する必要があります。したがって、CNIの実装は、ファイルマッピングに依存する代わりにHNSを呼び出して、ネットワークの詳細をPodまたはコンテナに渡す必要があります。</p><p>次のネットワーク機能はWindowsノードではサポートされていません</p><ul><li>ホストネットワーキングモードはWindows Podでは使用できません</li><li>ノード自体からのローカルNodePortアクセスは失敗します（他のノードまたは外部クライアントで機能）</li><li>ノードからのService VIPへのアクセスは、Windows Serverの将来のリリースで利用可能になる予定です</li><li>kube-proxyのオーバーレイネットワーキングサポートはアルファリリースです。さらに、<a href=https://support.microsoft.com/en-us/help/4482887/windows-10-update-kb4482887>KB4482887</a>がWindows Server 2019にインストールされている必要があります</li><li>ローカルトラフィックポリシーとDSRモード</li><li>l2bridge、l2tunnel、またはオーバーレイネットワークに接続されたWindowsコンテナは、IPv6スタックを介した通信をサポートしていません。これらのネットワークドライバーがIPv6アドレスを使用できるようにするために必要な機能として、優れたWindowsプラットフォームの機能があり、それに続いて、kubelet、kube-proxy、およびCNIプラグインといったKubernetesの機能があります。</li><li>win-overlay、win-bridge、およびAzure-CNIプラグインを介したICMPプロトコルを使用したアウトバウンド通信。具体的には、Windowsデータプレーン(<a href=https://www.microsoft.com/en-us/research/project/azure-virtual-filtering-platform/>VFP</a>)は、ICMPパケットの置き換えをサポートしていません。これの意味は：<ul><li>同じネットワーク内の宛先に向けられたICMPパケット（pingを介したPod間通信など）は期待どおりに機能し、制限はありません</li><li>TCP/UDPパケットは期待どおりに機能し、制限はありません</li><li>リモートネットワーク（Podからping経由の外部インターネット通信など）を通過するように指示されたICMPパケットは置き換えできないため、ソースにルーティングされません。</li><li>TCP/UDPパケットは引き続き置き換えできるため、<code>ping &lt;destination></code>を<code>curl &lt;destination></code>に置き換えることで、外部への接続をデバッグできます。</li></ul></li></ul><p>これらの機能はKubernetes v1.15で追加されました。</p><ul><li><code>kubectl port-forward</code></li></ul><h5 id=cniプラグイン>CNIプラグイン</h5><ul><li>Windowsリファレンスネットワークプラグインのwin-bridgeとwin-overlayは、<a href=https://github.com/containernetworking/cni/blob/master/SPEC.md>CNI仕様</a>v0.4.0において「CHECK」実装がないため、今のところ実装されていません。</li><li>Flannel VXLAN CNIについては、Windowsで次の制限があります。:</li></ul><ol><li>Node-podの直接間接続は設計上不可能です。Flannel<a href=https://github.com/coreos/flannel/pull/1096>PR 1096</a>を使用するローカルPodでのみ可能です</li><li>VNI 4096とUDPポート4789の使用に制限されています。VNIの制限は現在取り組んでおり、将来のリリースで解決される予定です（オープンソースのflannelの変更）。これらのパラメーターの詳細については、公式の<a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan>Flannel VXLAN</a>バックエンドのドキュメントをご覧ください。</li></ol><h5 id=dns-limitations>DNS</h5><ul><li>ClusterFirstWithHostNetは、DNSでサポートされていません。Windowsでは、FQDNとしてすべての名前を「.」で扱い、PQDNでの名前解決はスキップします。</li><li>Linuxでは、PQDNで名前解決しようとするときに使用するDNSサフィックスリストがあります。Windowsでは、1つのDNSサフィックスしかありません。これは、そのPodのNamespaceに関連付けられているDNSサフィックスです（たとえば、mydns.svc.cluster.local）。Windowsでは、そのサフィックスだけで名前解決可能なFQDNおよびServiceまたはNameでの名前解決ができます。たとえば、defaultのNamespaceで生成されたPodには、DNSサフィックス<strong>default.svc.cluster.local</strong>が付けられます。WindowsのPodでは、<strong>kubernetes.default.svc.cluster.local</strong>と<strong>kubernetes</strong>の両方を名前解決できますが、<strong>kubernetes.default</strong>や<strong>kubernetes.default.svc</strong>のような中間での名前解決はできません。</li><li>Windowsでは、複数のDNSリゾルバーを使用できます。これらには少し異なる動作が付属しているため、ネームクエリの解決には<code>Resolve-DNSName</code>ユーティリティを使用することをお勧めします。</li></ul><h5 id=セキュリティ>セキュリティ</h5><p>Secretはノードのボリュームに平文テキストで書き込まれます（Linuxのtmpfs/in-memoryの比較として）。これはカスタマーが2つのことを行う必要があります</p><ol><li>ファイルACLを使用してSecretファイルの場所を保護する</li><li><a href=https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-how-to-deploy-on-windows-server>BitLocker</a>を使って、ボリュームレベルの暗号化を使用する</li></ol><p><a href=/docs/concepts/policy/pod-security-policy/#users-and-groups>RunAsUser</a>は、現在Windowsではサポートされていません。回避策は、コンテナをパッケージ化する前にローカルアカウントを作成することです。RunAsUsername機能は、将来のリリースで追加される可能性があります。</p><p>SELinux、AppArmor、Seccomp、特性（POSIX機能）のような、Linux固有のPodセキュリティ環境の権限はサポートされていません。</p><p>さらに、既に述べたように特権付きコンテナは、Windowsにおいてサポートされていません。</p><h4 id=api>API</h4><p>ほとんどのKubernetes APIがWindowsでも機能することに違いはありません。そのわずかな違いはOSとコンテナランタイムの違いによるものです。特定の状況では、PodやコンテナなどのワークロードAPIの一部のプロパティが、Linuxで実装されているが、Windowsでは実行できないことを前提に設計されています。</p><p>高いレベルで、これらOSのコンセプトに違いがります。:</p><ul><li>ID - Linuxでは、Integer型として表されるuserID（UID）とgroupID（GID）を使用します。ユーザー名とグループ名は正規ではありません - それらは、UID+GIDの背後にある<code>/etc/groups</code>または<code>/etc/passwd</code>の単なるエイリアスです。Windowsは、Windows Security Access Manager（SAM）データベースに格納されているより大きなバイナリセキュリティ識別子（SID）を使用します。このデータベースは、ホストとコンテナ間、またはコンテナ間で共有されません。</li><li>ファイル権限 - Windowsは、権限とUID+GIDのビットマスクではなく、SIDに基づくアクセス制御リストを使用します</li><li>ファイルパス - Windowsの規則では、<code>/</code>ではなく<code>\</code>を使用します。Go IOライブラリは通常両方を受け入れ、それを機能させるだけですが、コンテナ内で解釈されるパスまたはコマンドラインを設定する場合、<code>\</code>が必要になる場合があります。</li><li>シグナル - Windowsのインタラクティブなアプリは終了を異なる方法で処理し、次の1つ以上を実装できます。:<ul><li>UIスレッドは、WM_CLOSEを含む明確に定義されたメッセージを処理します</li><li>コンソールアプリは、コントロールハンドラーを使用してctrl-cまたはctrl-breakを処理します</li><li>サービスは、SERVICE_CONTROL_STOP制御コードを受け入れることができるサービスコントロールハンドラー関数を登録します。</li></ul></li></ul><p>終了コードは、0が成功、0以外が失敗の場合と同じ規則に従います。特定のエラーコードは、WindowsとLinuxで異なる場合があります。ただし、Kubernetesのコンポーネント（kubelet、kube-proxy）から渡される終了コードは変更されていません。</p><h5 id=v1-container>V1.Container</h5><ul><li>V1.Container.ResourceRequirements.limits.cpuおよびV1.Container.ResourceRequirements.limits.memory - Windowsは、CPU割り当てにハード制限を使用しません。代わりに、共有システムが使用されます。ミリコアに基づく既存のフィールドは、Windowsスケジューラーによって追従される相対共有にスケーリングされます。<a href=https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kuberuntime/helpers_windows.go>参照: kuberuntime/helpers_windows.go</a>、<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/resource-controls>参照: resource controls in Microsoft docs</a><ul><li>Huge Pagesは、Windowsコンテナランタイムには実装されてないので、使用できません。コンテナに対して設定できない<a href=https://docs.microsoft.com/en-us/windows/desktop/Memory/large-page-support>ユーザー特権を主張</a>する必要があります。</li></ul></li><li>V1.Container.ResourceRequirements.requests.cpuおよびV1.Container.ResourceRequirements.requests.memory - リクエストはノードの利用可能なリソースから差し引かれるので、ノードのオーバープロビジョニングを回避するために使用できます。ただし、過剰にプロビジョニングされたノードのリソースを保証するために使用することはできません。オペレーターが完全にプロビジョニングし過ぎないようにする場合は、ベストプラクティスとしてこれらをすべてのコンテナに適用する必要があります。</li><li>V1.Container.SecurityContext.allowPrivilegeEscalation - Windowsでは使用できません、接続されている機能はありません</li><li>V1.Container.SecurityContext.Capabilities - POSIX機能はWindowsでは実装されていません</li><li>V1.Container.SecurityContext.privileged - Windowsでは特権コンテナをサポートしていません</li><li>V1.Container.SecurityContext.procMount - Windowsでは/procファイルシステムがありません</li><li>V1.Container.SecurityContext.readOnlyRootFilesystem - Windowsでは使用できません、レジストリおよびシステムプロセスがコンテナ内で実行するには、書き込みアクセスが必要です</li><li>V1.Container.SecurityContext.runAsGroup - Windowsでは使用できません、GIDのサポートもありません</li><li>V1.Container.SecurityContext.runAsNonRoot - Windowsではrootユーザーが存在しません。最も近いものは、ノードに存在しないIDであるContainerAdministratorです。</li><li>V1.Container.SecurityContext.runAsUser - Windowsでは使用できません。intとしてのUIDはサポートされていません。</li><li>V1.Container.SecurityContext.seLinuxOptions - Windowsでは使用できません、SELinuxがありません</li><li>V1.Container.terminationMessagePath - これは、Windowsが単一ファイルのマッピングをサポートしないという点でいくつかの制限があります。デフォルト値は/dev/termination-logであり、デフォルトではWindowsに存在しないため動作します。</li></ul><h5 id=v1-pod>V1.Pod</h5><ul><li>V1.Pod.hostIPC、v1.pod.hostpid - Windowsではホストのネームスペースを共有することはできません</li><li>V1.Pod.hostNetwork - ホストのネットワークを共有するためのWindows OSサポートはありません</li><li>V1.Pod.dnsPolicy - ClusterFirstWithHostNet - Windowsではホストネットワーキングがサポートされていないため、サポートされていません。</li><li>V1.Pod.podSecurityContext - 以下のV1.PodSecurityContextを参照</li><li>V1.Pod.shareProcessNamespace - これはベータ版の機能であり、Windowsに実装されていないLinuxのNamespace機能に依存しています。Windowsでは、プロセスのネームスペースまたはコンテナのルートファイルシステムを共有できません。共有できるのはネットワークだけです。</li><li>V1.Pod.terminationGracePeriodSeconds - これはWindowsのDockerに完全には実装されていません。<a href=https://github.com/moby/moby/issues/25982>リファレンス</a>を参照してください。今日の動作では、ENTRYPOINTプロセスにCTRL_SHUTDOWN_EVENTが送信され、Windowsではデフォルトで5秒待機し、最後に通常のWindowsシャットダウン動作を使用してすべてのプロセスをシャットダウンします。5秒のデフォルトは、実際にはWindowsレジストリー<a href=https://github.com/moby/moby/issues/25982#issuecomment-426441183>コンテナ内</a>にあるため、コンテナ作成時にオーバーライドできます。</li><li>V1.Pod.volumeDevices - これはベータ機能であり、Windowsには実装されていません。Windowsでは、rawブロックデバイスをPodに接続できません。</li><li>V1.Pod.volumes-EmptyDir、Secret、ConfigMap、HostPath - すべて動作し、TestGridにテストがあります<ul><li>V1.emptyDirVolumeSource - ノードのデフォルトのメディアはWindowsのディスクです。Windowsでは、RAMディスクが組み込まれていないため、メモリはサポートされていません。</li></ul></li><li>V1.VolumeMount.mountPropagation - mount propagationは、Windowsではサポートされていません。</li></ul><h5 id=v1-podsecuritycontext>V1.PodSecurityContext</h5><p>Windowsでは、PodSecurityContextフィールドはどれも機能しません。これらは参照用にここにリストされています。</p><ul><li>V1.PodSecurityContext.SELinuxOptions - SELinuxは、Windowsでは使用できません</li><li>V1.PodSecurityContext.RunAsUser - UIDを提供しますが、Windowsでは使用できません</li><li>V1.PodSecurityContext.RunAsGroup - GIDを提供しますが、Windowsでは使用できません</li><li>V1.PodSecurityContext.RunAsNonRoot - Windowsにはrootユーザーがありません。最も近いものは、ノードに存在しないIDであるContainerAdministratorです。</li><li>V1.PodSecurityContext.SupplementalGroups - GIDを提供しますが、Windowsでは使用できません</li><li>V1.PodSecurityContext.Sysctls - これらはLinuxのsysctlインターフェースの一部です。Windowsには同等のものはありません。</li></ul><h2 id=troubleshooting>ヘルプとトラブルシューティングを学ぶ</h2><p>Kubernetesクラスターのトラブルシューティングの主なヘルプソースは、この<a href=/docs/tasks/debug-application-cluster/troubleshooting/>セクション</a>から始める必要があります。このセクションには、いくつか追加的な、Windows固有のトラブルシューティングヘルプが含まれています。ログは、Kubernetesにおけるトラブルシューティング問題の重要な要素です。他のコントリビューターからトラブルシューティングの支援を求めるときは、必ずそれらを含めてください。SIG-Windows<a href=https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs>ログ収集に関するコントリビュートガイド</a>の指示に従ってください。</p><ol><li><p>start.ps1が正常に完了したことをどのように確認できますか？</p><p>ノード上でkubelet、kube-proxy、および（ネットワーキングソリューションとしてFlannelを選択した場合）flanneldホストエージェントプロセスが実行され、実行ログが個別のPowerShellウィンドウに表示されます。これに加えて、WindowsノードがKubernetesクラスターで「Ready」として表示されているはずです。</p></li><li><p>Kubernetesノードのプロセスをサービスとしてバックグラウンドで実行するように構成できますか？</p><p>Kubeletとkube-proxyは、ネイティブのWindowsサービスとして実行するように既に構成されています、障害（例えば、プロセスのクラッシュ）が発生した場合にサービスを自動的に再起動することにより、復元性を提供します。これらのノードコンポーネントをサービスとして構成するには、2つのオプションがあります。</p><ol><li><p>ネイティブWindowsサービスとして</p><p>Kubeletとkube-proxyは、<code>sc.exe</code>を使用してネイティブのWindowsサービスとして実行できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#080;font-style:italic># 2つの個別のコマンドでkubeletおよびkube-proxyのサービスを作成する</span>
</span></span><span style=display:flex><span>sc.exe create &lt;component_name&gt; binPath= <span style=color:#b44>&#34;&lt;path_to_binary&gt; --service &lt;other_args&gt;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 引数にスペースが含まれている場合は、エスケープする必要があることに注意してください。</span>
</span></span><span style=display:flex><span>sc.exe create kubelet binPath= <span style=color:#b44>&#34;C:\kubelet.exe --service --hostname-override &#39;minion&#39; &lt;other_args&gt;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># サービスを開始する</span>
</span></span><span style=display:flex><span><span style=color:#a2f>Start-Service</span> kubelet
</span></span><span style=display:flex><span><span style=color:#a2f>Start-Service</span> <span style=color:#a2f>kube-proxy</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># サービスを停止する</span>
</span></span><span style=display:flex><span><span style=color:#a2f>Stop-Service</span> kubelet (-Force)
</span></span><span style=display:flex><span><span style=color:#a2f>Stop-Service</span> <span style=color:#a2f>kube-proxy</span> (-Force)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># サービスの状態を問い合わせる</span>
</span></span><span style=display:flex><span><span style=color:#a2f>Get-Service</span> kubelet
</span></span><span style=display:flex><span><span style=color:#a2f>Get-Service</span> <span style=color:#a2f>kube-proxy</span>
</span></span></code></pre></div></li><li><p>nssm.exeの使用</p><p>また、<a href=https://nssm.cc/>nssm.exe</a>などの代替サービスマネージャーを使用して、これらのプロセス（flanneld、kubelet、kube-proxy）をバックグラウンドで実行することもできます。この<a href=https://github.com/Microsoft/SDN/tree/master/Kubernetes/flannel/register-svc.ps1>サンプルスクリプト</a>を使用すると、nssm.exeを利用してkubelet、kube-proxy、flanneld.exeを登録し、Windowsサービスとしてバックグラウンドで実行できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>register-svc</span>.ps1 -NetworkMode &lt;Network mode&gt; -ManagementIP &lt;Windows Node IP&gt; -ClusterCIDR &lt;Cluster subnet&gt; -KubeDnsServiceIP &lt;<span style=color:#a2f>Kube-dns</span> Service IP&gt; -LogDir &lt;Directory to place logs&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># NetworkMode      = ネットワークソリューションとして選択されたネットワークモードl2bridge（flannel host-gw、これもデフォルト値）またはoverlay（flannel vxlan）</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># ManagementIP     = Windowsノードに割り当てられたIPアドレス。 ipconfigを使用してこれを見つけることができます</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># ClusterCIDR      = クラスターのサブネット範囲。（デフォルト値 10.244.0.0/16）</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># KubeDnsServiceIP = Kubernetes DNSサービスIP（デフォルト値 10.96.0.10）</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># LogDir           = kubeletおよびkube-proxyログがそれぞれの出力ファイルにリダイレクトされるディレクトリ（デフォルト値 C:\k）</span>
</span></span></code></pre></div><p>上記のスクリプトが適切でない場合は、次の例を使用してnssm.exeを手動で構成できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#080;font-style:italic># flanneld.exeを登録する</span>
</span></span><span style=display:flex><span>nssm install flanneld C:\flannel\flanneld.exe
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>set </span>flanneld AppParameters --kubeconfig<span style=color:#666>-file</span>=c:\k\config --iface=&lt;ManagementIP&gt; --ip-masq=<span style=color:#666>1</span> --kube-subnet-mgr=<span style=color:#666>1</span>
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>set </span>flanneld AppEnvironmentExtra NODE_NAME=&lt;hostname&gt;
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>set </span>flanneld AppDirectory C:\flannel
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>start </span>flanneld
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># kubelet.exeを登録</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># マイクロソフトは、mcr.microsoft.com/k8s/core/pause:1.2.0としてポーズインフラストラクチャコンテナをリリース</span>
</span></span><span style=display:flex><span>nssm install kubelet C:\k\kubelet.exe
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>set </span>kubelet AppParameters --hostname-override=&lt;hostname&gt; --v=<span style=color:#666>6</span> --pod-infra-container-image=mcr.microsoft.com/k8s/core/pause<span>:</span><span style=color:#666>1.2</span>.0 --resolv-conf=<span style=color:#b44>&#34;&#34;</span> --allow-privileged=true --enable-debugging-handlers --cluster-dns=&lt;<span style=color:#a2f>DNS-service</span>-IP&gt; --cluster-domain=cluster.local --kubeconfig=c:\k\config --hairpin-mode=<span style=color:#a2f>promiscuous-bridge</span> --image-pull-progress-deadline=<span style=color:#666>20m</span> --cgroups-per-qos=false  --log-dir=&lt;log directory&gt; --logtostderr=false --enforce-node-allocatable=<span style=color:#b44>&#34;&#34;</span> --network-plugin=cni --cni-bin-dir=c:\k\cni --cni-conf-dir=c:\k\cni\config
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>set </span>kubelet AppDirectory C:\k
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>start </span>kubelet
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># kube-proxy.exeを登録する (l2bridge / host-gw)</span>
</span></span><span style=display:flex><span>nssm install <span style=color:#a2f>kube-proxy</span> C:\k\<span style=color:#a2f>kube-proxy</span>.exe
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>set kube-proxy</span> AppDirectory c:\k
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>set kube-proxy</span> AppParameters --v=<span style=color:#666>4</span> --proxy-mode=kernelspace --hostname-override=&lt;hostname&gt;--kubeconfig=c:\k\config --enable-dsr=false --log-dir=&lt;log directory&gt; --logtostderr=false
</span></span><span style=display:flex><span>nssm.exe <span style=color:#a2f>set kube-proxy</span> AppEnvironmentExtra KUBE_NETWORK=cbr0
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>set kube-proxy</span> DependOnService kubelet
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>start kube-proxy</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># kube-proxy.exeを登録する (overlay / vxlan)</span>
</span></span><span style=display:flex><span>nssm install <span style=color:#a2f>kube-proxy</span> C:\k\<span style=color:#a2f>kube-proxy</span>.exe
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>set kube-proxy</span> AppDirectory c:\k
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>set kube-proxy</span> AppParameters --v=<span style=color:#666>4</span> --proxy-mode=kernelspace --feature-gates=<span style=color:#b44>&#34;WinOverlay=true&#34;</span> --hostname-override=&lt;hostname&gt; --kubeconfig=c:\k\config --network-name=vxlan0 --source-vip=&lt;<span style=color:#a2f>source-vip</span>&gt; --enable-dsr=false --log-dir=&lt;log directory&gt; --logtostderr=false
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>set kube-proxy</span> DependOnService kubelet
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>start kube-proxy</span>
</span></span></code></pre></div><p>最初のトラブルシューティングでは、<a href=https://nssm.cc/>nssm.exe</a>で次のフラグを使用して、stdoutおよびstderrを出力ファイルにリダイレクトできます。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>nssm <span style=color:#a2f>set </span>&lt;Service Name&gt; AppStdout C:\k\mysvc.log
</span></span><span style=display:flex><span>nssm <span style=color:#a2f>set </span>&lt;Service Name&gt; AppStderr C:\k\mysvc.log
</span></span></code></pre></div><p>詳細については、公式の<a href=https://nssm.cc/usage>nssmの使用法</a>のドキュメントを参照してください。</p></li></ol></li><li><p>Windows Podにネットワーク接続がありません</p><p>仮想マシンを使用している場合は、すべてのVMネットワークアダプターでMACスプーフィングが有効になっていることを確認してください。</p></li><li><p>Windows Podが外部リソースにpingできません</p><p>現在、Windows Podには、ICMPプロトコル用にプログラムされた送信ルールはありません。ただし、TCP/UDPはサポートされています。クラスター外のリソースへの接続を実証する場合は、<code>ping &lt;IP></code>に対応する<code>curl &lt;IP></code>コマンドに置き換えてください。</p><p>それでも問題が解決しない場合は、<a href=https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf>cni.conf</a>のネットワーク構成に値する可能性があるので、いくつかの特別な注意が必要です。この静的ファイルはいつでも編集できます。構成の更新は、新しく作成されたすべてのKubernetesリソースに適用されます。</p><p>Kubernetesのネットワーキング要件の1つ(参照<a href=/ja/docs/concepts/cluster-administration/networking/>Kubernetesモデル</a>)は、内部でNATを使用せずにクラスター通信を行うためのものです。この要件を遵守するために、すべての通信に<a href=https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf#L20>ExceptionList</a>があり、アウトバウンドNATが発生しないようにします。ただし、これは、クエリしようとしている外部IPをExceptionListから除外する必要があることも意味します。そうして初めて、Windows PodからのトラフィックがSNAT処理され、外部からの応答を受信できるようになります。この点で、<code>cni.conf</code>のExceptionListは次のようになります。:</p><pre tabindex=0><code class=language-conf data-lang=conf>&#34;ExceptionList&#34;: [
                &#34;10.244.0.0/16&#34;,  # クラスターのサブネット
                &#34;10.96.0.0/12&#34;,   # Serviceのサブネット
                &#34;10.127.130.0/24&#34; # 管理 (ホスト) のサブネット
            ]
</code></pre></li><li><p>WindowsノードがNodePort Serviceにアクセスできません</p><p>ノード自体からのローカルNodePortアクセスは失敗します。これは既知の制限です。NodePortアクセスは、他のノードまたは外部クライアントから行えます。</p></li><li><p>コンテナのvNICとHNSエンドポイントが削除されています</p><p>この問題は、<code>hostname-override</code>パラメータが<a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>に渡されない場合に発生する可能性があります。これを解決するには、ユーザーは次のようにホスト名をkube-proxyに渡す必要があります。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>C:\k\<span style=color:#a2f>kube-proxy</span>.exe --hostname-override=$(hostname)
</span></span></code></pre></div></li><li><p>flannelを使用すると、クラスターに再参加した後、ノードに問題が発生します</p><p>以前に削除されたノードがクラスターに再参加するときはいつも、flannelDは新しいPodサブネットをノードに割り当てようとします。ユーザーは、次のパスにある古いPodサブネット構成ファイルを削除する必要があります。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>Remove-Item</span> C:\k\SourceVip.json
</span></span><span style=display:flex><span><span style=color:#a2f>Remove-Item</span> C:\k\SourceVipRequest.json
</span></span></code></pre></div></li><li><p><code>start.ps1</code>を起動した後、flanneldが「ネットワークが作成されるのを待っています」と表示されたままになります</p><p>この<a href=https://github.com/coreos/flannel/issues/1066>調査中の問題</a>に関する多数の報告があります。最も可能性が高いのは、flannelネットワークの管理IPが設定されるタイミングの問題です。回避策は、単純にstart.ps1を再起動するか、次のように手動で再起動することです。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>PS </span>C:&gt; [<span style=color:#800>Environment</span>]::SetEnvironmentVariable(<span style=color:#b44>&#34;NODE_NAME&#34;</span>, <span style=color:#b44>&#34;&lt;Windows_Worker_Hostname&gt;&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a2f>PS </span>C:&gt; C:\flannel\flanneld.exe --kubeconfig<span style=color:#666>-file</span>=c:\k\config --iface=&lt;Windows_Worker_Node_IP&gt; --ip-masq=<span style=color:#666>1</span> --kube-subnet-mgr=<span style=color:#666>1</span>
</span></span></code></pre></div></li><li><p><code>/run/flannel/subnet.env</code>がないため、Windows Podを起動できません</p><p>これは、Flannelが正しく起動しなかったことを示しています。 flanneld.exeの再起動を試みるか、Kubernetesマスターの<code>/run/flannel/subnet.env</code>からWindowsワーカーノードの<code>C:\run\flannel\subnet.env</code>に手動でファイルをコピーすることができます。「FLANNEL_SUBNET」行を別の番号に変更します。たとえば、ノードサブネット10.244.4.1/24が必要な場合は以下となります。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-env data-lang=env><span style=display:flex><span><span style=color:#b8860b>FLANNEL_NETWORK</span><span style=color:#666>=</span>10.244.0.0/16
</span></span><span style=display:flex><span><span style=color:#b8860b>FLANNEL_SUBNET</span><span style=color:#666>=</span>10.244.4.1/24
</span></span><span style=display:flex><span><span style=color:#b8860b>FLANNEL_MTU</span><span style=color:#666>=</span><span style=color:#666>1500</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>FLANNEL_IPMASQ</span><span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span></code></pre></div></li><li><p>WindowsノードがService IPを使用してServiceにアクセスできない</p><p>これは、Windows上の現在のネットワークスタックの既知の制限です。ただし、Windows PodはService IPにアクセスできます。</p></li><li><p>kubeletの起動時にネットワークアダプターが見つかりません</p><p>WindowsネットワーキングスタックがKubernetesネットワーキングを動かすには、仮想アダプターが必要です。次のコマンドを実行しても結果が返されない場合（管理シェルで）、仮想ネットワークの作成（Kubeletが機能するために必要な前提条件）に失敗したことになります。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>Get-HnsNetwork</span> | ? Name <span style=color:#666>-ieq</span> <span style=color:#b44>&#34;cbr0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>Get-NetAdapter</span> | ? Name <span style=color:#666>-Like</span> <span style=color:#b44>&#34;vEthernet (Ethernet*&#34;</span>
</span></span></code></pre></div><p>ホストのネットワークアダプターが「イーサネット」ではない場合、多くの場合、start.ps1スクリプトの<a href=https://github.com/microsoft/SDN/blob/master/Kubernetes/flannel/start.ps1#L6>InterfaceName</a>パラメーターを修正する価値があります。そうでない場合は<code>start-kubelet.ps1</code>スクリプトの出力結果を調べて、仮想ネットワークの作成中にエラーがないか確認します。</p></li><li><p>Podが「Container Creating」と表示されたまま動かなくなったり、何度も再起動を繰り返します</p><p>PauseイメージがOSバージョンと互換性があることを確認してください。<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/deploying-resources>説明</a>では、OSとコンテナの両方がバージョン1803であると想定しています。それ以降のバージョンのWindowsを使用している場合は、Insiderビルドなどでは、それに応じてイメージを調整する必要があります。イメージについては、Microsoftの<a href=https://hub.docker.com/u/microsoft/>Dockerレジストリ</a>を参照してください。いずれにしても、PauseイメージのDockerfileとサンプルサービスの両方で、イメージに:latestのタグが付けられていると想定しています。</p><p>Kubernetes v1.14以降、MicrosoftはPauseインフラストラクチャコンテナを<code>mcr.microsoft.com/k8s/core/pause:1.2.0</code>でリリースしています。</p></li><li><p>DNS名前解決が正しく機能していない</p><p>この<a href=#dns-limitations>セクション</a>でDNSの制限を確認してください。</p></li><li><p><code>kubectl port-forward</code>が「ポート転送を実行できません:wincatが見つかりません」で失敗します</p><p>これはKubernetes 1.15、およびPauseインフラストラクチャコンテナ<code>mcr.microsoft.com/k8s/core/pause:1.2.0</code>で実装されました。必ずこれらのバージョン以降を使用してください。
独自のPauseインフラストラクチャコンテナを構築する場合は、必ず<a href=https://github.com/kubernetes-sigs/sig-windows-tools/tree/master/cmd/wincat>wincat</a>を含めてください。</p></li><li><p>Windows Serverノードがプロキシの背後にあるため、Kubernetesのインストールが失敗します</p><p>プロキシの背後にある場合は、次のPowerShell環境変数を定義する必要があります。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=display:flex><span>[<span style=color:#800>Environment</span>]::SetEnvironmentVariable(<span style=color:#b44>&#34;HTTP_PROXY&#34;</span>, <span style=color:#b44>&#34;http://proxy.example.com:80/&#34;</span>, [<span style=color:#800>EnvironmentVariableTarget</span>]::Machine)
</span></span><span style=display:flex><span>[<span style=color:#800>Environment</span>]::SetEnvironmentVariable(<span style=color:#b44>&#34;HTTPS_PROXY&#34;</span>, <span style=color:#b44>&#34;http://proxy.example.com:443/&#34;</span>, [<span style=color:#800>EnvironmentVariableTarget</span>]::Machine)
</span></span></code></pre></div></li><li><p><code>pause</code>コンテナとは何ですか</p><p>Kubernetes Podでは、インフラストラクチャまたは「pause」コンテナが最初に作成され、コンテナエンドポイントをホストします。インフラストラクチャやワーカーコンテナなど、同じPodに属するコンテナは、共通のネットワークネームスペースとエンドポイント（同じIPとポートスペース）を共有します。Pauseコンテナは、ネットワーク構成を失うことなくクラッシュまたは再起動するワーカーコンテナに対応するために必要です。</p><p>「pause」（インフラストラクチャ）イメージは、Microsoft Container Registry（MCR）でホストされています。<code>docker pull mcr.microsoft.com/k8s/core/pause:1.2.0</code>を使用してアクセスできます。詳細については、<a href=https://github.com/kubernetes-sigs/windows-testing/blob/master/images/pause/Dockerfile>DOCKERFILE</a>をご覧ください。</p></li></ol><h3 id=さらなる調査>さらなる調査</h3><p>これらの手順で問題が解決しない場合は、次の方法で、KubernetesのWindowsノードでWindowsコンテナを実行する際のヘルプを利用できます。:</p><ul><li>StackOverflow <a href=https://stackoverflow.com/questions/tagged/windows-server-container>Windows Server Container</a>トピック</li><li>Kubernetesオフィシャルフォーラム <a href=https://discuss.kubernetes.io/>discuss.kubernetes.io</a></li><li>Kubernetes Slack <a href=https://kubernetes.slack.com/messages/sig-windows>#SIG-Windows Channel</a></li></ul><h2 id=issueとfeatureリクエストの報告>IssueとFeatureリクエストの報告</h2><p>バグのようなものがある場合、またはFeatureリクエストを行う場合は、<a href=https://github.com/kubernetes/kubernetes/issues>GitHubのIssueシステム</a>を使用してください。<a href=https://github.com/kubernetes/kubernetes/issues/new/choose>GitHub</a>でIssueを開いて、SIG-Windowsに割り当てることができます。以前に報告された場合は、まずIssueリストを検索し、Issueについての経験をコメントして、追加のログを加える必要があります。SIG-Windows Slackは、チケットを作成する前に、初期サポートとトラブルシューティングのアイデアを得るための素晴らしい手段でもあります。</p><p>バグを報告する場合は、問題の再現方法に関する次のような詳細情報を含めてください。:</p><ul><li>Kubernetesのバージョン: kubectlのバージョン</li><li>環境の詳細: クラウドプロバイダー、OSのディストリビューション、選択したネットワーキングと構成、およびDockerのバージョン</li><li>問題を再現するための詳細な手順</li><li><a href=https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs>関連するログ</a></li><li><code>/sig windows</code>でIssueにコメントして、Issueにsig/windowsのタグを付けて、SIG-Windowsメンバーが気付くようにします</li></ul><h2 id=次の項目>次の項目</h2><p>ロードマップには多くの機能があります。高レベルの簡略リストを以下に示しますが、<a href=https://github.com/orgs/kubernetes/projects/8>ロードマッププロジェクト</a>を見て、<a href=https://github.com/kubernetes/community/blob/master/sig-windows/>貢献すること</a>によってWindowsサポートを改善することをお勧めします。</p><h3 id=hyper-v分離>Hyper-V分離</h3><p>Hyper-V分離はKubernetesで以下のWindowsコンテナのユースケースを実現するために必要です。</p><ul><li>Pod間のハイパーバイザーベースの分離により、セキュリティを強化</li><li>下位互換性により、コンテナの再構築を必要とせずにノードで新しいWindows Serverバージョンを実行</li><li>Podの特定のCPU/NUMA設定</li><li>メモリの分離と予約</li></ul><p>既存のHyper-V分離サポートは、v1.10の試験的な機能であり、上記のCRI-ContainerD機能とRuntimeClass機能を優先して将来廃止される予定です。現在の機能を使用してHyper-V分離コンテナを作成するには、kubeletのフィーチャーゲートを<code>HyperVContainer=true</code>で開始し、Podにアノテーション<code>experimental.windows.kubernetes.io/isolation-type=hyperv</code>を含める必要があります。実験的リリースでは、この機能はPodごとに1つのコンテナに制限されています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>experimental.windows.kubernetes.io/isolation-type</span>:<span style=color:#bbb> </span>hyperv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>microsoft/iis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=kubeadmとクラスターapiを使用したデプロイ>kubeadmとクラスターAPIを使用したデプロイ</h3><p>Kubeadmは、ユーザーがKubernetesクラスターをデプロイするための事実上の標準になりつつあります。kubeadmのWindowsノードのサポートは進行中ですが、ガイドはすでに<a href=/ja/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes/>ここ</a>で利用可能です。Windowsノードが適切にプロビジョニングされるように、クラスターAPIにも投資しています。</p><h3 id=その他の主な機能>その他の主な機能</h3><ul><li>グループ管理サービスアカウントのベータサポート</li><li>その他のCNI</li><li>その他のストレージプラグイン</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3a51e66c5de55f9093a8dc55742006d3>2 - KubernetesでWindowsコンテナをスケジュールするためのガイド</h1><p>Windowsアプリケーションは、多くの組織で実行されるサービスとアプリケーションの大部分を占めます。このガイドでは、KubernetesでWindowsコンテナを構成してデプロイする手順について説明します。</p><h2 id=目的>目的</h2><ul><li>WindowsノードでWindowsコンテナを実行するサンプルのDeploymentを構成します</li><li>(オプション)Group Managed Service Accounts(GMSA)を使用してPodのActive Directory IDを構成します</li></ul><h2 id=始める前に>始める前に</h2><ul><li><a href=/ja/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes>Windows Serverを実行するマスターノードとワーカーノード</a>を含むKubernetesクラスターを作成します</li><li>Kubernetes上にServiceとワークロードを作成してデプロイすることは、LinuxコンテナとWindowsコンテナ共に、ほぼ同じように動作することに注意してください。クラスターとのインタフェースとなる<a href=/docs/reference/kubectl/overview/>Kubectlコマンド</a>も同じです。Windowsコンテナをすぐに体験できる例を以下セクションに用意しています。</li></ul><h2 id=はじめに-windowsコンテナのデプロイ>はじめに:Windowsコンテナのデプロイ</h2><p>WindowsコンテナをKubernetesにデプロイするには、最初にサンプルアプリケーションを作成する必要があります。以下のYAMLファイルの例では、簡単なウェブサーバーアプリケーションを作成しています。以下の内容で<code>win-webserver.yaml</code>という名前のサービススペックを作成します。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># このサービスが提供するポート</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>windowswebserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore:ltsc2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- powershell.exe<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- -command<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:#b44>&#34;&lt;#code used from https://gist.github.com/19WAS85/5424431#&gt; ; $$listener = New-Object System.Net.HttpListener ; $$listener.Prefixes.Add(&#39;http://*:80/&#39;) ; $$listener.Start() ; $$callerCounts = @{} ; Write-Host(&#39;Listening at http://*:80/&#39;) ; while ($$listener.IsListening) { ;$$context = $$listener.GetContext() ;$$requestUrl = $$context.Request.Url ;$$clientIP = $$context.Request.RemoteEndPoint.Address ;$$response = $$context.Response ;Write-Host &#39;&#39; ;Write-Host(&#39;&gt; {0}&#39; -f $$requestUrl) ;  ;$$count = 1 ;$$k=$$callerCounts.Get_Item($$clientIP) ;if ($$k -ne $$null) { $$count = $$k } ;$$callerCounts.Set_Item($$clientIP, $$count) ;$$ip=(Get-NetAdapter | Get-NetIpAddress); $$header=&#39;&lt;html&gt;&lt;body&gt;&lt;H1&gt;Windows Container Web Server&lt;/H1&gt;&#39; ;$$callerCountsString=&#39;&#39; ;$$callerCounts.Keys | % { $$callerCountsString=&#39;&lt;p&gt;IP {0} callerCount {1} &#39; -f $$ip[1].IPAddress,$$callerCounts.Item($$_) } ;$$footer=&#39;&lt;/body&gt;&lt;/html&gt;&#39; ;$$content=&#39;{0}{1}{2}&#39; -f $$header,$$callerCountsString,$$footer ;Write-Output $$content ;$$buffer = [System.Text.Encoding]::UTF8.GetBytes($$content) ;$$response.ContentLength64 = $$buffer.Length ;$$response.OutputStream.Write($$buffer, 0, $$buffer.Length) ;$$response.Close() ;$$responseStatus = $$response.StatusCode ;Write-Host(&#39;&lt; {0}&#39; -f $$responseStatus)  } ; &#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ポートマッピングもサポートされていますが、この例では簡単にするために、コンテナポート80がサービスに直接公開されています。</div><ol><li><p>すべてのノードが正常であることを確認します。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div></li><li><p>Serviceをデプロイして、Podの更新を確認します。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f win-webserver.yaml
</span></span><span style=display:flex><span>kubectl get pods -o wide -w
</span></span></code></pre></div><p>Serviceが正しくデプロイされると、両方のPodがReadyとして表示されます。watch状態のコマンドを終了するには、Ctrl + Cを押します。</p></li><li><p>デプロイが成功したことを確認します。検証するために行うこと:</p><ul><li>WindowsノードのPodごとの2つのコンテナに<code>docker ps</code>します</li><li>Linuxマスターからリストされた2つのPodに<code>kubectl get pods</code>します</li><li>ネットワークを介したノードとPod間通信、LinuxマスターからのPod IPのポート80に向けて<code>curl</code>して、ウェブサーバーの応答をチェックします</li><li>docker execまたはkubectl execを使用したPod間通信、Pod間(および複数のWindowsノードがある場合はホスト間)へのpingします</li><li>ServiceからPodへの通信、Linuxマスターおよび個々のPodからの仮想Service IP(<code>kubectl get services</code>で表示される)に<code>curl</code>します</li><li>サービスディスカバリ、Kubernetesの<a href=/ja/docs/concepts/services-networking/dns-pod-service/#services>default DNS suffix</a>と共にService名に<code>curl</code>します</li><li>Inbound connectivity, <code>curl</code> the NodePort from the Linux master or machines outside of the cluster</li><li>インバウンド接続、Linuxマスターまたはクラスター外のマシンからNodePortに<code>curl</code>します</li><li>アウトバウンド接続、kubectl execを使用したPod内からの外部IPに<code>curl</code>します</li></ul></li></ol><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 今のところ、Windowsネットワークスタックのプラットフォーム制限のため、Windowsコンテナホストは、ホストされているサービスのIPにアクセスできません。Service IPにアクセスできるのは、Windows Podだけです。</div><h2 id=可観測性>可観測性</h2><h3 id=ワークロードからのログキャプチャ>ワークロードからのログキャプチャ</h3><p>ログは可観測性の重要な要素です。これにより、ユーザーはワークロードの運用面に関する洞察を得ることができ、問題のトラブルシューティングの主要な要素になります。WindowsコンテナとWindowsコンテナ内のワークロードの動作はLinuxコンテナとは異なるため、ユーザーはログの収集に苦労し、運用の可視性が制限されていました。たとえば、Windowsワークロードは通常、ETW(Windowsのイベントトレース)にログを記録するか、アプリケーションイベントログにエントリをプッシュするように構成されます。Microsoftのオープンソースツールである<a href=https://github.com/microsoft/windows-container-tools/tree/master/LogMonitor>LogMonitor</a>は、Windowsコンテナ内の構成されたログソースを監視するための推奨方法です。LogMonitorは、イベントログ、ETWプロバイダー、カスタムアプリケーションログのモニタリングをサポートしており、それらをSTDOUTにパイプして、<code>kubectl logs &lt;pod></code>で使用できます。</p><p>LogMonitor GitHubページの指示に従って、バイナリと構成ファイルをすべてのコンテナにコピーして、LogMonitorがログをSTDOUTにプッシュするために必要なエントリーポイントを追加します。</p><h2 id=構成可能なコンテナのユーザー名の使用>構成可能なコンテナのユーザー名の使用</h2><p>Kubernetes v1.16以降、Windowsコンテナは、イメージのデフォルトとは異なるユーザー名でエントリーポイントとプロセスを実行するように構成できます。これが達成される方法は、Linuxコンテナで行われる方法とは少し異なります。詳しくは<a href=/docs/tasks/configure-pod-container/configure-runasusername/>こちら</a>.</p><h2 id=group-managed-service-accountsによるワークロードidの管理>Group Managed Service AccountsによるワークロードIDの管理</h2><p>Kubernetes v1.14以降、Windowsコンテナワークロードは、Group Managed Service Accounts(GMSA)を使用するように構成できます。Group Managed Service Accountsは、自動パスワード管理、簡略化されたサービスプリンシパル名（SPN）管理、および複数のサーバー間で他の管理者に管理を委任する機能を提供する特定の種類のActive Directoryアカウントです。GMSAで構成されたコンテナは、GMSAで構成されたIDを保持しながら、外部Active Directoryドメインリソースにアクセスできます。Windowsコンテナ用のGMSAの構成と使用の詳細は<a href=/docs/tasks/configure-pod-container/configure-gmsa/>こちら</a>。</p><h2 id=taintsとtolerations>TaintsとTolerations</h2><p>今日のユーザーは、LinuxとWindowsのワークロードをそれぞれのOS固有のノードで維持するために、Taintsとノードセレクターのいくつかの組み合わせを使用する必要があります。これはおそらくWindowsユーザーにのみ負担をかけます。推奨されるアプローチの概要を以下に示します。主な目標の1つは、このアプローチによって既存のLinuxワークロードの互換性が損なわれないようにすることです。</p><h3 id=os固有のワークロードが適切なコンテナホストに確実に到達するようにする>OS固有のワークロードが適切なコンテナホストに確実に到達するようにする</h3><p>ユーザーは、TaintsとTolerationsを使用して、Windowsコンテナを適切なホストでスケジュールできるようにすることができます。現在、すべてのKubernetesノードには次のデフォルトラベルがあります。:</p><ul><li>kubernetes.io/os = [windows|linux]</li><li>kubernetes.io/arch = [amd64|arm64|...]</li></ul><p>Podの仕様で<code>"kubernetes.io/os": windows</code>のようなnodeSelectorが指定されていない場合、PodをWindowsまたはLinuxの任意のホストでスケジュールすることができます。WindowsコンテナはWindowsでのみ実行でき、LinuxコンテナはLinuxでのみ実行できるため、これは問題になる可能性があります。ベストプラクティスは、nodeSelectorを使用することです。</p><p>ただし、多くの場合、ユーザーには既存の多数のLinuxコンテナのdeployment、およびコミュニティHelmチャートのような既成構成のエコシステムやOperatorのようなプログラム的にPodを生成するケースがあることを理解しています。このような状況では、nodeSelectorsを追加するための構成変更をためらう可能性があります。代替策は、Taintsを使用することです。kubeletは登録中にTaintsを設定できるため、Windowsだけで実行する時に自動的にTaintを追加するように簡単に変更できます。</p><p>例:<code>--register-with-taints='os=windows:NoSchedule'</code></p><p>すべてのWindowsノードにTaintを追加することにより、それらには何もスケジュールされません（既存のLinuxPodを含む）。Windows PodがWindowsノードでスケジュールされるためには、nodeSelectorがWindowsを選択することと、適切にマッチするTolerationが必要です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>node.kubernetes.io/windows-build</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;10.0.17763&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;os&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;windows&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=同じクラスター内の複数windowsバージョンの管理>同じクラスター内の複数Windowsバージョンの管理</h3><p>各Podで使用されるWindows Serverのバージョンは、ノードのバージョンと一致している必要があります。
同じクラスター内で複数のWindows Serverバージョンを使用したい場合は、追加のノードラベルとnodeSelectorsを設定する必要があります。</p><p>Kubernetes 1.17では、これを簡単するために新しいラベル<code>node.kubernetes.io/windows-build</code>が自動的に追加されます。古いバージョンを実行している場合は、このラベルをWindowsノードに手動で追加することをお勧めします。</p><p>このラベルは、互換性のために一致する必要があるWindowsのメジャー、マイナー、およびビルド番号を反映しています。以下は、Windows Serverの各バージョンで現在使用されている値です。</p><table><thead><tr><th>製品番号 　　</th><th>ビルド番号</th></tr></thead><tbody><tr><td>Windows Server 2019</td><td>10.0.17763</td></tr><tr><td>Windows Server version 1809</td><td>10.0.17763</td></tr><tr><td>Windows Server version 1903</td><td>10.0.18362</td></tr></tbody></table><h3 id=runtimeclassによる簡素化>RuntimeClassによる簡素化</h3><p><a href=https://kubernetes.io/ja/docs/concepts/containers/runtime-class/>RuntimeClass</a>は、TaintsとTolerationsを使用するプロセスを簡略化するために使用できます。クラスター管理者は、これらのTaintsとTolerationsをカプセル化するために使用する<code>RuntimeClass</code>オブジェクトを作成できます。</p><ol><li>このファイルを<code>runtimeClasses.yml</code>に保存します。これには、Windows OS、アーキテクチャ、およびバージョンに適切な<code>nodeSelector</code>が含まれています。</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>windows-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>scheduling</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;windows&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/arch</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;amd64&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>node.kubernetes.io/windows-build</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;10.0.17763&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>os<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Equal<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;windows&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ol><li>クラスター管理者として使用する<code>kubectl create -f runtimeClasses.yml</code>を実行します</li><li>Podの仕様に応じて<code>runtimeClassName: windows-2019</code>を追加します</li></ol><p>例:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>windows-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>800Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>.1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>300Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></span></span></code></pre></div></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>