<!doctype html><html lang=ja class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/concepts/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>コンセプト | Kubernetes</title><meta property="og:title" content="コンセプト"><meta property="og:description" content="プロダクショングレードのコンテナ管理基盤"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="コンセプト"><meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary"><meta name=twitter:title content="コンセプト"><meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="本セクションは、Kubernetesシステムの各パートと、クラスターを表現するためにKubernetesが使用する抽象概念について学習し、Kubernetesの仕組みをより深く理解するのに役立ちます。
概要 Kubernetesを機能させるには、Kubernetes API オブジェクト を使用して、実行したいアプリケーションやその他のワークロード、使用するコンテナイメージ、レプリカ(複製)の数、どんなネットワークやディスクリソースを利用可能にするかなど、クラスターの desired state (望ましい状態)を記述します。desired state (望ましい状態)をセットするには、Kubernetes APIを使用してオブジェクトを作成します。通常はコマンドラインインターフェイス kubectl を用いてKubernetes APIを操作しますが、Kubernetes APIを直接使用してクラスターと対話し、desired state (望ましい状態)を設定、または変更することもできます。
一旦desired state (望ましい状態)を設定すると、Pod Lifecycle Event Generator(PLEG)を使用したKubernetes コントロールプレーンが機能し、クラスターの現在の状態をdesired state (望ましい状態)に一致させます。そのためにKubernetesはさまざまなタスク(たとえば、コンテナの起動または再起動、特定アプリケーションのレプリカ数のスケーリング等)を自動的に実行します。Kubernetesコントロールプレーンは、クラスターで実行されている以下のプロセスで構成されています。
Kubernetes Master: kube-apiserver、kube-controller-manager、kube-scheduler の3プロセスの集合です。これらのプロセスはクラスター内の一つのノード上で実行されます。実行ノードはマスターノードとして指定します。 クラスター内の個々の非マスターノードは、それぞれ2つのプロセスを実行します。 kubelet: Kubernetes Masterと通信します。 kube-proxy: 各ノードのKubernetesネットワークサービスを反映するネットワークプロキシです。 Kubernetesオブジェクト Kubernetesには、デプロイ済みのコンテナ化されたアプリケーションやワークロード、関連するネットワークとディスクリソース、クラスターが何をしているかに関するその他の情報といった、システムの状態を表現する抽象が含まれています。これらの抽象は、Kubernetes APIのオブジェクトによって表現されます。詳細については、Kubernetesオブジェクトについて知るをご覧ください。
基本的なKubernetesのオブジェクトは次のとおりです。
Pod Service Volume Namespace Kubernetesには、コントローラーに依存して基本オブジェクトを構築し、追加の機能と便利な機能を提供する高レベルの抽象化も含まれています。これらには以下のものを含みます:
Deployment DaemonSet StatefulSet ReplicaSet Job Kubernetesコントロールプレーン Kubernetesマスターや kubeletプロセスといったKubernetesコントロールプレーンのさまざまなパーツは、Kubernetesがクラスターとどのように通信するかを統制します。コントロールプレーンはシステム内のすべてのKubernetesオブジェクトの記録を保持し、それらのオブジェクトの状態を管理するために継続的制御ループを実行します。コントロールプレーンの制御ループは常にクラスターの変更に反応し、システム内のすべてのオブジェクトの実際の状態が、指定した状態に一致するように動作します。
たとえば、Kubernetes APIを使用してDeploymentを作成する場合、システムには新しいdesired state (望ましい状態)が提供されます。Kubernetesコントロールプレーンは、そのオブジェクトの作成を記録します。そして、要求されたアプリケーションの開始、およびクラスターノードへのスケジューリングにより指示を完遂します。このようにしてクラスターの実際の状態を望ましい状態に一致させます。
Kubernetesマスター Kubernetesのマスターは、クラスターの望ましい状態を維持する責務を持ちます。kubectl コマンドラインインターフェイスを使用するなどしてKubernetesとやり取りするとき、ユーザーは実際にはクラスターにあるKubernetesのマスターと通信しています。
「マスター」とは、クラスター状態を管理するプロセスの集合を指します。通常これらのプロセスは、すべてクラスター内の単一ノードで実行されます。このノードはマスターとも呼ばれます。マスターは、可用性と冗長性のために複製することもできます。
Kubernetesノード クラスターのノードは、アプリケーションとクラウドワークフローを実行するマシン(VM、物理サーバーなど)です。Kubernetesのマスターは各ノードを制御します。運用者自身がノードと直接対話することはほとんどありません。
次の項目 コンセプトページを追加したい場合は、 ページテンプレートの使用 のコンセプトページタイプとコンセプトテンプレートに関する情報を確認してください。"><meta property="og:description" content="本セクションは、Kubernetesシステムの各パートと、クラスターを表現するためにKubernetesが使用する抽象概念について学習し、Kubernetesの仕組みをより深く理解するのに役立ちます。
概要 Kubernetesを機能させるには、Kubernetes API オブジェクト を使用して、実行したいアプリケーションやその他のワークロード、使用するコンテナイメージ、レプリカ(複製)の数、どんなネットワークやディスクリソースを利用可能にするかなど、クラスターの desired state (望ましい状態)を記述します。desired state (望ましい状態)をセットするには、Kubernetes APIを使用してオブジェクトを作成します。通常はコマンドラインインターフェイス kubectl を用いてKubernetes APIを操作しますが、Kubernetes APIを直接使用してクラスターと対話し、desired state (望ましい状態)を設定、または変更することもできます。
一旦desired state (望ましい状態)を設定すると、Pod Lifecycle Event Generator(PLEG)を使用したKubernetes コントロールプレーンが機能し、クラスターの現在の状態をdesired state (望ましい状態)に一致させます。そのためにKubernetesはさまざまなタスク(たとえば、コンテナの起動または再起動、特定アプリケーションのレプリカ数のスケーリング等)を自動的に実行します。Kubernetesコントロールプレーンは、クラスターで実行されている以下のプロセスで構成されています。
Kubernetes Master: kube-apiserver、kube-controller-manager、kube-scheduler の3プロセスの集合です。これらのプロセスはクラスター内の一つのノード上で実行されます。実行ノードはマスターノードとして指定します。 クラスター内の個々の非マスターノードは、それぞれ2つのプロセスを実行します。 kubelet: Kubernetes Masterと通信します。 kube-proxy: 各ノードのKubernetesネットワークサービスを反映するネットワークプロキシです。 Kubernetesオブジェクト Kubernetesには、デプロイ済みのコンテナ化されたアプリケーションやワークロード、関連するネットワークとディスクリソース、クラスターが何をしているかに関するその他の情報といった、システムの状態を表現する抽象が含まれています。これらの抽象は、Kubernetes APIのオブジェクトによって表現されます。詳細については、Kubernetesオブジェクトについて知るをご覧ください。
基本的なKubernetesのオブジェクトは次のとおりです。
Pod Service Volume Namespace Kubernetesには、コントローラーに依存して基本オブジェクトを構築し、追加の機能と便利な機能を提供する高レベルの抽象化も含まれています。これらには以下のものを含みます:
Deployment DaemonSet StatefulSet ReplicaSet Job Kubernetesコントロールプレーン Kubernetesマスターや kubeletプロセスといったKubernetesコントロールプレーンのさまざまなパーツは、Kubernetesがクラスターとどのように通信するかを統制します。コントロールプレーンはシステム内のすべてのKubernetesオブジェクトの記録を保持し、それらのオブジェクトの状態を管理するために継続的制御ループを実行します。コントロールプレーンの制御ループは常にクラスターの変更に反応し、システム内のすべてのオブジェクトの実際の状態が、指定した状態に一致するように動作します。
たとえば、Kubernetes APIを使用してDeploymentを作成する場合、システムには新しいdesired state (望ましい状態)が提供されます。Kubernetesコントロールプレーンは、そのオブジェクトの作成を記録します。そして、要求されたアプリケーションの開始、およびクラスターノードへのスケジューリングにより指示を完遂します。このようにしてクラスターの実際の状態を望ましい状態に一致させます。
Kubernetesマスター Kubernetesのマスターは、クラスターの望ましい状態を維持する責務を持ちます。kubectl コマンドラインインターフェイスを使用するなどしてKubernetesとやり取りするとき、ユーザーは実際にはクラスターにあるKubernetesのマスターと通信しています。
「マスター」とは、クラスター状態を管理するプロセスの集合を指します。通常これらのプロセスは、すべてクラスター内の単一ノードで実行されます。このノードはマスターとも呼ばれます。マスターは、可用性と冗長性のために複製することもできます。
Kubernetesノード クラスターのノードは、アプリケーションとクラウドワークフローを実行するマシン(VM、物理サーバーなど)です。Kubernetesのマスターは各ノードを制御します。運用者自身がノードと直接対話することはほとんどありません。
次の項目 コンセプトページを追加したい場合は、 ページテンプレートの使用 のコンセプトページタイプとコンセプトテンプレートに関する情報を確認してください。"><meta name=twitter:description content="本セクションは、Kubernetesシステムの各パートと、クラスターを表現するためにKubernetesが使用する抽象概念について学習し、Kubernetesの仕組みをより深く理解するのに役立ちます。
概要 Kubernetesを機能させるには、Kubernetes API オブジェクト を使用して、実行したいアプリケーションやその他のワークロード、使用するコンテナイメージ、レプリカ(複製)の数、どんなネットワークやディスクリソースを利用可能にするかなど、クラスターの desired state (望ましい状態)を記述します。desired state (望ましい状態)をセットするには、Kubernetes APIを使用してオブジェクトを作成します。通常はコマンドラインインターフェイス kubectl を用いてKubernetes APIを操作しますが、Kubernetes APIを直接使用してクラスターと対話し、desired state (望ましい状態)を設定、または変更することもできます。
一旦desired state (望ましい状態)を設定すると、Pod Lifecycle Event Generator(PLEG)を使用したKubernetes コントロールプレーンが機能し、クラスターの現在の状態をdesired state (望ましい状態)に一致させます。そのためにKubernetesはさまざまなタスク(たとえば、コンテナの起動または再起動、特定アプリケーションのレプリカ数のスケーリング等)を自動的に実行します。Kubernetesコントロールプレーンは、クラスターで実行されている以下のプロセスで構成されています。
Kubernetes Master: kube-apiserver、kube-controller-manager、kube-scheduler の3プロセスの集合です。これらのプロセスはクラスター内の一つのノード上で実行されます。実行ノードはマスターノードとして指定します。 クラスター内の個々の非マスターノードは、それぞれ2つのプロセスを実行します。 kubelet: Kubernetes Masterと通信します。 kube-proxy: 各ノードのKubernetesネットワークサービスを反映するネットワークプロキシです。 Kubernetesオブジェクト Kubernetesには、デプロイ済みのコンテナ化されたアプリケーションやワークロード、関連するネットワークとディスクリソース、クラスターが何をしているかに関するその他の情報といった、システムの状態を表現する抽象が含まれています。これらの抽象は、Kubernetes APIのオブジェクトによって表現されます。詳細については、Kubernetesオブジェクトについて知るをご覧ください。
基本的なKubernetesのオブジェクトは次のとおりです。
Pod Service Volume Namespace Kubernetesには、コントローラーに依存して基本オブジェクトを構築し、追加の機能と便利な機能を提供する高レベルの抽象化も含まれています。これらには以下のものを含みます:
Deployment DaemonSet StatefulSet ReplicaSet Job Kubernetesコントロールプレーン Kubernetesマスターや kubeletプロセスといったKubernetesコントロールプレーンのさまざまなパーツは、Kubernetesがクラスターとどのように通信するかを統制します。コントロールプレーンはシステム内のすべてのKubernetesオブジェクトの記録を保持し、それらのオブジェクトの状態を管理するために継続的制御ループを実行します。コントロールプレーンの制御ループは常にクラスターの変更に反応し、システム内のすべてのオブジェクトの実際の状態が、指定した状態に一致するように動作します。
たとえば、Kubernetes APIを使用してDeploymentを作成する場合、システムには新しいdesired state (望ましい状態)が提供されます。Kubernetesコントロールプレーンは、そのオブジェクトの作成を記録します。そして、要求されたアプリケーションの開始、およびクラスターノードへのスケジューリングにより指示を完遂します。このようにしてクラスターの実際の状態を望ましい状態に一致させます。
Kubernetesマスター Kubernetesのマスターは、クラスターの望ましい状態を維持する責務を持ちます。kubectl コマンドラインインターフェイスを使用するなどしてKubernetesとやり取りするとき、ユーザーは実際にはクラスターにあるKubernetesのマスターと通信しています。
「マスター」とは、クラスター状態を管理するプロセスの集合を指します。通常これらのプロセスは、すべてクラスター内の単一ノードで実行されます。このノードはマスターとも呼ばれます。マスターは、可用性と冗長性のために複製することもできます。
Kubernetesノード クラスターのノードは、アプリケーションとクラウドワークフローを実行するマシン(VM、物理サーバーなど)です。Kubernetesのマスターは各ノードを制御します。運用者自身がノードと直接対話することはほとんどありません。
次の項目 コンセプトページを追加したい場合は、 ページテンプレートの使用 のコンセプトページタイプとコンセプトテンプレートに関する情報を確認してください。"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/"><meta property="og:title" content="コンセプト"><meta name=twitter:title content="コンセプト"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ja/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ja/docs/>ドキュメント</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/blog/>Blogs</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/training/>トレーニング</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/partners/>パートナー</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/community/>コミュニティ</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/case-studies/>ケーススタディ</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>バージョン</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ja/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/concepts/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ja/docs/concepts/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語 (Japanese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/>한국어 (Korean)</a>
<a class=dropdown-item href=/fr/docs/concepts/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/concepts/>Русский (Russian)</a>
<a class=dropdown-item href=/pl/docs/concepts/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/concepts/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.</p><p><a href=/ja/docs/concepts/>このページの通常のビューに戻る</a>.</p></div><h1 class=title>コンセプト</h1><ul><li>1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>概要</a></li><ul><li>1.1: <a href=#pg-45bdca6129cf540121623e903c18ba46>Kubernetesとは何か？</a></li><li>1.2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Kubernetesのコンポーネント</a></li><li>1.3: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>Kubernetes API</a></li><li>1.4: <a href=#pg-110f33530cf761140cb1dab536baef04>Kubernetesオブジェクトを利用する</a></li><ul><li>1.4.1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>Kubernetesオブジェクトを理解する</a></li><li>1.4.2: <a href=#pg-6751db8ff5409476de8225d17d6c42dd>Kubernetesオブジェクト管理</a></li><li>1.4.3: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>オブジェクトの名前とID</a></li><li>1.4.4: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>Namespace(名前空間)</a></li><li>1.4.5: <a href=#pg-f1dec4557fb8ffbac9f11390aaaf9fa4>ラベル(Labels)とセレクター(Selectors)</a></li><li>1.4.6: <a href=#pg-93cd7a1d4e1623e2bf01afc49a5af69c>アノテーション(Annotations)</a></li><li>1.4.7: <a href=#pg-046c03090d47bc4b89b818dc645c3865>フィールドセレクター(Field Selectors)</a></li><li>1.4.8: <a href=#pg-5dd62c6a4a481b4cf1ac50f6799eb581>推奨ラベル(Recommended Labels)</a></li></ul></ul><li>2: <a href=#pg-2bf36ccd6b3dbeafecf87c39761b07c7>クラスターのアーキテクチャ</a></li><ul><li>2.1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>ノード</a></li><li>2.2: <a href=#pg-c0251def6da29b30afebfb04549f1703>ノードとコントロールプレーン間の通信</a></li><li>2.3: <a href=#pg-ca8819042a505291540e831283da66df>コントローラー</a></li><li>2.4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>クラウドコントローラーマネージャー</a></li><li>2.5: <a href=#pg-44a2e2e592af0846101e970aff9243e5>ガベージコレクション</a></li><li>2.6: <a href=#pg-c0ea5310f52e22c5de34dc84d9ab5e0d>コンテナランタイムインターフェイス(CRI)</a></li></ul><li>3: <a href=#pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>コンテナ</a></li><ul><li>3.1: <a href=#pg-8fda96dc403731ceba5e0ddd0ab3ad15>コンテナの概要</a></li><li>3.2: <a href=#pg-16042b4652ad19e565c7263824029a43>イメージ</a></li><li>3.3: <a href=#pg-643212488f778acf04bebed65ba34441>コンテナ環境</a></li><li>3.4: <a href=#pg-a858027489648786a3b16264e451272b>ランタイムクラス(Runtime Class)</a></li><li>3.5: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>コンテナライフサイクルフック</a></li></ul><li>4: <a href=#pg-d52aadda80edd9f8c514cfe2321363c2>ワークロード</a></li><ul><li>4.1: <a href=#pg-4d68b0ccf9c683e6368ffdcc40c838d4>Pod</a></li><ul><li>4.1.1: <a href=#pg-37afa6c66c74400d1579f10faf55e5b6>Podの概観</a></li><li>4.1.2: <a href=#pg-c3c2b9cf30915ec9d46c147201da3332>Podのライフサイクル</a></li><li>4.1.3: <a href=#pg-1ccbd4eeded6ab138d98b59175bd557e>Initコンテナ</a></li><li>4.1.4: <a href=#pg-4e9b9cbc9776b12e7335c53da377c9c8>Pod Preset</a></li><li>4.1.5: <a href=#pg-53a1005011e1bda2ce81819aad7c8b32>エフェメラルコンテナ</a></li></ul><li>4.2: <a href=#pg-89637410cacae45a36ab1cc278c482eb>ワークロードリソース</a></li><ul><li>4.2.1: <a href=#pg-a2dc0393e0c4079e1c504b6429844e86>Deployment</a></li><li>4.2.2: <a href=#pg-d459b930218774655fa7fd1620625539>ReplicaSet</a></li><li>4.2.3: <a href=#pg-6d72299952c37ca8cc61b416e5bdbcd4>StatefulSet</a></li><li>4.2.4: <a href=#pg-41600eb8b6631c88848156f381e9d588>DaemonSet</a></li><li>4.2.5: <a href=#pg-cc7cc3c4907039d9f863162e20bfbbef>Jobs</a></li><li>4.2.6: <a href=#pg-9add0d2120634b63073ad08dc8683bd6>ガベージコレクション</a></li><li>4.2.7: <a href=#pg-4de50a37ebb6f2340484192126cb7a04>終了したリソースのためのTTLコントローラー(TTL Controller for Finished Resources)</a></li><li>4.2.8: <a href=#pg-2e4cec01c525b45eccd6010e21cc76d9>CronJob</a></li></ul></ul><li>5: <a href=#pg-0a0a7eca3e302a3c08f8c85e15d337fd>Service、負荷分散とネットワーキング</a></li><ul><li>5.1: <a href=#pg-5701136fd2ce258047b6ddc389112352>Service</a></li><li>5.2: <a href=#pg-3a38878244d862dfdb8d7adb32f77584>Serviceトポロジー</a></li><li>5.3: <a href=#pg-91cb8a4438b003df11bc1c426a81b756>ServiceとPodに対するDNS</a></li><li>5.4: <a href=#pg-f804ac0532fcade3966ea2e3769ca031>サービスとアプリケーションの接続</a></li><li>5.5: <a href=#pg-f51db1097575de8072afe1f5b156a70c>EndpointSlice</a></li><li>5.6: <a href=#pg-199bcc92443dbc9bed44819467d7eb75>Ingress</a></li><li>5.7: <a href=#pg-5a8edeb1f2dc8e38cd6d561bb08b0d78>Ingressコントローラー</a></li><li>5.8: <a href=#pg-cd7657b1056ad32451974db57a951ba5>サービス内部トラフィックポリシー</a></li><li>5.9: <a href=#pg-374e5c954990aec58a0797adc70a5039>トポロジーを意識したヒント</a></li><li>5.10: <a href=#pg-ded1daafdcd293023ee333728007ca61>ネットワークポリシー</a></li><li>5.11: <a href=#pg-21f8d19c60c33914baab66224c3d46a7>IPv4/IPv6デュアルスタック</a></li></ul><li>6: <a href=#pg-f018f568c6723865753f150c3c59bdda>ストレージ</a></li><ul><li>6.1: <a href=#pg-27795584640a03bd2024f1fe3b3ab754>ボリューム</a></li><li>6.2: <a href=#pg-ffd12528a12882b282e1bd19e29f9e75>永続ボリューム</a></li><li>6.3: <a href=#pg-2db414b26d4daec3ebed19dd837830c3>投影ボリューム</a></li><li>6.4: <a href=#pg-707ca81a34eb1ca202f34692e9917d1e>CSI Volume Cloning</a></li><li>6.5: <a href=#pg-4d00116c86dade62bdd5be7dc2afa1ca>VolumeSnapshotClass</a></li><li>6.6: <a href=#pg-018f0a7fc6e2f6d16da37702fc39b4f3>ボリュームの動的プロビジョニング(Dynamic Volume Provisioning)</a></li><li>6.7: <a href=#pg-00cd24f4570b7acaac75c2551c948bc7>ストレージ容量</a></li><li>6.8: <a href=#pg-4f40cb95a671e51b4f0156a409d95c6d>ボリュームヘルスモニタリング</a></li><li>6.9: <a href=#pg-b2e4b16ac37988c678a3312a4a6639f8>ノード固有のボリューム制限</a></li></ul><li>7: <a href=#pg-275bea454e1cf4c5adeca4058b5af988>設定</a></li><ul><li>7.1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>設定のベストプラクティス</a></li><li>7.2: <a href=#pg-6b5ccadd699df0904e8e9917c5450c4b>ConfigMap</a></li><li>7.3: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>Secret</a></li><li>7.4: <a href=#pg-436057b96151ecb8a4a9a9f456b5d0fc>コンテナのリソース管理</a></li><li>7.5: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>kubeconfigファイルを使用してクラスターアクセスを組織する</a></li><li>7.6: <a href=#pg-ed4ae5e4344d619bc6df6e1278efae74>Podの優先度とプリエンプション</a></li></ul><li>8: <a href=#pg-712cb3c03ff14a39e5a83a6d9b71d203>セキュリティ</a></li><ul><li>8.1: <a href=#pg-1fb24c1dd155f43849da490a74c4b8c5>Podセキュリティの標準</a></li><li>8.2: <a href=#pg-04eeb110d75afc8acb2cf7a3db743985>クラウドネイティブセキュリティの概要</a></li><li>8.3: <a href=#pg-bc9934fccfeaf880eec6ea79025c0381>Podのセキュリティアドミッション</a></li><li>8.4: <a href=#pg-4d77d1ae4c06aa14f54b385191627881>Kubernetes APIへのアクセスコントロール</a></li></ul><li>9: <a href=#pg-c21d05f31057c5bcd2ebdd01f4e62a0e>スケジューリングと退避</a></li><ul><li>9.1: <a href=#pg-598f36d691ab197f9d995784574b0a12>Kubernetesのスケジューラー</a></li><li>9.2: <a href=#pg-21169f516071aea5d16734a4c27789a5>Node上へのPodのスケジューリング</a></li><li>9.3: <a href=#pg-da22fe2278df236f71efbe672f392677>Podのオーバーヘッド</a></li><li>9.4: <a href=#pg-ede4960b56a3529ee0bfe7c8fe2d09a5>TaintとToleration</a></li><li>9.5: <a href=#pg-b87723bf81b079042860f0ebd37b0a64>APIを起点とした退避</a></li><li>9.6: <a href=#pg-d9574a30fcbc631b0d2a57850e161e89>スケジューラーのパフォーマンスチューニング</a></li><li>9.7: <a href=#pg-961126cd43559012893979e568396a49>拡張リソースのリソースビンパッキング</a></li><li>9.8: <a href=#pg-602208c95fe7b1f1170310ce993f5814>スケジューリングフレームワーク</a></li></ul><li>10: <a href=#pg-ac9161c6d952925b083ad9602b4e8e7f>ポリシー</a></li><ul><li>10.1: <a href=#pg-a935ff8c59eb116b43494255cc67f69a>Limit Range</a></li><li>10.2: <a href=#pg-94ddc6e901c30f256138db11d09f05a3>リソースクォータ</a></li></ul><li>11: <a href=#pg-285a3785fd3d20f437c28d87ca4dadca>クラスターの管理</a></li><ul><li>11.1: <a href=#pg-fb494ea3b1874bd753dcd11c3f35c2dc>クラスター管理の概要</a></li><li>11.2: <a href=#pg-2bf9a93ab5ba014fb6ff70b22c29d432>証明書</a></li><li>11.3: <a href=#pg-3aeeecf7cdb2a21eb4b31db7a71c81e2>リソースの管理</a></li><li>11.4: <a href=#pg-d649067a69d8d5c7e71564b42b96909e>クラスターのネットワーク</a></li><li>11.5: <a href=#pg-5cc31ecfba86467f8884856412cfb6b2>システムログ</a></li><li>11.6: <a href=#pg-c4b1e87a84441f8a90699a345ce48d68>ロギングのアーキテクチャ</a></li><li>11.7: <a href=#pg-2e05a56491965ae320c2662590b2ca18>コンテナイメージのガベージコレクション</a></li><li>11.8: <a href=#pg-08e94e6a480e0d6b2de72d84a1b97617>Kubernetesのプロキシー</a></li><li>11.9: <a href=#pg-85d633ae590aa20ec024f1b7af1d74fc>アドオンのインストール</a></li></ul><li>12: <a href=#pg-7e0d97616b15e2c383c6a0a96ec442cb>Kubernetesを拡張する</a></li><ul><li>12.1: <a href=#pg-5c2b36cd0ddbe006b575d4e54c63d508>Kubernetesクラスターの拡張</a></li><li>12.2: <a href=#pg-0af41d3bd7c785621b58b7564793396a>Kubernetes APIの拡張</a></li><ul><li>12.2.1: <a href=#pg-342388440304e19ce30c0f8ada1c77ce>カスタムリソース</a></li><li>12.2.2: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>アグリゲーションレイヤーを使ったKubernetes APIの拡張</a></li></ul><li>12.3: <a href=#pg-3131452556176159fb269593c1a52012>オペレーターパターン</a></li></ul></ul><div class=content><p>本セクションは、Kubernetesシステムの各パートと、<a class=glossary-tooltip title=コンテナ化されたアプリケーションを実行する、ノードと呼ばれるワーカーマシンの集合です。すべてのクラスターには少なくとも1つのワーカーノードがあります。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=クラスター>クラスター</a>を表現するためにKubernetesが使用する抽象概念について学習し、Kubernetesの仕組みをより深く理解するのに役立ちます。</p><h2 id=概要>概要</h2><p>Kubernetesを機能させるには、<em>Kubernetes API オブジェクト</em> を使用して、実行したいアプリケーションやその他のワークロード、使用するコンテナイメージ、レプリカ(複製)の数、どんなネットワークやディスクリソースを利用可能にするかなど、クラスターの <em>desired state</em> (望ましい状態)を記述します。desired state (望ましい状態)をセットするには、Kubernetes APIを使用してオブジェクトを作成します。通常はコマンドラインインターフェイス <code>kubectl</code> を用いてKubernetes APIを操作しますが、Kubernetes APIを直接使用してクラスターと対話し、desired state (望ましい状態)を設定、または変更することもできます。</p><p>一旦desired state (望ましい状態)を設定すると、Pod Lifecycle Event Generator(<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md>PLEG</a>)を使用した<em>Kubernetes コントロールプレーン</em>が機能し、クラスターの現在の状態をdesired state (望ましい状態)に一致させます。そのためにKubernetesはさまざまなタスク(たとえば、コンテナの起動または再起動、特定アプリケーションのレプリカ数のスケーリング等)を自動的に実行します。Kubernetesコントロールプレーンは、クラスターで実行されている以下のプロセスで構成されています。</p><ul><li><strong>Kubernetes Master</strong>: <a href=/docs/admin/kube-apiserver/>kube-apiserver</a>、<a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a>、<a href=/docs/admin/kube-scheduler/>kube-scheduler</a> の3プロセスの集合です。これらのプロセスはクラスター内の一つのノード上で実行されます。実行ノードはマスターノードとして指定します。</li><li>クラスター内の個々の非マスターノードは、それぞれ2つのプロセスを実行します。<ul><li><strong><a href=/docs/admin/kubelet/>kubelet</a></strong>: Kubernetes Masterと通信します。</li><li><strong><a href=/docs/admin/kube-proxy/>kube-proxy</a></strong>: 各ノードのKubernetesネットワークサービスを反映するネットワークプロキシです。</li></ul></li></ul><h2 id=kubernetes-objects>Kubernetesオブジェクト</h2><p>Kubernetesには、デプロイ済みのコンテナ化されたアプリケーションやワークロード、関連するネットワークとディスクリソース、クラスターが何をしているかに関するその他の情報といった、システムの状態を表現する抽象が含まれています。これらの抽象は、Kubernetes APIのオブジェクトによって表現されます。詳細については、<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>Kubernetesオブジェクトについて知る</a>をご覧ください。</p><p>基本的なKubernetesのオブジェクトは次のとおりです。</p><ul><li><a href=/ja/docs/concepts/workloads/pods/pod-overview/>Pod</a></li><li><a href=/ja/docs/concepts/services-networking/service/>Service</a></li><li><a href=/docs/concepts/storage/volumes/>Volume</a></li><li><a href=/ja/docs/concepts/overview/working-with-objects/namespaces/>Namespace</a></li></ul><p>Kubernetesには、<a href=/ja/docs/concepts/architecture/controller/>コントローラー</a>に依存して基本オブジェクトを構築し、追加の機能と便利な機能を提供する高レベルの抽象化も含まれています。これらには以下のものを含みます:</p><ul><li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a></li><li><a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li><li><a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/ja/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a></li><li><a href=/docs/concepts/workloads/controllers/jobs-run-to-completion/>Job</a></li></ul><h2 id=kubernetes-control-plane>Kubernetesコントロールプレーン</h2><p>Kubernetesマスターや kubeletプロセスといったKubernetesコントロールプレーンのさまざまなパーツは、Kubernetesがクラスターとどのように通信するかを統制します。コントロールプレーンはシステム内のすべてのKubernetesオブジェクトの記録を保持し、それらのオブジェクトの状態を管理するために継続的制御ループを実行します。コントロールプレーンの制御ループは常にクラスターの変更に反応し、システム内のすべてのオブジェクトの実際の状態が、指定した状態に一致するように動作します。</p><p>たとえば、Kubernetes APIを使用してDeploymentを作成する場合、システムには新しいdesired state (望ましい状態)が提供されます。Kubernetesコントロールプレーンは、そのオブジェクトの作成を記録します。そして、要求されたアプリケーションの開始、およびクラスターノードへのスケジューリングにより指示を完遂します。このようにしてクラスターの実際の状態を望ましい状態に一致させます。</p><h3 id=kubernetesマスター>Kubernetesマスター</h3><p>Kubernetesのマスターは、クラスターの望ましい状態を維持する責務を持ちます。<code>kubectl</code> コマンドラインインターフェイスを使用するなどしてKubernetesとやり取りするとき、ユーザーは実際にはクラスターにあるKubernetesのマスターと通信しています。</p><p>「マスター」とは、クラスター状態を管理するプロセスの集合を指します。通常これらのプロセスは、すべてクラスター内の単一ノードで実行されます。このノードはマスターとも呼ばれます。マスターは、可用性と冗長性のために複製することもできます。</p><h3 id=kubernetesノード>Kubernetesノード</h3><p>クラスターのノードは、アプリケーションとクラウドワークフローを実行するマシン(VM、物理サーバーなど)です。Kubernetesのマスターは各ノードを制御します。運用者自身がノードと直接対話することはほとんどありません。</p><h2 id=次の項目>次の項目</h2><p>コンセプトページを追加したい場合は、
<a href=/docs/home/contribute/page-templates/>ページテンプレートの使用</a>
のコンセプトページタイプとコンセプトテンプレートに関する情報を確認してください。</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>1 - 概要</h1></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>1.1 - Kubernetesとは何か？</h1><div class=lead>Kubernetesは、宣言的な構成管理と自動化を促進し、コンテナ化されたワークロードやサービスを管理するための、ポータブルで拡張性のあるオープンソースのプラットフォームです。Kubernetesは巨大で急速に成長しているエコシステムを備えており、それらのサービス、サポート、ツールは幅広い形で利用可能です。</div><p>このページでは、Kubernetesの概要について説明します。</p><p>Kubernetesは、宣言的な構成管理と自動化を促進し、コンテナ化されたワークロードやサービスを管理するための、ポータブルで拡張性のあるオープンソースのプラットフォームです。Kubernetesは巨大で急速に成長しているエコシステムを備えており、それらのサービス、サポート、ツールは幅広い形で利用可能です。</p><p>Kubernetesの名称は、ギリシャ語に由来し、操舵手やパイロットを意味しています。Googleは2014年にKubernetesプロジェクトをオープンソース化しました。Kubernetesは、本番環境で大規模なワークロードを稼働させた<a href=/blog/2015/04/borg-predecessor-to-kubernetes/>Googleの15年以上の経験</a>と、コミュニティからの最高のアイディアや実践を組み合わせています。</p><h2 id=過去を振り返ってみると>過去を振り返ってみると</h2><p>過去を振り返って、Kubernetesがなぜこんなに便利なのかを見てみましょう。</p><p><img src=/images/docs/Container_Evolution.svg alt="Deployment evolution"></p><p><strong>仮想化ができる前の時代におけるデプロイ (Traditional deployment):</strong> 初期の頃は、組織は物理サーバー上にアプリケーションを実行させていました。物理サーバー上でアプリケーションのリソース制限を設定する方法がなかったため、リソースの割当問題が発生していました。例えば、複数のアプリケーションを実行させた場合、ひとつのアプリケーションがリソースの大半を消費してしまうと、他のアプリケーションのパフォーマンスが低下してしまうことがありました。この解決方法は、それぞれのアプリケーションを別々の物理サーバーで動かすことでした。しかし、リソースが十分に活用できなかったため、拡大しませんでした。また組織にとって多くの物理サーバーを維持することは費用がかかりました。</p><p><strong>仮想化を使ったデプロイ (Virtualized deployment):</strong> ひとつの解決方法として、仮想化が導入されました。1台の物理サーバーのCPU上で、複数の仮想マシン(VM)を実行させることができるようになりました。仮想化によりアプリケーションをVM毎に隔離する事ができ、ひとつのアプリケーションの情報が他のアプリケーションから自由にアクセスさせないといったセキュリティレベルを提供することができます。</p><p>仮想化により、物理サーバー内のリソース使用率が向上し、アプリケーションの追加や更新が容易になり、ハードウェアコストの削減などスケーラビリティが向上します。仮想化を利用すると、物理リソースのセットを使い捨て可能な仮想マシンのクラスターとして提示することができます。</p><p>各VMは、仮想ハードウェア上で各自のOSを含んだ全コンポーネントを実行する完全なマシンです。</p><p><strong>コンテナを使ったデプロイ (Container deployment):</strong> コンテナはVMと似ていますが、アプリケーション間でオペレーティング・システム(OS)を共有できる緩和された分離特性を持っています。そのため、コンテナは軽量だといわれます。VMと同じように、コンテナは各自のファイルシステム、CPUの共有、メモリー、プロセス空間等を持っています。基盤のインフラストラクチャから分離されているため、クラウドやOSディストリビューションを越えて移動することが可能です。</p><p>コンテナは、その他にも次のようなメリットを提供するため、人気が高まっています。</p><ul><li>アジャイルアプリケーションの作成とデプロイ: VMイメージの利用時と比較して、コンテナイメージ作成の容易さと効率性が向上します。</li><li>継続的な開発、インテグレーションとデプロイ: 信頼できる頻繁なコンテナイメージのビルドと、素早く簡単にロールバックすることが可能なデプロイを提供します。(イメージが不変であれば)</li><li>開発者と運用者の関心を分離: アプリケーションコンテナイメージの作成は、デプロイ時ではなく、ビルド/リリース時に行います。それによって、インフラストラクチャとアプリケーションを分離します。</li><li>可観測性はOSレベルの情報とメトリクスだけではなく、アプリケーションの稼働状態やその他の警告も表示します。</li><li>開発、テスト、本番環境を越えた環境の一貫性: クラウドで実行させるのと同じようにノートPCでも実行させる事ができます。</li><li>クラウドとOSディストリビューションの可搬性: Ubuntu、RHEL、CoreOS上でも、オンプレミスも、主要なパブリッククラウドでも、それ以外のどんな環境でも、実行できます。</li><li>アプリケーション中心の管理: 仮想マシン上でOSを実行するから、論理リソースを使用してOS上でアプリケーションを実行するへと抽象度のレベルを向上させます。</li><li>疎結合、分散化、拡張性、柔軟性のあるマイクロサービス: アプリケーションを小さく、同時にデプロイと管理が可能な独立した部品に分割されます。1台の大きな単一目的のマシン上に実行するモノリシックなスタックではありません。</li><li>リソースの分割: アプリケーションのパフォーマンスが予測可能です。</li><li>リソースの効率的な利用: 高い効率性と集約性が可能です。</li></ul><h2 id=why-you-need-kubernetes-and-what-can-it-do>Kubernetesが必要な理由と提供する機能</h2><p>コンテナは、アプリケーションを集約して実行する良い方法です。本番環境では、アプリケーションを実行しダウンタイムが発生しないように、コンテナを管理する必要があります。例えば、コンテナがダウンした場合、他のコンテナを起動する必要があります。このような動作がシステムに組込まれていると、管理が簡単になるのではないでしょうか？</p><p>そこを助けてくれるのがKubernetesです! Kubernetesは分散システムを弾力的に実行するフレームワークを提供してくれます。あなたのアプリケーションのためにスケーリングとフェイルオーバーの面倒を見てくれて、デプロイのパターンなどを提供します。例えば、Kubernetesはシステムにカナリアデプロイを簡単に管理することができます。</p><p>Kubernetesは以下を提供します。</p><ul><li><strong>サービスディスカバリーと負荷分散</strong>
Kubernetesは、DNS名または独自のIPアドレスを使ってコンテナを公開することができます。コンテナへのトラフィックが多い場合は、Kubernetesは負荷分散し、ネットワークトラフィックを振り分けることができるため、デプロイが安定します。</li><li><strong>ストレージ オーケストレーション</strong>
Kubernetesは、ローカルストレージやパブリッククラウドプロバイダーなど、選択したストレージシステムを自動でマウントすることができます。</li><li><strong>自動化されたロールアウトとロールバック</strong>
Kubernetesを使うとデプロイしたコンテナのあるべき状態を記述することができ、制御されたスピードで実際の状態をあるべき状態に変更することができます。例えば、アプリケーションのデプロイのために、新しいコンテナの作成や既存コンテナの削除、新しいコンテナにあらゆるリソースを適用する作業を、Kubernetesで自動化できます。</li><li><strong>自動ビンパッキング</strong>
コンテナ化されたタスクを実行するノードのクラスターをKubernetesへ提供します。各コンテナがどれくらいCPUやメモリー(RAM)を必要とするのかをKubernetesに宣言することができます。Kubernetesはコンテナをノードにあわせて調整することができ、リソースを最大限に活用してくれます。</li><li><strong>自己修復</strong>
Kubernetesは、処理が失敗したコンテナを再起動し、コンテナを入れ替え、定義したヘルスチェックに応答しないコンテナを強制終了します。処理の準備ができるまでは、クライアントに通知しません。</li><li><strong>機密情報と構成管理</strong>
Kubernetesは、パスワードやOAuthトークン、SSHキーのよう機密の情報を保持し、管理することができます。機密情報をデプロイし、コンテナイメージを再作成することなくアプリケーションの構成情報を更新することができます。スタック構成の中で機密情報を晒してしまうこともありません。</li></ul><h2 id=kubernetesにないもの>Kubernetesにないもの</h2><p>Kubernetesは、従来型の全部入りなPaaS(Platform as a Service)のシステムではありません。Kubernetesはハードウェアレベルではなく、コンテナレベルで動作するため、デプロイ、スケーリング、負荷分散といったPaaSが提供するのと共通の機能をいくつか提供し、またユーザーはロギングやモニタリング及びアラートを行うソリューションを統合できます。また一方、Kubernetesはモノリシックでなく、標準のソリューションは選択が自由で、追加と削除が容易な構成になっています。Kubernetesは開発プラットフォーム構築のためにビルディングブロックを提供しますが、重要な部分はユーザーの選択と柔軟性を維持しています。</p><p>Kubernetesは...</p><ul><li>サポートするアプリケーションの種類を制限しません。Kubernetesは、ステートレス、ステートフルやデータ処理のワークロードなど、非常に多様なワークロードをサポートすることを目的としています。アプリケーションがコンテナで実行できるのであれば、Kubernetes上で問題なく実行できるはずです。</li><li>ソースコードのデプロイやアプリケーションのビルドは行いません。継続的なインテグレーション、デリバリー、デプロイ(CI/CD)のワークフローは、技術的な要件だけでなく組織の文化や好みで決められます。</li><li>ミドルウェア(例:メッセージバス)、データ処理フレームワーク(例:Spark)、データベース(例:MySQL)、キャッシュ、クラスターストレージシステム(例:Ceph)といったアプリケーションレベルの機能を組み込んで提供しません。それらのコンポーネントは、Kubernetes上で実行することもできますし、<a href=https://openservicebrokerapi.org/>Open Service Broker</a>のようなポータブルメカニズムを経由してKubernetes上で実行されるアプリケーションからアクセスすることも可能です。</li><li>ロギング、モニタリングやアラートを行うソリューションは指定しません。PoCとしていくつかのインテグレーションとメトリクスを収集し出力するメカニズムを提供します。</li><li>構成言語/システム(例:Jsonnet)の提供も指示もしません。任意の形式の宣言型仕様の対象となる可能性のある宣言型APIを提供します。</li><li>統合的なマシンの構成、メンテナンス、管理、または自己修復を行うシステムは提供も採用も行いません。</li><li>さらに、Kubernetesは単なるオーケストレーションシステムではありません。実際には、オーケストレーションの必要性はありません。オーケストレーションの技術的な定義は、「最初にAを実行し、次にB、その次にCを実行」のような定義されたワークフローの実行です。対照的にKubernetesは、現在の状態から提示されたあるべき状態にあわせて継続的に維持するといった、独立していて構成可能な制御プロセスのセットを提供します。AからCへどのように移行するかは問題ではありません。集中管理も必要ありません。これにより、使いやすく、より強力で、堅牢で、弾力性と拡張性があるシステムが実現します。</li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/overview/components/>Kubernetesのコンポーネント</a>を御覧ください。</li><li><a href=/ja/docs/setup/>はじめる</a>準備はできましたか？</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>1.2 - Kubernetesのコンポーネント</h1><div class=lead>Kubernetesクラスターはコントロールプレーンやノードと呼ばれるマシン群といったコンポーネントからなります。</div><p>Kubernetesをデプロイすると、クラスターが展開されます。<p><p>Kubernetesクラスターは、 コンテナ化されたアプリケーションを実行する、<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>と呼ばれるワーカーマシンの集合です。すべてのクラスターには少なくとも1つのワーカーノードがあります。</p></p><p>ワーカーノードは、アプリケーションのコンポーネントであるPodをホストします。マスターノードは、クラスター内のワーカーノードとPodを管理します。複数のマスターノードを使用して、クラスターにフェイルオーバーと高可用性を提供します。
ワーカーノードは、アプリケーションワークロードのコンポーネントである<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>をホストします。<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>は、クラスター内のワーカーノードとPodを管理します。本番環境では、コントロールプレーンは複数のコンピューターを使用し、クラスターは複数のノードを使用し、耐障害性や高可用性を提供します。</p></p><p>このドキュメントでは、Kubernetesクラスターが機能するために必要となるさまざまなコンポーネントの概要を説明します。</p><p>すべてのコンポーネントが結び付けられたKubernetesクラスターの図を次に示します。</p><p><img src=/images/docs/components-of-kubernetes.svg alt=Kubernetesのコンポーネント></p><h2 id=コントロールプレーンコンポーネント>コントロールプレーンコンポーネント</h2><p>コントロールプレーンコンポーネントは、クラスターに関する全体的な決定(スケジューリングなど)を行います。また、クラスターイベントの検出および応答を行います(たとえば、deploymentの<code>replicas</code>フィールドが満たされていない場合に、新しい <a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> を起動する等)。</p><p>コントロールプレーンコンポーネントはクラスター内のどのマシンでも実行できますが、シンプルにするため、セットアップスクリプトは通常、すべてのコントロールプレーンコンポーネントを同じマシンで起動し、そのマシンではユーザーコンテナを実行しません。
マルチマスター VMセットアップの例については、<a href=/docs/admin/high-availability/>高可用性クラスターの構築</a> を参照してください。</p><h3 id=kube-apiserver>kube-apiserver</h3><p>APIサーバーは、Kubernetes APIを外部に提供するKubernetes<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>のコンポーネントです。
APIサーバーはKubernetesコントロールプレーンのフロントエンドになります。</p><p>Kubernetes APIサーバーの主な実装は<a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a>です。
kube-apiserverは水平方向にスケールするように設計されています—つまり、インスタンスを追加することでスケールが可能です。
複数のkube-apiserverインスタンスを実行することで、インスタンス間でトラフィックを分散させることが可能です。</p><h3 id=etcd>etcd</h3><p>一貫性、高可用性を持ったキーバリューストアで、Kubernetesの全てのクラスター情報の保存場所として利用されています。</p><p>etcdをKubernetesのデータストアとして使用する場合、必ずデータの<a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>バックアップ</a>プランを作成して下さい。</p><p>公式<a href=https://etcd.io/docs/>ドキュメント</a>でetcdに関する詳細な情報を見つけることができます。</p><h3 id=kube-scheduler>kube-scheduler</h3><p>コントロールプレーン上で動作するコンポーネントで、新しく作られた<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>に<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>が割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。</p><p>スケジューリングの決定は、PodあるいはPod群のリソース要求量、ハードウェア/ソフトウェア/ポリシーによる制約、アフィニティおよびアンチアフィニティの指定、データの局所性、ワークロード間の干渉、有効期限などを考慮して行われます。</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>コントロールプレーン上で動作するコンポーネントで、複数の<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>プロセスを実行します。</p><p>論理的には、各<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>は個別のプロセスですが、複雑さを減らすために一つの実行ファイルにまとめてコンパイルされ、単一のプロセスとして動きます。</p><p>コントローラーには以下が含まれます。</p><ul><li>ノードコントローラー：ノードがダウンした場合の通知と対応を担当します。</li><li>レプリケーションコントローラー：システム内の全レプリケーションコントローラーオブジェクトについて、Podの数を正しく保つ役割を持ちます。</li><li>エンドポイントコントローラー：エンドポイントオブジェクトを注入します(つまり、ServiceとPodを紐付けます)。</li><li>サービスアカウントとトークンコントローラー：新規の名前空間に対して、デフォルトアカウントとAPIアクセストークンを作成します。</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3>クラウド特有の制御ロジックを組み込むKubernetesの<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>コンポーネントです。クラウドコントロールマネージャーは、クラスターをクラウドプロバイダーAPIをリンクし、クラスタのみで相互作用するコンポーネントからクラウドプラットフォームで相互作用するコンポーネントを分離します。<p>cloud-controller-managerは、クラウドプロバイダー固有のコントローラーのみを実行します。
KubernetesをオンプレミスあるいはPC内での学習環境で動かす際には、クラスターにcloud container managerはありません。</p><p>kube-controller-managerを使用すると、cloud-controller-managerは複数の論理的に独立したコントロールループをシングルバイナリにまとめ、これが一つのプロセスとして動作します。パフォーマンスを向上させるあるいは障害に耐えるために水平方向にスケールする(一つ以上のコピーを動かす)ことができます。</p><p>次のコントローラーには、クラウドプロバイダーへの依存関係を持つ可能性があります。</p><ul><li>ノードコントローラー：ノードが応答を停止した後、クラウドで削除されたかどうかを判断するため、クラウドプロバイダーをチェックします。</li><li>ルーティングコントローラー：基盤であるクラウドインフラでルーティングを設定します。</li><li>サービスコントローラー：クラウドプロバイダーのロードバランサーの作成、更新、削除を行います。</li></ul><h2 id=node-components>ノードコンポーネント</h2><p>ノードコンポーネントはすべてのノードで実行され、稼働中のPodの管理やKubernetesの実行環境を提供します。</p><h3 id=kubelet>kubelet</h3><p>クラスター内の各<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>で実行されるエージェントです。各<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>が<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>で実行されていることを保証します。</p><p>kubeletは、さまざまなメカニズムを通じて提供されるPodSpecのセットを取得し、それらのPodSpecに記述されているコンテナが正常に実行されている状態を保証します。kubeletは、Kubernetesが作成したものではないコンテナは管理しません。</p><h3 id=kube-proxy>kube-proxy</h3><p>kube-proxyはクラスター内の各<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a>で動作しているネットワークプロキシで、Kubernetesの<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>コンセプトの一部を実装しています。</p><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>は、Nodeのネットワークルールをメンテナンスします。これらのネットワークルールにより、クラスターの内部または外部のネットワークセッションからPodへのネットワーク通信が可能になります。</p><p>kube-proxyは、オペレーティングシステムにパケットフィルタリング層があり、かつ使用可能な場合、パケットフィルタリング層を使用します。それ以外の場合は自身でトラフィックを転送します。</p><h3 id=container-runtime>コンテナランタイム</h3><p>コンテナランタイムは、コンテナの実行を担当するソフトウェアです。</p><p>Kubernetesは次の複数のコンテナランタイムをサポートします。
<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>、<a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>、<a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>、
および全ての
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>
実装です。</p><h2 id=アドオン>アドオン</h2><p>アドオンはクラスター機能を実装するためにKubernetesリソース(<a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>、<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>など)を使用します。
アドオンはクラスターレベルの機能を提供しているため、アドオンのリソースで名前空間が必要なものは<code>kube-system</code>名前空間に属します。</p><p>いくつかのアドオンについて以下で説明します。より多くの利用可能なアドオンのリストは、<a href=/ja/docs/concepts/cluster-administration/addons/>アドオン</a> をご覧ください。</p><h3 id=dns>DNS</h3><p>クラスターDNS以外のアドオンは必須ではありませんが、すべてのKubernetesクラスターは<a href=/ja/docs/concepts/services-networking/dns-pod-service/>クラスターDNS</a>を持つべきです。多くの使用例がクラスターDNSを前提としています。</p><p>クラスターDNSは、環境内の他のDNSサーバーに加えて、KubernetesサービスのDNSレコードを提供するDNSサーバーです。</p><p>Kubernetesによって開始されたコンテナは、DNS検索にこのDNSサーバーを自動的に含めます。</p><h3 id=web-ui-ダッシュボード>Web UI (ダッシュボード)</h3><p><a href=/ja/docs/tasks/access-application-cluster/web-ui-dashboard/>ダッシュボード</a>は、Kubernetesクラスター用の汎用WebベースUIです。これによりユーザーはクラスターおよびクラスター内で実行されているアプリケーションについて、管理およびトラブルシューティングを行うことができます。</p><h3 id=コンテナリソース監視>コンテナリソース監視</h3><p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>コンテナリソース監視</a>は、コンテナに関する一般的な時系列メトリックを中央データベースに記録します。また、そのデータを閲覧するためのUIを提供します。</p><h3 id=クラスターレベルログ>クラスターレベルログ</h3><p><a href=/docs/concepts/cluster-administration/logging/>クラスターレベルログ</a>メカニズムは、コンテナのログを、検索／参照インターフェイスを備えた中央ログストアに保存します。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/architecture/nodes/>ノード</a>について学ぶ</li><li><a href=/ja/docs/concepts/architecture/controller/>コントローラー</a>について学ぶ</li><li><a href=/ja/docs/concepts/scheduling-eviction/kube-scheduler/>kube-scheduler</a>について学ぶ</li><li>etcdの公式 <a href=https://etcd.io/docs/>ドキュメント</a>を読む</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>1.3 - Kubernetes API</h1><div class=lead>Kubernetes APIを使用すると、Kubernetes内のオブジェクトの状態をクエリで操作できます。 Kubernetesのコントロールプレーンの中核は、APIサーバーとそれが公開するHTTP APIです。ユーザー、クラスターのさまざまな部分、および外部コンポーネントはすべて、APIサーバーを介して互いに通信します。</div><p>Kubernetesの中核である <a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>は<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API server'>API server</a> です。
APIサーバーは、エンドユーザー、クラスターのさまざまな部分、および外部コンポーネントが相互に通信できるようにするHTTP APIを公開します。</p><p>Kubernetes APIを使用すると、Kubernetes API内のオブジェクトの状態をクエリで操作できます（例：Pod、Namespace、ConfigMap、Events）。</p><p>ほとんどの操作は、APIを使用している<a href=/docs/reference/kubectl/overview/>kubectl</a>コマンドラインインターフェースもしくは<a href=/docs/reference/setup-tools/kubeadm/>kubeadm</a>のような別のコマンドラインツールを通して実行できます。
RESTコールを利用して直接APIにアクセスすることも可能です。</p><p>Kubernetes APIを利用してアプリケーションを書いているのであれば、<a href=/docs/reference/using-api/client-libraries/>client libraries</a>の利用を考えてみてください。</p><h2 id=api-specification>OpenAPI 仕様</h2><p>完全なAPIの詳細は、<a href=https://www.openapis.org/>OpenAPI</a>を使用して文書化されています。</p><h3 id=openapi-v2>OpenAPI V2</h3><p>Kubernetes APIサーバーは、<code>/openapi/v2</code>エンドポイントを介してOpenAPI v2仕様を提供します。
次のように要求ヘッダーを使用して、応答フォーマットを要求できます。</p><table><caption style=display:none>OpenAPI v2クエリの有効なリクエストヘッダー値</caption><thead><tr><th>ヘッダー</th><th style=min-width:50%>取りうる値</th><th>備考</th></tr></thead><tbody><tr><td><code>Accept-Encoding</code></td><td><code>gzip</code></td><td><em>このヘッダーを使わないことも可能</em></td></tr><tr><td rowspan=3><code>Accept</code></td><td><code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code></td><td><em>主にクラスター内での使用</em></td></tr><tr><td><code>application/json</code></td><td><em>デフォルト</em></td></tr><tr><td><code>*</code></td><td><code>application/json</code>を提供</td></tr></tbody></table><p>Kubernetesは、他の手段として主にクラスター間の連携用途向けのAPIに、Protocol buffersをベースにしたシリアライズフォーマットを実装しています。このフォーマットに関しては、<a href=https://github.com/kubernetes/design-proposals-archive/blob/main/api-machinery/protobuf.md>Kubernetes Protobuf serialization</a>デザイン提案を参照してください。また、各スキーマのInterface Definition Language（IDL）ファイルは、APIオブジェクトを定義しているGoパッケージ内に配置されています。</p><h3 id=openapi-v3>OpenAPI V3</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [beta]</code></div><p>Kubernetes v1.25では、OpenAPI v3によるAPI仕様をベータサポートとして提供しています。これは、デフォルトで有効化されているベータ機能です。kube-apiserverの<code>OpenAPIV3</code>という<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>を切ることにより、このベータ機能を無効化することができます。</p><p><code>/openapi/v3</code>が、全ての利用可能なグループやバージョンの一覧を閲覧するためのディスカバリーエンドポイントとして提供されています。このエンドポイントは、JSONのみを返却します。利用可能なグループやバージョンは、次のような形式で提供されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;paths&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;api/v1&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;serverRelativeURL&#34;: </span><span style=color:#b44>&#34;/openapi/v3/api/v1?hash=CC0E9BFD992D8C59AEC98A1E2336F899E8318D3CF4C68944C3DEC640AF5AB52D864AC50DAA8D145B3494F75FA3CFF939FCBDDA431DAD3CA79738B297795818CF&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;apis/admissionregistration.k8s.io/v1&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;serverRelativeURL&#34;: </span><span style=color:#b44>&#34;/openapi/v3/apis/admissionregistration.k8s.io/v1?hash=E19CC93A116982CE5422FC42B590A8AFAD92CDE9AE4D59B5CAAD568F083AD07946E6CB5817531680BCE6E215C16973CD39003B0425F3477CFD854E89A9DB6597&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>....<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>クライアントサイドのキャッシングを改善するために、相対URLはイミュータブルな(不変の)OpenAPI記述を指しています。
また、APIサーバーも、同様の目的で適切なHTTPキャッシュヘッダー(<code>Expires</code>には1年先の日付、<code>Cache-Control</code>には<code>immutable</code>)をセットします。廃止されたURLが使用された場合、APIサーバーは最新のURLへのリダイレクトを返します。</p><p>Kubernetes APIサーバーは、<code>/openapi/v3/apis/&lt;group>/&lt;version>?hash=&lt;hash></code>のエンドポイントにて、KubernetesのグループバージョンごとにOpenAPI v3仕様を公開しています。</p><p>受理されるリクエストヘッダーについては、以下の表の通りです。</p><table><caption style=display:none>OpenAPI v3において有効なリクエストヘッダー</caption><thead><tr><th>ヘッダー</th><th style=min-width:50%>取りうる値</th><th>備考</th></tr></thead><tbody><tr><td><code>Accept-Encoding</code></td><td><code>gzip</code></td><td><em>このヘッダーを使わないことも可能</em></td></tr><tr><td rowspan=3><code>Accept</code></td><td><code>application/com.github.proto-openapi.spec.v3@v1.0+protobuf</code></td><td><em>主にクラスター内での使用</em></td></tr><tr><td><code>application/json</code></td><td><em>デフォルト</em></td></tr><tr><td><code>*</code></td><td><em></em><code>application/json</code>を提供</td></tr></tbody></table><h2 id=永続性>永続性</h2><p>KubernetesはAPIリソースの観点からシリアル化された状態を<a class=glossary-tooltip title=一貫性、高可用性を持ったキーバリューストアで、Kubernetesの全てのクラスター情報の保存場所として利用されています。 data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>に書き込むことで保存します。</p><h2 id=apiグループとバージョニング>APIグループとバージョニング</h2><p>フィールドの削除やリソース表現の再構成を簡単に行えるようにするため、Kubernetesは複数のAPIバージョンをサポートしており、<code>/api/v1</code>や<code>/apis/rbac.authorization.k8s.io/v1alpha1</code>のように、それぞれ異なるAPIのパスが割り当てられています。</p><p>APIが、システムリソースと動作について明確かつ一貫したビューを提供し、サポート終了、実験的なAPIへのアクセス制御を有効にするために、リソースまたはフィールドレベルではなく、APIレベルでバージョンが行われます。</p><p>APIの発展や拡張を簡易に行えるようにするため、Kubernetesは<a href=/docs/reference/using-api/#enabling-or-disabling>有効もしくは無効</a>を行える<a href=/docs/reference/using-api/#api-groups>APIグループ</a>を実装しました。</p><p>APIリソースは、APIグループ、リソースタイプ、ネームスペース（namespacedリソースのための）、名前によって区別されます。APIサーバーは、APIバージョン間の変換を透過的に処理します。すべてのバージョンの違いは、実際のところ同じ永続データとして表現されます。APIサーバーは、同じ基本的なデータを複数のAPIバージョンで提供することができます。</p><p>例えば、同じリソースで<code>v1</code>と<code>v1beta1</code>の2つのバージョンが有ることを考えてみます。<code>v1beta1</code>バージョンのAPIを利用しオブジェクトを最初に作成したとして、<code>v1beta1</code>もしくは<code>v1</code>どちらのAPIバージョンを利用してもオブジェクトのread、update、deleteができます。</p><h2 id=apiの変更>APIの変更</h2><p>成功を収めているシステムはすべて、新しいユースケースの出現や既存の変化に応じて成長し、変化する必要があります。
したがって、Kubernetesには、Kubernetes APIを継続的に変更および拡張できる設計機能があります。
Kubernetesプロジェクトは、既存のクライアントとの互換性を破壊 <em>しないこと</em> 、およびその互換性を一定期間維持して、他のプロジェクトが適応する機会を提供することを目的としています。</p><p>基本的に、新しいAPIリソースと新しいリソースフィールドは追加することができます。
リソースまたはフィールドを削除するには、<a href=/docs/reference/using-api/deprecation-policy/>API非推奨ポリシー</a>に従ってください。</p><p>Kubernetesは、公式のKubernetes APIが一度一般提供（GA）に達した場合、通常は<code>v1</code>APIバージョンです、互換性を維持することを強い責任があります。さらに、Kubernetesは <em>beta</em> についても可能な限り互換性を維持し続けます。ベータAPIを採用した場合、その機能が安定版になったあとでも、APIを利用してクラスタを操作し続けることができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Kubernetesは、 <em>alpha</em> APIバージョンについても互換性の維持に注力しますが、いくつかの事情により不可である場合もあります。アルファAPIバージョンを使っている場合、クラスタのアップグレードやAPIが変更された場合に備えて、Kubernetesのリリースノートを確認してください。</div><p>APIバージョンレベルの定義に関する詳細は<a href=/docs/reference/using-api/#api-versioning>APIバージョンのリファレンス</a>を参照してください。</p><h2 id=apiの拡張>APIの拡張</h2><p>Kubernetes APIは2つの方法で拡張できます。</p><ol><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>は、APIサーバーが選択したリソースAPIをどのように提供するかを宣言的に定義します。</li><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>アグリゲーションレイヤー</a>を実装することでKubernetes APIを拡張することもできます。</li></ol><h2 id=次の項目>次の項目</h2><ul><li>自分自身で<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>カスタムリソース定義</a>を追加してKubernetes APIを拡張する方法について学んでください。</li><li><a href=/docs/concepts/security/controlling-access/>Kubernetes APIのアクセス制御</a>では、クラスターがAPIアクセスの認証と承認を管理する方法を説明しています。</li><li><a href=/ja/docs/reference/kubernetes-api/>APIリファレンス</a>を読んで、APIエンドポイント、リソースタイプやサンプルについて学んでください。</li><li><a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#readme>APIの変更</a>から、互換性のある変更とは何か, どのようにAPIを変更するかについて学んでください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-110f33530cf761140cb1dab536baef04>1.4 - Kubernetesオブジェクトを利用する</h1><div class=lead>Kubernetesオブジェクトは、Kubernetes上で永続的なエンティティです。Kubernetesはこれらのエンティティを使い、クラスターの状態を表現します。 Kubernetesオブジェクトモデルと、これらのオブジェクトの利用方法について学びます。</div></div><div class=td-content><h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>1.4.1 - Kubernetesオブジェクトを理解する</h1><p>このページでは、KubernetesオブジェクトがKubernetes APIでどのように表現されているか、またそれらを<code>.yaml</code>フォーマットでどのように表現するかを説明します。</p><h2 id=kubernetes-objects>Kubernetesオブジェクトを理解する</h2><p><em>Kubernetesオブジェクト</em> は、Kubernetes上で永続的なエンティティです。Kubernetesはこれらのエンティティを使い、クラスターの状態を表現します。具体的に言うと、下記のような内容が表現できます:</p><ul><li>どのようなコンテナ化されたアプリケーションが稼働しているか(またそれらはどのノード上で動いているか)</li><li>それらのアプリケーションから利用可能なリソース</li><li>アプリケーションがどのように振る舞うかのポリシー、例えば再起動、アップグレード、耐障害性ポリシーなど</li></ul><p>Kubernetesオブジェクトは「意図の記録」です。一度オブジェクトを作成すると、Kubernetesは常にそのオブジェクトが存在し続けるように動きます。オブジェクトを作成することで、Kubernetesに対し効果的にあなたのクラスターのワークロードがこのようになっていて欲しいと伝えているのです。これが、あなたのクラスターの<strong>望ましい状態</strong>です。</p><p>Kubernetesオブジェクトを操作するには、作成、変更、または削除に関わらず<a href=/ja/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>を使う必要があるでしょう。例えば<code>kubectl</code>コマンドラインインターフェースを使った場合、このCLIが処理に必要なKubernetes API命令を、あなたに代わり発行します。あなたのプログラムから<a href=/docs/reference/using-api/client-libraries/>クライアントライブラリ</a>を利用し、直接Kubernetes APIを利用することも可能です。</p><h3 id=オブジェクトのspec-仕様-とstatus-状態>オブジェクトのspec(仕様)とstatus(状態)</h3><p>ほとんどのKubernetesオブジェクトは、オブジェクトの設定を管理する２つの入れ子になったオブジェクトのフィールドを持っています。それはオブジェクト <em><code>spec</code></em> とオブジェクト <em><code>status</code></em> です。<code>spec</code>を持っているオブジェクトに関しては、オブジェクト作成時に<code>spec</code>を設定する必要があり、望ましい状態としてオブジェクトに持たせたい特徴を記述する必要があります。</p><p><code>status</code> オブジェクトはオブジェクトの <em>現在の状態</em> を示し、その情報はKubernetesシステムとそのコンポーネントにより提供、更新されます。Kubernetes<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>は、あなたから指定された望ましい状態と現在の状態が一致するよう常にかつ積極的に管理をします。</p><p>例えば、KubernetesのDeploymentはクラスター上で稼働するアプリケーションを表現するオブジェクトです。Deploymentを作成するとき、アプリケーションの複製を３つ稼働させるようDeploymentのspecで指定するかもしれません。KubernetesはDeploymentのspecを読み取り、指定されたアプリケーションを３つ起動し、現在の状態がspecに一致するようにします。もしこれらのインスタンスでどれかが落ちた場合(statusが変わる)、Kubernetesはspecと、statusの違いに反応し、修正しようとします。この場合は、落ちたインスタンスの代わりのインスタンスを立ち上げます。</p><p>spec、status、metadataに関するさらなる情報は、<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>Kubernetes API Conventions</a>をご確認ください。</p><h3 id=kubernetesオブジェクトを記述する>Kubernetesオブジェクトを記述する</h3><p>Kubernetesでオブジェクトを作成する場合、オブジェクトの基本的な情報(例えば名前)と共に、望ましい状態を記述したオブジェクトのspecを渡さなければいけません。KubernetesAPIを利用しオブジェクトを作成する場合(直接APIを呼ぶか、<code>kubectl</code>を利用するかに関わらず)、APIリクエストはそれらの情報をJSON形式でリクエストのBody部に含んでいなければなりません。</p><p>ここで、KubernetesのDeploymentに必要なフィールドとオブジェクトのspecを記載した<code>.yaml</code>ファイルの例を示します:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>上に示した<code>.yaml</code>ファイルを利用してDeploymentを作成するには、<code>kubectl</code>コマンドラインインターフェースに含まれている<a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>コマンドに<code>.yaml</code>ファイルを引数に指定し、実行します。ここで例を示します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record
</span></span></code></pre></div><p>出力結果は、下記に似た形になります:</p><pre tabindex=0><code>deployment.apps/nginx-deployment created
</code></pre><h3 id=必須フィールド>必須フィールド</h3><p>Kubernetesオブジェクトを<code>.yaml</code>ファイルに記載して作成する場合、下記に示すフィールドに値をセットしておく必要があります:</p><ul><li><code>apiVersion</code> - どのバージョンのKubernetesAPIを利用してオブジェクトを作成するか</li><li><code>kind</code> - どの種類のオブジェクトを作成するか</li><li><code>metadata</code> - オブジェクトを一意に特定するための情報、文字列の<code>name</code>、<code>UID</code>、また任意の<code>namespace</code>が該当する</li><li><code>spec</code> - オブジェクトの望ましい状態</li></ul><p><code>spec</code>の正確なフォーマットは、Kubernetesオブジェクトごとに異なり、オブジェクトごとに特有な入れ子のフィールドを持っています。<a href=/docs/reference/generated/kubernetes-api/v1.25/>Kubernetes API リファレンス</a>が、Kubernetesで作成できる全てのオブジェクトに関するspecのフォーマットを探すのに役立ちます。
例えば、<code>Pod</code>オブジェクトに関する<code>spec</code>のフォーマットは<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec v1 core</a>を、また<code>Deployment</code>オブジェクトに関する<code>spec</code>のフォーマットは<a href=/docs/reference/generated/kubernetes-api/v1.25/#deploymentspec-v1-apps>DeploymentSpec v1 apps</a>をご確認ください。</p><h2 id=次の項目>次の項目</h2><ul><li>最も重要、かつ基本的なKubernetesオブジェクト群を学びましょう、例えば、<a href=/ja/docs/concepts/workloads/pods/>Pod</a>です。</li><li>Kubernetesの<a href=/ja/docs/concepts/architecture/controller/>コントローラー</a>を学びましょう。</li><li><a href=/docs/reference/using-api/>Using the Kubernetes API</a>はこのページでは取り上げていない他のAPIについて説明します。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6751db8ff5409476de8225d17d6c42dd>1.4.2 - Kubernetesオブジェクト管理</h1><p><code>kubectl</code>コマンドラインツールは、Kubernetesオブジェクトを作成、管理するためにいくつかの異なる方法をサポートしています。
このドキュメントでは、それらの異なるアプローチごとの概要を提供します。
Kubectlを使ったオブジェクト管理の詳細は、<a href=https://kubectl.docs.kubernetes.io>Kubectl book</a>を参照してください。</p><h2 id=管理手法>管理手法</h2><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> Kubernetesのオブジェクトは、いずれか一つの手法で管理してください。
同じオブジェクトに対して、複数の手法を組み合わせた場合、未定義の挙動をもたらします。</div><table><thead><tr><th>管理手法</th><th>何を対象にするか</th><th>推奨環境</th><th>サポートライター</th><th>学習曲線</th></tr></thead><tbody><tr><td>命令型コマンド</td><td>現行のオブジェクト</td><td>開発用プロジェクト</td><td>1+</td><td>緩やか</td></tr><tr><td>命令型オブジェクト設定</td><td>個々のファイル</td><td>本番用プロジェクト</td><td>1</td><td>中程度</td></tr><tr><td>宣言型オブジェクト設定</td><td>ファイルのディレクトリ</td><td>本番用プロジェクト</td><td>1+</td><td>急</td></tr></tbody></table><h2 id=命令型コマンド>命令型コマンド</h2><p>命令型コマンドを使う場合、ユーザーはクラスター内の現行のオブジェクトに対して処理を行います。
ユーザーは<code>kubectl</code>コマンドに処理内容を引数、もしくはフラグで指定します。</p><p>これはKubernetesの使い始め、またはクラスターに対して一度限りのタスクを行う際の最も簡単な手法です。
なぜなら、この手法は現行のオブジェクトに対して直接操作ができ、以前の設定履歴は提供されないからです。</p><h3 id=例>例</h3><p>Deploymentオブジェクトを作成し、nginxコンテナの単一インスタンスを起動します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl run nginx --image nginx
</span></span></code></pre></div><p>同じことを異なる構文で行います:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create deployment nginx --image nginx
</span></span></code></pre></div><h3 id=トレードオフ>トレードオフ</h3><p>オブジェクト設定手法に対する長所:</p><ul><li>コマンドは簡潔、簡単に学ぶことができ、そして覚えやすいです</li><li>コマンドではクラスタの設定を変えるのに、わずか1ステップしか必要としません</li></ul><p>オブジェクト設定手法に対する短所:</p><ul><li>コマンドは変更レビュープロセスと連携しません</li><li>コマンドは変更に伴う監査証跡を提供しません</li><li>コマンドは現行がどうなっているかという情報を除き、レコードのソースを提供しません</li><li>コマンドはオブジェクトを作成するためのテンプレートを提供しません</li></ul><h2 id=命令型オブジェクト設定>命令型オブジェクト設定</h2><p>命令型オブジェクト設定では、kubectlコマンドに処理内容(create、replaceなど)、任意のフラグ、そして最低1つのファイル名を指定します。
指定されたファイルは、YAMLまたはJSON形式でオブジェクトの全ての定義情報を含んでいなければいけません。</p><p>オブジェクト定義の詳細は、<a href=/docs/reference/generated/kubernetes-api/v1.25/>APIリファレンス</a>を参照してください。</p><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> 命令型の<code>replace</code>コマンドは、既存の構成情報を新しく提供された設定に置き換え、設定ファイルに無いオブジェクトの全ての変更を削除します。
このアプローチは、構成情報が設定ファイルとは無関係に更新されるリソースタイプでは使用しないでください。
例えば、タイプが<code>LoadBalancer</code>のServiceオブジェクトにおける<code>externalIPs</code>フィールドは、設定ファイルとは無関係に、クラスターによって更新されます。</div><h3 id=例-1>例</h3><p>設定ファイルに定義されたオブジェクトを作成します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create -f nginx.yaml
</span></span></code></pre></div><p>設定ファイルに定義されたオブジェクトを削除します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl delete -f nginx.yaml -f redis.yaml
</span></span></code></pre></div><p>設定ファイルに定義された情報で、現行の設定を上書き更新します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl replace -f nginx.yaml
</span></span></code></pre></div><h3 id=トレードオフ-1>トレードオフ</h3><p>命令型コマンド手法に対する長所:</p><ul><li>オブジェクト設定をGitのような、ソースコード管理システムに格納することができます</li><li>オブジェクト設定の変更内容をプッシュする前にレビュー、監査証跡を残すようなプロセスと連携することができます</li><li>オブジェクト設定は新しいオブジェクトを作る際のテンプレートを提供します</li></ul><p>命令型コマンド手法に対する短所:</p><ul><li>オブジェクト設定ではオブジェクトスキーマの基礎的な理解が必要です</li><li>オブジェクト設定ではYAMLファイルを書くという、追加のステップが必要です</li></ul><p>宣言型オブジェクト設定手法に対する長所:</p><ul><li>命令型オブジェクト設定の振る舞いは、よりシンプルで簡単に理解ができます</li><li>Kubernetesバージョン1.5においては、命令型オブジェクト設定の方がより成熟しています</li></ul><p>宣言型オブジェクト設定手法に対する短所:</p><ul><li>命令型オブジェクト設定は各ファイルごとに設定を書くには最も適していますが、ディレクトリには適していません</li><li>現行オブジェクトの更新は設定ファイルに対して反映しなければなりません。反映されない場合、次の置き換え時に更新内容が失われてしまいます</li></ul><h2 id=宣言型オブジェクト設定>宣言型オブジェクト設定</h2><p>宣言型オブジェクト設定を利用する場合、ユーザーはローカルに置かれている設定ファイルを操作します。
しかし、ユーザーはファイルに対する操作内容を指定しません。作成、更新、そして削除といった操作はオブジェクトごとに<code>kubectl</code>が検出します。
この仕組みが、異なるオブジェクトごとに異なる操作をディレクトリに対して行うことを可能にしています。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 宣言型オブジェクト設定は、他の人が行った変更が設定ファイルにマージされなかったとしても、それらの変更を保持します。
これは、<code>replace</code>API操作のように、全てのオブジェクト設定を置き換えるわけではなく、<code>patch</code>API操作による、変更箇所のみの更新が可能にしています。</div><h3 id=例-2>例</h3><p><code>config</code>ディレクトリ配下にある全てのオブジェクト設定ファイルを処理し、作成、または現行オブジェクトへのパッチを行います。
まず、<code>diff</code>でどのような変更が行われるかを確認した後に適用します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -f configs/
</span></span><span style=display:flex><span>kubectl apply -f configs/
</span></span></code></pre></div><p>再帰的にディレクトリを処理します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -R -f configs/
</span></span><span style=display:flex><span>kubectl apply -R -f configs/
</span></span></code></pre></div><h3 id=トレードオフ-2>トレードオフ</h3><p>命令型オブジェクト設定手法に対する長所:</p><ul><li>現行オブジェクトに直接行われた変更が、それらが設定ファイルに反映されていなかったとしても、保持されます</li><li>宣言型オブジェクト設定は、ディレクトリごとの処理をより良くサポートしており、自動的にオブジェクトごとに操作のタイプ(作成、パッチ、削除)を検出します</li></ul><p>命令型オブジェクト設定手法に対する短所:</p><ul><li>宣言型オブジェクト設定は、デバッグ、そして想定外の結果が出たときに理解するのが困難です</li><li>差分を利用した一部のみの更新は、複雑なマージ、パッチの操作が必要です</li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-command/>命令型コマンドを利用したKubernetesオブジェクトの管理</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-config/>オブジェクト設定(命令型)を利用したKubernetesオブジェクトの管理</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/declarative-config/>オブジェクト設定(宣言型)を利用したKubernetesオブジェクトの管理</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/kustomization/>Kustomize(宣言型)を利用したKubernetesオブジェクトの管理</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectlコマンドリファレンス</a></li><li><a href=https://kubectl.docs.kubernetes.io>Kubectl Book</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>Kubernetes APIリファレンス</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>1.4.3 - オブジェクトの名前とID</h1><p>クラスター内の各オブジェクトには、そのタイプのリソースに固有の<a href=#names><em>名前</em></a>があります。すべてのKubernetesオブジェクトには、クラスター全体で一意の<a href=#uids><em>UID</em></a>もあります。</p><p>たとえば、同じ<a href=/ja/docs/concepts/overview/working-with-objects/namespaces/>名前空間</a>内に<code>myapp-1234</code>という名前のPodは1つしか含められませんが、<code>myapp-1234</code>という名前の1つのPodと1つのDeploymentを含めることができます。</p><p>ユーザーが一意ではない属性を付与するために、Kubernetesは<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>と<a href=/ja/docs/concepts/overview/working-with-objects/annotations/>アノテーション</a>を提供しています。</p><h2 id=names>名前</h2><p>クライアントから提供され、リソースURL内のオブジェクトを参照する文字列です。例えば<code>/api/v1/pods/何らかの名前</code>のようになります。</p><p>同じ種類のオブジェクトは、同じ名前を同時に持つことはできません。しかし、オブジェクトを削除することで、旧オブジェクトと同じ名前で新しいオブジェクトを作成できます。</p><p>次の3つの命名規則がよく使われます。</p><h3 id=dns-subdomain-names>DNSサブドメイン名</h3><p>ほとんどのリソースタイプには、<a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>で定義されているDNSサブドメイン名として使用できる名前が必要です。
つまり、名前は次のとおりでなければなりません:</p><ul><li>253文字以内</li><li>英小文字、数字、「-」または「.」のみを含む</li><li>英数字で始まる</li><li>英数字で終わる</li></ul><h3 id=dns-label-names>DNSラベル名</h3><p>一部のリソースタイプでは、<a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>で定義されているDNSラベル標準に従う名前が必要です。
つまり、名前は次のとおりでなければなりません:</p><ul><li>63文字以内</li><li>英小文字、数字または「-」のみを含む</li><li>英数字で始まる</li><li>英数字で終わる</li></ul><h3 id=path-segment-names>パスセグメント名</h3><p>一部のリソースタイプでは、名前をパスセグメントとして安全にエンコードできるようにする必要があります。
つまり、名前を「.」や「..」にすることはできず、名前に「/」または「%」を含めることはできません。</p><p>以下は、<code>nginx-demo</code>という名前のPodのマニフェストの例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 一部のリソースタイプには、名前に追加の制限があります。</div><h2 id=uids>UID</h2><p>オブジェクトを一意に識別するためのKubernetesが生成する文字列です。</p><p>Kubernetesクラスターの生存期間中にわたって生成された全てのオブジェクトは、異なるUIDを持っています。これは類似のエンティティの、同一時間軸での存在を区別するのが目的です。</p><p>Kubernetes UIDは、UUIDのことを指します。
UUIDは、ISO/IEC 9834-8およびITU-T X.667として標準化されています。</p><h2 id=次の項目>次の項目</h2><ul><li>Kubernetesの<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>についてお読みください。</li><li><a href=https://git.k8s.io/design-proposals-archive/architecture/identifiers.md>Kubernetesの識別子と名前</a>デザインドキュメントをご覧ください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>1.4.4 - Namespace(名前空間)</h1><p>Kubernetesは、同一の物理クラスター上で複数の仮想クラスターの動作をサポートします。
この仮想クラスターをNamespaceと呼びます。</p><h2 id=複数のnamespaceを使う時>複数のNamespaceを使う時</h2><p>Namespaceは、複数のチーム・プロジェクトにまたがる多くのユーザーがいる環境での使用を目的としています。
数人から数十人しかユーザーのいないクラスターに対して、あなたはNamespaceを作成したり、考える必要は全くありません。
Kubernetesが提供するNamespaceの機能が必要となった時に、Namespaceの使用を始めてください。</p><p>Namespaceは名前空間のスコープを提供します。リソース名は単一のNamespace内ではユニークである必要がありますが、Namespace全体ではその必要はありません。Namespaceは相互にネストすることはできず、各Kubernetesリソースは1つのNamespaceにのみ存在できます。</p><p>Namespaceは、複数のユーザーの間でクラスターリソースを分割する方法です。(これは<a href=/docs/concepts/policy/resource-quotas/>リソースクォータ</a>を介して分割します。)</p><p>同じアプリケーションの異なるバージョンなど、少し違うリソースをただ分割するだけに、複数のNamespaceを使う必要はありません。
同一のNamespace内でリソースを区別するためには<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>を使用してください。</p><h2 id=namespaceを利用する>Namespaceを利用する</h2><p>Namespaceの作成と削除方法は<a href=/docs/tasks/administer-cluster/namespaces/>Namespaceの管理ガイドドキュメント</a>に記載されています。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> プレフィックス<code>kube-</code>を持つNamespaceは、KubernetesシステムのNamespaceとして予約されているため利用は避けてください。</div><h3 id=namespaceの表示>Namespaceの表示</h3><p>ユーザーは、以下の方法で単一クラスター内の現在のNamespaceの一覧を表示できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-system       Active   1d
kube-public       Active   1d
</code></pre><p>Kubernetesの起動時には4つの初期Namespaceが作成されています。</p><ul><li><code>default</code> 他にNamespaceを持っていないオブジェクトのためのデフォルトNamespace</li><li><code>kube-system</code> Kubernetesシステムによって作成されたオブジェクトのためのNamespace</li><li><code>kube-public</code> このNamespaceは自動的に作成され、全てのユーザーから読み取り可能です。(認証されていないユーザーも含みます。)
このNamespaceは、リソースをクラスター全体を通じてパブリックに表示・読み取り可能にするため、ほとんどクラスターによって使用される用途で予約されます。 このNamespaceのパブリックな側面は単なる慣例であり、要件ではありません。</li><li><code>kube-node-lease</code> クラスターのスケールに応じたノードハートビートのパフォーマンスを向上させる各ノードに関連したLeaseオブジェクトのためのNamespace。</li></ul><h3 id=namespaceの設定>Namespaceの設定</h3><p>現在のリクエストのNamespaceを設定するには、<code>--namespace</code>フラグを使用します。</p><p>例:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span></code></pre></div><h3 id=namespace設定の永続化>Namespace設定の永続化</h3><p>ユーザーはあるコンテキストのその後のコマンドで使うために、コンテキスト内で永続的にNamespaceを保存できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Validate it</span>
</span></span><span style=display:flex><span>kubectl config view --minify | grep namespace:
</span></span></code></pre></div><h2 id=namespaceとdns>NamespaceとDNS</h2><p>ユーザーが<a href=/ja/docs/concepts/services-networking/service/>Service</a>を作成するとき、Serviceは対応する<a href=/ja/docs/concepts/services-networking/dns-pod-service/>DNSエントリ</a>を作成します。
このエントリは<code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code>という形式になり、これはもしあるコンテナがただ<code>&lt;service-name></code>を指定していた場合、Namespace内のローカルのServiceに対して名前解決されます。
これはデベロップメント、ステージング、プロダクションといった複数のNamespaceをまたいで同じ設定を使う時に効果的です。
もしユーザーがNamespaceをまたいでアクセスしたい時、 完全修飾ドメイン名(FQDN)を指定する必要があります。</p><h2 id=すべてのオブジェクトはnamespaceに属しているとは限らない>すべてのオブジェクトはNamespaceに属しているとは限らない</h2><p>ほとんどのKubernetesリソース(例えば、Pod、Service、ReplicationControllerなど)はいくつかのNamespaceにあります。
しかしNamespaceのリソースそれ自体は単一のNamespace内にありません。
そして<a href=/ja/docs/concepts/architecture/nodes/>Node</a>やPersistentVolumeのような低レベルのリソースはどのNamespaceにも属していません。</p><p>どのKubernetesリソースがNamespaceに属しているか、属していないかを見るためには、以下のコマンドで確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Namespaceに属しているもの</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Namespaceに属していないもの</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace>新しいNamespaceの作成</a>について学習してください。</li><li><a href=/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace>Namespaceの削除</a>について学習してください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f1dec4557fb8ffbac9f11390aaaf9fa4>1.4.5 - ラベル(Labels)とセレクター(Selectors)</h1><p><em>ラベル(Labels)</em> はPodなどのオブジェクトに割り当てられたキーとバリューのペアです。<br>ラベルはユーザーに関連した意味のあるオブジェクトの属性を指定するために使われることを目的としています。しかしKubernetesのコアシステムに対して直接的にその意味を暗示するものではありません。<br>ラベルはオブジェクトのサブセットを選択し、グルーピングするために使うことができます。また、ラベルはオブジェクトの作成時に割り当てられ、その後いつでも追加、修正ができます。<br>各オブジェクトはキーとバリューのラベルのセットを定義できます。各キーは、単一のオブジェクトに対してはユニークである必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ラベルは効率的な検索・閲覧を可能にし、UIやCLI上での利用に最適です。
識別用途でない情報は、<a href=/ja/docs/concepts/overview/working-with-objects/annotations/>アノテーション</a>を用いて記録されるべきです。</p><h2 id=ラベルを使う動機>ラベルを使う動機</h2><p>ラベルは、クライアントにそのマッピング情報を保存することを要求することなく、ユーザー独自の組織構造をシステムオブジェクト上で疎結合にマッピングできます。</p><p>サービスデプロイメントとバッチ処理のパイプラインは多くの場合、多次元のエンティティとなります(例: 複数のパーティション、Deployment、リリーストラック、ティアー、ティアー毎のマイクロサービスなど)<br>管理は分野横断的な操作が必要になることが多く、それによって厳密な階層表現、特にユーザーによるものでなく、インフラストラクチャーによって定義された厳格な階層のカプセル化が破られます。</p><p>ラベルの例:</p><ul><li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li><li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li><li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li><li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li><li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li></ul><p>これらは単によく使われるラベルの例です。ユーザーは自由に規約を決めることができます。
ラベルのキーは、ある1つのオブジェクトに対してユニークである必要があることは覚えておかなくてはなりません。</p><h2 id=syntax-and-character-set>構文と文字セット</h2><p>ラベルは、キーとバリューのベアです。正しいラベルキーは2つのセグメントを持ちます。<br>それは<code>/</code>によって分割されたオプショナルなプレフィックスと名前です。<br>名前セグメントは必須で、63文字以下である必要があり、文字列の最初と最後は英数字(<code>[a-z0-9A-Z]</code>)で、文字列の間ではこれに加えてダッシュ(<code>-</code>)、アンダースコア(<code>_</code>)、ドット(<code>.</code>)を使うことができます。<br>プレフィックスはオプションです。もしプレフィックスが指定されていた場合、プレフィックスはDNSサブドメイン形式である必要があり、それはドット(<code>.</code>)で区切られたDNSラベルのセットで、253文字以下である必要があり、最後にスラッシュ(<code>/</code>)が続きます。</p><p>もしプレフィックスが省略された場合、ラベルキーはそのユーザーに対してプライベートであると推定されます。<br>エンドユーザーのオブジェクトにラベルを追加するような自動化されたシステムコンポーネント(例: <code>kube-scheduler</code> <code>kube-controller-manager</code> <code>kube-apiserver</code> <code>kubectl</code>やその他のサードパーティツール)は、プレフィックスを指定しなくてはなりません。</p><p><code>kubernetes.io/</code>と<code>k8s.io/</code>プレフィックスは、Kubernetesコアコンポーネントのために予約されています。</p><p>正しいラベル値は63文字以下の長さで、空文字か、もしくは開始と終了が英数字(<code>[a-z0-9A-Z]</code>)で、文字列の間がダッシュ(<code>-</code>)、アンダースコア(<code>_</code>)、ドット(<code>.</code>)と英数字である文字列を使うことができます。</p><p>例えば、<code>environment: production</code>と<code>app: nginx</code>の2つのラベルを持つPodの設定ファイルは下記のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>label-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=label-selectors>ラベルセレクター</h2><p><a href=/ja/docs/concepts/overview/working-with-objects/names/>名前とUID</a>とは異なり、ラベルはユニーク性を提供しません。通常、多くのオブジェクトが同じラベルを保持することを想定します。</p><p><em>ラベルセレクター</em> を介して、クライアントとユーザーはオブジェクトのセットを指定できます。ラベルセレクターはKubernetesにおいてコアなグルーピング機能となります。</p><p>Kubernetes APIは現在2タイプのセレクターをサポートしています。<br>それは<em>等価ベース(equality-based)</em> と<em>集合ベース(set-based)</em> です。<br>単一のラベルセレクターは、コンマ区切りの複数の<em>要件(requirements)</em> で構成されています。<br>複数の要件がある場合、コンマセパレーターは論理積 <em>AND</em>(<code>&&</code>)オペレーターと同様にふるまい、全ての要件を満たす必要があります。</p><p>空文字の場合や、指定なしのセレクターに関するセマンティクスは、コンテキストに依存します。
そしてセレクターを使うAPIタイプは、それらのセレクターの妥当性とそれらが示す意味をドキュメントに記載するべきです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ReplicaSetなど、いくつかのAPIタイプにおいて、2つのインスタンスのラベルセレクターは単一の名前空間において重複してはいけません。重複していると、コントローラがそれらのラベルセレクターがコンフリクトした操作とみなし、どれだけの数のレプリカを稼働させるべきか決めることができなくなります。</div><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> 等価ベース、集合ベースともに、論理OR (<code>||</code>) オペレーターは存在しません。フィルターステートメントが意図した通りになっていることを確認してください。</div><h3 id=等価ベース-equality-based-の要件-requirement><em>等価ベース(Equality-based)</em> の要件(requirement)</h3><p><em>等価ベース(Equality-based)</em> もしくは<em>不等ベース(Inequality-based)</em> の要件は、ラベルキーとラベル値によるフィルタリングを可能にします。<br>要件に一致したオブジェクトは、指定されたラベルの全てを満たさなくてはいけませんが、それらのオブジェクトはさらに追加のラベルも持つことができます。<br>そして等価ベースの要件においては、3つの種類のオペレーターの利用が許可されています。<code>=</code>、<code>==</code>、<code>!=</code>となります。<br>最初の2つのオペレーター(<code>=</code>、<code>==</code>)は<em>等価(Equality)</em> を表現し(この2つは単なる同義語)、最後の1つ(<code>!=</code>)は<em>不等(Inequality)</em> を意味します。<br>例えば</p><pre tabindex=0><code>environment = production
tier != frontend
</code></pre><p>最初の例は、キーが<code>environment</code>で、値が<code>production</code>である全てのリソースを対象にします。<br>次の例は、キーが<code>tier</code>で、値が<code>frontend</code>とは異なるリソースと、<code>tier</code>という名前のキーを持たない全てのリソースを対象にします。<br>コンマセパレーター<code>,</code>を使って、<code>production</code>の中から、<code>frontend</code>のものを除外するようにフィルターすることもできます。<br><code>environment=production,tier!=frontend</code></p><p>等価ベースのラベル要件の1つの使用シナリオとして、PodにおけるNodeの選択要件を指定するケースがあります。<br>例えば、下記のサンプルPodは、ラベル<code>accelerator=nvidia-tesla-p100</code>をもったNodeを選択します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=集合ベース-set-based-の要件-requirement><em>集合ベース(Set-based)</em> の要件(requirement)</h3><p><em>集合ベース(Set-based)</em> のラベルの要件は値のセットによってキーをフィルタリングします。<br><code>in</code>、<code>notin</code>、<code>exists</code>の3つのオペレーターをサポートしています(キーを特定するのみ)。</p><p>例えば:</p><pre tabindex=0><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><ul><li>最初の例では、キーが<code>environment</code>で、値が<code>production</code>か<code>qa</code>に等しいリソースを全て選択します。</li><li>第2の例では、キーが<code>tier</code>で、値が<code>frontend</code>と<code>backend</code>以外のもの、そして<code>tier</code>キーを持たないリソースを全て選択します。</li><li>第3の例では、<code>partition</code>というキーをもつラベルを全て選択し、値はチェックしません。</li><li>第4の例では、<code>partition</code>というキーを持たないラベルを全て選択し、値はチェックしません。</li></ul><p>同様に、コンマセパレーターは、<em>AND</em> オペレーターと同様にふるまいます。そのため、<code>partition</code>と<code>environment</code>キーの値がともに<code>qa</code>でないラベルを選択するには、<code>partition,environment notin (qa)</code>と記述することで可能です。<br><em>集合ベース</em> のラベルセレクターは、<code>environment=production</code>という記述が<code>environment in (production)</code>と等しいため、一般的な等価形式となります。 <code>!=</code>と<code>notin</code>も同様に等価となります。</p><p><em>集合ベース</em> の要件は、<em>等価ベース</em> の要件と混在できます。<br>例えば:<br><code>partition in (customerA, customerB),environment!=qa</code>.</p><h2 id=api>API</h2><h3 id=listとwatchによるフィルタリング>LISTとWATCHによるフィルタリング</h3><p>LISTとWATCHオペレーションは、単一のクエリパラメータを使うことによって返されるオブジェクトのセットをフィルターするためのラベルセレクターを指定できます。<br><em>集合ベース</em> と<em>等価ベース</em> のどちらの要件も許可されています(ここでは、URLクエリストリング内で出現します)。</p><ul><li><em>等価ベース</em> での要件: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li><em>集合ベース</em> での要件: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>上記の2つの形式のラベルセレクターはRESTクライアントを介してリストにしたり、もしくは確認するために使われます。<br>例えば、<code>kubectl</code>によって<code>apiserver</code>をターゲットにし、<em>等価ベース</em> の要件でフィルターすると以下のように書けます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>environment</span><span style=color:#666>=</span>production,tier<span style=color:#666>=</span>frontend
</span></span></code></pre></div><p>もしくは、<em>集合ベース</em> の要件を指定すると以下のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production),tier in (frontend)&#39;</span>
</span></span></code></pre></div><p>すでに言及したように、<em>集合ベース</em> の要件は、<em>等価ベース</em> の要件より表現力があります。<br>例えば、値に対する <em>OR</em> オペレーターを実装して以下のように書けます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production, qa)&#39;</span>
</span></span></code></pre></div><p>もしくは、<em>exists</em> オペレーターを介して、否定マッチングによる制限もできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment,environment notin (frontend)&#39;</span>
</span></span></code></pre></div><h3 id=apiオブジェクトに参照を設定する>APIオブジェクトに参照を設定する</h3><p><a href=/ja/docs/concepts/services-networking/service/><code>Service</code></a> と <a href=/docs/concepts/workloads/controllers/replicationcontroller/><code>ReplicationController</code></a>のような、いくつかのKubernetesオブジェクトでは、ラベルセレクターを<a href=/ja/docs/concepts/workloads/pods/>Pod</a>のような他のリソースのセットを指定するのにも使われます。</p><h4 id=serviceとreplicationcontroller>ServiceとReplicationController</h4><p><code>Service</code>が対象とするPodの集合は、ラベルセレクターによって定義されます。<br>同様に、<code>ReplicationController</code>が管理するべきPod数についてもラベルセレクターを使って定義されます。</p><p>それぞれのオブジェクトに対するラベルセレクターはマップを使って<code>json</code>もしくは<code>yaml</code>形式のファイルで定義され、<em>等価ベース</em> のセレクターのみサポートされています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;selector&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span> : <span style=color:#b44>&#34;redis&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>もしくは</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div><p>このセレクター(それぞれ<code>json</code>または<code>yaml</code>形式)は、<code>component=redis</code>または<code>component in (redis)</code>と等価です。</p><h4 id=集合ベース-の要件指定をサポートするリソース><em>集合ベース</em> の要件指定をサポートするリソース</h4><p><a href=/docs/concepts/workloads/controllers/job/><code>Job</code></a>や<a href=/ja/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>、<a href=/ja/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>や<a href=/ja/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>などの比較的新しいリソースは、<em>集合ベース</em> での要件指定もサポートしています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[cache]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: environment, operator: NotIn, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>matchLabels</code>は、<code>{key,value}</code>ペアのマップです。<code>matchLabels</code>内の単一の<code>{key,value}</code>は、<code>matchExpressions</code>の要素と等しく、それは、<code>key</code>フィールドがキー名で、<code>operator</code>が"In"で、<code>values</code>配列は単に"値"を保持します。<br><code>matchExpressions</code>はPodセレクター要件のリストです。対応しているオペレーターは<code>In</code>、<code>NotIn</code>、<code>Exists</code>と<code>DoesNotExist</code>です。<code>values</code>のセットは、<code>In</code>と<code>NotIn</code>オペレーターにおいては空文字を許容しません。<br><code>matchLabels</code>と<code>matchExpressions</code>の両方によって指定された全ての要件指定はANDで判定されます。つまり要件にマッチするには指定された全ての要件を満たす必要があります。</p><h4 id=nodeのセットを選択する>Nodeのセットを選択する</h4><p>ラベルを選択するための1つのユースケースはPodがスケジュールできるNodeのセットを制限することです。<br>さらなる情報に関しては、<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>Node選定</a> のドキュメントを参照してください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-93cd7a1d4e1623e2bf01afc49a5af69c>1.4.6 - アノテーション(Annotations)</h1><p>ユーザーは、識別用途でない任意のメタデータをオブジェクトに割り当てるためにアノテーションを使用できます。ツールやライブラリなどのクライアントは、このメタデータを取得できます。</p><h2 id=オブジェクトにメタデータを割り当てる>オブジェクトにメタデータを割り当てる</h2><p>ユーザーは、Kubernetesオブジェクトに対してラベルやアノテーションの両方またはどちらか一方を割り当てることができます。
ラベルはオブジェクトの選択や、特定の条件を満たしたオブジェクトの集合を探すことに使うことができます。
それと対照的に、アノテーションはオブジェクトを識別、または選択するために使用されません。
アノテーション内のメタデータは大小様々で、構造化されているものや、そうでないものも設定でき、ラベルでは許可されていない文字も含むことができます。</p><p>アノテーションは、ラベルと同様に、キーとバリューのマップとなります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;annotations&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下記は、アノテーション内で記録できる情報の例です。</p><ul><li><p>宣言的設定レイヤによって管理されているフィールド。これらのフィールドをアノテーションとして割り当てることで、クライアントもしくはサーバによってセットされたデフォルト値、オートサイジングやオートスケーリングシステムによってセットされたフィールドや、自動生成のフィールドなどと区別することができます。</p></li><li><p>ビルド、リリースやタイムスタンプのようなイメージの情報、リリースID、gitのブランチ、PR番号、イメージハッシュ、レジストリアドレスなど</p></li><li><p>ロギング、監視、分析用のポインタ、もしくは監査用リポジトリ</p></li><li><p>デバッグ目的で使用されるためのクライアントライブラリやツールの情報。例えば、名前、バージョン、ビルド情報など。</p></li><li><p>他のエコシステムのコンポーネントからの関連オブジェクトのURLなど、ユーザーやツール、システムの出所情報。</p></li><li><p>軽量ロールアウトツールのメタデータ。　例えば設定やチェックポイントなど。</p></li><li><p>情報をどこで確認できるかを示すためのもの。例えばチームのウェブサイト、責任者の電話番号や、ページャー番号やディレクトリエンティティなど。</p></li><li><p>システムのふるまいの変更や、標準ではない機能を利用可能にするために、エンドユーザーがシステムに対して指定する値</p></li></ul><p>アノテーションを使用するかわりに、ユーザーはこのようなタイプの情報を外部のデータベースやディレクトリに保存することもできます。しかし、それによりデプロイ、管理、イントロスペクションを行うためのクライアンライブラリやツールの生成が非常に難しくなります。</p><h2 id=構文と文字セット>構文と文字セット</h2><p><em>アノテーション</em> はキーとバリューのペアです。有効なアノテーションのキーの形式は2つのセグメントがあります。
プレフィックス(オプション)と名前で、それらはスラッシュ<code>/</code>で区切られます。
名前セグメントは必須で、63文字以下である必要があり、文字列の最初と最後は英数字(<code>[a-z0-9A-Z]</code>)と、文字列の間にダッシュ(<code>-</code>)、アンダースコア(<code>_</code>)、ドット(<code>.</code>)を使うことができます。
プレフィックスはオプションです。もしプレフィックスが指定されていた場合、プレフィックスはDNSサブドメイン形式である必要があり、それはドット(<code>.</code>)で区切られたDNSラベルのセットで、253文字以下である必要があり、最後にスラッシュ(<code>/</code>)が続きます。</p><p>もしプレフィックスが除外された場合、アノテーションキーはそのユーザーに対してプライベートであると推定されます。
エンドユーザーのオブジェクトにアノテーションを追加するような自動化されたシステムコンポーネント(例: <code>kube-scheduler</code> <code>kube-controller-manager</code> <code>kube-apiserver</code> <code>kubectl</code>やその他のサードパーティツール)は、プレフィックスを指定しなくてはなりません。</p><p><code>kubernetes.io/</code>と<code>k8s.io/</code>プレフィックスは、Kubernetesコアコンポーネントのために予約されています。</p><p>たとえば、<code>imageregistry: https://hub.docker.com/</code>というアノテーションが付いたPodの構成ファイルは次のとおりです:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotations-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageregistry</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://hub.docker.com/&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=次の項目>次の項目</h2><p><a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルとセレクター</a>について学習してください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-046c03090d47bc4b89b818dc645c3865>1.4.7 - フィールドセレクター(Field Selectors)</h1><p><em>フィールドセレクター(Field Selectors)</em> は、1つかそれ以上のリソースフィールドの値を元に<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects>Kubernetesリソースを選択</a>するためのものです。<br>フィールドセレクタークエリの例は以下の通りです。</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>下記の<code>kubectl</code>コマンドは、<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase><code>status.phase</code></a>フィールドの値が<code>Running</code>である全てのPodを選択します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> フィールドセレクターは本質的にリソースの <em>フィルター</em> となります。デフォルトでは、セレクター/フィルターが指定されていない場合は、全てのタイプのリソースが取得されます。これは、<code>kubectl</code>クエリの<code>kubectl get pods</code>と<code>kubectl get pods --field-selector ""</code>が同じであることを意味します。</div><h2 id=サポートされているフィールド>サポートされているフィールド</h2><p>サポートされているフィールドセレクターはKubernetesリソースタイプによって異なります。全てのリソースタイプは<code>metadata.name</code>と<code>metadata.namespace</code>フィールドをサポートしています。サポートされていないフィールドセレクターの使用をするとエラーとなります。<br>例えば以下の通りです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</span></span></code></pre></div><pre tabindex=0><code>Error from server (BadRequest): Unable to find &#34;ingresses&#34; that match label selector &#34;&#34;, field selector &#34;foo.bar=baz&#34;: &#34;foo.bar&#34; is not a known field selector: only &#34;metadata.name&#34;, &#34;metadata.namespace&#34;
</code></pre><h2 id=サポートされているオペレーター>サポートされているオペレーター</h2><p>ユーザーは、<code>=</code>、<code>==</code>や<code>!=</code>といったオペレーターをフィールドセレクターと組み合わせて使用できます。(<code>=</code>と<code>==</code>は同義)<br>例として、下記の<code>kubectl</code>コマンドは<code>default</code>ネームスペースに属していない全てのKubernetes Serviceを選択します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div><h2 id=連結されたセレクター>連結されたセレクター</h2><p><a href=/docs/concepts/overview/working-with-objects/labels>ラベル</a>や他のセレクターと同様に、フィールドセレクターはコンマ区切りのリストとして連結することができます。<br>下記の<code>kubectl</code>コマンドは、<code>status.phase</code>が<code>Runnning</code>でなく、かつ<code>spec.restartPolicy</code>フィールドが<code>Always</code>に等しいような全てのPodを選択します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</span></span></code></pre></div><h2 id=複数のリソースタイプ>複数のリソースタイプ</h2><p>ユーザーは複数のリソースタイプにまたがったフィールドセレクターを利用できます。<br>下記の<code>kubectl</code>コマンドは、<code>default</code>ネームスペースに属していない全てのStatefulSetとServiceを選択します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets,services --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5dd62c6a4a481b4cf1ac50f6799eb581>1.4.8 - 推奨ラベル(Recommended Labels)</h1><p>ユーザーはkubectlやダッシュボード以外に、多くのツールでKubernetesオブジェクトの管理と可視化ができます。共通のラベルセットにより、全てのツールにおいて解釈可能な共通のマナーに沿ってオブジェクトを表現することで、ツールの相互運用を可能にします。</p><p>ツール化に対するサポートに加えて、推奨ラベルはクエリ可能な方法でアプリケーションを表現します。</p><p>メタデータは、<em>アプリケーション</em> のコンセプトを中心に構成されています。KubernetesはPaaS(Platform as a Service)でなく、アプリケーションの公式な概念を持たず、またそれを強制することはありません。
そのかわり、アプリケーションは、非公式で、メタデータによって表現されています。単一のアプリケーションが有する項目に対する定義は厳密に決められていません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ラベルには推奨ラベルというものがあります。それらのラベルはアプリケーションの管理を容易にします。しかしコア機能のツール化において必須のものではありません。</div><p>共有されたラベルとアノテーションは、<code>app.kubernetes.io</code>という共通のプレフィックスを持ちます。プレフィックスの無いラベルはユーザーに対してプライベートなものになります。その共有されたプレフィックスは、共有ラベルがユーザーのカスタムラベルに干渉しないことを保証します。</p><h2 id=ラベル>ラベル</h2><p>これらの推奨ラベルの利点を最大限得るためには、全てのリソースオブジェクトに対して推奨ラベルが適用されるべきです。</p><table><thead><tr><th>キー</th><th>説明</th><th>例</th><th>型</th></tr></thead><tbody><tr><td><code>app.kubernetes.io/name</code></td><td>アプリケーション名</td><td><code>mysql</code></td><td>文字列</td></tr><tr><td><code>app.kubernetes.io/instance</code></td><td>アプリケーションのインスタンスを特定するための固有名</td><td><code>mysql-abcxzy</code></td><td>文字列</td></tr><tr><td><code>app.kubernetes.io/version</code></td><td>アプリケーションの現在のバージョン (例: セマンティックバージョン、リビジョンのハッシュなど)</td><td><code>5.7.21</code></td><td>文字列</td></tr><tr><td><code>app.kubernetes.io/component</code></td><td>アーキテクチャ内のコンポーネント</td><td><code>database</code></td><td>文字列</td></tr><tr><td><code>app.kubernetes.io/part-of</code></td><td>このアプリケーションによって構成される上位レベルのアプリケーション</td><td><code>wordpress</code></td><td>文字列</td></tr><tr><td><code>app.kubernetes.io/managed-by</code></td><td>このアプリケーションの操作を管理するために使われているツール</td><td><code>helm</code></td><td>文字列</td></tr></tbody></table><p>これらのラベルが実際にどう使われているかを表すために、下記のStatefulSetのオブジェクトを考えましょう。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=アプリケーションとアプリケーションのインスタンス>アプリケーションとアプリケーションのインスタンス</h2><p>単一のアプリケーションは、Kubernetesクラスタ内で、いくつかのケースでは同一の名前空間に対して1回または複数回インストールされることがあります。
例えば、WordPressは複数のウェブサイトがあれば、それぞれ別のWordPressが複数回インストールされることがあります。</p><p>アプリケーション名と、アプリケーションのインスタンス名はそれぞれ別に記録されます。
例えば、WordPressは<code>app.kubernetes.io/name</code>に<code>wordpress</code>と記述され、インスタンス名に関しては<code>app.kubernetes.io/instance</code>に<code>wordpress-abcxzy</code>と記述されます。この仕組みはアプリケーションと、アプリケーションのインスタンスを特定可能にします。全てのアプリケーションインスタンスは固有の名前を持たなければなりません。</p><h2 id=ラベルの使用例>ラベルの使用例</h2><p>ここでは、ラベルの異なる使用例を示します。これらの例はそれぞれシステムの複雑さが異なります。</p><h3 id=シンプルなステートレスサービス>シンプルなステートレスサービス</h3><p><code>Deployment</code>と<code>Service</code>オブジェクトを使って、シンプルなステートレスサービスをデプロイするケースを考えます。下記の2つのスニペットはラベルが最もシンプルな形式においてどのように使われるかをあらわします。</p><p>下記の<code>Deployment</code>は、アプリケーションを稼働させるポッドを管理するのに使われます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>下記の<code>Service</code>は、アプリケーションを公開するために使われます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=データベースを使ったウェブアプリケーション>データベースを使ったウェブアプリケーション</h3><p>次にもう少し複雑なアプリケーションについて考えます。データベース(MySQL)を使ったウェブアプリケーション(WordPress)で、Helmを使ってインストールします。
下記のスニペットは、このアプリケーションをデプロイするために使うオブジェクト設定の出だし部分です。</p><p>はじめに下記の<code>Deployment</code>は、WordPressのために使われます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>下記の<code>Service</code>は、WordPressを公開するために使われます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQLは<code>StatefulSet</code>として公開され、MySQL自身と、MySQLが属する親アプリケーションのメタデータを持ちます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>この<code>Service</code>はMySQLをWordPressアプリケーションの一部として公開します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQLの<code>StatefulSet</code>と<code>Service</code>により、MySQLとWordPressに関するより広範な情報が含まれていることに気づくでしょう。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf36ccd6b3dbeafecf87c39761b07c7>2 - クラスターのアーキテクチャ</h1></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>2.1 - ノード</h1><p>Kubernetesはコンテナを <em>Node</em> 上で実行されるPodに配置することで、ワークロードを実行します。
ノードはクラスターによりますが、1つのVMまたは物理的なマシンです。
各ノードは<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>やそれを制御する<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>を実行するのに必要なサービスを含んでいます。</p><p>通常、1つのクラスターで複数のノードを持ちます。学習用途やリソースの制限がある環境では、1ノードかもしれません。</p><p>1つのノード上の<a href=/ja/docs/concepts/overview/components/#node-components>コンポーネント</a>には、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>、<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>、<a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>が含まれます。</p><h2 id=management>管理</h2><p>ノードを<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>に加えるには2つの方法があります:</p><ol><li>ノード上のkubeletが、コントロールプレーンに自己登録する。</li><li>あなた、もしくは他のユーザーが手動でNodeオブジェクトを追加する。</li></ol><p>Nodeオブジェクトの作成、もしくはノード上のkubeletによる自己登録の後、コントロールプレーンはNodeオブジェクトが有効かチェックします。例えば、下記のjsonマニフェストでノードを作成してみましょう:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kubernetesは内部的にNodeオブジェクトを作成します。 APIサーバーに登録したkubeletがノードの<code>metadata.name</code>フィールドが一致しているか検証します。ノードが有効な場合、つまり必要なサービスがすべて実行されている場合は、Podを実行する資格があります。それ以外の場合、該当ノードが有効になるまではいかなるクラスターの活動に対しても無視されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>Kubernetesは無効なNodeのオブジェクトを保持し、それが有効になるまで検証を続けます。</p><p>ヘルスチェックを止めるためには、あなた、もしくは<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>が明示的にNodeを削除する必要があります。</p></div><p>Nodeオブジェクトの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><h3 id=self-registration-of-nodes>ノードの自己登録</h3><p>kubeletのフラグ <code>--register-node</code>がtrue（デフォルト）のとき、kubeletは自分自身をAPIサーバーに登録しようとします。これはほとんどのディストリビューションで使用されている推奨パターンです。</p><p>自己登録については、kubeletは以下のオプションを伴って起動されます:</p><ul><li><code>--kubeconfig</code> - 自分自身をAPIサーバーに対して認証するための資格情報へのパス</li><li><code>--cloud-provider</code> - 自身に関するメタデータを読むために<a class=glossary-tooltip title='An organization that offers a cloud computing platform.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-cloud-provider' target=_blank aria-label=クラウドプロバイダー>クラウドプロバイダー</a>と会話する方法</li><li><code>--register-node</code> - 自身をAPIサーバーに自動的に登録</li><li><code>--register-with-taints</code> - 与えられた<a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taint>taint</a>のリストでノードを登録します (カンマ区切りの <code>&lt;key>=&lt;value>:&lt;effect></code>)。</li></ul><p><code>register-node</code>がfalseの場合、このオプションは機能しません</p><ul><li><code>--node-ip</code> - ノードのIPアドレス</li><li><code>--node-labels</code> - ノードをクラスターに登録するときに追加する<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=Label>Label</a>（<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction許可プラグイン</a>によって適用されるラベルの制限を参照）</li><li><code>--node-status-update-frequency</code> - kubeletがノードのステータスをマスターにPOSTする頻度の指定</li></ul><p><a href=/docs/reference/access-authn-authz/node/>ノード認証モード</a>および<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction許可プラグイン</a>が有効になっている場合、kubeletは自分自身のノードリソースを作成/変更することのみ許可されています。</p><h3 id=manual-node-administration>手動によるノード管理</h3><p>クラスター管理者は<a class=glossary-tooltip title='A command line tool for communicating with a Kubernetes cluster.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>を使用してNodeオブジェクトを作成および変更できます。</p><p>管理者が手動でNodeオブジェクトを作成したい場合は、kubeletフラグ <code>--register-node = false</code>を設定してください。</p><p>管理者は<code>--register-node</code>の設定に関係なくNodeオブジェクトを変更することができます。
例えば、ノードにラベルを設定し、それをunschedulableとしてマークすることが含まれます。</p><p>ノード上のラベルは、スケジューリングを制御するためにPod上のノードセレクターと組み合わせて使用できます。
例えば、Podをノードのサブセットでのみ実行する資格があるように制限します。</p><p>ノードをunschedulableとしてマークすると、新しいPodがそのノードにスケジュールされるのを防ぎますが、ノード上の既存のPodには影響しません。
これは、ノードの再起動などの前の準備ステップとして役立ちます。</p><p>ノードにスケジュール不可能のマークを付けるには、次のコマンドを実行します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon $ノード名
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>によって作成されたPodはノード上のunschedulable属性を考慮しません。
これは、再起動の準備中にアプリケーションからアプリケーションが削除されている場合でも、DaemonSetがマシンに属していることを前提としているためです。</div><h2 id=ノードのステータス>ノードのステータス</h2><p>ノードのステータスは以下の情報を含みます:</p><ul><li><a href=#addresses>Addresses</a></li><li><a href=#condition>Conditions</a></li><li><a href=#capacity>CapacityとAllocatable</a></li><li><a href=#info>Info</a></li></ul><p><code>kubectl</code>を使用し、ノードのステータスや詳細を確認できます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe node &lt;ノード名をここに挿入&gt;
</span></span></code></pre></div><p>出力情報の各箇所について、以下で説明します。</p><h3 id=addresses>Addresses</h3><p>これらのフィールドの使い方は、お使いのクラウドプロバイダーやベアメタルの設定内容によって異なります。</p><ul><li>HostName: ノードのカーネルによって伝えられたホスト名です。kubeletの<code>--hostname-override</code>パラメーターによって上書きすることができます。</li><li>ExternalIP: 通常は、外部にルーティング可能(クラスターの外からアクセス可能)なノードのIPアドレスです。</li><li>InternalIP: 通常は、クラスター内でのみルーティング可能なノードのIPアドレスです。</li></ul><h3 id=condition>Conditions</h3><p><code>conditions</code>フィールドは全ての<code>Running</code>なノードのステータスを表します。例として、以下のような状態を含みます:</p><table><caption style=display:none>ノードのConditionと、各condition適用時の概要</caption><thead><tr><th>ノードのCondition</th><th>概要</th></tr></thead><tbody><tr><td><code>Ready</code></td><td>ノードの状態が有効でPodを配置可能な場合に<code>True</code>になります。ノードの状態に問題があり、Podが配置できない場合に<code>False</code>になります。ノードコントローラーが、<code>node-monitor-grace-period</code>で設定された時間内(デフォルトでは40秒)に該当ノードと疎通できない場合、<code>Unknown</code>になります。</td></tr><tr><td><code>DiskPressure</code></td><td>ノードのディスク容量が圧迫されているときに<code>True</code>になります。圧迫とは、ディスクの空き容量が少ないことを指します。それ以外のときは<code>False</code>です。</td></tr><tr><td><code>MemoryPressure</code></td><td>ノードのメモリが圧迫されているときに<code>True</code>になります。圧迫とは、メモリの空き容量が少ないことを指します。それ以外のときは<code>False</code>です。</td></tr><tr><td><code>PIDPressure</code></td><td>プロセスが圧迫されているときに<code>True</code>になります。圧迫とは、プロセス数が多すぎることを指します。それ以外のときは<code>False</code>です。</td></tr><tr><td><code>NetworkUnavailable</code></td><td>ノードのネットワークが適切に設定されていない場合に<code>True</code>になります。それ以外のときは<code>False</code>です。</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>備考:</strong> コマンドラインを使用してcordonされたNodeを表示する場合、Conditionは<code>SchedulingDisabled</code>を含みます。
<code>SchedulingDisabled</code>はKubernetesのAPIにおけるConditionではありません;その代わり、cordonされたノードはUnschedulableとしてマークされます。</div><p>Nodeの状態は、Nodeリソースの<code>.status</code>の一部として表現されます。例えば、正常なノードの場合は以下のようなjson構造が表示されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Ready conditionが<code>pod-eviction-timeout</code>(<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>に渡された引数)に設定された時間を超えても<code>Unknown</code>や<code>False</code>のままになっている場合、該当ノード上にあるPodはノードコントローラーによって削除がスケジュールされます。デフォルトの退役のタイムアウトの時間は<strong>5分</strong>です。ノードが到達不能ないくつかの場合においては、APIサーバーが該当ノードのkubeletと疎通できない状態になっています。その場合、APIサーバーがkubeletと再び通信を確立するまでの間、Podの削除を行うことはできません。削除がスケジュールされるまでの間、削除対象のPodは切り離されたノードの上で稼働を続けることになります。</p><p>ノードコントローラーはクラスター内でPodが停止するのを確認するまでは強制的に削除しないようになりました。到達不能なノード上で動いているPodは<code>Terminating</code>または<code>Unknown</code>のステータスになります。Kubernetesが基盤となるインフラストラクチャーを推定できない場合、クラスター管理者は手動でNodeオブジェクトを削除する必要があります。KubernetesからNodeオブジェクトを削除すると、そのノードで実行されているすべてのPodオブジェクトがAPIサーバーから削除され、それらの名前が解放されます。</p><p>ノードのライフサイクルコントローラーがconditionを表した<a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>taint</a>を自動的に生成します。
スケジューラーがPodをノードに割り当てる際、ノードのtaintを考慮します。Podが許容するtaintは例外です。</p><p>詳細は<a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-nodes-by-condition>条件によるtaintの付与</a>を参照してください。</p><h3 id=capacity>CapacityとAllocatable</h3><p>ノードで利用可能なリソース（CPU、メモリ、およびノードでスケジュールできる最大Pod数）について説明します。</p><p>capacityブロック内のフィールドは、ノードが持っているリソースの合計量を示します。
allocatableブロックは、通常のPodによって消費されるノード上のリソースの量を示します。</p><p>CapacityとAllocatableについて深く知りたい場合は、ノード上でどのように<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>コンピュートリソースが予約されるか</a>を読みながら学ぶことができます。</p><h3 id=info>Info</h3><p>カーネルのバージョン、Kubernetesのバージョン（kubeletおよびkube-proxyのバージョン）、（使用されている場合）Dockerのバージョン、OS名など、ノードに関する一般的な情報です。
この情報はノードからkubeletを通じて取得され、Kubernetes APIに公開されます。</p><h2 id=ハートビート>ハートビート</h2><p>ハートビートは、Kubernetesノードから送信され、ノードが利用可能か判断するのに役立ちます。
以下の２つのハートビートがあります：</p><ul><li>Nodeの<code>.status</code>の更新</li><li><a href=/docs/reference/generated/kubernetes-api/v1.25#lease-v1-coordination-k8s-io>Lease object</a>です。
各ノードは<code>kube-node-lease</code>という<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>に関連したLeaseオブジェクトを持ちます。
Leaseは軽量なリソースで、クラスターのスケールに応じてノードのハートビートにおけるパフォーマンスを改善します。</li></ul><p>kubeletが<code>NodeStatus</code>とLeaseオブジェクトの作成および更新を担当します。</p><ul><li>kubeletは、ステータスに変化があったり、設定した間隔の間に更新がない時に<code>NodeStatus</code>を更新します。<code>NodeStatus</code>更新のデフォルト間隔は５分です。(到達不能の場合のデフォルトタイムアウトである40秒よりもはるかに長いです)</li><li>kubeletは10秒間隔(デフォルトの更新間隔)でLeaseオブジェクトの生成と更新を実施します。Leaseの更新は<code>NodeStatus</code>の更新とは独立されて行われます。Leaseの更新が失敗した場合、kubeletは200ミリ秒から始まり7秒を上限とした指数バックオフでリトライします。</li></ul><h2 id=ノードコントローラー>ノードコントローラー</h2><p>ノード<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>は、ノードのさまざまな側面を管理するKubernetesのコントロールプレーンコンポーネントです。</p><p>ノードコントローラーは、ノードの存続期間中に複数の役割を果たします。1つ目は、ノードが登録されたときにCIDRブロックをノードに割り当てることです（CIDR割り当てがオンになっている場合）。</p><p>2つ目は、ノードコントローラーの内部ノードリストをクラウドの利用可能なマシンのリストと一致させることです。
クラウド環境で実行している場合、ノードに異常があると、ノードコントローラーはクラウドプロバイダーにそのNodeのVMがまだ使用可能かどうかを問い合わせます。
使用可能でない場合、ノードコントローラーはノードのリストから該当ノードを削除します。</p><p>3つ目は、ノードの状態を監視することです。
ノードが到達不能(例えば、ノードがダウンしているなどので理由で、ノードコントローラーがハートビートの受信を停止した場合)になると、ノードコントローラーは、NodeStatusのNodeReady conditionをConditionUnknownに変更する役割があります。その後も該当ノードが到達不能のままであった場合、Graceful Terminationを使って全てのPodを退役させます。デフォルトのタイムアウトは、ConditionUnknownの報告を開始するまで40秒、その後Podの追い出しを開始するまで5分に設定されています。
ノードコントローラーは、<code>--node-monitor-period</code>に設定された秒数ごとに各ノードの状態をチェックします。</p><h4 id=信頼性>信頼性</h4><p>ほとんどの場合、排除の速度は1秒あたり<code>--node-eviction-rate</code>に設定された数値（デフォルトは秒間0.1）です。つまり、10秒間に1つ以上のPodをノードから追い出すことはありません。</p><p>特定のアベイラビリティーゾーン内のノードのステータスが異常になると、ノード排除の挙動が変わります。ノードコントローラーは、ゾーン内のノードの何%が異常（NodeReady条件がConditionUnknownまたはConditionFalseである）であるかを同時に確認します。
異常なノードの割合が少なくとも <code>--healthy-zone-threshold</code>に設定した値を下回る場合（デフォルトは0.55）であれば、退役率は低下します。クラスターが小さい場合（すなわち、 <code>--large-cluster-size-threshold</code>の設定値よりもノード数が少ない場合。デフォルトは50）、退役は停止し、そうでない場合、退役率は秒間で<code>--secondary-node-eviction-rate</code>の設定値（デフォルトは0.01）に減少します。
これらのポリシーがアベイラビリティーゾーンごとに実装されているのは、1つのアベイラビリティーゾーンがマスターから分割される一方、他のアベイラビリティーゾーンは接続されたままになる可能性があるためです。
クラスターが複数のクラウドプロバイダーのアベイラビリティーゾーンにまたがっていない場合、アベイラビリティーゾーンは1つだけです（クラスター全体）。</p><p>ノードを複数のアベイラビリティゾーンに分散させる主な理由は、1つのゾーン全体が停止したときにワークロードを正常なゾーンに移動できることです。
したがって、ゾーン内のすべてのノードが異常である場合、ノードコントローラーは通常のレート <code>--node-eviction-rate</code>で退役します。
コーナーケースは、すべてのゾーンが完全にUnhealthyである（すなわち、クラスタ内にHealthyなノードがない）場合です。
このような場合、ノードコントローラーはマスター接続に問題があると見なし、接続が回復するまですべての退役を停止します。</p><p>ノードコントローラーは、Podがtaintを許容しない場合、 <code>NoExecute</code>のtaintを持つノード上で実行されているPodを排除する責務もあります。
さらに、ノードコントローラーはノードに到達できない、または準備ができていないなどのノードの問題に対応する<a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taint>taint</a>を追加する責務があります。これはスケジューラーが、問題のあるノードにPodを配置しない事を意味しています。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> <code>kubectl cordon</code>はノードに'unschedulable'としてマークします。それはロードバランサーのターゲットリストからノードを削除するという
サービスコントローラーの副次的な効果をもたらします。これにより、ロードバランサトラフィックの流入をcordonされたノードから効率的に除去する事ができます。</div><h3 id=ノードのキャパシティ>ノードのキャパシティ</h3><p>Nodeオブジェクトはノードのリソースキャパシティ（CPUの数とメモリの量）を監視します。
<a href=#self-registration-of-nodes>自己登録</a>したノードは、Nodeオブジェクトを作成するときにキャパシティを報告します。
<a href=#manual-node-administration>手動によるノード管理</a>を実行している場合は、ノードを追加するときにキャパシティを設定する必要があります。</p><p>Kubernetes<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=スケジューラー>スケジューラー</a>は、ノード上のすべてのPodに十分なリソースがあることを確認します。スケジューラーは、ノード上のコンテナが要求するリソースの合計がノードキャパシティ以下であることを確認します。
これは、kubeletによって管理されたすべてのコンテナを含みますが、コンテナランタイムによって直接開始されたコンテナやkubeletの制御外で実行されているプロセスは含みません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Pod以外のプロセス用にリソースを明示的に予約したい場合は、<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>Systemデーモン用にリソースを予約</a>を参照してください。</div><h2 id=ノードのトポロジー>ノードのトポロジー</h2><p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><code>TopologyManager</code>の<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にすると、
kubeletはリソースの割当を決定する際にトポロジーのヒントを利用できます。
詳細は、<a href=/ja/docs/tasks/administer-cluster/topology-manager/>ノードのトポロジー管理ポリシーを制御する</a>を参照してください。</p><h2 id=graceful-node-shutdown>ノードの正常終了</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code></div><p>kubeletは、ノードのシステムシャットダウンを検出すると、ノード上で動作しているPodを終了させます。</p><p>Kubelet は、ノードのシャットダウン時に、ポッドが通常の<a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>通常のポッド終了プロセス</a>に従うようにします。</p><p>Graceful Node Shutdownはsystemdに依存しているため、<a href=https://www.freedesktop.org/wiki/Software/systemd/inhibit/>systemd inhibitor locks</a>を
利用してノードのシャットダウンを一定時間遅らせることができます。</p><p>Graceful Node Shutdownは、v1.21でデフォルトで有効になっている<code>GracefulNodeShutdown</code> <a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>で制御されます。</p><p>なお、デフォルトでは、後述の設定オプション<code>ShutdownGracePeriod</code>および<code>ShutdownGracePeriodCriticalPods</code>の両方がゼロに設定されているため、Graceful node shutdownは有効になりません。この機能を有効にするには、この2つのkubeletの設定を適切に設定し、ゼロ以外の値を設定する必要があります。</p><p>Graceful shutdownでは、kubeletは以下の2段階でPodを終了させます。</p><ol><li>そのノード上で動作している通常のPodを終了させます。</li><li>そのノード上で動作している<a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>を終了させます。</li></ol><p>Graceful Node Shutdownには、2つの<a href=/docs/tasks/administer-cluster/kubelet-config-file/><code>KubeletConfiguration</code></a>オプションを設定します。:</p><ul><li><code>ShutdownGracePeriod</code>:<ul><li>ノードがシャットダウンを遅らせるべき合計期間を指定します。これは、通常のPodと<a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>の両方のPod終了の合計猶予期間です。</li></ul></li><li><code>ShutdownGracePeriodCriticalPods</code>:<ul><li>ノードのシャットダウン時に<a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>を終了させるために使用する期間を指定します。この値は、ShutdownGracePeriodよりも小さくする必要があります。</li></ul></li></ul><p>例えば、<code>ShutdownGracePeriod=30s</code>、<code>ShutdownGracePeriodCriticalPods=10s</code>とすると、
kubeletはノードのシャットダウンを30秒遅らせます。シャットダウンの間、最初の20(30-10)秒は通常のポッドを優雅に終了させるために確保され、
残りの10秒は重要なポッドを終了させるために確保されることになります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>Graceful Node Shutdown中にPodが退避された場合、それらのPodの<code>.status</code>は<code>Failed</code>になります。
<code>kubectl get pods</code>を実行すると、退避させられたPodのステータスが <code>Shutdown</code> と表示されます。
また、<code>kubectl describe pod</code>を実行すると、ノードのシャットダウンのためにPodが退避されたことがわかります。</p><pre tabindex=0><code>Status:         Failed
Reason:         Shutdown
Message:        Node is shutting, evicting pods
</code></pre><p>失敗したポッドオブジェクトは、明示的に削除されるか、<a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>GCによってクリーンアップ</a>されるまで保存されます。
これは、ノードが突然終了した場合とは異なった振る舞いです。</p></div><h2 id=swap-memory>スワップメモリの管理</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code></div><p>Kubernetes 1.22以前では、ノードはスワップメモリの使用をサポートしておらず、ノード上でスワップが検出された場合、
kubeletはデフォルトで起動に失敗していました。1.22以降では、スワップメモリのサポートをノードごとに有効にすることができます。</p><p>ノードでスワップを有効にするには、kubeletの <code>NodeSwap</code> <a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にし、
<code>--fail-swap-on</code>コマンドラインフラグまたは<code>failSwapOn</code><a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a>を false に設定する必要があります。</p><p>ユーザーはオプションで、ノードがスワップメモリをどのように使用するかを指定するために、<code>memorySwap.swapBehavior</code>を設定することもできます。ノードがスワップメモリをどのように使用するかを指定します。例えば、以下のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>memorySwap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>swapBehavior</span>:<span style=color:#bbb> </span>LimitedSwap<span style=color:#bbb>
</span></span></span></code></pre></div><p>swapBehaviorで使用できる設定オプションは以下の通りです。:</p><ul><li><code>LimitedSwap</code>: Kubernetesのワークロードが、使用できるスワップ量に制限を設けます。Kubernetesが管理していないノード上のワークロードは、依然としてスワップを使用できます。</li><li><code>UnlimitedSwap</code>: Kubernetesのワークロードが使用できるスワップ量に制限を設けません。システムの限界まで、要求されただけのスワップメモリを使用することができます。</li></ul><p><code>memorySwap</code>の設定が指定されておらず、<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>が有効な場合、デフォルトのkubeletは<code>LimitedSwap</code>の設定と同じ動作を適用します。</p><p><code>LimitedSwap</code>設定の動作は、ノードがコントロールグループ(「cgroups」とも呼ばれる)のv1とv2のどちらで動作しているかによって異なります。</p><p>Kubernetesのワークロードでは、メモリとスワップを組み合わせて使用することができ、ポッドのメモリ制限が設定されている場合はその制限まで使用できます。</p><ul><li><strong>cgroupsv1:</strong> Kubernetesのワークロードは、メモリとスワップを組み合わせて使用することができ、ポッドのメモリ制限が設定されている場合はその制限まで使用できます。</li><li><strong>cgroupsv2:</strong> Kubernetesのワークロードは、スワップメモリを使用できません。</li></ul><p>詳しくは、<a href=https://github.com/kubernetes/enhancements/issues/2400>KEP-2400</a>と
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2400-node-swap/README.md>design proposal</a>をご覧いただき、テストにご協力、ご意見をお聞かせください。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/overview/components/#node-components>ノードコンポーネント</a>について学習する。</li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#node-v1-core>Node APIオブジェクト</a>について読む。</li><li>アーキテクチャ設計文書の<a href=https://git.k8s.io/design-proposals-archive/architecture/architecture.md#the-kubernetes-node>Node</a>という章を読む。</li><li><a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>TaintとToleration</a>について読む。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0251def6da29b30afebfb04549f1703>2.2 - ノードとコントロールプレーン間の通信</h1><p>本ドキュメントは、APIサーバーとKubernetesクラスター間の通信経路をまとめたものです。
その目的は、信頼できないネットワーク上(またはクラウドプロバイダー上の完全なパブリックIP)でクラスターが実行できるよう、ユーザーがインストールをカスタマイズしてネットワーク構成を強固にできるようにすることです。</p><h2 id=node-to-control-plane>ノードからコントロールプレーンへの通信</h2><p>Kubernetesには「ハブアンドスポーク」というAPIパターンがあります。ノード(またはノードが実行するPod)からのすべてのAPIの使用は、APIサーバーで終了します。他のコントロールプレーンコンポーネントは、どれもリモートサービスを公開するようには設計されていません。APIサーバーは、1つ以上の形式のクライアント<a href=/ja/docs/reference/access-authn-authz/authentication/>認証</a>が有効になっている状態で、セキュアなHTTPSポート(通常は443)でリモート接続をリッスンするように設定されています。
特に<a href=/ja/docs/reference/access-authn-authz/authentication/#anonymous-requests>匿名リクエスト</a>や<a href=/ja/docs/reference/access-authn-authz/authentication/#service-account-token>サービスアカウントトークン</a>が許可されている場合は、1つ以上の<a href=/docs/reference/access-authn-authz/authorization/>認可</a>形式を有効にする必要があります。</p><p>ノードは、有効なクライアント認証情報とともに、APIサーバーに安全に接続できるように、クラスターのパブリックルート証明書でプロビジョニングされる必要があります。適切なやり方は、kubeletに提供されるクライアント認証情報が、クライアント証明書の形式であることです。kubeletクライアント証明書の自動プロビジョニングについては、<a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLSブートストラップ</a>を参照してください。</p><p>APIサーバーに接続したいPodは、サービスアカウントを利用することで、安全に接続することができます。これにより、Podのインスタンス化時に、Kubernetesはパブリックルート証明書と有効なBearerトークンを自動的にPodに挿入します。
<code>kubernetes</code>サービス(<code>デフォルト</code>の名前空間)は、APIサーバー上のHTTPSエンドポイントに(<code>kube-proxy</code>経由で)リダイレクトされる仮想IPアドレスで構成されます。</p><p>また、コントロールプレーンのコンポーネントは、セキュアなポートを介してAPIサーバーとも通信します。</p><p>その結果、ノードやノード上で動作するPodからコントロールプレーンへの接続は、デフォルトでセキュアであり、信頼されていないネットワークやパブリックネットワークを介して実行することができます。</p><h2 id=control-plane-to-node>コントロールプレーンからノードへの通信</h2><p>コントロールプレーン(APIサーバー)からノードへの主要な通信経路は2つあります。
1つ目は、APIサーバーからクラスター内の各ノードで実行されるkubeletプロセスへの通信経路です。
2つ目は、APIサーバーの <em>プロキシー</em> 機能を介した、APIサーバーから任意のノード、Pod、またはサービスへの通信経路です。</p><h3 id=api-server-to-kubelet>APIサーバーからkubeletへの通信</h3><p>APIサーバーからkubeletへの接続は、以下の目的で使用されます:</p><ul><li>Podのログの取得。</li><li>実行中のPodへのアタッチ(通常は<code>kubectl</code>を使用)。</li><li>kubeletのポート転送機能の提供。</li></ul><p>これらの接続は、kubeletのHTTPSエンドポイントで終了します。デフォルトでは、APIサーバーはkubeletのサービング証明書を検証しないため、接続は中間者攻撃の対象となり、信頼されていないネットワークやパブリックネットワークを介して実行するのは<strong>安全ではありません</strong>。</p><p>この接続を検証するには、<code>--kubelet-certificate-authority</code>フラグを使用して、kubeletのサービング証明書を検証するために使用するルート証明書バンドルを、APIサーバーに提供します。</p><p>それができない場合は、信頼できないネットワークやパブリックネットワークを介した接続を回避するため、必要に応じてAPIサーバーとkubeletの間で<a href=#ssh-tunnels>SSHトンネル</a>を使用します。</p><p>最後に、kubelet APIを保護するために、<a href=/docs/reference/access-authn-authz/kubelet-authn-authz/>Kubelet認証/認可</a>を有効にする必要があります。</p><h3 id=api-server-to-nodes-pods-and-services>APIサーバーからノード、Pod、サービスへの通信</h3><p>APIサーバーからノード、Pod、またはサービスへの接続は、デフォルトで平文のHTTP接続になるため、認証も暗号化もされません。API URL内のノード、Pod、サービス名に<code>https:</code>を付けることで、セキュアなHTTPS接続を介して実行できますが、HTTPSエンドポイントから提供された証明書を検証したり、クライアント認証情報を提供したりすることはありません。そのため、接続の暗号化はされますが、完全性の保証はありません。これらの接続を、信頼されていないネットワークやパブリックネットワークを介して実行するのは、<strong>現在のところ安全ではありません</strong>。</p><h3 id=ssh-tunnels>SSHトンネル</h3><p>Kubernetesは、コントロールプレーンからノードへの通信経路を保護するために、SSHトンネルをサポートしています。この構成では、APIサーバーがクラスター内の各ノードへのSSHトンネルを開始(ポート22でリッスンしているSSHサーバーに接続)し、kubelet、ノード、Pod、またはサービス宛てのすべてのトラフィックをトンネル経由で渡します。
このトンネルにより、ノードが稼働するネットワークの外部にトラフィックが公開されないようになります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> SSHトンネルは現在非推奨であるため、自分が何をしているのか理解していないのであれば、使用すべきではありません。この通信経路の代替となるものとして、<a href=#konnectivity-service>Konnectivityサービス</a>があります。</div><h3 id=konnectivity-service>Konnectivityサービス</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>SSHトンネルの代替として、Konnectivityサービスは、コントロールプレーンからクラスターへの通信に、TCPレベルのプロキシーを提供します。Konnectivityサービスは、コントロールプレーンネットワークのKonnectivityサーバーと、ノードネットワークのKonnectivityエージェントの、2つの部分で構成されています。
Konnectivityエージェントは、Konnectivityサーバーへの接続を開始し、ネットワーク接続を維持します。
Konnectivityサービスを有効にすると、コントロールプレーンからノードへのトラフィックは、すべてこの接続を経由するようになります。</p><p><a href=/docs/tasks/extend-kubernetes/setup-konnectivity/>Konnectivityサービスのセットアップ</a>に従って、クラスターにKonnectivityサービスをセットアップしてください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>2.3 - コントローラー</h1><p>ロボット工学やオートメーションの分野において、 <em>制御ループ</em> とは、あるシステムの状態を制御する終了状態のないループのことです。</p><p>ここでは、制御ループの一例として、部屋の中にあるサーモスタットを挙げます。</p><p>あなたが温度を設定すると、それはサーモスタットに <em>目的の状態(desired state)</em> を伝えることになります。実際の部屋の温度は <em>現在の状態</em> です。サーモスタットは、装置をオンまたはオフにすることによって、現在の状態を目的の状態に近づけるように動作します。</p>Kubernetesにおいて、コントローラーは<a class=glossary-tooltip title=コンテナ化されたアプリケーションを実行する、ノードと呼ばれるワーカーマシンの集合です。すべてのクラスターには少なくとも1つのワーカーノードがあります。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=クラスター>クラスター</a>の状態を監視し、必要に応じて変更を加えたり要求したりする制御ループです。それぞれのコントローラーは現在のクラスターの状態を望ましい状態に近づけるように動作します。<h2 id=コントローラーパターン>コントローラーパターン</h2><p>コントローラーは少なくとも1種類のKubernetesのリソースを監視します。これらの<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>オブジェクト</a>には目的の状態を表すspecフィールドがあります。リソースのコントローラーは、現在の状態を目的の状態に近づける責務を持ちます。</p><p>コントローラーは自分自身でアクションを実行する場合もありますが、Kubernetesではコントローラーが<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>に意味のある副作用を持つメッセージを送信することが一般的です。以下では、このような例を見ていきます。</p><h3 id=apiサーバー経由でコントロールする>APIサーバー経由でコントロールする</h3><p><a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>コントローラーはKubernetesのビルトインのコントローラーの一例です。ビルトインのコントローラーは、クラスターのAPIサーバーとやりとりをして状態を管理します。</p><p>Jobは、1つ以上の<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>を起動して、タスクを実行した後に停止する、Kubernetesのリソースです。</p><p>(1度<a href=/ja/docs/concepts/scheduling-eviction/>スケジュール</a>されると、Podオブジェクトはkubeletに対する目的の状態の一部になります。)</p><p>Jobコントローラーが新しいタスクを見つけると、その処理が完了するように、クラスター上のどこかで、一連のNode上のkubeletが正しい数のPodを実行することを保証します。ただし、Jobコントローラーは、自分自身でPodやコンテナを実行することはありません。代わりに、APIサーバーに対してPodの作成や削除を依頼します。<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>上の他のコンポーネントが(スケジュールして実行するべき新しいPodが存在するという)新しい情報を基に動作することによって、最終的に目的の処理が完了します。</p><p>新しいJobが作成されたとき、目的の状態は、そのJobが完了することです。JobコントローラーはそのJobに対する現在の状態を目的の状態に近づけるようにします。つまり、そのJobが行ってほしい処理を実行するPodを作成し、Jobが完了に近づくようにします。</p><p>コントローラーは、コントローラーを設定するオブジェクトも更新します。たとえば、あるJobが完了した場合、Jobコントローラーは、Jobオブジェクトに<code>Finished</code>というマークを付けます。</p><p>(これは、部屋が設定温度になったことを示すために、サーモスタットがランプを消灯するのに少し似ています。)</p><h3 id=直接的なコントロール>直接的なコントロール</h3><p>Jobとは対照的に、クラスターの外部に変更を加える必要があるコントローラーもあります。</p><p>たとえば、クラスターに十分な数の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>が存在することを保証する制御ループの場合、そのコントローラーは、必要に応じて新しいNodeをセットアップするために、現在のクラスターの外部とやりとりをする必要があります。</p><p>外部の状態とやりとりをするコントローラーは、目的の状態をAPIサーバーから取得した後、外部のシステムと直接通信し、現在の状態を目的の状態に近づけます。</p><p>(クラスター内のノードを水平にスケールさせる<a href=https://github.com/kubernetes/autoscaler/>コントローラー</a>が実際に存在します。)</p><p>ここで重要な点は、コントローラーが目的の状態を実現するために変更を加えてから、現在の状態をクラスターのAPIサーバーに報告することです。他の制御ループは、その報告されたデータを監視し、独自のアクションを実行できます。</p><p>サーモスタットの例では、部屋が非常に寒い場合、別のコントローラーが霜防止ヒーターをオンにすることもあります。Kubernetesクラスターを使用すると、コントロールプレーンは、<a href=/ja/docs/concepts/extend-kubernetes/>Kubernetesを拡張して</a>実装することにより、IPアドレス管理ツールやストレージサービス、クラウドプロバイダーAPI、およびその他のサービスと間接的に連携します。</p><h2 id=desired-vs-current>目的の状態 vs 現在の状態</h2><p>Kubernetesはシステムに対してクラウドネイティブな見方をするため、常に変化し続けるような状態を扱えるように設計されています。</p><p>処理を実行したり、制御ループが故障を自動的に修正したりしているどの時点でも、クラスターは変化中である可能性があります。つまり、クラスターは決して安定した状態にならない可能性があるということです。</p><p>コントローラーがクラスターのために実行されていて、有用な変更が行われるのであれば、全体的な状態が安定しているかどうかは問題にはなりません。</p><h2 id=設計>設計</h2><p>設計理念として、Kubernetesは多数のコントローラーを使用しており、各コントローラーはクラスターの状態の特定の側面をそれぞれ管理しています。最もよくあるパターンは、特定の制御ループ(コントローラー)が目的の状態として1種類のリソースを使用し、目的の状態を実現することを管理するために別の種類のリソースを用意するというものです。たとえば、Jobのコントローラーは、Jobオブジェクト(新しい処理を見つけるため)およびPodオブジェクト(Jobを実行し、処理が完了したか確認するため)を監視します。この場合、なにか別のものがJobを作成し、JobコントローラーはPodを作成します。</p><p>相互にリンクされた単一のモノリシックな制御ループよりは、複数の単純なコントローラーが存在する方が役に立ちます。コントローラーは故障することがあるため、Kubernetesは故障を許容するように設計されています。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>同じ種類のオブジェクトを作成または更新するコントローラーが、複数存在する場合があります。実際には、Kubernetesコントローラーは、自分が制御するリソースに関連するリソースにのみ注意を払うように作られています。</p><p>たとえば、DeploymentとJobがありますが、これらは両方ともPodを作成するものです。しかし、JobコントローラーはDeploymentが作成したPodを削除することはありません。各コントローラーが2つのPodを区別できる情報(<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>)が存在するためです。</p></div><h2 id=running-controllers>コントローラーを実行する方法</h2><p>Kubernetesには、<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>内部で動作する一組のビルトインのコントローラーが用意されています。これらビルトインのコントローラーは、コアとなる重要な振る舞いを提供します。</p><p>DeploymentコントローラーとJobコントローラーは、Kubernetes自体の一部として同梱されているコントローラーの例です(それゆえ「ビルトイン」のコントローラーと呼ばれます)。Kubernetesは回復性のあるコントロールプレーンを実行できるようにしているため、ビルトインのコントローラーの一部が故障しても、コントロールプレーンの別の部分が作業を引き継いでくれます。</p><p>Kubernetesを拡張するためにコントロールプレーンの外で動作するコントローラーもあります。もし望むなら、新しいコントローラーを自分で書くこともできます。自作のコントローラーをPodセットとして動作させたり、Kubernetesの外部で動作させることもできます。どのような動作方法が最も適しているかは、そのコントローラーがどのようなことを行うのかに依存します。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/#kubernetes-control-plane>Kubernetesコントロールプレーン</a>について読む</li><li>基本的な<a href=/ja/docs/concepts/#kubernetes-objects>Kubernetesオブジェクト</a>について学ぶ</li><li><a href=/ja/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>について学ぶ</li><li>自分でコントローラーを書きたい場合は、「Kubernetesを拡張する」の<a href=/ja/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>エクステンションパターン</a>を読んでください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>2.4 - クラウドコントローラーマネージャー</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>クラウドインフラストラクチャー技術により、パブリック、プライベート、ハイブリッドクラウド上でKubernetesを動かすことができます。Kubernetesは、コンポーネント間の密なつながりが不要な自動化されたAPI駆動インフラストラクチャーを信条としています。</p><p><p>cloud-controller-managerは クラウド特有の制御ロジックを組み込むKubernetesの<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>コンポーネントです。クラウドコントロールマネージャーは、クラスターをクラウドプロバイダーAPIをリンクし、クラスタのみで相互作用するコンポーネントからクラウドプラットフォームで相互作用するコンポーネントを分離します。</p></p><p>Kubernetesと下のクラウドインフラストラクチャー間の相互運用ロジックを分離することで、cloud-controller-managerコンポーネントはクラウドプロバイダを主なKubernetesプロジェクトと比較し異なるペースで機能をリリース可能にします。</p><p>cloud-controller-managerは、プラグイン機構を用い、異なるクラウドプロバイダーに対してそれぞれのプラットフォームとKubernetesの結合を可能にする構成になっています。</p><h2 id=設計>設計</h2><p><img src=/images/docs/components-of-kubernetes.svg alt=Kubernetesのコンポーネント></p><p>クラウドコントローラーマネージャーは、複製されたプロセスの集合としてコントロールプレーンで実行されます。（通常、Pod内のコンテナとなります）各cloud-controller-managerは、シングルプロセスで複数の<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a>を実装します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> コントロールプレーンの一部ではなく、Kubernetesの<a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=addon>addon</a>としてクラウドコントローラーマネージャーを実行することもできます。</div><h2 id=functions-of-the-ccm>クラウドコントローラーマネージャーの機能</h2><p>クラウドコントローラーマネージャーのコントローラーは以下を含んでいます。</p><h4 id=ノードコントローラー>ノードコントローラー</h4><p>ノードコントローラーは、クラウドインフラストラクチャーで新しいサーバーが作成された際に、<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>オブジェクトを作成する責務を持ちます。ノードコントローラーは、クラウドプロバイダーのテナント内で動作しているホストの情報を取得します。ノードコントローラーは下記に示す機能を実行します:</p><ol><li>Nodeオブジェクトを、コントローラーがクラウドプロバイダーAPIを通じて見つけた各サーバーで初期化する</li><li>Nodeオブジェクトに、ノードがデプロイされているリージョンや利用可能なリソース（CPU、メモリなど）のようなクラウド特有な情報を注釈付けやラベル付けをする</li><li>ノードのホスト名とネットワークアドレスを取得する</li><li>ノードの正常性を検証する。ノードが応答しなくなった場合、クラウドプロバイダーのAPIを利用しサーバーがdeactivated / deleted / terminatedであるかを確認する。クラウドからノードが削除されていた場合、KubernetesクラスターからNodeオブジェクトを削除する</li></ol><p>いくつかのクラウドプロバイダーは、これをノードコントローラーと個別のノードライフサイクルコントローラーに分けて実装しています。</p><h4 id=ルートコントローラー>ルートコントローラー</h4><p>ルートコントローラーは、クラスタ内の異なるノード上で稼働しているコンテナが相互に通信できるように、クラウド内のルートを適切に設定する責務を持ちます。</p><p>クラウドプロバイダーによっては、ルートコントローラーはPodネットワークのIPアドレスのブロックを割り当てることもあります。</p><h4 id=サービスコントローラー>サービスコントローラー</h4><p><a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Services>Services</a>は、マネージドロードバランサー、IPアドレスネットワークパケットフィルタや対象のヘルスチェックのようなクラウドインフラストラクチャーコンポーネントのインテグレーションを行います。サービスコントローラーは、ロードバランサーや他のインフラストラクチャーコンポーネントを必要とするServiceリソースを宣言する際にそれらのコンポーネントを設定するため、クラウドプロバイダーのAPIと対話します。</p><h2 id=認可>認可</h2><p>このセクションでは、クラウドコントローラーマネージャーが操作を行うために様々なAPIオブジェクトに必要な権限を分類します。</p><h3 id=authorization-node-controller>ノードコントローラー</h3><p>ノードコントローラーはNodeオブジェクトのみに対して働きます。Nodeオブジェクトに対して、readとmodifyの全権限が必要です。</p><p><code>v1/Node</code>:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=authorization-route-controller>ルートコントローラー</h3><p>ルートコントローラーは、Nodeオブジェクトの作成を待ち受け、ルートを適切に設定します。Nodeオブジェクトについて、get権限が必要です。</p><p><code>v1/Node</code>:</p><ul><li>Get</li></ul><h3 id=authorization-service-controller>サービスコントローラー</h3><p>サービスコントローラーは、Serviceオブジェクトの作成、更新、削除イベントを待ち受け、その後、サービスのEndpointを適切に設定します。</p><p>サービスにアクセスするため、list、watchの権限が必要です。サービスを更新するため、patch、updateの権限が必要です。</p><p>サービスのEndpointリソースを設定するため、create、list、get、watchそしてupdateの権限が必要です。</p><p><code>v1/Service</code>:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=authorization-miscellaneous>その他</h3><p>クラウドコントローラーマネージャーのコア機能の実装は、Eventオブジェクトのcreate権限と、セキュアな処理を保証するため、ServiceAccountのcreate権限が必要です。</p><p><code>v1/Event</code>:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p><code>v1/ServiceAccount</code>:</p><ul><li>Create</li></ul><p>クラウドコントローラーマネージャーの<a class=glossary-tooltip title='Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a> ClusterRoleはこのようになります:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=次の項目>次の項目</h2><p><a href=/ja/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>Cloud Controller Manager Administration</a>
はクラウドコントラーマネージャーの実行と管理を説明しています。</p><p>どのようにあなた自身のクラウドコントローラーマネージャーが実装されるのか、もしくは既存プロジェクトの拡張について知りたいですか？</p><p>クラウドコントローラーマネージャーは、いかなるクラウドからもプラグインとしての実装を許可するためにGoインターフェースを使います。具体的には、<a href=https://github.com/kubernetes/cloud-provider>kubernetes/cloud-provider</a>の <a href=https://github.com/kubernetes/cloud-provider/blob/release-1.21/cloud.go#L42-L69><code>cloud.go</code></a>で定義されている<code>CloudProvider</code>を使います。</p><p>本ドキュメントでハイライトした共有コントローラー（Node、Route、Service）の実装と共有クラウドプロバイダーインターフェースに沿ったいくつかの足場は、Kubernetesコアの一部です。クラウドプロバイダに特化した実装は、Kubernetesのコアの外部として、また<code>CloudProvider</code>インターフェースを実装します。</p><p>プラグイン開発ついての詳細な情報は、<a href=/ja/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Developing Cloud Controller Manager</a>を見てください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-44a2e2e592af0846101e970aff9243e5>2.5 - ガベージコレクション</h1><p>ガベージコレクションは、Kubernetesがクラスターリソースをクリーンアップするために使用するさまざまなメカニズムの総称です。これにより、次のようなリソースのクリーンアップが可能になります:</p><ul><li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>終了したPod</a></li><li><a href=/ja/docs/concepts/workloads/controllers/ttlafterfinished/>完了したJob</a></li><li><a href=#owners-dependents>owner referenceのないオブジェクト</a></li><li><a href=#containers-images>未使用のコンテナとコンテナイメージ</a></li><li><a href=/ja/docs/concepts/storage/persistent-volumes/#delete>StorageClassの再利用ポリシーがDeleteである動的にプロビジョニングされたPersistentVolume</a></li><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process>失効または期限切れのCertificateSigningRequests (CSRs)</a></li><li>次のシナリオで削除された<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>:<ul><li>クラウド上でクラスターが<a href=/ja/docs/concepts/architecture/cloud-controller/>クラウドコントローラーマネージャー</a>を使用する場合</li><li>オンプレミスでクラスターがクラウドコントローラーマネージャーと同様のアドオンを使用する場合</li></ul></li><li><a href=/ja/docs/concepts/architecture/nodes/#heartbeats>Node Leaseオブジェクト</a></li></ul><h2 id=owners-dependents>オーナーの依存関係</h2><p>Kubernetesの多くのオブジェクトは、<a href=/docs/concepts/overview/working-with-objects/owners-dependents/><em>owner reference</em></a>を介して相互にリンクしています。
owner referenceは、どのオブジェクトが他のオブジェクトに依存しているかをコントロールプレーンに通知します。
Kubernetesは、owner referenceを使用して、コントロールプレーンやその他のAPIクライアントに、オブジェクトを削除する前に関連するリソースをクリーンアップする機会を提供します。
ほとんどの場合、Kubernetesはowner referenceを自動的に管理します。</p><p>Ownershipは、一部のリソースでも使用される<a href=/docs/concepts/overview/working-with-objects/labels/>ラベルおよびセレクター</a>メカニズムとは異なります。
たとえば、<code>EndpointSlice</code>オブジェクトを作成する<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を考えます。
Serviceは<em>ラベル</em>を使用して、コントロールプレーンがServiceに使用されている<code>EndpointSlice</code>オブジェクトを判別できるようにします。
ラベルに加えて、Serviceに代わって管理される各<code>EndpointSlice</code>には、owner referenceがあります。
owner referenceは、Kubernetesのさまざまな部分が制御していないオブジェクトへの干渉を回避するのに役立ちます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>namespace間のowner referenceは、設計上許可されていません。
namespaceの依存関係は、クラスタースコープまたはnamespaceのオーナーを指定できます。
namespaceのオーナーは、依存関係と同じnamespaceに<strong>存在する必要があります</strong>。
そうでない場合、owner referenceは不在として扱われ、すべてのオーナーが不在であることが確認されると、依存関係は削除される可能性があります。</p><p>クラスタースコープの依存関係は、クラスタースコープのオーナーのみを指定できます。
v1.20以降では、クラスタースコープの依存関係がnamespaceを持つkindをオーナーとして指定している場合、それは解決できないowner referenceを持つものとして扱われ、ガベージコレクションを行うことはできません。</p><p>V1.20以降では、ガベージコレクタは無効な名前空間間の<code>ownerReference</code>、またはnamespaceのkindを参照する<code>ownerReference</code>をもつクラスター・スコープの依存関係を検出した場合、無効な依存関係の<code>OwnerRefInvalidNamespace</code>と<code>involvedObject</code>を理由とする警告イベントが報告されます。
以下のコマンドを実行すると、そのようなイベントを確認できます。
<code>kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace</code></p></div><h2 id=cascading-deletion>カスケード削除</h2><p>Kubernetesは、ReplicaSetを削除したときに残されたPodなど、owner referenceがなくなったオブジェクトをチェックして削除します。
オブジェクトを削除する場合、カスケード削除と呼ばれるプロセスで、Kubernetesがオブジェクトの依存関係を自動的に削除するかどうかを制御できます。
カスケード削除には、次の2つのタイプがあります。</p><ul><li>フォアグラウンドカスケード削除</li><li>バックグラウンドカスケード削除</li></ul><p>また、Kubernetes <a class=glossary-tooltip title='A namespaced key that tells Kubernetes to wait until specific conditions are met before it fully deletes an object marked for deletion.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=finalizer>finalizer</a>を使用して、ガベージコレクションがowner referenceを持つリソースを削除する方法とタイミングを制御することもできます。</p><h3 id=foreground-deletion>フォアグラウンドカスケード削除</h3><p>フォアグラウンドカスケード削除では、削除するオーナーオブジェクトは最初に<em>削除進行中</em>の状態になります。
この状態では、オーナーオブジェクトに次のことが起こります。</p><ul><li>Kubernetes APIサーバーは、オブジェクトの<code>metadata.deletionTimestamp</code>フィールドを、オブジェクトに削除のマークが付けられた時刻に設定します。</li><li>Kubernetes APIサーバーは、<code>metadata.finalizers</code>フィールドを<code>foregroundDeletion</code>に設定します。</li><li>オブジェクトは、削除プロセスが完了するまで、KubernetesAPIを介して表示されたままになります。</li></ul><p>オーナーオブジェクトが削除進行中の状態に入ると、コントローラーは依存関係を削除します。
すべての依存関係オブジェクトを削除した後、コントローラーはオーナーオブジェクトを削除します。
この時点で、オブジェクトはKubernetesAPIに表示されなくなります。</p><p>フォアグラウンドカスケード削除中に、オーナーの削除をブロックする依存関係は、<code>ownerReference.blockOwnerDeletion=true</code>フィールドを持つ依存関係のみです。
詳細については、<a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-foreground-cascading-deletion>フォアグラウンドカスケード削除の使用</a>を参照してください。</p><h3 id=background-deletion>バックグラウンドカスケード削除</h3><p>バックグラウンドカスケード削除では、Kubernetes APIサーバーがオーナーオブジェクトをすぐに削除し、コントローラーがバックグラウンドで依存オブジェクトをクリーンアップします。
デフォルトでは、フォアグラウンド削除を手動で使用するか、依存オブジェクトを孤立させることを選択しない限り、Kubernetesはバックグラウンドカスケード削除を使用します。</p><p>詳細については、<a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-background-cascading-deletion>バックグラウンドカスケード削除の使用</a>を参照してください。</p><h3 id=孤立した依存関係>孤立した依存関係</h3><p>Kubernetesがオーナーオブジェクトを削除すると、残された依存関係は<em>orphan</em>オブジェクトと呼ばれます。
デフォルトでは、Kubernetesは依存関係オブジェクトを削除します。この動作をオーバーライドする方法については、<a href=/docs/tasks/administer-cluster/use-cascading-deletion/#set-orphan-deletion-policy>オーナーオブジェクトと孤立した依存関係の削除</a>を参照してください。</p><h2 id=containers-images>未使用のコンテナとイメージのガベージコレクション</h2><p><a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>は未使用のイメージに対して5分ごとに、未使用のコンテナーに対して1分ごとにガベージコレクションを実行します。
外部のガベージコレクションツールは、kubeletの動作を壊し、存在するはずのコンテナを削除する可能性があるため、使用しないでください。</p><p>未使用のコンテナーとイメージのガベージコレクションのオプションを設定するには、<a href=/docs/tasks/administer-cluster/kubelet-config-file/>設定ファイル</a>を使用してkubeletを調整し、<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration><code>KubeletConfiguration</code></a>リソースタイプを使用してガベージコレクションに関連するパラメーターを変更します。</p><h3 id=コンテナイメージのライフサイクル>コンテナイメージのライフサイクル</h3><p>Kubernetesは、kubeletの一部である<em>イメージマネージャー</em>を通じて、<a class=glossary-tooltip title='Tool that provides understanding of the resource usage and performance characteristics for containers' data-toggle=tooltip data-placement=top href=https://github.com/google/cadvisor/ target=_blank aria-label=cadvisor>cadvisor</a>の協力を得て、すべてのイメージのライフサイクルを管理します。kubeletは、ガベージコレクションを決定する際に、次のディスク使用制限を考慮します。</p><ul><li><code>HighThresholdPercent</code></li><li><code>LowThresholdPercent</code></li></ul><p>設定された<code>HighThresholdPercent</code>値を超えるディスク使用量はガベージコレクションをトリガーします。
ガベージコレクションは、最後に使用された時間に基づいて、最も古いものから順にイメージを削除します。
kubeletは、ディスク使用量が<code>LowThresholdPercent</code>値に達するまでイメージを削除します。</p><h3 id=container-image-garbage-collection>コンテナのガベージコレクション</h3><p>kubeletは、次の変数に基づいて未使用のコンテナをガベージコレクションします。</p><ul><li><code>MinAge</code>: kubeletがガベージコレクションできるコンテナの最低期間。<code>0</code>を設定すると無効化されます。</li><li><code>MaxPerPodContainer</code>: 各Podのペアが持つことができるデッドコンテナの最大数。<code>0</code>未満に設定すると無効化されます。</li><li><code>MaxContainers</code>: クラスターが持つことができるデッドコンテナーの最大数。<code>0</code>未満に設定すると無効化されます。</li></ul><p>これらの変数に加えて、kubeletは、通常、最も古いものから順に、定義されていない削除されたコンテナをガベージコレクションします。</p><p><code>MaxPerPodContainer</code>と<code>MaxContainers</code>は、Podごとのコンテナーの最大数(<code>MaxPerPodContainer</code>)を保持すると、グローバルなデッドコンテナの許容合計(<code>MaxContainers</code>)を超える状況で、互いに競合する可能性があります。
この状況では、kubeletは<code>MaxPerPodContainer</code>を調整して競合に対処します。最悪のシナリオは、<code>MaxPerPodContainer</code>を1にダウングレードし、最も古いコンテナーを削除することです。
さらに、削除されたPodが所有するコンテナは、<code>MinAge</code>より古くなると削除されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> kubeletがガベージコレクションするのは、自分が管理するコンテナのみです。</div><h2 id=configuring-gc>ガベージコレクションの設定</h2><p>これらのリソースを管理するコントローラーに固有のオプションを設定することにより、リソースのガベージコレクションを調整できます。次のページは、ガベージコレクションを設定する方法を示しています。</p><ul><li><a href=/docs/tasks/administer-cluster/use-cascading-deletion/>Kubernetesオブジェクトのカスケード削除の設定</a></li><li><a href=/ja/docs/concepts/workloads/controllers/ttlafterfinished/>完了したジョブのクリーンアップの設定</a></li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/concepts/overview/working-with-objects/owners-dependents/>Kubernetes オブジェクトの所有権</a>を学びます。</li><li>Kubernetes <a href=/docs/concepts/overview/working-with-objects/finalizers/>finalizer</a>を学びます。</li><li>完了したジョブをクリーンアップする<a href=/ja/docs/concepts/workloads/controllers/ttlafterfinished/>TTL controller</a>(beta)について学びます。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0ea5310f52e22c5de34dc84d9ab5e0d>2.6 - コンテナランタイムインターフェイス(CRI)</h1><p>CRIは、クラスターコンポーネントを再コンパイルすることなく、kubeletがさまざまなコンテナランタイムを使用できるようにするプラグインインターフェイスです。</p><p><a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>が<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>とそのコンテナを起動できるように、クラスター内の各ノードで動作する<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label='container runtime'>container runtime</a>が必要です。</p><p>kubeletとContainerRuntime間の通信のメインプロトコルです。</p><p>Kubernetes Container Runtime Interface(CRI)は、<a href=/ja/docs/concepts/overview/components/#node-components>クラスターコンポーネント</a><a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>と<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label='container runtime'>container runtime</a>間の通信用のメイン<a href=/ja/docs/concepts/overview/components/#node-components>gRPC</a>プロトコルを定義します。</p><h2 id=api>API</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code></div><p>kubeletは、gRPCを介してコンテナランタイムに接続するときにクライアントとして機能します。ランタイムおよびイメージサービスエンドポイントは、コンテナランタイムで使用可能である必要があります。コンテナランタイムは、<code>--image-service-endpoint</code>および<code>--container-runtime-endpoint</code><a href=/ja/docs/reference/command-line-tools-reference/kubelet>コマンドラインフラグ</a>を使用して、kubelet内で個別に設定できます。</p><p>Kubernetes v1.25の場合、kubeletはCRI <code>v1</code>の使用を優先します。
コンテナランタイムがCRIの<code>v1</code>をサポートしていない場合、kubeletはサポートされている古いバージョンのネゴシエーションを試みます。
kubelet v1.25はCRI <code>v1alpha2</code>をネゴシエートすることもできますが、このバージョンは非推奨と見なされます。
kubeletがサポートされているCRIバージョンをネゴシエートできない場合、kubeletはあきらめて、ノードとして登録されません。</p><h2 id=アップグレード>アップグレード</h2><p>Kubernetesをアップグレードする場合、kubeletはコンポーネントの再起動時に最新のCRIバージョンを自動的に選択しようとします。
それが失敗した場合、フォールバックは上記のように行われます。
コンテナランタイムがアップグレードされたためにgRPCリダイヤルが必要な場合は、コンテナランタイムも最初に選択されたバージョンをサポートする必要があります。
そうでない場合、リダイヤルは失敗することが予想されます。これには、kubeletの再起動が必要です。</p><h2 id=次の項目>次の項目</h2><ul><li>CRI<a href=https://github.com/kubernetes/cri-api/blob/c75ef5b/pkg/apis/runtime/v1/api.proto>プロトコル定義</a>の詳細を学ぶ。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>3 - コンテナ</h1><div class=lead>アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術</div><p>実行するそれぞれのコンテナは繰り返し使用可能です。依存関係を含めて標準化されており、どこで実行しても同じ動作が得られることを意味しています。</p><p>コンテナは基盤となるホストインフラからアプリケーションを切り離します。これにより、さまざまなクラウドやOS環境下でのデプロイが容易になります。</p><h2 id=container-images>コンテナイメージ</h2><p><a href=/ja/docs/concepts/containers/images/>コンテナイメージ</a>はすぐに実行可能なソフトウェアパッケージで、アプリケーションの実行に必要なものをすべて含んています。コードと必要なランタイム、アプリケーションとシステムのライブラリ、そして必須な設定項目のデフォルト値を含みます。</p><p>設計上、コンテナは不変で、既に実行中のコンテナのコードを変更することはできません。コンテナ化されたアプリケーションがあり変更したい場合は、変更を含んだ新しいイメージをビルドし、コンテナを再作成して、更新されたイメージから起動する必要があります。</p><h2 id=コンテナランタイム>コンテナランタイム</h2><p>コンテナランタイムは、コンテナの実行を担当するソフトウェアです。</p><p>Kubernetesは次の複数のコンテナランタイムをサポートします。
<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>、<a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>、<a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>、
および全ての
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>
実装です。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/concepts/containers/images/>コンテナイメージ</a>についてお読みください。</li><li><a href=/ja/docs/concepts/workloads/pods/>Pod</a>についてお読みください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-8fda96dc403731ceba5e0ddd0ab3ad15>3.1 - コンテナの概要</h1><p>コンテナは、アプリケーションの(コンパイルされた)コードと、実行時に必要な依存関係をパッケージ化するための技術です。実行する各コンテナは再現性があります。依存関係を含めることによる標準化は、どこで実行しても同じ動作が得られることを意味します。</p><p>コンテナは、基礎となるホストインフラストラクチャからアプリケーションを切り離します。これにより、さまざまなクラウド環境やOS環境でのデプロイが容易になります。</p><h2 id=container-images>コンテナイメージ</h2><p><a href=/docs/concepts/containers/images/>コンテナイメージ</a>は、アプリケーションを実行するために必要なすべてのものを含んだ、すぐに実行可能なソフトウェアパッケージです。コードとそれが必要とする任意のランタイム、アプリケーションとシステムのライブラリ、および必須の設定のデフォルト値が含まれています。</p><p>設計上、コンテナは不変であるため、すでに実行中のコンテナのコードを変更することはできません。コンテナ化されたアプリケーションがあり、変更を加えたい場合は、変更を含む新しいコンテナをビルドし、コンテナを再作成して更新されたイメージから起動する必要があります。</p><h2 id=container-runtimes>コンテナランタイム</h2><p>コンテナランタイムは、コンテナの実行を担当するソフトウェアです。</p><p>Kubernetesは次の複数のコンテナランタイムをサポートします。
<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>、<a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>、<a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>、
および全ての
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>
実装です。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/concepts/containers/images/>コンテナイメージ</a>についてお読みください。</li><li><a href=/ja/docs/concepts/workloads/pods/>Pod</a>についてお読みください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-16042b4652ad19e565c7263824029a43>3.2 - イメージ</h1><p>コンテナイメージはアプリケーションと依存関係のあるすべてソフトウェアをカプセル化したバイナリデータを表します。コンテナイメージはスタンドアロンで実行可能なソフトウェアをひとつにまとめ、ランタイム環境に関する想定を明確に定義しています。</p><p>アプリケーションのコンテナイメージを作成し、一般的には<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>で参照する前にレジストリへPushします。</p><p>このページではコンテナイメージの概要を説明します。</p><h2 id=イメージの名称>イメージの名称</h2><p>コンテナイメージは、<code>pause</code>、<code>example/mycontainer</code>、または<code>kube-apiserver</code>のような名前が通常つけられます。
イメージにはレジストリのホスト名も含めることができ(例：<code>fictional.registry.example/imagename</code>)、さらにポート番号も含めることが可能です(例：<code>fictional.registry.example:10443/imagename</code>)。</p><p>レジストリのホスト名を指定しない場合は、KubernetesはDockerパブリックレジストリを意味していると見なします。</p><p>イメージ名の後に、<em>タグ</em> を追加することができます(<code>docker</code>や<code>podman</code>のようなコマンドを利用した場合と同様)。
タグによって同じイメージの異なるバージョンを識別できます。</p><p>イメージタグは大文字と小文字、数値、アンダースコア(<code>_</code>)、ピリオド(<code>.</code>)とマイナス(<code>-</code>)で構成されます。
イメージタグでは区切り記号(<code>_</code>、<code>-</code>、<code>.</code>)を指定できる追加ルールがあります。
タグを指定しない場合は、Kubernetesは<code>latest</code>タグを指定したと見なします。</p><h2 id=イメージの更新>イメージの更新</h2><p><a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>、<a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>、Pod、またはPodテンプレートを含むその他のオブジェクトを最初に作成するとき、デフォルトでは、Pod内のすべてのコンテナのPullポリシーは、明示的に指定されていない場合、<code>IfNotPresent</code>に設定されます。</p><p>イメージがすでに存在する場合、このポリシーは<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>にイメージのPullをスキップさせます。</p><h3 id=イメージpullポリシー>イメージPullポリシー</h3><p>コンテナの<code>imagePullPolicy</code>とイメージのタグは、<a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>が指定されたイメージをPull(ダウンロード)しようとする時に影響します。</p><p>以下は、<code>imagePullPolicy</code>に設定できる値とその効果の一覧です。</p><dl><dt><code>IfNotPresent</code></dt><dd>イメージがローカルにまだ存在しない場合のみ、イメージがPullされます。</dd><dt><code>Always</code></dt><dd>kubeletがコンテナを起動するときは常にコンテナイメージレジストリに照会して、イメージ名をイメージ<a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>ダイジェスト</a>に解決します。
ローカルにキャッシュされた同一ダイジェストのコンテナイメージがあった場合、kubeletはキャッシュされたイメージを使用します。
そうでない場合、kubeletは解決されたダイジェストのイメージをPullし、そのイメージを使ってコンテナを起動します。</dd><dt><code>Never</code></dt><dd>kubeletは、イメージを取得しようとしません。ローカルにイメージがすでに存在する場合、kubeletはコンテナを起動しようとします。それ以外の場合、起動に失敗します。
詳細は、<a href=#pre-pulled-images>事前にPullしたイメージ</a>を参照してください。</dd></dl><p>レジストリに確実にアクセスできるのであれば、基盤となるイメージプロバイダーのキャッシュセマンティクスにより<code>imagePullPolicy: Always</code>でも効率的です。
コンテナランタイムは、イメージレイヤーが既にノード上に存在することを認識できるので、再度ダウンロードする必要がありません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>本番環境でコンテナをデプロイする場合は、<code>:latest</code>タグの使用を避けるべきです。
実行中のイメージのバージョンを追跡するのが難しく、正しくロールバックすることがより困難になるためです。</p><p>かわりに、<code>v1.42.0</code>のような特定できるタグを指定してください。</p></div><p>Podがいつも同じバージョンのコンテナイメージを使用するために、イメージのダイジェストを指定することができます。<code>&lt;image-name>:&lt;tag></code>を<code>&lt;image-name>@&lt;digest></code>に置き換えてください(例えば、<code>image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>)。</p><p>イメージタグを使用する場合、イメージレジストリがそのイメージのタグが表すコードを変更すると、新旧のコードを実行するPodが混在することになるかもしれません。
イメージダイジェストは特定のバージョンのイメージを一意に識別するため、Kubernetesは特定のイメージ名とダイジェストが指定されたコンテナを起動するたびに同じコードを実行します。
イメージをダイジェストで指定することは、レジストリの変更でそのようなバージョンの混在を起こさないように、実行するコードを固定します。</p><p>Pod(およびPodテンプレート)を作成する時に、実行中のワークロードがタグではなくイメージダイジェストに基づき定義されるように変化させるサードパーティーの<a href=/docs/reference/access-authn-authz/admission-controllers/>アドミッションコントローラー</a>があります。
レジストリでどのようなタグの変更があっても、すべてのワークロードが必ず同じコードを実行するようにしたい場合に役立ちます。</p><h4 id=imagepullpolicy-defaulting>デフォルトのイメージPullポリシー</h4><p>新しいPodがAPIサーバに送信されると、クラスターは特定の条件が満たされたときに<code>imagePullPolicy</code>フィールドを設定します。</p><ul><li><code>imagePullPolicy</code>フィールドを省略し、コンテナイメージのタグに<code>:latest</code>を指定した場合、<code>imagePullPolicy</code>には自動的に<code>Always</code>が設定される</li><li><code>imagePullPolicy</code>フィールドを省略し、コンテナイメージのタグを指定しなかった場合、<code>imagePullPolicy</code>には自動的に<code>Always</code>が設定される</li><li><code>imagePullPolicy</code>フィールドを省略し、コンテナイメージのタグに<code>:latest</code>以外を指定した場合、<code>imagePullPolicy</code>には自動的に<code>IfNotPresent</code>が設定される</li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>コンテナの<code>imagePullPolicy</code>の値は、そのオブジェクトが最初に <em>作成</em> されたときに常に設定され、イメージのタグが後で変更された場合でも更新されません。</p><p>例えば、タグが<code>:latest</code> <em>でない</em> イメージを使ってDeploymentを生成した場合、後でDeploymentのイメージを<code>:latest</code>タグに変更しても、<code>imagePullPolicy</code>は<code>Always</code>に更新されません。オブジェクトのPullポリシーは、初期作成後に手動で変更する必要があります。</p></div><h4 id=必要なイメージをpullする>必要なイメージをPullする</h4><p>常に強制的にPullしたい場合は、以下のいずれかを行ってください。</p><ul><li>コンテナの<code>imagePullPolicy</code>に<code>Always</code>を設定する。</li><li><code>imagePullPolicy</code>を省略し、使用するイメージに<code>:latest</code>タグ使用する。Pod生成時に、Kubernetesがポリシーに<code>Always</code>を設定する。</li><li><code>imagePullPolicy</code>と使用するイメージのタグを省略する。Pod生成時に、Kubernetesがポリシーに<code>Always</code>を設定する。</li><li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a>アドミッションコントローラーを有効にする。</li></ul><h3 id=imagepullbackoff>ImagePullBackOff</h3><p>kubeletがコンテナランタイムを使ってPodのコンテナの生成を開始するとき、<code>ImagePullBackOff</code>のためにコンテナが<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#container-state-waiting>Waiting</a>状態になる可能性があります。</p><p><code>ImagePullBackOff</code>ステータスは、KubernetesがコンテナイメージをPullできないために、コンテナを開始できないことを意味します(イメージ名が無効である、<code>imagePullSecret</code>なしでプライベートレジストリからPullしたなどの理由のため)。<code>BackOff</code>は、バックオフの遅延を増加させながらKubernetesがイメージをPullしようとし続けることを示します。</p><p>Kubernetesは、組み込まれた制限である300秒(5分)に達するまで、試行するごとに遅延を増加させます。</p><h2 id=イメージインデックスを使ったマルチアーキテクチャイメージ>イメージインデックスを使ったマルチアーキテクチャイメージ</h2><p>コンテナレジストリはバイナリイメージの提供だけでなく、<a href=https://github.com/opencontainers/image-spec/blob/master/image-index.md>コンテナイメージインデックス</a>も提供する事ができます。イメージインデックスはコンテナのアーキテクチャ固有バージョンに関する複数の<a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>イメージマニフェスト</a>を指すことができます。イメージインデックスの目的はイメージの名前(例:<code>pause</code>、<code>example/mycontainer</code>、<code>kube-apiserver</code>)をもたせ、様々なシステムが使用しているマシンアーキテクチャにあう適切なバイナリイメージを取得できることです。</p><p>Kubernetes自身は、通常コンテナイメージに<code>-$(ARCH)</code>のサフィックスを持つ名前をつけます。下位互換の為にサフィックス付きの古い仕様のイメージを生成してください。その目的は、<code>pause</code>のようなすべてのアーキテクチャのマニフェストを持つイメージと、サフィックスのあるイメージをハードコードしていた可能性のある古い仕様の設定やYAMLファイルと下位互換がある<code>pause-amd64</code>のようなイメージを生成することです。</p><h2 id=プライベートレジストリを使用する方法>プライベートレジストリを使用する方法</h2><p>プライベートレジストリではイメージを読み込む為にキーが必要になる場合があります。<br>認証情報はいくつかの方法で提供できます。</p><ul><li>プライベートレジストリへの認証をNodeに設定する<ul><li>すべてのPodがプライベートレジストリを読み取ることができる</li><li>クラスター管理者によるNodeの設定が必要</li></ul></li><li>事前にPullされたイメージ<ul><li>すべてのPodがNode上にキャッシュされたイメージを利用できる</li><li>セットアップするためにはすべてのNodeに対するrootアクセスが必要</li></ul></li><li>PodでImagePullSecretsを指定する<ul><li>キーを提供したPodのみがプライベートレジストリへアクセスできる</li></ul></li><li>ベンダー固有またはローカルエクステンション<ul><li>カスタムNode構成を使っている場合、あなた(または、あなたのクラウドプロバイダー)はコンテナレジストリへの認証の仕組みを組み込むことができる</li></ul></li></ul><p>これらのオプションについて、以下で詳しく説明します。</p><h3 id=プライベートレジストリへの認証をnodeに設定する>プライベートレジストリへの認証をNodeに設定する</h3><p>認証情報を設定するための具体的な手順は、使用するコンテナランタイムとレジストリに依存します。最も正確な情報として、ソリューションのドキュメントを参照する必要があります。</p><p>プライベートなコンテナイメージレジストリを設定する例として、<a href=/docs/tasks/configure-pod-container/pull-image-private-registry>プライベートレジストリからイメージをPullする</a>タスクを参照してください。その例では、Docker Hubのプライベートレジストリを使用しています。</p><h3 id=config-json>config.jsonの解釈</h3><p><code>config.json</code>の解釈は、Dockerのオリジナルの実装とKubernetesの解釈で異なります。
Dockerでは、<code>auths</code>キーはルートURLしか指定できませんが、Kubernetesではプレフィックスのマッチしたパスだけでなく、グロブパターンのURLも指定できます。
以下のような<code>config.json</code>が有効であるということです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;*my-registry.io/images&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;…&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ルートURL(<code>*my-registry.io</code>)は、以下の構文でマッチングされます:</p><pre tabindex=0><code>pattern:
    { term }

term:
    &#39;*&#39;         セパレーター以外の任意の文字列にマッチする
    &#39;?&#39;         セパレーター以外の任意の一文字にマッチする
    &#39;[&#39; [ &#39;^&#39; ] { character-range } &#39;]&#39;
                文字クラス (空であってはならない)
    c           文字 c とマッチする (c != &#39;*&#39;, &#39;?&#39;, &#39;\\&#39;, &#39;[&#39;)
    &#39;\\&#39; c      文字 c とマッチする

character-range:
    c           文字 c とマッチする (c != &#39;\\&#39;, &#39;-&#39;, &#39;]&#39;)
    &#39;\\&#39; c      文字 c とマッチする
    lo &#39;-&#39; hi   lo &lt;= c &lt;= hi の文字 c とマッチする
</code></pre><p>イメージのPull操作では、有効なパターンごとに認証情報をCRIコンテナランタイムに渡すようになりました。例えば、以下のようなコンテナイメージ名は正常にマッチングされます。</p><ul><li><code>my-registry.io/images</code></li><li><code>my-registry.io/images/my-image</code></li><li><code>my-registry.io/images/another-image</code></li><li><code>sub.my-registry.io/images/my-image</code></li><li><code>a.sub.my-registry.io/images/my-image</code></li></ul><p>kubeletは、見つかったすべての認証情報に対してイメージのPullを順次実行します。これは、次のように<code>config.json</code>に複数のエントリーを書くことも可能であることを意味します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;my-registry.io/images&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;…&#34;</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;my-registry.io/images/subpath&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;…&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>コンテナが<code>my-registry.io/images/subpath/my-image</code>をPullするイメージとして指定した場合、kubeletが認証ソースの片方からダウンロードに失敗すると、両方の認証ソースからダウンロードを試みます。</p><h3 id=pre-pulled-images>事前にPullしたイメージ</h3><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Node構成を制御できる場合、この方法が適しています。
クラウドプロバイダーがNodeを管理し自動的に設定を置き換える場合は、確実に機能できません。</div><p>デフォルトでは、kubeletは指定されたレジストリからそれぞれのイメージをPullしようとします。
また一方では、コンテナの<code>imagePullPolicy</code>プロパティに<code>IfNotPresent</code>や<code>Never</code>が設定されている場合、ローカルのイメージが使用されます。(それぞれに対して、優先的またはか排他的に)</p><p>レジストリ認証の代替として事前にPullしたイメージを利用したい場合、クラスターのすべてのNodeが同じ事前にPullしたイメージを持っていることを確認する必要があります。</p><p>特定のイメージをあらかじめロードしておくことは高速化やプライベートレジストリへの認証の代替として利用することができます。</p><p>すべてのPodは事前にPullしたイメージへの読み取りアクセス権をもちます。</p><h3 id=podでimagepullsecretsを指定する>PodでimagePullSecretsを指定する</h3><div class="alert alert-info note callout" role=alert><strong>備考:</strong> この方法がプライベートレジストリのイメージに基づいてコンテナを実行するための推奨の方法です。</div><p>KubernetesはPodでのコンテナイメージレジストリキーの指定をサポートしています。</p><h4 id=dockerの設定を利用してsecretを作成する>Dockerの設定を利用してSecretを作成する。</h4><p>レジストリへの認証のためにユーザー名、レジストリのパスワード、クライアントのメールアドレス、およびそのホスト名を知っている必要があります。</p><p>適切な大文字の値を置き換えて、次のコマンドを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</span></span></code></pre></div><p>既にDocker認証情報ファイルを持っている場合は、上記のコマンドの代わりに、認証情報ファイルをKubernetes <a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secrets>Secrets</a>としてインポートすることができます。
<a href=/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>既存のDocker認証情報に基づいてSecretを作成する</a> で、この設定方法を説明します.</p><p>これは複数のプライベートコンテナレジストリを使用している場合に特に有効です。<code>kubectl create secret docker-registry</code>はひとつのプライベートレジストリにのみ機能するSecretを作成するからです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Podは自分自身のNamespace内にあるimage pull secretsのみが参照可能であるため、この作業はNemespace毎に1回行う必要があります。</div><h4 id=podのimagepullsecretsを参照する方法>PodのimagePullSecretsを参照する方法</h4><p>これで、<code>imagePullSecrets</code>セクションをPod定義へ追加することでSecretを参照するPodを作成できます。</p><p>例:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>  namespace: awesomeapps
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  imagePullSecrets:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: myregistrykey
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>これは、プライベートレジストリを使用する各Podで行う必要があります。</p><p>ただし、この項目の設定は<a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>リソースの中でimagePullSecretsを指定することで自動化することができます。</p><p>詳細の手順は、<a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>ImagePullSecretsをService Accountに追加する</a>をクリックしてください。</p><p>これを各Nodeの<code>.docker/config.json</code>に組み合わせて利用できます。認証情報はマージされます。</p><h2 id=ユースケース>ユースケース</h2><p>プライベートレジストリを設定するためのソリューションはいくつかあります。ここでは、いくつかの一般的なユースケースと推奨される解決方法を示します。</p><ol><li>クラスターに独自仕様でない(例えば、オープンソース)イメージだけを実行する。イメージを非公開にする必要がない<ul><li>パブリックレジストリのパブリックイメージを利用する<ul><li>設定は必要ない</li><li>クラウドプロバイダーによっては、可用性の向上とイメージをPullする時間を短くする為に、自動的にキャッシュやミラーされたパプリックイメージが提供される</li></ul></li></ul></li><li>社外には非公開の必要があるが、すべてのクラスター利用者には見せてよい独自仕様のイメージをクラスターで実行している<ul><li>ホストされたプライペートレジストリを使用<ul><li>プライベートレジストリにアクセスする必要があるノードには、手動設定が必要となる場合がある</li></ul></li><li>または、オープンな読み取りアクセスを許可したファイヤーウォールの背後で内部向けプライベートレジストリを実行する<ul><li>Kubernetesの設定は必要ない</li></ul></li><li>イメージへのアクセスを制御できるホストされたコンテナイメージレジストリサービスを利用する<ul><li>Nodeを手動設定するよりもクラスターのオートスケーリングのほうがうまく機能する</li></ul></li><li>また、Node設定変更を自由にできないクラスターでは<code>imagePullSecrets</code>を使用する</li></ul></li><li>独自仕様のイメージを含むクラスターで、いくつかは厳格なアクセス制御が必要である<ul><li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImagesアドミッションコントローラー</a>が有効化かを確認する必要がある。さもないと、全部のPodがすべてのイメージへのアクセスができてしまう可能性がある</li><li>機密データはイメージに含めてしまうのではなく、"Secret"リソースに移行する</li></ul></li><li>それぞれのテナントが独自のプライベートレジストリを必要とするマルチテナントのクラスターである<ul><li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImagesアドミッションコントローラー</a>が有効化を確認する必要がある。さもないと、すべてのテナントの全Podが全部のイメージにアクセスできてしまう可能性がある</li><li>認証が必要なプライベートレジストリを実行する</li><li>それぞれのテナントでレジストリ認証を生成し、Secretへ設定し、各テナントのNamespaceに追加する</li><li>テナントは、Secretを各NamespaceのimagePullSecretsへ追加する</li></ul></li></ol><p>複数のレジストリへのアクセスが必要な場合、それぞれのレジストリ毎にひとつのSecretを作成する事ができます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>OCI Image Manifest Specification</a>を読む</li><li><a href=/ja/docs/concepts/architecture/garbage-collection/#container-image-garbage-collection>コンテナのガベージコレクション</a>について学ぶ</li><li><a href=/docs/tasks/configure-pod-container/pull-image-private-registry>pulling an Image from a Private Registry</a>について学ぶ</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-643212488f778acf04bebed65ba34441>3.3 - コンテナ環境</h1><p>このページでは、コンテナ環境で利用可能なリソースについて説明します。</p><h2 id=コンテナ環境>コンテナ環境</h2><p>Kubernetesはコンテナにいくつかの重要なリソースを提供します。</p><ul><li>イメージと1つ以上のボリュームの組み合わせのファイルシステム</li><li>コンテナ自体に関する情報</li><li>クラスター内の他のオブジェクトに関する情報</li></ul><h3 id=コンテナ情報>コンテナ情報</h3><p>コンテナの <em>ホスト名</em> は、コンテナが実行されているPodの名前です。
ホスト名は<code>hostname</code>コマンドまたはlibcの<a href=http://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a>関数呼び出しにより利用可能です。</p><p>Podの名前と名前空間は<a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>downward API</a>を通じて環境変数として利用可能です。</p><p>Pod定義からのユーザー定義の環境変数もコンテナで利用できます。
コンテナイメージで静的に指定されている環境変数も同様です。</p><h3 id=クラスター情報>クラスター情報</h3><p>コンテナの作成時に実行されていたすべてのサービスのリストは、環境変数として使用できます。
このリストは、新しいコンテナのPodおよびKubernetesコントロールプレーンサービスと同じ名前空間のサービスに制限されます。</p><p><em>bar</em> という名前のコンテナに対応する <em>foo</em> という名前のサービスの場合、以下の変数が定義されています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;サービスが実行されているホスト&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;サービスが実行されているポート&gt;
</span></span></code></pre></div><p>サービスは専用のIPアドレスを持ち、<a href=http://releases.k8s.io/v1.25.0/cluster/addons/dns/>DNSアドオン</a>が有効の場合、DNSを介してコンテナで利用可能です。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/containers/container-lifecycle-hooks/>コンテナライフサイクルフック</a>の詳細</li><li><a href=/ja/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>コンテナライフサイクルイベントへのハンドラー紐付け</a>のハンズオン</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a858027489648786a3b16264e451272b>3.4 - ランタイムクラス(Runtime Class)</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code></div><p>このページではRuntimeClassリソースと、runtimeセクションのメカニズムについて説明します。</p><p>RuntimeClassはコンテナランタイムの設定を選択するための機能です。そのコンテナランタイム設定はPodのコンテナを稼働させるために使われます。</p><h2 id=runtimeclassを使う動機>RuntimeClassを使う動機</h2><p>異なるPodに異なるRuntimeClassを設定することで、パフォーマンスとセキュリティのバランスをとることができます。例えば、ワークロードの一部に高レベルの情報セキュリティ保証が必要な場合、ハードウェア仮想化を使用するコンテナランタイムで実行されるようにそれらのPodをスケジュールすることを選択できます。その後、追加のオーバーヘッドを犠牲にして、代替ランタイムをさらに分離することでメリットが得られます。</p><p>RuntimeClassを使用して、コンテナランタイムは同じで設定が異なるPodを実行することもできます。</p><h2 id=セットアップ>セットアップ</h2><ol><li>ノード上でCRI実装を設定する。(ランタイムに依存)</li><li>対応するRuntimeClassリソースを作成する。</li></ol><h3 id=1-ノード上でcri実装を設定する>1. ノード上でCRI実装を設定する</h3><p>RuntimeClassを通じて利用可能な設定はContainer Runtime Interface (CRI)の実装依存となります。
ユーザーの環境のCRI実装の設定方法は、対応するドキュメント(<a href=#cri-configuration>下記</a>)を参照ください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> RuntimeClassは、クラスター全体で同じ種類のノード設定であることを仮定しています。(これは全てのノードがコンテナランタイムに関して同じ方法で構成されていることを意味します)。
設定が異なるノードをサポートするには、<a href=#scheduling>スケジューリング</a>を参照してください。</div><p>RuntimeClassの設定は、RuntimeClassによって参照される<code>ハンドラー</code>名を持ちます。そのハンドラーは有効な<a href=/ja/docs/concepts/overview/working-with-objects/names/#dns-label-names>DNSラベル名</a>でなくてはなりません。</p><h3 id=2-対応するruntimeclassリソースを作成する>2. 対応するRuntimeClassリソースを作成する</h3><p>ステップ1にて設定する各項目は、関連する<code>ハンドラー</code> 名を持ちます。それはどの設定かを指定するものです。各ハンドラーにおいて、対応するRuntimeClassオブジェクトが作成されます。</p><p>そのRuntimeClassリソースは現時点で2つの重要なフィールドを持ちます。それはRuntimeClassの名前(<code>metadata.name</code>)とハンドラー(<code>handler</code>)です。そのオブジェクトの定義は下記のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># RuntimeClassはnode.k8s.ioというAPIグループで定義されます。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RuntimeClass名</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RuntimeClassはネームスペースなしのリソースです。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 対応するCRI設定</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>myconfiguration<span style=color:#bbb>
</span></span></span></code></pre></div><p>RuntimeClassオブジェクトの名前は<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>に従う必要があります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> RuntimeClassの書き込み操作(create/update/patch/delete)はクラスター管理者のみに制限されることを推奨します。
これはたいていデフォルトで有効となっています。さらなる詳細に関しては<a href=/docs/reference/access-authn-authz/authorization/>Authorization
Overview</a>を参照してください。</div><h2 id=使用例>使用例</h2><p>RuntimeClassがクラスターに対して設定されると、PodSpecで<code>runtimeClassName</code>を指定して使用できます。
例えば</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>これは、kubeletに対してPodを稼働させるためのRuntimeClassを使うように指示します。もし設定されたRuntimeClassが存在しない場合や、CRIが対応するハンドラーを実行できない場合、そのPodは<code>Failed</code>という<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>フェーズ</a>になります。
エラーメッセージに関しては対応する<a href=/docs/tasks/debug/debug-application/debug-running-pod/>イベント</a>を参照して下さい。</p><p>もし<code>runtimeClassName</code>が指定されていない場合、デフォルトのRuntimeHandlerが使用され、これはRuntimeClassの機能が無効であるときのふるまいと同じものとなります。</p><h3 id=cri-configuration>CRIの設定</h3><p>CRIランタイムのセットアップに関するさらなる詳細は、<a href=/docs/setup/cri/>CRIのインストール</a>を参照してください。</p><h4 id=hahahugoshortcode-s3-hbhb><a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a></h4><p>ランタイムハンドラーは、<code>/etc/containerd/config.toml</code>にあるcontainerdの設定ファイルにより設定されます。
正しいハンドラーは、その<code>runtime</code>セクションで設定されます。</p><pre tabindex=0><code>[plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes.${HANDLER_NAME}]
</code></pre><p>詳細はcontainerdの<a href=https://github.com/containerd/containerd/blob/main/docs/cri/config.md>設定に関するドキュメント</a>を参照してください。</p><h4 id=hahahugoshortcode-s4-hbhb><a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a></h4><p>ランタイムハンドラーは、<code>/etc/crio/crio.conf</code>にあるCRI-Oの設定ファイルにより設定されます。
正しいハンドラーは<a href=https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md#crioruntime-table>crio.runtime
table</a>で設定されます。</p><pre tabindex=0><code>[crio.runtime.runtimes.${HANDLER_NAME}]
  runtime_path = &#34;${PATH_TO_BINARY}&#34;
</code></pre><p>詳細はCRI-Oの<a href=https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md>設定に関するドキュメント</a>を参照してください。</p><h2 id=scheduling>スケジューリング</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code></div><p>RuntimeClassの<code>scheduling</code>フィールドを指定することで、設定されたRuntimeClassをサポートするノードにPodがスケジューリングされるように制限することができます。
<code>scheduling</code>が設定されていない場合、このRuntimeClassはすべてのノードでサポートされていると仮定されます。</p><p>特定のRuntimeClassをサポートしているノードへPodが配置されることを保証するために、各ノードは<code>runtimeclass.scheduling.nodeSelector</code>フィールドによって選択される共通のラベルを持つべきです。
RuntimeClassのnodeSelectorはアドミッション機能によりPodのnodeSelectorに統合され、効率よくノードを選択します。
もし設定が衝突した場合は、Pod作成は拒否されるでしょう。</p><p>もしサポートされているノードが他のRuntimeClassのPodが稼働しないようにtaint付与されていた場合、RuntimeClassに対して<code>tolerations</code>を付与することができます。
<code>nodeSelector</code>と同様に、tolerationsはPodのtolerationsにアドミッション機能によって統合され、効率よく許容されたノードを選択します。</p><p>ノードの選択とtolerationsについての詳細は<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>ノード上へのPodのスケジューリング</a>を参照してください。</p><h3 id=podオーバーヘッド>Podオーバーヘッド</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [stable]</code></div><p>Podが稼働する時に関連する <em>オーバーヘッド</em> リソースを指定できます。オーバーヘッドを宣言すると、クラスター(スケジューラーを含む)がPodとリソースに関する決定を行うときにオーバーヘッドを考慮することができます。</p><p>PodのオーバーヘッドはRuntimeClass内の<code>overhead</code>フィールドによって定義されます。
このフィールドを使用することで、RuntimeClassを使用して稼働するPodのオーバーヘッドを指定することができ、Kubernetes内部で使用されるオーバーヘッドを確保することができます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md>RuntimeClassデザイン</a></li><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md#runtimeclass-scheduling>RuntimeClassスケジューリングデザイン</a></li><li><a href=/docs/concepts/scheduling-eviction/pod-overhead/>Podオーバーヘッド</a>のコンセプトを読む</li><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/688-pod-overhead>PodOverhead機能デザイン</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e6941d969d81540208a3e78bc56f43bc>3.5 - コンテナライフサイクルフック</h1><p>このページでは、kubeletにより管理されるコンテナがコンテナライフサイクルフックフレームワークを使用して、管理ライフサイクル中にイベントによって引き起こされたコードを実行する方法について説明します。</p><h2 id=概要>概要</h2><p>Angularなどのコンポーネントライフサイクルフックを持つ多くのプログラミング言語フレームワークと同様に、Kubernetesはコンテナにライフサイクルフックを提供します。
フックにより、コンテナは管理ライフサイクル内のイベントを認識し、対応するライフサイクルフックが実行されたときにハンドラーに実装されたコードを実行できます。</p><h2 id=コンテナフック>コンテナフック</h2><p>コンテナに公開されている2つのフックがあります。</p><p><code>PostStart</code></p><p>このフックはコンテナが作成された直後に実行されます。
しかし、フックがコンテナのENTRYPOINTの前に実行されるという保証はありません。
ハンドラーにパラメーターは渡されません。</p><p><code>PreStop</code></p><p>このフックは、APIからの要求、またはliveness/startup probeの失敗、プリエンプション、リソース競合などの管理イベントが原因でコンテナが終了する直前に呼び出されます。コンテナがすでに終了状態または完了状態にある場合には<code>PreStop</code>フックの呼び出しは失敗し、コンテナを停止するTERMシグナルが送信される前にフックは完了する必要があります。<code>PreStop</code>フックが実行される前にPodの終了猶予期間のカウントダウンが開始されるので、ハンドラーの結果に関わらず、コンテナはPodの終了猶予期間内に最終的に終了します。
ハンドラーにパラメーターは渡されません。</p><p>終了動作の詳細な説明は、<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>Termination of Pods</a>にあります。</p><h3 id=フックハンドラーの実装>フックハンドラーの実装</h3><p>コンテナは、フックのハンドラーを実装して登録することでそのフックにアクセスできます。
コンテナに実装できるフックハンドラーは2種類あります。</p><ul><li>Exec - コンテナのcgroupsと名前空間の中で、 <code>pre-stop.sh</code>のような特定のコマンドを実行します。
コマンドによって消費されたリソースはコンテナに対してカウントされます。</li><li>HTTP - コンテナ上の特定のエンドポイントに対してHTTP要求を実行します。</li></ul><h3 id=フックハンドラーの実行>フックハンドラーの実行</h3><p>コンテナライフサイクル管理フックが呼び出されると、Kubernetes管理システムはフックアクションにしたがってハンドラーを実行します。
<code>httpGet</code>と<code>tcpSocket</code>はkubeletプロセスによって実行され、<code>exec</code>はコンテナの中で実行されます。</p><p>フックハンドラーの呼び出しは、コンテナを含むPodのコンテキスト内で同期しています。
これは、<code>PostStart</code>フックの場合、コンテナのENTRYPOINTとフックは非同期に起動することを意味します。
しかし、フックの実行に時間がかかりすぎたりハングしたりすると、コンテナは<code>running</code>状態になることができません。</p><p><code>PreStop</code>フックはコンテナを停止するシグナルから非同期で実行されるのではなく、TERMシグナルが送られる前に実行を完了する必要があります。
もし<code>PreStop</code>フックが実行中にハングした場合、Podは<code>Terminating</code>状態になり、
<code>terminationGracePeriodSeconds</code>の時間切れで強制終了されるまで続きます。
この猶予時間は、<code>PreStop</code>フックが実行され正常にコンテナを停止できるまでの合計時間に適用されます。
例えば<code>terminationGracePeriodSeconds</code>が60で、フックの終了に55秒かかり、シグナルを受信した後にコンテナを正常に停止させるのに10秒かかる場合、コンテナは正常に停止する前に終了されてしまいます。<code>terminationGracePeriodSeconds</code>が、これら2つの実行にかかる合計時間(55+10)よりも短いからです。</p><p><code>PostStart</code>または<code>PreStop</code>フックが失敗した場合、コンテナは強制終了します。</p><p>ユーザーはフックハンドラーをできるだけ軽量にするべきです。
ただし、コンテナを停止する前に状態を保存するなどの場合は、長時間のコマンド実行が必要なケースもあります。</p><h3 id=フック配信保証>フック配信保証</h3><p>フックの配信は <em>少なくとも1回</em> を意図しています。これはフックが<code>PostStart</code>や<code>PreStop</code>のような任意のイベントに対して複数回呼ばれることがあることを意味します。
これを正しく処理するのはフックの実装次第です。</p><p>通常、1回の配信のみが行われます。
たとえば、HTTPフックレシーバーがダウンしていてトラフィックを受け取れない場合、再送信は試みられません。
ただし、まれに二重配信が発生することがあります。
たとえば、フックの送信中にkubeletが再起動した場合、kubeletが起動した後にフックが再送信される可能性があります。</p><h3 id=フックハンドラーのデバッグ>フックハンドラーのデバッグ</h3><p>フックハンドラーのログは、Podのイベントには表示されません。
ハンドラーが何らかの理由で失敗した場合は、イベントをブロードキャストします。
<code>PostStart</code>の場合、これは<code>FailedPostStartHook</code>イベントで、<code>PreStop</code>の場合、これは<code>FailedPreStopHook</code>イベントです。
失敗の<code>FailedPreStopHook</code>イベントを自分自身で生成する場合には、<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/lifecycle-events.yaml>lifecycle-events.yaml</a>ファイルに対してpostStartのコマンドを"badcommand"に変更し、適用してください。
<code>kubectl describe pod lifecycle-demo</code>を実行した結果のイベントの出力例を以下に示します。</p><pre tabindex=0><code>Events:
  Type     Reason               Age              From               Message
  ----     ------               ----             ----               -------
  Normal   Scheduled            7s               default-scheduler  Successfully assigned default/lifecycle-demo to ip-XXX-XXX-XX-XX.us-east-2...
  Normal   Pulled               6s               kubelet            Successfully pulled image &#34;nginx&#34; in 229.604315ms
  Normal   Pulling              4s (x2 over 6s)  kubelet            Pulling image &#34;nginx&#34;
  Normal   Created              4s (x2 over 5s)  kubelet            Created container lifecycle-demo-container
  Normal   Started              4s (x2 over 5s)  kubelet            Started container lifecycle-demo-container
  Warning  FailedPostStartHook  4s (x2 over 5s)  kubelet            Exec lifecycle hook ([badcommand]) for Container &#34;lifecycle-demo-container&#34; in Pod &#34;lifecycle-demo_default(30229739-9651-4e5a-9a32-a8f1688862db)&#34; failed - error: command &#39;badcommand&#39; exited with 126: , message: &#34;OCI runtime exec failed: exec failed: container_linux.go:380: starting container process caused: exec: \&#34;badcommand\&#34;: executable file not found in $PATH: unknown\r\n&#34;
  Normal   Killing              4s (x2 over 5s)  kubelet            FailedPostStartHook
  Normal   Pulled               4s               kubelet            Successfully pulled image &#34;nginx&#34; in 215.66395ms
  Warning  BackOff              2s (x2 over 3s)  kubelet            Back-off restarting failed container
</code></pre><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/containers/container-environment/>コンテナ環境</a>の詳細</li><li><a href=/ja/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>コンテナライフサイクルイベントへのハンドラー紐付け</a>のハンズオン</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d52aadda80edd9f8c514cfe2321363c2>4 - ワークロード</h1><div class=lead>Kubernetesにおけるデプロイ可能な最小のオブジェクトであるPodと、高レベルな抽象化がPodの実行を助けることを理解します。</div><p>ワークロードとは、Kubernetes上で実行中のアプリケーションです。
ワークロードが1つのコンポーネントからなる場合でも、複数のコンポーネントが協調して動作する場合でも、Kubernetesではそれらは<a href=/ja/docs/concepts/workloads/pods>Pod</a>の集合として実行されます。Kubernetesでは、Podはクラスター上で実行中の<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>の集合として表されます。</p><p>Podには定義されたライフサイクルがあります。たとえば、一度Podがクラスター上で実行中になると、そのPodが実行中の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>上で深刻な障害が起こったとき、そのノード上のすべてのPodは停止してしまうことになります。Kubernetesではそのようなレベルの障害を最終的なものとして扱うため、たとえノードが後で復元したとしても、ユーザーは新しいPodを作成し直す必要があります。</p><p>しかし、生活をかなり楽にするためには、それぞれのPodを直接管理する必要はありません。<em>ワークロードリソース</em> を利用すれば、あなたの代わりにPodの集合の管理を行ってもらえます。これらのリソースはあなたが指定した状態に一致するように<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>を設定し、正しい種類のPodが正しい数だけ実行中になることを保証してくれます。</p><p>ワークロードリソースには、次のような種類があります。</p><ul><li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>と<a href=/ja/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>(レガシーなリソース<a class=glossary-tooltip title='A (deprecated) API object that manages a replicated application.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-replication-controller' target=_blank aria-label=ReplicationController>ReplicationController</a>を置き換えるものです)</li><li><a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>(ストレージドライバやネットワークプラグインなど、ノードローカルな機能を提供するためのPodを実行するために使われます)</li><li><a href=/docs/concepts/workloads/controllers/job/>Job</a>と<a href=/ja/docs/concepts/workloads/controllers/cron-jobs/>CronJob</a>(実行後に完了するようなタスクのために使われます)</li></ul><p>多少関連のある2種類の補助的な概念もあります。</p><ul><li><a href=/ja/docs/concepts/workloads/controllers/garbage-collection/>ガベージコレクション</a>は、オブジェクトが <em>所有するリソース</em> が削除された後に、そのオブジェクトをクラスターからクリーンアップします。</li><li><a href=/ja/docs/concepts/workloads/controllers/ttlafterfinished/>終了したリソースのためのTTLコントローラー</a>は、Jobの完了後、定義した時間が経過した後にJobを削除します。</li></ul><h2 id=次の項目>次の項目</h2><p>各リソースについて読む以外にも、以下のページでそれぞれのワークロードに関連する特定のタスクについて学ぶことができます。</p><ul><li><a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>Deploymentを使用してステートレスアプリケーションを実行する</a></li><li><a href=/ja/docs/tasks/run-application/run-single-instance-stateful-application/>単一レプリカ</a>または<a href=/ja/docs/tasks/run-application/run-replicated-stateful-application/>レプリカセット</a>のいずれかとしてステートフルなアプリケーションを実行する</li><li><a href=/ja/docs/tasks/job/automated-tasks-with-cron-jobs/>CronJobを使用して自動タスクを実行する</a></li></ul><p>アプリケーションが実行できるようになったら、インターネット上で公開したくなるかもしれません。その場合には、<a href=/ja/docs/concepts/services-networking/service/>Service</a>として公開したり、ウェブアプリケーションだけの場合、<a href=/ja/docs/concepts/services-networking/ingress>Ingress</a>を使用することができます。</p><p>コードを設定から分離するKubernetesのしくみについて学ぶには、<a href=/ja/docs/concepts/configuration/>設定</a>を読んでください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4d68b0ccf9c683e6368ffdcc40c838d4>4.1 - Pod</h1><p><em>Pod</em>は、Kubernetes内で作成・管理できるコンピューティングの最小のデプロイ可能なユニットです。</p><p><em>Pod</em>(Podという名前は、たとえばクジラの群れ(pod of whales)やえんどう豆のさや(pea pod)などの表現と同じような意味です)は、1つまたは複数の<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>のグループであり、ストレージやネットワークの共有リソースを持ち、コンテナの実行方法に関する仕様を持っています。同じPodに含まれるリソースは、常に同じ場所で同時にスケジューリングされ、共有されたコンテキストの中で実行されます。Podはアプリケーションに特化した「論理的なホスト」をモデル化します。つまり、1つのPod内には、1つまたは複数の比較的密に結合されたアプリケーションコンテナが含まれます。クラウド外の文脈で説明すると、アプリケーションが同じ物理ホストや同じバーチャルマシンで実行されることが、クラウドアプリケーションの場合には同じ論理ホスト上で実行されることに相当します。</p><p>アプリケーションコンテナと同様に、Podでも、Podのスタートアップ時に実行される<a href=/ja/docs/concepts/workloads/pods/init-containers/>initコンテナ</a>を含めることができます。また、クラスターで利用できる場合には、<a href=/ja/docs/concepts/workloads/pods/ephemeral-containers/>エフェメラルコンテナ</a>を注入してデバッグすることもできます。</p><h2 id=podとは何か>Podとは何か？</h2><div class="alert alert-info note callout" role=alert><strong>備考:</strong> KubernetesはDockerだけでなく複数の<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>をサポートしていますが、<a href=https://www.docker.com/>Docker</a>が最も一般的に知られたランタイムであるため、Docker由来の用語を使ってPodを説明するのが理解の助けとなります。</div><p>Podの共有コンテキストは、Dockerコンテナを隔離するのに使われているのと同じ、Linuxのnamespaces、cgroups、場合によっては他の隔離技術の集合を用いて作られます。Podのコンテキスト内では、各アプリケーションが追加の準隔離技術を適用することもあります。</p><p>Dockerの概念を使って説明すると、Podは共有の名前空間と共有ファイルシステムのボリュームを持つDockerコンテナのグループに似ています。</p><h2 id=podを使用する>Podを使用する</h2><p>以下は、<code>nginx:1.14.2</code>イメージが実行されるコンテナからなるPodの例を記載しています。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/simple-pod.yaml download=pods/simple-pod.yaml><code>pods/simple-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-simple-pod-yaml")' title="Copy pods/simple-pod.yaml to clipboard"></img></div><div class=includecode id=pods-simple-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>上記のようなPodを作成するには、以下のコマンドを実行します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml
</span></span></code></pre></div><p>Podは通常、直接作成されず、ワークロードリソースで作成されます。ワークロードリソースでPodを作成する方法の詳細については、<a href=#working-with-pods>Podを利用する</a>を参照してください。</p><h3 id=podを管理するためのワークロードリソース>Podを管理するためのワークロードリソース</h3><p>通常、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、自分でPodを直接作成する必要はありません。その代わりに、<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>や<a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>などのワークロードリソースを使用してPodを作成します。もしPodが状態を保持する必要がある場合は、<a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>リソースを使用することを検討してください。</p><p>Kubernetesクラスター内のPodは、主に次の2種類の方法で使われます。</p><ul><li><p><strong>単一のコンテナを稼働させるPod</strong>。「1Pod1コンテナ」構成のモデルは、Kubernetesでは最も一般的なユースケースです。このケースでは、ユーザーはPodを単一のコンテナのラッパーとして考えることができます。Kubernetesはコンテナを直接管理するのではなく、Podを管理します。</p></li><li><p><strong>協調して稼働させる必要がある複数のコンテナを稼働させるPod</strong>。単一のPodは、密に結合してリソースを共有する必要があるような、同じ場所で稼働する複数のコンテナからなるアプリケーションをカプセル化することもできます。これらの同じ場所で稼働するコンテナ群は、単一のまとまりのあるサービスのユニットを構成します。たとえば、1つのコンテナが共有ボリュームからファイルをパブリックに配信し、別の<em>サイドカー</em>コンテナがそれらのファイルを更新するという構成が考えられます。Podはこれらの複数のコンテナ、ストレージリソース、一時的なネットワークIDなどを、単一のユニットとしてまとめます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 複数のコンテナを同じ場所で同時に管理するように単一のPod内にグループ化するのは、比較的高度なユースケースです。このパターンを使用するのは、コンテナが密に結合しているような特定のインスタンス内でのみにするべきです。</div></li></ul><p>各Podは、与えられたアプリケーションの単一のインスタンスを稼働するためのものです。もしユーザーのアプリケーションを水平にスケールさせたい場合(例: 複数インスタンスを稼働させる)、複数のPodを使うべきです。1つのPodは各インスタンスに対応しています。Kubernetesでは、これは一般的に<em>レプリケーション</em>と呼ばれます。レプリケーションされたPodは、通常ワークロードリソースと、それに対応する<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>によって、作成・管理されます。</p><p>Kubernetesがワークロードリソースとそのコントローラーを活用して、スケーラブルで自動回復するアプリケーションを実装する方法については、詳しくは<a href=#pods-and-controllers>Podとコントローラー</a>を参照してください。</p><h3 id=podが複数のコンテナを管理する方法>Podが複数のコンテナを管理する方法</h3><p>Podは、まとまりの強いサービスのユニットを構成する、複数の協調する(コンテナとして実行される)プロセスをサポートするために設計されました。単一のPod内の複数のコンテナは、クラスター内の同じ物理または仮想マシン上で、自動的に同じ場所に配置・スケジューリングされます。コンテナ間では、リソースや依存関係を共有したり、お互いに通信したり、停止するときにはタイミングや方法を協調して実行できます。</p><p>たとえば、あるコンテナが共有ボリューム内のファイルを配信するウェブサーバーとして動作し、別の「サイドカー」コンテナがリモートのリソースからファイルをアップデートするような構成が考えられます。この構成を以下のダイアグラムに示します。</p><figure class=diagram-medium><img src=/images/docs/pod.svg alt=Pod作成ダイアグラム></figure><p>Podによっては、<a class=glossary-tooltip title='A container used to run part of a workload. Compare with init container.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-app-container' target=_blank aria-label=appコンテナ>appコンテナ</a>に加えて<a class=glossary-tooltip title='One or more initialization containers that must run to completion before any app containers run.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-init-container' target=_blank aria-label=initコンテナ>initコンテナ</a>を持っている場合があります。initコンテナはappコンテナが起動する前に実行・完了するコンテナです。</p><p>Podは、Podを構成する複数のコンテナに対して、<a href=#pod-networking>ネットワーク</a>と<a href=#pod-storage>ストレージ</a>の2種類の共有リソースを提供します。</p><h2 id=working-with-pods>Podを利用する</h2><p>通常Kubernetesでは、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、個別のPodを直接作成することはめったにありません。その理由は、Podがある程度一時的で使い捨てできる存在として設計されているためです。Podが作成されると(あなたが直接作成した場合でも、<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>が間接的に作成した場合でも)、新しいPodはクラスター内の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>上で実行されるようにスケジューリングされます。Podは、実行が完了するか、Podオブジェクトが削除されるか、リソース不足によって<em>強制退去</em>されるか、ノードが停止するまで、そのノード上にとどまります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Pod内のコンテナの再起動とPodの再起動を混同しないでください。Podはプロセスではなく、コンテナが実行するための環境です。Podは削除されるまでは残り続けます。</div><p>Podオブジェクトのためのマニフェストを作成したときは、指定したPodの名前が有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>であることを確認してください。</p><h3 id=pod-os>Pod OS</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [stable]</code></div><p><code>.spec.os.name</code>フィールドで<code>windows</code>か<code>linux</code>のいずれかを設定し、Podを実行させたいOSを指定する必要があります。Kubernetesは今のところ、この2つのOSだけサポートしています。将来的には増える可能性があります。</p><p>Kubernetes v1.25では、このフィールドに設定した値はPodの<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=スケジューリング>スケジューリング</a>に影響を与えません。<code>.spec.os.name</code>を設定することで、Pod OSに権限を認証することができ、バリデーションにも使用されます。kubeletが実行されているノードのOSが、指定されたPod OSと異なる場合、kubeletはPodの実行を拒否します。
<a href=/ja/docs/concepts/security/pod-security-standards/>Podセキュリティの標準</a>もこのフィールドを使用し、指定したOSと関係ないポリシーの適用を回避しています。</p><h3 id=pods-and-controllers>Podとコンテナコントローラー</h3><p>ワークロードリソースは、複数のPodを作成・管理するために利用できます。リソースに対応するコントローラーが、複製やロールアウトを扱い、Podの障害時には自動回復を行います。たとえば、あるノードに障害が発生した場合、コントローラーはそのノードの動作が停止したことを検知し、代わりのPodを作成します。そして、スケジューラーが代わりのPodを健全なノード上に配置します。</p><p>以下に、1つ以上のPodを管理するワークロードリソースの一例をあげます。</p><ul><li><a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a></li><li><a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a></li><li><a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a></li></ul><h3 id=pod-template>Podテンプレート</h3><p><a class=glossary-tooltip title=ワークロードとは、Kubernetes上で実行中のアプリケーションです。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/ target=_blank aria-label=workload>workload</a>リソース向けのコントローラーは、Podを<em>Podテンプレート</em>を元に作成し、あなたの代わりにPodを管理してくれます。</p><p>PodTemplateはPodを作成するための仕様で、<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>、<a href=/ja/docs/concepts/workloads/controllers/job/>Job</a>、<a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>などのワークロードリソースの中に含まれています。</p><p>ワークロードリソースに対応する各コントローラーは、ワークロードオブジェクト内にある<code>PodTemplate</code>を使用して実際のPodを作成します。<code>PodTemplate</code>は、アプリを実行するために使われるワークロードリソースがどんな種類のものであれ、その目的の状態の一部を構成するものです。</p><p>以下は、単純なJobのマニフェストの一例で、1つのコンテナを実行する<code>template</code>があります。Pod内のコンテナはメッセージを出力した後、一時停止します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># これがPodテンプレートです</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo &#34;Hello, Kubernetes!&#34; &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Podテンプレートはここまでです</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Podテンプレートを修正するか新しいPodに切り替えたとしても、すでに存在するPodには直接の影響はありません。ワークロードリソース内のPodテンプレートを変更すると、そのリソースは更新されたテンプレートを使用して代わりとなるPodを作成する必要があります。</p><p>たとえば、StatefulSetコントローラーは、各StatefulSetごとに、実行中のPodが現在のPodテンプレートに一致することを保証します。Podテンプレートを変更するためにStatefulSetを編集すると、StatefulSetは更新されたテンプレートを元にした新しいPodを作成するようになります。最終的に、すべての古いPodが新しいPodで置き換えられ、更新は完了します。</p><p>各ワークロードリソースは、Podテンプレートへの変更を処理するための独自のルールを実装しています。特にStatefulSetについて更に詳しく知りたい場合は、StatefulSetの基本チュートリアル内の<a href=/ja/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets>アップデート戦略</a>を読んでください。</p><p>ノード上では、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>はPodテンプレートに関する詳細について監視や管理を直接行うわけではありません。こうした詳細は抽象化されています。こうした抽象化や関心の分離のおかげでシステムのセマンティクスが単純化され、既存のコードを変更せずにクラスターの動作を容易に拡張できるようになっているのです。</p><h2 id=podの更新と取替>Podの更新と取替</h2><p>前のセクションで述べたように、ワークロードリソースのPodテンプレートが変更されると、コントローラーは既存のPodを更新したりパッチを適用したりするのではなく、更新されたテンプレートに基づいて新しいPodを作成します。</p><p>KubernetesはPodを直接管理することを妨げません。実行中のPodの一部のフィールドをその場で更新することが可能です。しかし、<a href=/docs/reference/generated/kubernetes-api/v1.25/#patch-pod-v1-core><code>patch</code></a>と<a href=/docs/reference/generated/kubernetes-api/v1.25/#replace-pod-v1-core><code>replace</code></a>といった、Podのアップデート操作にはいくつかの制限があります:</p><ul><li><p>Podのメタデータのほとんどは固定されたものです。たとえば<code>namespace</code>、<code>name</code>、<code>uid</code>または<code>creationTimestamp</code>フィールドは変更できません。<code>generation</code>フィールドは特別で、現在の値を増加させる更新のみを受け付けます。</p></li><li><p><code>metadata.deletionTimestamp</code>が設定されている場合、<code>metadata.finalizers</code>リストに新しい項目を追加することはできません。</p></li><li><p>Podの更新では<code>spec.containers[*].image</code>、<code>spec.initContainers[*].image</code>、<code>spec.activeDeadlineSeconds</code>または<code>spec.tolerations</code>以外のフィールドを変更してはなりません。
<code>spec.tolerations</code>については新しい項目のみを追加することができます。</p></li><li><p><code>spec.activeDeadlineSeconds</code>フィールドを更新する場合、2種類の更新が可能です:</p><ol><li>未割り当てのフィールドに正の数を設定する</li><li>現在の値から負の数でない、より小さい数に更新する</li></ol></li></ul><h2 id=リソースの共有と通信>リソースの共有と通信</h2><p>Podは、データの共有と構成するコンテナ間での通信を可能にします。</p><h3 id=pod-storage>Pod内のストレージ</h3><p>Podでは、共有ストレージである<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>の集合を指定できます。Pod内のすべてのコンテナは共有ボリュームにアクセスできるため、それら複数のコンテナでデータを共有できるようになります。また、ボリュームを利用すれば、Pod内のコンテナの1つに再起動が必要になった場合にも、Pod内の永続化データを保持し続けられるようにできます。Kubernetesの共有ストレージの実装方法とPodで利用できるようにする方法に関するさらに詳しい情報は、<a href=/ja/docs/concepts/storage/>ストレージ</a>を読んでください。</p><h3 id=pod-networking>Podネットワーク</h3><p>各Podには、各アドレスファミリーごとにユニークなIPアドレスが割り当てられます。Pod内のすべてのコンテナは、IPアドレスとネットワークポートを含むネットワーク名前空間を共有します。Podの中では(かつその場合に<strong>のみ</strong>)、そのPod内のコンテナは<code>localhost</code>を使用して他のコンテナと通信できます。Podの内部にあるコンテナが<em>Podの外部にある</em>エンティティと通信する場合、(ポートなどの)共有ネットワークリソースの使い方をコンテナ間で調整しなければなりません。Pod内では、コンテナはIPアドレスとポートの空間を共有するため、<code>localhost</code>で他のコンテナにアクセスできます。また、Pod内のコンテナは、SystemVのセマフォやPOSIXの共有メモリなど、標準のプロセス間通信を使って他のコンテナと通信することもできます。異なるPod内のコンテナは異なるIPアドレスを持つため、特別な設定をしない限り、OSレベルIPCで通信することはできません。異なるPod上で実行中のコンテナ間でやり取りをしたい場合は、IPネットワークを使用して通信できます。</p><p>Pod内のコンテナは、システムのhostnameがPodに設定した<code>name</code>と同一であると考えます。ネットワークについての詳しい情報は、<a href=/ja/docs/concepts/cluster-administration/networking/>ネットワーク</a>で説明しています。</p><h2 id=コンテナの特権モード>コンテナの特権モード</h2><p>Linuxでは、Pod内のどんなコンテナも、<code>privileged</code>フラグをコンテナのspecの<a href=/docs/tasks/configure-pod-container/security-context/>security context</a>に設定することで、特権モード(privileged mode)を有効にできます。これは、ネットワークスタックの操作やハードウェアデバイスへのアクセスなど、オペレーティングシステムの管理者の権限が必要なコンテナの場合に役に立ちます。</p><p><code>WindowsHostProcessContainers</code>機能を有効にしたクラスターの場合、Pod仕様のsecurityContextに<code>windowsOptions.hostProcess</code>フラグを設定することで、<a href=/docs/tasks/configure-pod-container/create-hostprocess-pod>Windows HostProcess Pod</a>を作成することが可能です。これらのPod内のすべてのコンテナは、Windows HostProcessコンテナとして実行する必要があります。HostProcess Podはホスト上で直接実行され、Linuxの特権コンテナで行われるような管理作業を行うのにも使用できます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> この設定を有効にするには、<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>が特権コンテナの概念をサポートしていなければなりません。</div><h2 id=static-pod>static Pod</h2><p><em>static Pod</em>は、<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>には管理されない、特定のノード上でkubeletデーモンによって直接管理されるPodのことです。大部分のPodはコントロープレーン(たとえば<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>)によって管理されますが、static Podの場合はkubeletが各static Podを直接管理します(障害時には再起動します)。</p><p>static Podは常に特定のノード上の1つの<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>に紐付けられます。static Podの主な用途は、セルフホストのコントロールプレーンを実行すること、言い換えると、kubeletを使用して個別の<a href=/ja/docs/concepts/overview/components/#control-plane-components>コントロールプレーンコンポーネント</a>を管理することです。</p><p>kubeletは自動的にKubernetes APIサーバー上に各static Podに対応する<a class=glossary-tooltip title='kubelet上のstatic Podを追跡するAPIサーバー内のオブジェクトです。' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-mirror-pod' target=_blank aria-label=ミラーPod>ミラーPod</a>の作成を試みます。つまり、ノード上で実行中のPodはAPIサーバー上でも見えるようになるけれども、APIサーバー上から制御はできないということです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Static Podの<code>spec</code>は他のAPIオブジェクト
(例えば<a class=glossary-tooltip title='Provides an identity for processes that run in a Pod.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=サービスアカウント>サービスアカウント</a>、
<a class=glossary-tooltip title=機密性のないデータをキーと値のペアで保存するために使用されるAPIオブジェクトです。環境変数、コマンドライン引数、またはボリューム内の設定ファイルとして使用できます。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>、
<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>、など)を参照することはできません。</div><h2 id=コンテナのprobe>コンテナのProbe</h2><p><em>Probe</em> はkubeletがコンテナに対して行う定期診断です。診断を実行するために、kubeletはさまざまなアクションを実行できます:</p><ul><li><code>ExecAction</code> (コンテナランタイムの助けを借りて実行)</li><li><code>TCPSocketAction</code> (kubeletにより直接チェック)</li><li><code>HTTPGetAction</code> (kubeletにより直接チェック)</li></ul><p>更に詳しく知りたい場合は、Podのライフサイクルドキュメントにある<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>Probe</a>を読んでください。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>について学ぶ。</li><li><a href=/ja/docs/concepts/containers/runtime-class/>RuntimeClass</a>と、それを用いてPodごとに異なるコンテナランタイム設定する方法について学ぶ。</li><li><a href=/ja/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>と、それを使用してクラスターの停止(disruption)中にアプリケーションの可用性を管理する方法について読む。</li><li>PodはKubernetes REST API内のトップレベルのリソースです。
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/>Pod</a>オブジェクトの定義では、オブジェクトの詳細について記述されています。</li><li><a href=/blog/2015/06/the-distributed-system-toolkit-patterns/>The Distributed System Toolkit: Patterns for Composite Containers</a>では、2つ以上のコンテナを利用する場合の一般的なレイアウトについて説明しています。</li><li><a href=/docs/concepts/scheduling-eviction/topology-spread-constraints/>Podトポロジー分布制約</a>について読む。</li></ul><p>Kubernetesが共通のPod APIを他のリソース内(たとえば<a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>や<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>など)にラッピングしている理由の文脈を理解するためには、Kubernetes以前から存在する以下のような既存技術について読むのが助けになります。</p><ul><li><a href=https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a></li><li><a href=https://research.google.com/pubs/pub43438.html>Borg</a></li><li><a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a></li><li><a href=https://research.google/pubs/pub41684/>Omega</a></li><li><a href=https://engineering.fb.com/data-center-engineering/tupperware/>Tupperware</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-37afa6c66c74400d1579f10faf55e5b6>4.1.1 - Podの概観</h1><p>このページでは、Kubernetesのオブジェクトモデルにおいて、デプロイ可能な最小単位のオブジェクトである<code>Pod</code>に関して説明します。</p><h2 id=understanding-pods>Podについて理解する</h2><p><em>Pod</em> は、Kubernetesアプリケーションの基本的な実行単位です。これは、作成またはデプロイするKubernetesオブジェクトモデルの中で最小かつ最も単純な単位です。Podは、<a class=glossary-tooltip title=コンテナ化されたアプリケーションを実行する、ノードと呼ばれるワーカーマシンの集合です。すべてのクラスターには少なくとも1つのワーカーノードがあります。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=クラスター>クラスター</a>で実行されているプロセスを表します。</p><p>Podは、アプリケーションのコンテナ(いくつかの場合においては複数のコンテナ)、ストレージリソース、ユニークなネットワークIP、およびコンテナの実行方法を管理するオプションをカプセル化します。Podはデプロイメントの単位、すなわち<em>Kubernetesのアプリケーションの単一インスタンス</em> で、単一の<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>または密結合なリソースを共有する少数のコンテナで構成される場合があります。</p><p><a href=https://www.docker.com>Docker</a>はKubernetesのPod内で使われる最も一般的なコンテナランタイムですが、Podは他の<a href=/ja/docs/setup/production-environment/container-runtimes/>コンテナランタイム</a>も同様にサポートしています。</p><p>Kubernetesクラスター内でのPodは2つの主な方法で使うことができます。</p><ul><li><strong>単一のコンテナを稼働させるPod</strong> : いわゆる*「1Pod1コンテナ」* 構成のモデルは、最も一般的なKubernetesのユースケースです。
このケースでは、ユーザーはPodを単一のコンテナのラッパーとして考えることができ、Kubernetesはコンテナを直接扱うというよりは、Podを管理することになります。</li><li><strong>協調して稼働させる必要がある複数のコンテナを稼働させるPod</strong> : 単一のPodは、リソースを共有する必要があるような、密接に連携した複数の同じ環境にあるコンテナからなるアプリケーションをカプセル化することもできます。 これらの同じ環境にあるコンテナ群は、サービスの結合力の強いユニットを構成することができます。
-- 1つのコンテナが、共有されたボリュームからファイルをパブリックな場所に送信し、一方では分割された<em>サイドカー</em> コンテナがそれらのファイルを更新します。そのPodはそれらのコンテナとストレージリソースを、単一の管理可能なエンティティとしてまとめます。</li></ul><p><a href=https://kubernetes.io/blog>Kubernetes Blog</a>にて、Podのユースケースに関するいくつかの追加情報を見ることができます。さらなる情報を得たい場合は、下記のページを参照ください。</p><ul><li><a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>The Distributed System Toolkit: Patterns for Composite Containers</a></li><li><a href=https://kubernetes.io/blog/2016/06/container-design-patterns>Container Design Patterns</a></li></ul><p>各Podは、与えられたアプリケーションの単一のインスタンスを稼働するためのものです。もしユーザーのアプリケーションを水平にスケールさせたい場合(例: 複数インスタンスを稼働させる)、複数のPodを使うべきです。1つのPodは各インスタンスに対応しています。
Kubernetesにおいて、これは一般的に <em>レプリケーション</em> と呼ばれます。
レプリケーションされたPodは、通常コントローラーと呼ばれる抽象概念によって単一のグループとして作成、管理されます。
さらなる情報に関しては<a href=#pods-and-controllers>Podとコントローラー</a>を参照して下さい。</p><h3 id=podがどのように複数のコンテナを管理しているか>Podがどのように複数のコンテナを管理しているか</h3><p>Podは凝集性の高いサービスのユニットを構成するような複数の協調プロセス(コンテナ）をサポートするためにデザインされました。
単一のPod内のコンテナ群は、クラスター内において同一の物理マシンもしくは仮想マシン上において自動で同じ環境に配備され、スケジュールされます。コンテナはリソースや依存関係を共有し、お互いにコミュニケートし、それらがいつ、どのように削除されるかを調整できます。</p><p>注意点として、単一のPod内で同じ環境に配備され、同時管理される複数のコンテナをグルーピングするのは、比較的に発展的なユースケースとなります。
ユーザーは、コンテナ群が密接に連携するような、特定のインスタンスにおいてのみこのパターンを使用するべきです。
例えば、ユーザーが共有ボリューム内にあるファイル用のWebサーバとして稼働するコンテナと、下記のダイアグラムにあるような、リモートのソースからファイルを更新するような分離された<em>サイドカー</em> コンテナを持っているような場合です。</p><figure><img src=/images/docs/pod.svg alt=Podのダイアグラム width=50%></figure><p>Podは、Podによって構成されたコンテナ群のために2種類の共有リソースを提供します。 <em>ネットワーキング</em> と<em>ストレージ</em> です。</p><h4 id=ネットワーキング>ネットワーキング</h4><p>各Podは固有のIPアドレスを割り当てられます。単一のPod内の各コンテナは、IPアドレスやネットワークポートを含む、そのネットワークの名前空間を共有します。<em>Pod内の</em> コンテナは<code>localhost</code>を使用してお互いに疎通できます。単一のPod内のコンテナが<em>Pod外</em> のエンティティと疎通する場合、共有されたネットワークリソース(ポートなど）をどのように使うかに関して調整しなければなりません。</p><h4 id=ストレージ>ストレージ</h4><p>単一のPodは共有されたストレージ<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>のセットを指定できます。Pod内の全てのコンテナは、その共有されたボリュームにアクセスでき、コンテナ間でデータを共有することを可能にします。ボリュームもまた、もしPod内のコンテナの1つが再起動が必要になった場合に備えて、データを永続化できます。
単一のPod内での共有ストレージをKubernetesがどう実装しているかについてのさらなる情報については、<a href=/docs/concepts/storage/volumes/>Volumes</a>を参照してください。</p><h2 id=podを利用する>Podを利用する</h2><p>ユーザーはまれに、Kubernetes内で独立したPodを直接作成する場合があります(シングルトンPodなど)。
これはPodが比較的、一時的な使い捨てエンティティとしてデザインされているためです。Podが作成された時(ユーザーによって直接的、またはコントローラーによって間接的に作成された場合)、ユーザーのクラスター内の単一の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>上で稼働するようにスケジューリングされます。そのPodはプロセスが停止されたり、Podオブジェクトが削除されたり、Podがリソースの欠如のために<em>追い出され</em> たり、ノードが故障するまでノード上に残り続けます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 単一のPod内でのコンテナを再起動することと、そのPodを再起動することを混同しないでください。Podはそれ自体は実行されませんが、コンテナが実行される環境であり、削除されるまで存在し続けます。</div><p>Podは、Podそれ自体によって自己修復しません。もし、稼働されていないノード上にPodがスケジュールされた場合や、スケジューリング操作自体が失敗した場合、Podが削除されます。同様に、Podはリソースの欠如や、ノードのメンテナンスによる追い出しがあった場合はそこで停止します。Kubernetesは<em>コントローラー</em> と呼ばれる高レベルの抽象概念を使用し、それは比較的使い捨て可能なPodインスタンスの管理を行います。
このように、Podを直接使うのは可能ですが、コントローラーを使用したPodを管理する方がより一般的です。KubernetesがPodのスケーリングと修復機能を実現するためにコントローラーをどのように使うかに関する情報は<a href=#pods-and-controllers>Podとコントローラー</a>を参照してください。</p><h3 id=podとコントローラー>Podとコントローラー</h3><p>単一のコントローラーは、ユーザーのために複数のPodを作成・管理し、レプリケーションやロールアウト、クラスターのスコープ内で自己修復の機能をハンドリングします。例えば、もしノードが故障した場合、コントローラーは異なるノード上にPodを置き換えるようにスケジューリングすることで、自動的にリプレース可能となります。</p><p>1つまたはそれ以上のPodを含むコントローラーの例は下記の通りです。</p><ul><li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a></li><li><a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li></ul><p>通常は、コントローラーはユーザーが作成したPodテンプレートを使用して、担当するPodを作成します。</p><h2 id=podテンプレート>Podテンプレート</h2><p>Podテンプレートは、<a href=/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>、 <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/>Job</a>や、
<a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>のような他のオブジェクト内で含まれるPodの仕様となります。
コントローラーは実際のPodを作成するためにPodテンプレートを使用します。
下記のサンプルは、メッセージを表示する単一のコンテナを含んだ、シンプルなPodのマニフェストとなります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>myapp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo Hello Kubernetes! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>全てのレプリカの現在の理想的な状態を指定するというよりも、Podテンプレートはクッキーの抜き型のようなものです。一度クッキーがカットされると、そのクッキーは抜き型から離れて関係が無くなります。そこにはいわゆる”量子もつれ”といったものはありません。テンプレートに対するその後の変更や新しいテンプレートへの切り替えは、すでに作成されたPod上には直接的な影響はありません。
同様に、ReplicationControllerによって作成されたPodは、変更後に直接更新されます。これはPodとの意図的な違いとなり、そのPodに属する全てのコンテナの現在の理想的な状態を指定します。このアプローチは根本的にシステムのセマンティクスを単純化し、機能の柔軟性を高めます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/workloads/pods/pod/>Pod</a>についてさらに学びましょう</li><li>Podの振る舞いに関して学ぶには下記を参照してください<ul><li><a href=/ja/docs/concepts/workloads/pods/pod/#termination-of-pods>Podの停止</a></li><li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c3c2b9cf30915ec9d46c147201da3332>4.1.2 - Podのライフサイクル</h1><p>このページではPodのライフサイクルについて説明します。Podは定義されたライフサイクルに従い <code>Pending</code><a href=#pod-phase>フェーズ</a>から始まり、少なくとも1つのプライマリーコンテナが正常に開始した場合は<code>Running</code>を経由し、次に失敗により終了したコンテナの有無に応じて、<code>Succeeded</code>または<code>Failed</code>フェーズを経由します。</p><p>Podの実行中、kubeletはコンテナを再起動して、ある種の障害を処理できます。Pod内で、Kubernetesはさまざまなコンテナの<a href=#container-states>ステータス</a>を追跡して、回復させるためのアクションを決定します。</p><p>Kubernetes APIでは、Podには仕様と実際のステータスの両方があります。Podオブジェクトのステータスは、<a href=#pod-conditions>PodのCondition</a>のセットで構成されます。<a href=#pod-readiness-gate>カスタムのReadiness情報</a>をPodのConditionデータに挿入することもできます。</p><p>Podはその生存期間に1回だけ<a href=/docs/concepts/scheduling-eviction/>スケジューリング</a>されます。PodがNodeにスケジュール(割り当て)されると、Podは停止または<a href=#pod-termination>終了</a>するまでそのNode上で実行されます。</p><h2 id=podのライフタイム>Podのライフタイム</h2><p>個々のアプリケーションコンテナと同様に、Podは(永続的ではなく)比較的短期間の存在と捉えられます。Podが作成されると、一意のID(<a href=/ja/docs/concepts/overview/working-with-objects/names/#uids>UID</a>)が割り当てられ、(再起動ポリシーに従って)終了または削除されるまでNodeで実行されるようにスケジュールされます。<br><a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>が停止した場合、そのNodeにスケジュールされたPodは、タイムアウト時間の経過後に<a href=#pod-garbage-collection>削除</a>されます。</p><p>Pod自体は、自己修復しません。Podが<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a>にスケジュールされ、その後に失敗、またはスケジュール操作自体が失敗した場合、Podは削除されます。同様に、リソースの不足またはNodeのメンテナンスによりPodはNodeから立ち退きます。Kubernetesは、比較的使い捨てのPodインスタンスの管理作業を処理する、<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>と呼ばれる上位レベルの抽象化を使用します。</p><p>特定のPod(UIDで定義)は新しいNodeに"再スケジュール"されません。代わりに、必要に応じて同じ名前で、新しいUIDを持つ同一のPodに置き換えることができます。</p><p><a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a>など、Podと同じ存続期間を持つものがあると言われる場合、それは(そのUIDを持つ)Podが存在する限り存在することを意味します。そのPodが何らかの理由で削除された場合、たとえ同じ代替物が作成されたとしても、関連するもの(例えばボリューム)も同様に破壊されて再作成されます。</p><figure><img src=/images/docs/pod.svg width=50%><figcaption><h4>Podの図</h4></figcaption></figure><p><em>file puller(ファイル取得コンテナ)とWebサーバーを含むマルチコンテナのPod。コンテナ間の共有ストレージとして永続ボリュームを使用しています。</em></p><h2 id=pod-phase>Podのフェーズ</h2><p>Podの<code>status</code>項目は<a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a>オブジェクトで、それは<code>phase</code>のフィールドがあります。</p><p>Podのフェーズは、そのPodがライフサイクルのどの状態にあるかを、簡単かつ高レベルにまとめたものです。このフェーズはコンテナやPodの状態を包括的にまとめることを目的としたものではなく、また包括的なステートマシンでもありません。</p><p>Podの各フェーズの値と意味は厳重に守られています。ここに記載されているもの以外に<code>phase</code>の値は存在しないと思ってください。</p><p>これらが<code>phase</code>の取りうる値です。</p><table><thead><tr><th style=text-align:left>値</th><th style=text-align:left>概要</th></tr></thead><tbody><tr><td style=text-align:left><code>Pending</code></td><td style=text-align:left>PodがKubernetesクラスターによって承認されましたが、1つ以上のコンテナがセットアップされて稼働する準備ができていません。これには、スケジュールされるまでの時間と、ネットワーク経由でイメージをダウンロードするための時間などが含まれます。</td></tr><tr><td style=text-align:left><code>Running</code></td><td style=text-align:left>PodがNodeにバインドされ、すべてのコンテナが作成されました。少なくとも1つのコンテナがまだ実行されているか、開始または再起動中です。</td></tr><tr><td style=text-align:left><code>Succeeded</code></td><td style=text-align:left>Pod内のすべてのコンテナが正常に終了し、再起動されません。</td></tr><tr><td style=text-align:left><code>Failed</code></td><td style=text-align:left>Pod内のすべてのコンテナが終了し、少なくとも1つのコンテナが異常終了しました。つまり、コンテナはゼロ以外のステータスで終了したか、システムによって終了されました。</td></tr><tr><td style=text-align:left><code>Unknown</code></td><td style=text-align:left>何らかの理由によりPodの状態を取得できませんでした。このフェーズは通常はPodのホストとの通信エラーにより発生します。</td></tr></tbody></table><p>Nodeが停止するか、クラスタの残りの部分から切断された場合、Kubernetesは失われたNode上のすべてのPodの<code>Phase</code>をFailedに設定するためのポリシーを適用します。</p><h2 id=container-states>コンテナのステータス</h2><p>Pod全体の<a href=#pod-phase>フェーズ</a>と同様に、KubernetesはPod内の各コンテナの状態を追跡します。<a href=/ja/docs/concepts/containers/container-lifecycle-hooks/>container lifecycle hooks</a>を使用して、コンテナのライフサイクルの特定のポイントで実行するイベントをトリガーできます。</p><p>Podが<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=scheduler>scheduler</a>によってNodeに割り当てられると、kubeletは<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label='container runtime'>container runtime</a>を使用してコンテナの作成を開始します。コンテナの状態は<code>Waiting</code>、<code>Running</code>または<code>Terminated</code>の3ついずれかです。</p><p>Podのコンテナの状態を確認するには<code>kubectl describe pod [POD_NAME]</code>のコマンドを使用します。Pod内のコンテナごとにStateの項目として表示されます。</p><p>各状態の意味は次のとおりです。</p><h3 id=container-state-waiting><code>Waiting</code></h3><p>コンテナが<code>Running</code>または<code>Terminated</code>のいずれの状態でもない場合コンテナは<code>Waiting</code>の状態になります。Waiting状態のコンテナは引き続きコンテナイメージレジストリからイメージを取得したり<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>を適用したりするなど必要な操作を実行します。<code>Waiting</code>状態のコンテナを持つPodに対して<code>kubectl</code>コマンドを使用すると、そのコンテナが<code>Waiting</code>の状態である理由の要約が表示されます。</p><h3 id=container-state-running><code>Running</code></h3><p><code>Running</code>状態はコンテナが問題なく実行されていることを示します。<code>postStart</code>フックが構成されていた場合、それはすでに実行が完了しています。<code>Running</code>状態のコンテナを持つPodに対して<code>kubectl</code>コマンドを使用すると、そのコンテナが<code>Running</code>状態になった時刻が表示されます。</p><h3 id=container-state-terminated><code>Terminated</code></h3><p><code>Terminated</code>状態のコンテナは実行されて、完了したときまたは何らかの理由で失敗したことを示します。<code>Terminated</code>状態のコンテナを持つPodに対して<code>kubectl</code>コマンドを使用すると、いずれにせよ理由と終了コード、コンテナの開始時刻と終了時刻が表示されます。</p><p>コンテナがTerminatedに入る前に<code>preStop</code>フックがあれば実行されます。</p><h2 id=restart-policy>コンテナの再起動ポリシー</h2><p>Podの<code>spec</code>には、Always、OnFailure、またはNeverのいずれかの値を持つ<code>restartPolicy</code>フィールドがあります。デフォルト値はAlwaysです。</p><p><code>restartPolicy</code>は、Pod内のすべてのコンテナに適用されます。<code>restartPolicy</code>は、同じNode上のkubeletによるコンテナの再起動のみを参照します。Pod内のコンテナが終了した後、kubeletは5分を上限とする指数バックオフ遅延（10秒、20秒、40秒...）でコンテナを再起動します。コンテナが10分間実行されると、kubeletはコンテナの再起動バックオフタイマーをリセットします。</p><h2 id=pod-conditions>PodのCondition</h2><p>PodにはPodStatusがあります。それはPodが成功したかどうかの情報を持つ<a href=/docs/reference/generated/kubernetes-api/v1.25/#podcondition-v1-core>PodConditions</a>の配列です。</p><ul><li><code>PodScheduled</code>: PodがNodeにスケジュールされました。</li><li><code>ContainersReady</code>: Pod内のすべてのコンテナが準備できた状態です。</li><li><code>Initialized</code>: すべての<a href=/ja/docs/concepts/workloads/pods/init-containers>Initコンテナ</a>が正常に実行されました。</li><li><code>Ready</code>: Podはリクエストを処理でき、一致するすべてのサービスの負荷分散プールに追加されます。</li></ul><table><thead><tr><th style=text-align:left>フィールド名</th><th style=text-align:left>内容</th></tr></thead><tbody><tr><td style=text-align:left><code>type</code></td><td style=text-align:left>このPodの状態の名前です。</td></tr><tr><td style=text-align:left><code>status</code></td><td style=text-align:left>その状態が適用可能かどうか示します。可能な値は"<code>True</code>"と"<code>False</code>"、"<code>Unknown</code>"のうちのいずれかです。</td></tr><tr><td style=text-align:left><code>lastProbeTime</code></td><td style=text-align:left>Pod Conditionが最後に確認されたときのタイムスタンプが表示されます。</td></tr><tr><td style=text-align:left><code>lastTransitionTime</code></td><td style=text-align:left>最後にPodのステータスの遷移があった際のタイムスタンプが表示されます。</td></tr><tr><td style=text-align:left><code>reason</code></td><td style=text-align:left>最後の状態遷移の理由を示す、機械可読のアッパーキャメルケースのテキストです。</td></tr><tr><td style=text-align:left><code>message</code></td><td style=text-align:left>ステータスの遷移に関する詳細を示す人間向けのメッセージです。</td></tr></tbody></table><h2 id=pod-readiness-gate>PodのReadiness</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code></div><p>追加のフィードバックやシグナルをPodStatus:_Pod readiness_に注入できるようにします。これを使用するには、Podの<code>spec</code>で<code>readinessGates</code>を設定して、kubeletがPodのReadinessを評価する追加の状態のリストを指定します。</p><p>ReadinessゲートはPodの<code>status.conditions</code>フィールドの現在の状態によって決まります。Kubernetesが<code>Podのstatus.conditions</code>フィールドでそのような状態を発見できない場合、ステータスはデフォルトで<code>False</code>になります。</p><p>以下はその例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>Kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readinessGates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>conditionType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready <span style=color:#bbb> </span><span style=color:#080;font-style:italic># これはビルトインのPodCondition</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># 追加のPodCondition</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://abcd...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>PodのConditionは、Kubernetesの<a href=/ja/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set>label key format</a>に準拠している必要があります。</p><h3 id=pod-readiness-status>PodのReadinessの状態</h3><p><code>kubectl patch</code>コマンドはオブジェクトステータスのパッチ適用をまだサポートしていません。Podにこれらの<code>status.conditions</code>を設定するには、アプリケーションと<a class=glossary-tooltip title='A specialized controller used to manage a custom resource' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operators>operators</a>は<code>PATCH</code>アクションを使用する必要があります。<a href=/docs/reference/using-api/client-libraries/>Kubernetes client library</a>を使用して、PodのReadinessのためにカスタムのPodのConditionを設定するコードを記述できます。</p><p>カスタムのPodのConditionが導入されるとPodは次の両方の条件に当てはまる場合<strong>のみ</strong>準備できていると評価されます:</p><ul><li>Pod内のすべてのコンテナが準備完了している。</li><li><code>ReadinessGates</code>で指定された条件が全て<code>True</code>である。</li></ul><p>Podのコンテナは準備完了ですが、少なくとも1つのカスタムのConditionが欠落しているか「False」の場合、kubeletはPodの<a href=#pod-condition>Condition</a>を<code>ContainersReady</code>に設定します。</p><h2 id=container-probes>コンテナのProbe</h2><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core>Probe</a> は <a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> により定期的に実行されるコンテナの診断です。診断を行うために、kubeletはコンテナに実装された <a href=/docs/reference/generated/kubernetes-api/v1.25/#handler-v1-core>Handler</a>を呼びます。Handlerには次の3つの種類があります:</p><ul><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#execaction-v1-core>ExecAction</a>:
コンテナ内で特定のコマンドを実行します。コマンドがステータス0で終了した場合に診断を成功と見まします。</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#tcpsocketaction-v1-core>TCPSocketAction</a>:
PodのIPの特定のポートにTCPチェックを行います。
そのポートが空いていれば診断を成功とみなします。</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#httpgetaction-v1-core>HTTPGetAction</a>:
PodのIPの特定のポートとパスに対して、HTTP GETのリクエストを送信します。
レスポンスのステータスコードが200以上400未満の際に診断を成功とみなします。</p></li></ul><p>各Probe 次の3つのうちの一つの結果を持ちます:</p><ul><li><code>Success</code>: コンテナの診断が成功しました。</li><li><code>Failure</code>: コンテナの診断が失敗しました。</li><li><code>Unknown</code>: コンテナの診断が失敗し、取れるアクションがありません。</li></ul><p>Kubeletは3種類のProbeを実行中のコンテナで行い、また反応することができます:</p><ul><li><p><code>livenessProbe</code>: コンテナが動いているかを示します。
livenessProbe に失敗すると、kubeletはコンテナを殺します、そしてコンテナは<a href=#restart-policy>restart policy</a>に従います。
コンテナにlivenessProbeが設定されていない場合、デフォルトの状態は<code>Success</code>です。</p></li><li><p><code>readinessProbe</code>: コンテナがリクエスト応答する準備ができているかを示します。
readinessProbeに失敗すると、エンドポイントコントローラーにより、ServiceからそのPodのIPアドレスが削除されます。
initial delay前のデフォルトのreadinessProbeの初期値は<code>Failure</code>です。
コンテナにreadinessProbeが設定されていない場合、デフォルトの状態は<code>Success</code>です。</p></li><li><p><code>startupProbe</code>: コンテナ内のアプリケーションが起動したかどうかを示します。
startupProbeが設定された場合、完了するまでその他のすべてのProbeは無効になります。
startupProbeに失敗すると、kubeletはコンテナを殺します、そしてコンテナは<a href=#restart-policy>restart policy</a>に従います。
コンテナにstartupProbeが設定されていない場合、デフォルトの状態は<code>Success</code>です。</p></li></ul><p>livenessProbe、readinessProbeまたはstartupProbeを設定する方法の詳細については、<a href=/ja/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>Liveness Probe、Readiness ProbeおよびStartup Probeを使用する</a>を参照してください。</p><h3 id=when-should-you-use-a-liveness-probe>livenessProbeをいつ使うべきか?</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code></div><p>コンテナ自体に問題が発生した場合や状態が悪くなった際にクラッシュすることができればlivenessProbeは不要です.
この場合kubeletが自動でPodの<code>restartPolicy</code>に基づいたアクションを実行します。</p><p>Probeに失敗したときにコンテナを殺したり再起動させたりするには、livenessProbeを設定し<code>restartPolicy</code>をAlwaysまたはOnFailureにします。</p><h3 id=when-should-you-use-a-readiness-probe>readinessProbeをいつ使うべきか?</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code></div><p>Probeが成功したときにのみPodにトラフィックを送信したい場合は、readinessProbeを指定します。
この場合readinessProbeはlivenessProbeと同じになる可能性がありますが、readinessProbeが存在するということは、Podがトラフィックを受けずに開始され、Probe成功が開始した後でトラフィックを受け始めることになります。コンテナが起動時に大きなデータ、構成ファイル、またはマイグレーションを読み込む必要がある場合は、readinessProbeを指定します。</p><p>コンテナがメンテナンスのために停止できるようにするには、livenessProbeとは異なる、特定のエンドポイントを確認するreadinessProbeを指定することができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Podが削除されたときにリクエストを来ないようにするためには必ずしもreadinessProbeが必要というわけではありません。Podの削除時にはreadinessProbeが存在するかどうかに関係なくPodは自動的に自身をunreadyにします。Pod内のコンテナが停止するのを待つ間Podはunreadyのままです。</div><h3 id=when-should-you-use-a-startup-probe>startupProbeをいつ使うべきか?</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>startupProbeは、サービスの開始に時間がかかるコンテナを持つPodに役立ちます。livenessProbeの間隔を長く設定するのではなく、コンテナの起動時に別のProbeを構成して、livenessProbeの間隔よりも長い時間を許可できます。
コンテナの起動時間が、<code>initialDelaySeconds + failureThreshold x periodSeconds</code>よりも長い場合は、livenessProbeと同じエンドポイントをチェックするためにstartupProbeを指定します。<code>periodSeconds</code>のデフォルトは30秒です。次に、<code>failureThreshold</code>をlivenessProbeのデフォルト値を変更せずにコンテナが起動できるように、十分に高い値を設定します。これによりデッドロックを防ぐことができます。</p><h2 id=pod-termination>Podの終了</h2><p>Podは、クラスター内のNodeで実行中のプロセスを表すため、不要になったときにそれらのプロセスを正常に終了できるようにすることが重要です(対照的なケースは、KILLシグナルで強制終了され、クリーンアップする機会がない場合)。</p><p>ユーザーは削除を要求可能であるべきで、プロセスがいつ終了するかを知ることができなければなりませんが、削除が最終的に完了することも保証できるべきです。ユーザーがPodの削除を要求すると、システムはPodが強制終了される前に意図された猶予期間を記録および追跡します。強制削除までの猶予期間がある場合、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>正常な終了を試みます。</p><p>通常、コンテナランタイムは各コンテナのメインプロセスにTERMシグナルを送信します。多くのコンテナランタイムは、コンテナイメージで定義されたSTOPSIGNAL値を尊重し、TERMシグナルの代わりにこれを送信します。猶予期間が終了すると、プロセスにKILLシグナルが送信され、Podは<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API server'>API server</a>から削除されます。プロセスの終了を待っている間にkubeletかコンテナランタイムの管理サービスが再起動されると、クラスターは元の猶予期間を含めて、最初からリトライされます。</p><p>フローの例は下のようになります。</p><ol><li>ユーザーがデフォルトの猶予期間(30秒)でPodを削除するために<code>kubectl</code>コマンドを送信する。</li><li>API server内のPodは、猶予期間を越えるとPodが「死んでいる」と見なされるように更新される。<br>削除中のPodに対して<code>kubectl describe</code>コマンドを使用すると、Podは「終了中」と表示される。<br>Podが実行されているNode上で、Podが終了しているとマークされている(正常な終了期間が設定されている)とkubeletが認識するとすぐに、kubeletはローカルでPodの終了プロセスを開始します。<ol><li>Pod内のコンテナの1つが<code>preStop</code><a href=/ja/docs/concepts/containers/container-lifecycle-hooks/#hook-details>フック</a>を定義している場合は、コンテナの内側で呼び出される。猶予期間が終了した後も <code>preStop</code>フックがまだ実行されている場合は、一度だけ猶予期間を延長される(2秒)。<div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>preStop</code>フックが完了するまでにより長い時間が必要な場合は、<code>terminationGracePeriodSeconds</code>を変更する必要があります。</div></li><li>kubeletはコンテナランタイムをトリガーして、コンテナ内のプロセス番号1にTERMシグナルを送信する。<div class="alert alert-info note callout" role=alert><strong>備考:</strong> Pod内のすべてのコンテナが同時にTERMシグナルを受信するわけではなく、シャットダウンの順序が問題になる場合はそれぞれに<code>preStop</code>フックを使用して同期することを検討する。</div></li></ol></li><li>kubeletが正常な終了を開始すると同時に、コントロールプレーンは、終了中のPodをEndpoints(および有効な場合はEndpointSlice)オブジェクトから削除します。これらのオブジェクトは、<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selector>selector</a>が設定された<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を表します。<a class=glossary-tooltip title=ReplicaSetは、指定された数のPodレプリカが一度に動作するように保証します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSets>ReplicaSets</a>とその他のワークロードリソースは、終了中のPodを有効なサービス中のReplicaSetとして扱いません。ゆっくりと終了するPodは、(サービスプロキシーのような)ロードバランサーが終了猶予期間が_始まる_とエンドポイントからそれらのPodを削除するので、トラフィックを継続して処理できません。</li><li>猶予期間が終了すると、kubeletは強制削除を開始する。コンテナランタイムは、Pod内でまだ実行中のプロセスに<code>SIGKILL</code>を送信する。kubeletは、コンテナランタイムが非表示の<code>pause</code>コンテナを使用している場合、そのコンテナをクリーンアップします。</li><li>kubeletは猶予期間を0(即時削除)に設定することでAPI server上のPodの削除を終了する。</li><li>API serverはPodのAPIオブジェクトを削除し、クライアントからは見えなくなります。</li></ol><h3 id=pod-termination-forced>Podの強制削除</h3><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> 強制削除は、Podによっては潜在的に危険な場合があるため、慎重に実行する必要があります。</div><p>デフォルトでは、すべての削除は30秒以内に正常に行われます。<code>kubectl delete</code> コマンドは、ユーザーがデフォルト値を上書きして独自の値を指定できるようにする <code>--grace-period=&lt;seconds></code> オプションをサポートします。</p><p><code>--grace-period</code>を<code>0</code>に設定した場合、PodはAPI serverから即座に強制的に削除されます。PodがNode上でまだ実行されている場合、その強制削除によりkubeletがトリガーされ、すぐにクリーンアップが開始されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 強制削除を実行するために <code>--grace-period=0</code> と共に <code>--force</code> というフラグを追加で指定する必要があります。</div><p>強制削除が実行されると、API serverは、Podが実行されていたNode上でPodが停止されたというkubeletからの確認を待ちません。API内のPodは直ちに削除されるため、新しいPodを同じ名前で作成できるようになります。Node上では、すぐに終了するように設定されるPodは、強制終了される前にわずかな猶予期間が与えられます。</p><p>StatefulSetのPodについては、<a href=/ja/docs/tasks/run-application/force-delete-stateful-set-pod/>StatefulSetからPodを削除するためのタスクのドキュメント</a>を参照してください。</p><h3 id=pod-garbage-collection>終了したPodのガベージコレクション</h3><p>失敗したPodは人間または<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>が明示的に削除するまで存在します。</p><p>コントロールプレーンは終了状態のPod(SucceededまたはFailedの<code>phase</code>を持つ)の数が設定された閾値(kube-controller-manager内の<code>terminated-pod-gc-threshold</code>によって定義される)を超えたとき、それらのPodを削除します。これはPodが作成されて時間とともに終了するため、リソースリークを避けます。</p><h2 id=次の項目>次の項目</h2><ul><li><p><a href=/ja/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>attaching handlers to Container lifecycle events</a>のハンズオンをやってみる</p></li><li><p><a href=/ja/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>Configure Liveness, Readiness and Startup Probes</a>のハンズオンをやってみる</p></li><li><p><a href=/ja/docs/concepts/containers/container-lifecycle-hooks/>Container lifecycle hooks</a>についてもっと学ぶ</p></li><li><p>APIのPod/コンテナステータスの詳細情報は<a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a>および<a href=/docs/reference/generated/kubernetes-api/v1.25/#containerstatus-v1-core>ContainerStatus</a>を参照してください</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ccbd4eeded6ab138d98b59175bd557e>4.1.3 - Initコンテナ</h1><p>このページでは、Initコンテナについて概観します。Initコンテナとは、<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>内でアプリケーションコンテナの前に実行される特別なコンテナです。
Initコンテナにはアプリケーションコンテナのイメージに存在しないセットアップスクリプトやユーティリティーを含めることができます。</p><p>Initコンテナは、Podの仕様のうち<code>containers</code>という配列(これがアプリケーションコンテナを示します)と並べて指定します。</p><h2 id=understanding-init-containers>Initコンテナを理解する</h2><p>単一の<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>は、Pod内にアプリケーションを実行している複数のコンテナを持つことができますが、同様に、アプリケーションコンテナが起動する前に実行されるInitコンテナも1つ以上持つことができます。</p><p>Initコンテナは下記の項目をのぞいて、通常のコンテナと全く同じものとなります。</p><ul><li>Initコンテナは常に完了するまで稼働します。</li><li>各Initコンテナは、次のInitコンテナが稼働する前に正常に完了しなくてはなりません。</li></ul><p>もしあるPodの単一のInitコンテナが失敗した場合、Kubeletは成功するまで何度もそのInitコンテナを再起動します。しかし、もしそのPodの<code>restartPolicy</code>がNeverで、そのPodの起動時にInitコンテナが失敗した場合、KubernetesはそのPod全体を失敗として扱います。</p><p>PodにInitコンテナを指定するためには、<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec>Podの仕様</a>に<code>initContainers</code>フィールドを<code>container</code>アイテムの配列として追加してください(アプリケーションの<code>containers</code>フィールドとそのコンテンツに似ています)。
詳細については、APIリファレンスの<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>Container</a>を参照してください。</p><p>Initコンテナのステータスは、<code>.status.initContainerStatuses</code>フィールドにコンテナのステータスの配列として返されます(<code>.status.containerStatuses</code>と同様)。</p><h3 id=differences-from-regular-containers>通常のコンテナとの違い</h3><p>Initコンテナは、リソースリミット、ボリューム、セキュリティ設定などのアプリケーションコンテナの全てのフィールドと機能をサポートしています。しかし、Initコンテナに対するリソースリクエストやリソースリミットの扱いは異なります。<a href=#resources>リソース</a>にて説明します。</p><p>また、InitコンテナはそのPodの準備ができる前に完了しなくてはならないため、<code>lifecycle</code>、<code>livenessProbe</code>、<code>readinessProbe</code>および<code>startupProbe</code>をサポートしていません。</p><p>複数のInitコンテナを単一のPodに対して指定した場合、KubeletはそれらのInitコンテナを1つずつ順番に実行します。各Initコンテナは、次のInitコンテナが稼働する前に正常終了しなくてはなりません。全てのInitコンテナの実行が完了すると、KubeletはPodのアプリケーションコンテナを初期化し、通常通り実行します。</p><h2 id=using-init-containers>Initコンテナを使用する</h2><p>Initコンテナはアプリケーションコンテナのイメージとは分離されているため、コンテナの起動に関連したコードにおいていくつかの利点があります。</p><ul><li>Initコンテナはアプリケーションのイメージに存在しないセットアップ用のユーティリティーやカスタムコードを含むことができます。例えば、セットアップ中に<code>sed</code>、<code>awk</code>、<code>python</code>や、<code>dig</code>のようなツールを使うためだけに、別のイメージを元にしてアプリケーションイメージを作る必要がなくなります。</li><li>アプリケーションイメージをビルドする役割とデプロイする役割は、共同で単一のアプリケーションイメージをビルドする必要がないため、それぞれ独立して実施することができます。</li><li>Initコンテナは同一Pod内のアプリケーションコンテナと別のファイルシステムビューで稼働することができます。その結果、アプリケーションコンテナがアクセスできない<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>に対するアクセス権限を得ることができます。</li><li>Initコンテナはアプリケーションコンテナが開始する前に完了するまで実行されるため、Initコンテナを使用することで、特定の前提条件が満たされるまでアプリケーションコンテナの起動をブロックしたり遅らせることができます。前提条件が満たされると、Pod内の全てのアプリケーションコンテナを並行して起動することができます。</li><li>Initコンテナはアプリケーションコンテナイメージの安全性を低下させるようなユーティリティーやカスタムコードを安全に実行することができます。不必要なツールを分離しておくことで、アプリケーションコンテナイメージのアタックサーフィスを制限することができます。</li></ul><h3 id=examples>例</h3><p>Initコンテナを活用する方法について、いくつかのアイデアを次に示します。</p><ul><li><p>シェルコマンドを使って単一の<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>が作成されるのを待機する。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>{</span>1..100<span style=color:#666>}</span>; <span style=color:#a2f;font-weight:700>do</span> sleep 1; <span style=color:#a2f;font-weight:700>if</span> dig myservice; <span style=color:#a2f;font-weight:700>then</span> <span style=color:#a2f>exit</span> 0; <span style=color:#a2f;font-weight:700>fi</span>; <span style=color:#a2f;font-weight:700>done</span>; <span style=color:#a2f>exit</span> <span style=color:#666>1</span>
</span></span></code></pre></div></li><li><p>以下のようなコマンドを使って下位のAPIからPodの情報をリモートサーバに登録する。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X POST http://<span style=color:#b8860b>$MANAGEMENT_SERVICE_HOST</span>:<span style=color:#b8860b>$MANAGEMENT_SERVICE_PORT</span>/register -d <span style=color:#b44>&#39;instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)&#39;</span>
</span></span></code></pre></div></li><li><p>以下のようなコマンドを使ってアプリケーションコンテナの起動を待機する。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sleep <span style=color:#666>60</span>
</span></span></code></pre></div></li><li><p>gitリポジトリを<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a>にクローンする。</p></li><li><p>いくつかの値を設定ファイルに配置し、メインのアプリケーションコンテナのための設定ファイルを動的に生成するためのテンプレートツールを実行する。例えば、そのPodの<code>POD_IP</code>の値を設定ファイルに配置し、Jinjaを使ってメインのアプリケーションコンテナの設定ファイルを生成する。</p></li></ul><h4 id=init-containers-in-use>Initコンテナの具体的な使用方法</h4><p>下記の例は2つのInitコンテナを含むシンプルなPodを定義しています。
1つ目のInitコンテナは<code>myservies</code>の起動を、2つ目のInitコンテナは<code>mydb</code>の起動をそれぞれ待ちます。両方のInitコンテナの実行が完了すると、Podは<code>spec</code>セクションにあるアプリケーションコンテナを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo The app is running! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>次のコマンドを実行して、このPodを開始できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f myapp.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>pod/myapp-pod created
</code></pre><p>そして次のコマンドでステータスを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m
</code></pre><p>より詳細な情報は次のコマンドで確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe -f myapp.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>Name:          myapp-pod
Namespace:     default
[...]
Labels:        app.kubernetes.io/name=MyApp
Status:        Pending
[...]
Init Containers:
  init-myservice:
[...]
    State:         Running
[...]
  init-mydb:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Containers:
  myapp-container:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  ---------    --------    -----    ----                      -------------                           --------      ------        -------
  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container with docker id 5ced34a04634; Security:[seccomp=unconfined]
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container with docker id 5ced34a04634
</code></pre><p>このPod内のInitコンテナのログを確認するためには、次のコマンドを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs myapp-pod -c init-myservice <span style=color:#080;font-style:italic># 1つ目のInitコンテナを調査する</span>
</span></span><span style=display:flex><span>kubectl logs myapp-pod -c init-mydb      <span style=color:#080;font-style:italic># 2つ目のInitコンテナを調査する</span>
</span></span></code></pre></div><p>この時点で、これらのInitコンテナは<code>mydb</code>と<code>myservice</code>という名前のServiceの検出を待機しています。</p><p>これらのServiceを検出させるための構成は以下の通りです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>mydb</code>および<code>myservice</code>というServiceを作成するために、以下のコマンドを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f services.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>service/myservice created
service/mydb created
</code></pre><p>Initコンテナが完了し、<code>myapp-pod</code>というPodがRunning状態に移行したことが確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>NAME        READY     STATUS    RESTARTS   AGE
myapp-pod   1/1       Running   0          9m
</code></pre><p>このシンプルな例を独自のInitコンテナを作成する際の参考にしてください。<a href=#what-s-next>次の項目</a>にさらに詳細な使用例に関するリンクがあります。</p><h2 id=detailed-behavior>Initコンテナのふるまいに関する詳細</h2><p>Podの起動時に、kubeletはネットワークおよびストレージの準備が整うまで、Initコンテナを実行可能な状態にしません。また、kubeletはPodのspecに定義された順番に従ってPodのInitコンテナを起動します。</p><p>各Initコンテナは次のInitコンテナが起動する前に正常に終了しなくてはなりません。もしあるInitコンテナがランタイムにより起動失敗した場合、もしくはエラーで終了した場合、そのPodの<code>restartPolicy</code>の値に従ってリトライされます。しかし、もしPodの<code>restartPolicy</code>が<code>Always</code>に設定されていた場合、Initコンテナの<code>restartPolicy</code>は<code>OnFailure</code>が適用されます。</p><p>Podは全てのInitコンテナが完了するまで<code>Ready</code>状態となりません。Initコンテナ上のポートはServiceによって集約されません。初期化中のPodのステータスは<code>Pending</code>となりますが、<code>Initialized</code>という値はtrueとなります。</p><p>もしそのPodを<a href=#pod-restart-reasons>再起動</a>するとき、または再起動されたとき、全てのInitコンテナは必ず再度実行されます。</p><p>Initコンテナの仕様の変更は、コンテナイメージのフィールドのみに制限されています。
Initコンテナのイメージフィールド値を変更すると、そのPodは再起動されます。</p><p>Initコンテナは何度も再起動、リトライおよび再実行可能なため、べき等(Idempotent)である必要があります。特に、<code>EmptyDirs</code>にファイルを書き込むコードは、書き込み先のファイルがすでに存在している可能性を考慮に入れる必要があります。</p><p>Initコンテナはアプリケーションコンテナの全てのフィールドを持っています。しかしKubernetesは、Initコンテナが完了と異なる状態を定義できないため<code>readinessProbe</code>が使用されることを禁止しています。これはバリデーションの際に適用されます。</p><p>Initコンテナがずっと失敗し続けたままの状態を防ぐために、Podに<code>activeDeadlineSeconds</code>を設定してください。<code>activeDeadlineSeconds</code>の設定はInitコンテナが実行中の時間にも適用されます。しかし<code>activeDeadlineSeconds</code>はInitコンテナが終了した後でも効果があるため、チームがアプリケーションをJobとしてデプロイする場合にのみ使用することが推奨されています。
すでに正しく動作しているPodは<code>activeDeadlineSeconds</code>を設定すると強制終了されます。</p><p>Pod内の各アプリケーションコンテナとInitコンテナの名前はユニークである必要があります。他のコンテナと同じ名前を共有していた場合、バリデーションエラーが返されます。</p><h3 id=resources>リソース</h3><p>Initコンテナの順序と実行を考えるとき、リソースの使用に関して下記のルールが適用されます。</p><ul><li>全てのInitコンテナの中で定義された最も高いリソースリクエストとリソースリミットが、<em>有効なinitリクエスト／リミット</em> になります。いずれかのリソースでリミットが設定されていない場合、これが最上級のリミットとみなされます。</li><li>Podのリソースの<em>有効なリクエスト／リミット</em> は、下記の2つの中のどちらか高い方となります。<ul><li>リソースに対する全てのアプリケーションコンテナのリクエスト／リミットの合計</li><li>リソースに対する有効なinitリクエスト／リミット</li></ul></li><li>スケジューリングは有効なリクエスト／リミットに基づいて実行されます。つまり、InitコンテナはPodの生存中には使用されない初期化用のリソースを確保することができます。</li><li>Podの<em>有効なQoS(quality of service)ティアー</em> は、Initコンテナとアプリケーションコンテナで同様です。</li></ul><p>クォータとリミットは有効なPodリクエストとリミットに基づいて適用されます。</p><p>Podレベルのコントロールグループ(cgroups)は、スケジューラーと同様に、有効なPodリクエストとリミットに基づいています。</p><h3 id=pod-restart-reasons>Podの再起動の理由</h3><p>以下の理由によりPodは再起動し、Initコンテナの再実行も引き起こす可能性があります。</p><ul><li>そのPodのインフラストラクチャーコンテナが再起動された場合。これはあまり起きるものでなく、Nodeに対するルート権限を持ったユーザーにより行われることがあります。</li><li><code>restartPolicy</code>が<code>Always</code>と設定されているPod内の全てのコンテナが停止され、強制的に再起動が行われたことで、ガベージコレクションによりInitコンテナの完了記録が失われた場合。</li></ul><p>Kubernetes v1.20以降では、initコンテナのイメージが変更されたり、ガベージコレクションによってinitコンテナの完了記録が失われたりした場合でも、Podは再起動されません。以前のバージョンを使用している場合は、対応バージョンのドキュメントを参照してください。</p><h2 id=what-s-next>次の項目</h2><ul><li><a href=/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container>Initコンテナを含むPodの作成</a>方法について学ぶ。</li><li><a href=/ja/docs/tasks/debug-application-cluster/debug-init-containers/>Initコンテナのデバッグ</a>を行う方法について学ぶ。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4e9b9cbc9776b12e7335c53da377c9c8>4.1.4 - Pod Preset</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.6 [alpha]</code></div><p>このページではPodPresetについて概観します。PodPresetは、Podの作成時にそのPodに対して、Secret、Volume、VolumeMountや環境変数など、特定の情報を注入するためのオブジェクトです。</p><h2 id=podpresetを理解する>PodPresetを理解する</h2><p><code>PodPreset</code>はPodの作成時に追加のランタイム要求を注入するためのAPIリソースです。ユーザーはPodPresetを適用する対象のPodを指定するために、<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルセレクター</a>を使用します。</p><p>PodPresetの使用により、Podテンプレートの作者はPodにおいて、全ての情報を明示的に指定する必要がなくなります。この方法により、特定のServiceを使っているPodテンプレートの作者は、そのServiceについて全ての詳細を知る必要がなくなります。</p><h2 id=enable-pod-preset>クラスターでPodPresetを有効にする</h2><p>ユーザーのクラスター内でPodPresetを使うためには、クラスター内の以下の項目をご確認ください。</p><ol><li><code>settings.k8s.io/v1alpha1/podpreset</code>というAPIを有効にします。例えば、これはAPI Serverの <code>--runtime-config</code>オプションに<code>settings.k8s.io/v1alpha1=true</code>を含むことで可能になります。Minikubeにおいては、クラスターの起動時に<code>--extra-config=apiserver.runtime-config=settings.k8s.io/v1alpha1=true</code>をつけることで可能です。</li><li><code>PodPreset</code>に対する管理コントローラーを有効にします。これを行うための1つの方法として、API Serverの<code>--enable-admission-plugins</code>オプションの値に<code>PodPreset</code>を含む方法があります。例えば、Minikubeにおいては、クラスターの起動時に</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--extra-config<span style=color:#666>=</span>apiserver.enable-admission-plugins<span style=color:#666>=</span>NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodPreset
</span></span></code></pre></div><p>を追加することで可能になります。</p><h2 id=podpresetはどのように動くか>PodPresetはどのように動くか</h2><p>Kubernetesは<code>PodPreset</code>に対する管理用コントローラーを提供し、これが有効になっている時、コントローラーはリクエストされたPod作成要求に対してPodPresetを適用します。Pod作成要求が発生した時、Kubernetesシステムは下記の処理を行います。</p><ol><li>使用可能な全ての<code>PodPreset</code>を取得する。</li><li>それらの<code>PodPreset</code>のラベルセレクターが、作成されたPod上のラベルと一致するかチェックする。</li><li><code>PodPreset</code>によって定義された様々なリソースを、作成されたPodにマージしようと試みる。</li><li>エラーが起きた時、そのPod上でマージエラーが起きたことを説明するイベントをスローし、<code>PodPreset</code>からリソースを1つも注入されていないPodを作成します。</li><li><code>PodPreset</code>によって修正されたことを示すために、マージ後の修正されたPodにアノテーションをつけます。そのアノテーションは<code>podpreset.admission.kubernetes.io/podpreset-&lt;PodPreset名>: "&lt;リソースのバージョン>"</code>という形式になります。</li></ol><p>各Podは0以上のPodPresetにマッチすることができます。そして各PodPresetは0以上のPodに適用されます。単一のPodPresetが1以上のPodに適用された時、KubernetesはそのPodのSpecを修正します。<code>env</code>、<code>envFrom</code>、<code>volumeMounts</code>への変更があると、KubernetesはそのPod内の全てのコンテナのSpecを修正します。<code>volumes</code>への変更があった場合、KubernetesはそのPodのSpecを修正します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>単一のPodPresetは必要に応じてPodのspec内の以下のフィールドを修正することができます。</p><ul><li><code>.spec.containers</code>フィールド</li><li><code>.spec.initContainers</code>フィールド</li></ul></div><h3 id=特定のpodに対するpodpresetを無効にする>特定のPodに対するPodPresetを無効にする</h3><p>PodPresetによるPodの変更を受け付けたくないようなインスタンスがある場合があります。このようなケースでは、ユーザーはそのPodの<code>.spec</code>内に次のような形式のアノテーションを追加できます。<br><code>podpreset.admission.kubernetes.io/exclude: "true"</code></p><h2 id=次の項目>次の項目</h2><p><a href=/docs/tasks/inject-data-application/podpreset/>PodPresetを使ったPodへのデータの注入</a></p><p>PodPresetの内部についてのさらなる情報は、<a href=https://git.k8s.io/community/contributors/design-proposals/service-catalog/pod-preset.md>PodPresetのデザインプロポーザル</a>を参照してください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-53a1005011e1bda2ce81819aad7c8b32>4.1.5 - エフェメラルコンテナ</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>このページでは、特別な種類のコンテナであるエフェメラルコンテナの概要を説明します。エフェメラルコンテナは、トラブルシューティングなどのユーザーが開始するアクションを実行するために、すでに存在する<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>内で一時的に実行するコンテナです。エフェメラルコンテナは、アプリケーションの構築ではなく、serviceの調査のために利用します。</p><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> エフェメラルコンテナは初期のアルファ状態であり、本番クラスタには適しません。<a href=/docs/reference/using-api/deprecation-policy/>Kubernetesの非推奨ポリシー</a>に従って、このアルファ機能は、将来大きく変更されたり、完全に削除される可能性があります。</div><h2 id=エフェメラルコンテナを理解する>エフェメラルコンテナを理解する</h2><p><a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>は、Kubernetesのアプリケーションの基本的なビルディングブロックです。Podは破棄可能かつ置き換え可能であることが想定されているため、一度Podが作成されると新しいコンテナを追加することはできません。その代わりに、通常は<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>を使用してPodを削除して置き換えます。</p><p>たとえば、再現困難なバグのトラブルシューティングなどのために、すでに存在するPodの状態を調査する必要が出てくることがあります。このような場合、既存のPod内でエフェメラルコンテナを実行することで、Podの状態を調査したり、任意のコマンドを実行したりできます。</p><h3 id=エフェメラルコンテナとは何か>エフェメラルコンテナとは何か？</h3><p>エフェメラルコンテナは、他のコンテナと異なり、リソースや実行が保証されず、自動的に再起動されることも決してないため、アプリケーションを構築する目的には適しません。エフェメラルコンテナは、通常のコンテナと同じ<code>ContainerSpec</code>で記述されますが、多くのフィールドに互換性がなかったり、使用できなくなっています。</p><ul><li>エフェメラルコンテナはポートを持つことができないため、<code>ports</code>、<code>livenessProbe</code>、<code>readinessProbe</code>などは使えなくなっています。</li><li>Podリソースの割り当てはイミュータブルであるため、<code>resources</code>の設定が禁止されています。</li><li>利用が許可されているフィールドの一覧については、<a href=/docs/reference/generated/kubernetes-api/v1.25/#ephemeralcontainer-v1-core>EphemeralContainerのリファレンスドキュメント</a>を参照してください。</li></ul><p>エフェメラルコンテナは、直接<code>pod.spec</code>に追加するのではなく、API内の特別な<code>ephemeralcontainers</code>ハンドラを使用して作成します。そのため、エフェメラルコンテナを<code>kubectl edit</code>を使用して追加することはできません。</p><p>エフェメラルコンテナをPodに追加した後は、通常のコンテナのようにエフェメラルコンテナを変更または削除することはできません。</p><h2 id=エフェメラルコンテナの用途>エフェメラルコンテナの用途</h2><p>エフェメラルコンテナは、コンテナがクラッシュしてしまったり、コンテナイメージにデバッグ用ユーティリティが同梱されていない場合など、<code>kubectl exec</code>では不十分なときにインタラクティブなトラブルシューティングを行うために役立ちます。</p><p>特に、<a href=https://github.com/GoogleContainerTools/distroless>distrolessイメージ</a>を利用すると、攻撃対象領域を減らし、バグや脆弱性を露出する可能性を減らせる最小のコンテナイメージをデプロイできるようになります。distrolessイメージにはシェルもデバッグ用のユーティリティも含まれないため、<code>kubectl exec</code>のみを使用してdistrolessイメージのトラブルシューティングを行うのは困難です。</p><p>エフェメラルコンテナを利用する場合には、他のコンテナ内のプロセスにアクセスできるように、<a href=/ja/docs/tasks/configure-pod-container/share-process-namespace/>プロセス名前空間の共有</a>を有効にすると便利です。</p><p>エフェメラルコンテナを利用してトラブルシューティングを行う例については、<a href=/docs/tasks/debug/debug-application/debug-running-pod/#ephemeral-container>デバッグ用のエフェメラルコンテナを使用してデバッグする</a>を参照してください。</p><h2 id=ephemeral-containers-api>Ephemeral containers API</h2><div class="alert alert-info note callout" role=alert><strong>備考:</strong> このセクションの例を実行するには、<code>EphemeralContainers</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にして、Kubernetesクライアントとサーバーのバージョンをv1.16以上にする必要があります。</div><p>このセクションの例では、API内でエフェメラルコンテナを表示する方法を示します。通常は、APIを直接呼び出すのではなく、<code>kubectl alpha debug</code>やその他の<code>kubectl</code><a href=/docs/tasks/extend-kubectl/kubectl-plugins/>プラグイン</a>を使用して、これらのステップを自動化します。</p><p>エフェメラルコンテナは、Podの<code>ephemeralcontainers</code>サブリソースを使用して作成されます。このサブリソースは、<code>kubectl --raw</code>を使用して確認できます。まずはじめに、以下に<code>EphemeralContainers</code>リストとして追加するためのエフェメラルコンテナを示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example-pod&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>: [{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;command&#34;</span>: [
</span></span><span style=display:flex><span>            <span style=color:#b44>&#34;sh&#34;</span>
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>: <span style=color:#b44>&#34;IfNotPresent&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;debugger&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;stdin&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;tty&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>: <span style=color:#b44>&#34;File&#34;</span>
</span></span><span style=display:flex><span>    }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>すでに実行中の<code>example-pod</code>のエフェメラルコンテナを更新するには、次のコマンドを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace --raw /api/v1/namespaces/default/pods/example-pod/ephemeralcontainers -f ec.json
</span></span></code></pre></div><p>このコマンドを実行すると、新しいエフェメラルコンテナのリストが返されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;example-pod&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;selfLink&#34;</span>:<span style=color:#b44>&#34;/api/v1/namespaces/default/pods/example-pod/ephemeralcontainers&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;uid&#34;</span>:<span style=color:#b44>&#34;a14a6d9b-62f2-4119-9d8e-e2ed6bc3a47c&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>:<span style=color:#b44>&#34;15886&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>:<span style=color:#b44>&#34;2019-08-29T06:41:42Z&#34;</span>
</span></span><span style=display:flex><span>   },
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>:[
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;debugger&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;busybox&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;command&#34;</span>:[
</span></span><span style=display:flex><span>            <span style=color:#b44>&#34;sh&#34;</span>
</span></span><span style=display:flex><span>         ],
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;resources&#34;</span>:{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         },
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>:<span style=color:#b44>&#34;File&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>:<span style=color:#b44>&#34;IfNotPresent&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;stdin&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;tty&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>新しく作成されたエフェメラルコンテナの状態を確認するには、<code>kubectl describe</code>を使用します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod example-pod
</span></span></code></pre></div><pre tabindex=0><code>...
Ephemeral Containers:
  debugger:
    Container ID:  docker://cf81908f149e7e9213d3c3644eda55c72efaff67652a2685c1146f0ce151e80f
    Image:         busybox
    Image ID:      docker-pullable://busybox@sha256:9f1003c480699be56815db0f8146ad2e22efea85129b5b5983d0e0fb52d9ab70
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Command:
      sh
    State:          Running
      Started:      Thu, 29 Aug 2019 06:42:21 +0000
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:         &lt;none&gt;
...
</code></pre><p>新しいエフェメラルコンテナとやりとりをするには、他のコンテナと同じように、<code>kubectl attach</code>、<code>kubectl exec</code>、<code>kubectl logs</code>などのコマンドが利用できます。例えば、次のようなコマンドが実行できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it example-pod -c debugger
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-89637410cacae45a36ab1cc278c482eb>4.2 - ワークロードリソース</h1></div><div class=td-content><h1 id=pg-a2dc0393e0c4079e1c504b6429844e86>4.2.1 - Deployment</h1><p><em>Deployment</em> は<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>と<a class=glossary-tooltip title=ReplicaSetは、指定された数のPodレプリカが一度に動作するように保証します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSet>ReplicaSet</a>の宣言的なアップデート機能を提供します。</p><p>Deploymentにおいて <em>理想的な状態</em> を記述すると、Deployment<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>は指定された頻度で現在の状態を理想的な状態に変更します。Deploymentを定義することによって、新しいReplicaSetを作成したり、既存のDeploymentを削除して新しいDeploymentで全てのリソースを適用できます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentによって作成されたReplicaSetを管理しないでください。ご自身のユースケースが以下の項目に含まれない場合、メインのKubernetesリポジトリーにIssueを作成することを検討してください。</div><h2 id=ユースケース>ユースケース</h2><p>以下の項目はDeploymentの典型的なユースケースです。</p><ul><li>ReplicaSetをロールアウトするために<a href=#creating-a-deployment>Deploymentの作成</a>を行う: ReplicaSetはバックグラウンドでPodを作成します。Podの作成が完了したかどうかは、ロールアウトのステータスを確認してください。</li><li>DeploymentのPodTemplateSpecを更新することにより<a href=#updating-a-deployment>Podの新しい状態を宣言する</a>: 新しいReplicaSetが作成され、Deploymentは指定された頻度で古いReplicaSetから新しいReplicaSetへのPodの移行を管理します。新しいReplicaSetはDeploymentのリビジョンを更新します。</li><li>Deploymentの現在の状態が不安定な場合、<a href=#rolling-back-a-deployment>Deploymentのロールバック</a>をする: ロールバックによる各更新作業は、Deploymentのリビジョンを更新します。</li><li>より多くの負荷をさばけるように、<a href=#scaling-a-deployment>Deploymentをスケールアップ</a>する。</li><li>PodTemplateSpecに対する複数の修正を適用するために<a href=#pausing-and-resuming-a-deployment>Deploymentを停止(Pause)し</a>、それを再開して新しいロールアウトを開始します。</li><li><a href=#deployment-status>Deploymentのステータス</a> をロールアウトが失敗したサインとして利用する。</li><li>今後必要としない<a href=#clean-up-policy>古いReplicaSetのクリーンアップ</a></li></ul><h2 id=creating-a-deployment>Deploymentの作成</h2><p>以下はDeploymentの例です。これは<code>nginx</code>Podのレプリカを3つ持つReplicaSetを作成します。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/nginx-deployment.yaml download=controllers/nginx-deployment.yaml><code>controllers/nginx-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-nginx-deployment-yaml")' title="Copy controllers/nginx-deployment.yaml to clipboard"></img></div><div class=includecode id=controllers-nginx-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>この例では、</p><ul><li><p><code>.metadata.name</code>フィールドで指定された<code>nginx-deployment</code>という名前のDeploymentが作成されます。</p></li><li><p>このDeploymentは<code>.spec.replicas</code>フィールドで指定された通り、3つのレプリカPodを作成します。</p></li><li><p><code>.spec.selector</code>フィールドは、Deploymentが管理するPodのラベルを定義します。ここでは、Podテンプレートにて定義されたラベル(<code>app: nginx</code>)を選択しています。しかし、PodTemplate自体がそのルールを満たす限り、さらに洗練された方法でセレクターを指定することができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>.spec.selector.matchLabels</code>フィールドはキーバリューペアのマップです。
<code>matchLabels</code>マップにおいて、{key, value}というペアは、keyというフィールドの値が"key"で、その演算子が"In"で、値の配列が"value"のみ含むような<code>matchExpressions</code>の要素と等しくなります。
<code>matchLabels</code>と<code>matchExpressions</code>の両方が設定された場合、条件に一致するには両方とも満たす必要があります。</div></li><li><p><code>template</code>フィールドは、以下のサブフィールドを持ちます。:</p><ul><li>Podは<code>.metadata.labels</code>フィールドによって指定された<code>app: nginx</code>というラベルがつけられます。</li><li>PodTemplate、または<code>.template.spec</code>フィールドは、Podが<code>nginx</code>という名前で<a href=https://hub.docker.com/>Docker Hub</a>にある<code>nginx</code>のバージョン1.14.2が動くコンテナを1つ動かすことを示します。</li><li>1つのコンテナを作成し、<code>.spec.template.spec.containers[0].name</code>フィールドを使って<code>nginx</code>という名前をつけます。</li></ul></li></ul><p>作成を始める前に、Kubernetesクラスターが稼働していることを確認してください。
上記のDeploymentを作成するためには以下のステップにしたがってください:</p><ol><li>以下のコマンドを実行してDeploymentを作成してください。</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml
</span></span></code></pre></div><ol start=2><li>Deploymentが作成されたことを確認するために、<code>kubectl get deployments</code>を実行してください。</li></ol><p>Deploymentがまだ作成中の場合、コマンドの実行結果は以下のとおりです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   0/3     <span style=color:#666>0</span>            <span style=color:#666>0</span>           1s
</span></span></code></pre></div><p>クラスターにてDeploymentを調査するとき、以下のフィールドが出力されます。</p><ul><li><code>NAME</code>は、クラスター内にあるDeploymentの名前一覧です。</li><li><code>READY</code>は、ユーザーが使用できるアプリケーションのレプリカの数です。使用可能な数/理想的な数の形式で表示されます。</li><li><code>UP-TO-DATE</code>は、理想的な状態を満たすためにアップデートが完了したレプリカの数です。</li><li><code>AVAILABLE</code>は、ユーザーが利用可能なレプリカの数です。</li><li><code>AGE</code>は、アプリケーションが稼働してからの時間です。</li></ul><p><code>.spec.replicas</code>フィールドの値によると、理想的なレプリカ数は3であることがわかります。</p><ol start=3><li>Deploymentのロールアウトステータスを確認するために、<code>kubectl rollout status deployment.v1.apps/nginx-deployment</code>を実行してください。</li></ol><p>コマンドの実行結果は以下のとおりです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Waiting <span style=color:#a2f;font-weight:700>for</span> rollout to finish: <span style=color:#666>2</span> out of <span style=color:#666>3</span> new replicas have been updated...
</span></span><span style=display:flex><span>deployment <span style=color:#b44>&#34;nginx-deployment&#34;</span> successfully rolled out
</span></span></code></pre></div><ol start=4><li>数秒後、再度<code>kubectl get deployments</code>を実行してください。
コマンドの実行結果は以下のとおりです。</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   3/3     <span style=color:#666>3</span>            <span style=color:#666>3</span>           18s
</span></span></code></pre></div><p>Deploymentが3つ全てのレプリカを作成して、全てのレプリカが最新(Podが最新のPodテンプレートを含んでいる)になり、利用可能となっていることを確認してください。</p><ol start=5><li>Deploymentによって作成されたReplicaSet(<code>rs</code>)を確認するには<code>kubectl get rs</code>を実行してください。コマンドの実行結果は以下のとおりです:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                          DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>nginx-deployment-75675f5897   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       18s
</span></span></code></pre></div><p>ReplicaSetの出力には次のフィールドが表示されます:</p><ul><li><code>NAME</code>は、名前空間内にあるReplicaSetの名前の一覧です。</li><li><code>DESIRED</code>は、アプリケーションの理想的な <em>レプリカ</em> の値です。これはDeploymentを作成したときに定義したもので、これが <em>理想的な状態</em> と呼ばれるものです。</li><li><code>CURRENT</code>は現在実行されているレプリカの数です。</li><li><code>READY</code>は、ユーザーが使用できるアプリケーションのレプリカの数です。</li><li><code>AGE</code>は、アプリケーションが稼働してからの時間です。</li></ul><p>ReplicaSetの名前は<code>[Deployment名]-[ランダム文字列]</code>という形式になることに注意してください。ランダム文字列はランダムに生成され、pod-template-hashをシードとして使用します。</p><ol start=6><li>各Podにラベルが自動的に付けられるのを確認するには<code>kubectl get pods --show-labels</code>を実行してください。
コマンドの実行結果は以下のとおりです:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                                READY     STATUS    RESTARTS   AGE       LABELS
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-7ci7o   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-kzszj   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-qqcnn   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
</span></span></code></pre></div><p>作成されたReplicaSetは<code>nginx</code>Podを3つ作成することを保証します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>Deploymentに対して適切なセレクターとPodテンプレートのラベルを設定する必要があります(このケースでは<code>app: nginx</code>)。</p><p>ラベルやセレクターを他のコントローラーと重複させないでください(他のDeploymentやStatefulSetを含む)。Kubernetesはユーザーがラベルを重複させることを阻止しないため、複数のコントローラーでセレクターの重複が発生すると、コントローラー間で衝突し予期せぬふるまいをすることになります。</p></div><h3 id=pod-template-hashラベル>pod-template-hashラベル</h3><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> このラベルを変更しないでください。</div><p><code>pod-template-hash</code>ラベルはDeploymentコントローラーによってDeploymentが作成し適用した各ReplicaSetに対して追加されます。</p><p>このラベルはDeploymentが管理するReplicaSetが重複しないことを保証します。このラベルはReplicaSetの<code>PodTemplate</code>をハッシュ化することにより生成され、生成されたハッシュ値はラベル値としてReplicaSetセレクター、Podテンプレートラベル、ReplicaSetが作成した全てのPodに対して追加されます。</p><h2 id=updating-a-deployment>Deploymentの更新</h2><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentのロールアウトは、DeploymentのPodテンプレート(この場合<code>.spec.template</code>)が変更された場合にのみトリガーされます。例えばテンプレートのラベルもしくはコンテナーイメージが更新された場合です。Deploymentのスケールのような更新では、ロールアウトはトリガーされません。</div><p>Deploymentを更新するには以下のステップに従ってください。</p><ol><li><p>nginxのPodで、<code>nginx:1.14.2</code>イメージの代わりに<code>nginx:1.16.1</code>を使うように更新します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</span></span></code></pre></div><p>または単に次のコマンドを使用します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre><p>また、Deploymentを<code>編集</code>して、<code>.spec.template.spec.containers[0].image</code>を<code>nginx:1.14.2</code>から<code>nginx:1.16.1</code>に変更することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment edited
</code></pre></li><li><p>ロールアウトのステータスを確認するには、以下のコマンドを実行してください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
</code></pre><p>もしくは</p><pre tabindex=0><code>deployment &#34;nginx-deployment&#34; successfully rolled out
</code></pre></li></ol><p>更新されたDeploymentのさらなる情報を取得するには、以下を確認してください。</p><ul><li><p>ロールアウトが成功したあと、<code>kubectl get deployments</code>を実行してDeploymentを確認できます。
実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           36s
</code></pre></li><li><p>Deploymentが新しいReplicaSetを作成してPodを更新させたり、新しいReplicaSetのレプリカを3にスケールアップさせたり、古いReplicaSetのレプリカを0にスケールダウンさせるのを確認するには<code>kubectl get rs</code>を実行してください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       6s
nginx-deployment-2035384211   0         0         0       36s
</code></pre></li><li><p><code>get pods</code>を実行させると、新しいPodのみ確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1564180365-khku8   1/1       Running   0          14s
nginx-deployment-1564180365-nacti   1/1       Running   0          14s
nginx-deployment-1564180365-z9gth   1/1       Running   0          14s
</code></pre><p>次にPodを更新させたいときは、DeploymentのPodテンプレートを再度更新するだけです。</p><p>Deploymentは、Podが更新されている間に特定の数のPodのみ停止状態になることを保証します。デフォルトでは、目標とするPod数の少なくとも75%が稼働状態であることを保証します(25% max unavailable)。</p><p>また、DeploymentはPodが更新されている間に、目標とするPod数を特定の数まで超えてPodを稼働させることを保証します。デフォルトでは、目標とするPod数に対して最大でも125%を超えてPodを稼働させることを保証します(25% max surge)。</p><p>例えば、上記で説明したDeploymentの状態を注意深く見ると、最初に新しいPodが作成され、次に古いPodが削除されるのを確認できます。十分な数の新しいPodが稼働するまでは、Deploymentは古いPodを削除しません。また十分な数の古いPodが削除しない限り新しいPodは作成されません。少なくとも2つのPodが利用可能で、最大でもトータルで4つのPodが利用可能になっていることを保証します。</p></li><li><p>Deploymentの詳細情報を取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployments
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=2
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
   Containers:
    nginx:
      Image:        nginx:1.16.1
      Port:         80/TCP
      Environment:  &lt;none&gt;
      Mounts:       &lt;none&gt;
    Volumes:        &lt;none&gt;
  Conditions:
    Type           Status  Reason
    ----           ------  ------
    Available      True    MinimumReplicasAvailable
    Progressing    True    NewReplicaSetAvailable
  OldReplicaSets:  &lt;none&gt;
  NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)
  Events:
    Type    Reason             Age   From                   Message
    ----    ------             ----  ----                   -------
    Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica set nginx-deployment-2035384211 to 3
    Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 1
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 2
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 2
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 1
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 3
    Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 0
</code></pre><p>最初にDeploymentを作成した時、ReplicaSet(nginx-deployment-2035384211)を作成してすぐにレプリカ数を3にスケールするのを確認できます。Deploymentを更新すると新しいReplicaSet(nginx-deployment-1564180365)を作成してレプリカ数を1にスケールアップし、古いReplicaSeetを2にスケールダウンさせます。これは常に最低でも2つのPodが利用可能で、かつ最大4つのPodが作成されている状態にするためです。Deploymentは同じローリングアップ戦略に従って新しいReplicaSetのスケールアップと古いReplicaSetのスケールダウンを続けます。最終的に新しいReplicaSetを3にスケールアップさせ、古いReplicaSetを0にスケールダウンさせます。</p></li></ul><h3 id=ロールオーバー-リアルタイムでの複数のpodの更新>ロールオーバー (リアルタイムでの複数のPodの更新)</h3><p>Deploymentコントローラーにより、新しいDeploymentが観測される度にReplicaSetが作成され、理想とするレプリカ数のPodを作成します。Deploymentが更新されると、既存のReplicaSetが管理するPodのラベルが<code>.spec.selector</code>にマッチするが、テンプレートが<code>.spec.template</code>にマッチしない場合はスケールダウンされます。最終的に、新しいReplicaSetは<code>.spec.replicas</code>の値にスケールアップされ、古いReplicaSetは0にスケールダウンされます。</p><p>Deploymentのロールアウトが進行中にDeploymentを更新すると、Deploymentは更新する毎に新しいReplicaSetを作成してスケールアップさせ、以前にスケールアップしたReplicaSetのロールオーバーを行います。Deploymentは更新前のReplicaSetを古いReplicaSetのリストに追加し、スケールダウンを開始します。</p><p>例えば、5つのレプリカを持つ<code>nginx:1.14.2</code>のDeploymentを作成し、<code>nginx:1.14.2</code>の3つのレプリカが作成されているときに5つのレプリカを持つ<code>nginx:1.16.1</code>に更新します。このケースではDeploymentは作成済みの<code>nginx:1.14.2</code>の3つのPodをすぐに削除し、<code>nginx:1.16.1</code>のPodの作成を開始します。<code>nginx:1.14.2</code>の5つのレプリカを全て作成するのを待つことはありません。</p><h3 id=ラベルセレクターの更新>ラベルセレクターの更新</h3><p>通常、ラベルセレクターを更新することは推奨されません。事前にラベルセレクターの使い方を計画しておきましょう。いかなる場合であっても更新が必要なときは十分に注意を払い、変更時の影響範囲を把握しておきましょう。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>apps/v1</code>API バージョンにおいて、Deploymentのラベルセレクターは作成後に不変となります。</div><ul><li>セレクターの追加は、Deployment Specのテンプレートラベルも新しいラベルで更新する必要があります。そうでない場合はバリデーションエラーが返されます。この変更は重複がない更新となります。これは新しいセレクターは古いセレクターを持つReplicaSetとPodを選択せず、結果として古い全てのReplicaSetがみなし子状態になり、新しいReplicaSetを作成することを意味します。</li><li>セレクターの更新により、セレクターキー内の既存の値が変更されます。これにより、セレクターの追加と同じふるまいをします。</li><li>セレクターの削除により、Deploymentのセレクターから存在している値を削除します。これはPodテンプレートのラベルに関する変更を要求しません。既存のReplicaSetはみなし子状態にならず、新しいReplicaSetは作成されませんが、削除されたラベルは既存のPodとReplicaSetでは残り続けます。</li></ul><h2 id=rolling-back-a-deployment>Deploymentのロールバック</h2><p>例えば、クラッシュループ状態などのようにDeploymentが不安定な場合においては、Deploymentをロールバックしたくなることがあります。Deploymentの全てのロールアウト履歴は、いつでもロールバックできるようにデフォルトでシステムに保持されています(リビジョン履歴の上限は設定することで変更可能です)。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentのリビジョンは、Deploymentのロールアウトがトリガーされた時に作成されます。これはDeploymentのPodテンプレート(<code>.spec.template</code>)が変更されたときのみ新しいリビジョンが作成されることを意味します。Deploymentのスケーリングなど、他の種類の更新においてはDeploymentのリビジョンは作成されません。これは手動もしくはオートスケーリングを同時に行うことができるようにするためです。これは過去のリビジョンにロールバックするとき、DeploymentのPodテンプレートの箇所のみロールバックされることを意味します。</div><ul><li><p><code>nginx:1.16.1</code>の代わりに<code>nginx:1.161</code>というイメージに更新して、Deploymentの更新中にタイプミスをしたと仮定します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.161
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre></li><li><p>このロールアウトはうまくいきません。ロールアウトのステータスを見るとそれを確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Waiting for rollout to finish: 1 out of 3 new replicas have been updated...
</code></pre></li><li><p>ロールアウトのステータスの確認は、Ctrl-Cを押すことで停止できます。ロールアウトがうまく行かないときは、<a href=#deployment-status>Deploymentのステータス</a>を読んでさらなる情報を得てください。</p></li><li><p>古いレプリカ数(<code>nginx-deployment-1564180365</code> and <code>nginx-deployment-2035384211</code>)が2になっていることを確認でき、新しいレプリカ数(nginx-deployment-3066724191)は1になっています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       25s
nginx-deployment-2035384211   0         0         0       36s
nginx-deployment-3066724191   1         1         0       6s
</code></pre></li><li><p>作成されたPodを確認していると、新しいReplicaSetによって作成された1つのPodはコンテナイメージのpullに失敗し続けているのがわかります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                                READY     STATUS             RESTARTS   AGE
nginx-deployment-1564180365-70iae   1/1       Running            0          25s
nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s
nginx-deployment-1564180365-hysrc   1/1       Running            0          25s
nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s
</code></pre><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentコントローラーは、この悪い状態のロールアウトを自動的に停止し、新しいReplicaSetのスケールアップを止めます。これはユーザーが指定したローリングアップデートに関するパラメータ(特に<code>maxUnavailable</code>)に依存します。デフォルトではKubernetesがこの値を25%に設定します。</div></li><li><p>Deploymentの詳細情報を取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Name:           nginx-deployment
Namespace:      default
CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700
Labels:         app=nginx
Selector:       app=nginx
Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable
StrategyType:       RollingUpdate
MinReadySeconds:    0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.161
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    ReplicaSetUpdated
OldReplicaSets:     nginx-deployment-1564180365 (3/3 replicas created)
NewReplicaSet:      nginx-deployment-3066724191 (1/1 replicas created)
Events:
  FirstSeen LastSeen    Count   From                    SubObjectPath   Type        Reason              Message
  --------- --------    -----   ----                    -------------   --------    ------              -------
  1m        1m          1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 1
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1
</code></pre><p>これを修正するために、Deploymentを安定した状態の過去のリビジョンに更新する必要があります。</p></li></ul><h3 id=deploymentのロールアウト履歴の確認>Deploymentのロールアウト履歴の確認</h3><p>ロールアウトの履歴を確認するには、以下の手順に従って下さい。</p><ol><li><p>最初に、Deploymentのリビジョンを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployments &#34;nginx-deployment&#34;
REVISION    CHANGE-CAUSE
1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml
2           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1
3           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.161
</code></pre><p><code>CHANGE-CAUSE</code>はリビジョンの作成時にDeploymentの<code>kubernetes.io/change-cause</code>アノテーションからリビジョンにコピーされます。以下の方法により<code>CHANGE-CAUSE</code>メッセージを指定できます。</p><ul><li><code>kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause="image updated to 1.16.1"</code>の実行によりアノテーションを追加します。</li><li>リソースのマニフェストを手動で編集します。</li></ul></li><li><p>各リビジョンの詳細を確認するためには以下のコマンドを実行してください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment --revision<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployments &#34;nginx-deployment&#34; revision 2
  Labels:       app=nginx
          pod-template-hash=1159050644
  Annotations:  kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1
  Containers:
   nginx:
    Image:      nginx:1.16.1
    Port:       80/TCP
     QoS Tier:
        cpu:      BestEffort
        memory:   BestEffort
    Environment Variables:      &lt;none&gt;
  No volumes.
</code></pre></li></ol><h3 id=rolling-back-to-a-previous-revision>過去のリビジョンにロールバックする</h3><p>現在のリビジョンから過去のリビジョン(リビジョン番号2)にロールバックさせるには、以下の手順に従ってください。</p><ol><li><p>現在のリビジョンから過去のリビジョンにロールバックします。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout undo deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment rolled back
</code></pre><p>その他に、<code>--to-revision</code>を指定することにより特定のリビジョンにロールバックできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment rolled back
</code></pre><p>ロールアウトに関連したコマンドのさらなる情報は<a href=/docs/reference/generated/kubectl/kubectl-commands#rollout><code>kubectl rollout</code></a>を参照してください。</p><p>Deploymentが過去の安定したリビジョンにロールバックされました。Deploymentコントローラーによって、リビジョン番号2にロールバックする<code>DeploymentRollback</code>イベントが作成されたのを確認できます。</p></li><li><p>ロールバックが成功し、Deploymentが正常に稼働していることを確認するために、以下のコマンドを実行してください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           30m
</code></pre></li><li><p>Deploymentの詳細情報を取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=4
                        kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.16.1
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &lt;none&gt;
NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created)
Events:
  Type    Reason              Age   From                   Message
  ----    ------              ----  ----                   -------
  Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica set nginx-deployment-75675f5897 to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 0
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-595696685f to 1
  Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment &#34;nginx-deployment&#34; to revision 2
  Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica set nginx-deployment-595696685f to 0
</code></pre></li></ol><h2 id=scaling-a-deployment>Deploymentのスケーリング</h2><p>以下のコマンドを実行させてDeploymentをスケールできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment.v1.apps/nginx-deployment --replicas<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment scaled
</code></pre><p>クラスター内で<a href=/ja/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>水平Podオートスケーラー</a>が有効になっていると仮定します。ここでDeploymentのオートスケーラーを設定し、稼働しているPodのCPU使用量に基づいて、稼働させたいPodのレプリカ数の最小値と最大値を設定できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment.v1.apps/nginx-deployment --min<span style=color:#666>=</span><span style=color:#666>10</span> --max<span style=color:#666>=</span><span style=color:#666>15</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>80</span>
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment scaled
</code></pre><h3 id=比例スケーリング>比例スケーリング</h3><p>Deploymentのローリングアップデートは、同時に複数のバージョンのアプリケーションの稼働をサポートします。ユーザーやオートスケーラーがローリングアップデートをロールアウト中(更新中もしくは一時停止中)のDeploymentに対して行うと、Deploymentコントローラーはリスクを削減するために既存のアクティブなReplicaSetのレプリカのバランシングを行います。これを<em>比例スケーリング</em> と呼びます。</p><p>レプリカ数が10、<a href=#max-surge>maxSurge</a>=3、<a href=#max-unavailable>maxUnavailable</a>=2であるDeploymentが稼働している例です。</p><ul><li><p>Deployment内で10のレプリカが稼働していることを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment     10        10        10           10          50s
</code></pre></li><li><p>クラスター内で、解決できない新しいイメージに更新します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:sometag
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre></li><li><p>イメージの更新は新しいReplicaSet nginx-deployment-1989198191へのロールアウトを開始させます。しかしロールアウトは、上述した<code>maxUnavailable</code>の要求によりブロックされます。ここでロールアウトのステータスを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY     AGE
nginx-deployment-1989198191   5         5         0         9s
nginx-deployment-618515232    8         8         8         1m
</code></pre></li><li><p>次にDeploymentのスケーリングをするための新しい要求が発生します。オートスケーラーはDeploymentのレプリカ数を15に増やします。Deploymentコントローラーは新しい5つのレプリカをどこに追加するか決める必要がでてきます。比例スケーリングを使用していない場合、5つのレプリカは全て新しいReplicaSetに追加されます。比例スケーリングでは、追加されるレプリカは全てのReplicaSetに分散されます。比例割合が大きいものはレプリカ数の大きいReplicaSetとなり、比例割合が低いときはレプリカ数の小さいReplicaSetとなります。残っているレプリカはもっとも大きいレプリカ数を持つReplicaSetに追加されます。レプリカ数が0のReplicaSetはスケールアップされません。</p></li></ul><p>上記の例では、3つのレプリカが古いReplicaSetに追加され、2つのレプリカが新しいReplicaSetに追加されました。ロールアウトの処理では、新しいレプリカ数のPodが正常になったと仮定すると、最終的に新しいReplicaSetに全てのレプリカを移動させます。これを確認するためには以下のコマンドを実行して下さい。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                 DESIRED   CURRENT   UP-TO-DATE  AVAILABLE   AGE
nginx-deployment     15        18        7           8           7m
</code></pre><p>ロールアウトのステータスでレプリカがどのように各ReplicaSetに追加されるか確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT  READY     AGE
nginx-deployment-1989198191   7         7        0         7m
nginx-deployment-618515232    11        11       11        7m
</code></pre><h2 id=pausing-and-resuming-a-deployment>Deployment更新の一時停止と再開</h2><p>ユーザーは1つ以上の更新処理をトリガーする前に更新の一時停止と再開ができます。これにより、不必要なロールアウトを実行することなく一時停止と再開を行う間に複数の修正を反映できます。</p><ul><li><p>例えば、作成直後のDeploymentを考えます。
Deploymentの詳細情報を確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx     3         3         3            3           1m
</code></pre><p>ロールアウトのステータスを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         1m
</code></pre></li><li><p>以下のコマンドを実行して更新処理の一時停止を行います。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout pause deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment paused
</code></pre></li><li><p>次にDeploymentのイメージを更新します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre></li><li><p>新しいロールアウトが開始されていないことを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployments &#34;nginx&#34;
REVISION  CHANGE-CAUSE
1   &lt;none&gt;
</code></pre></li><li><p>Deploymentの更新に成功したことを確認するためにロールアウトのステータスを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         2m
</code></pre></li><li><p>更新は何度でも実行できます。例えば、Deploymentが使用するリソースを更新します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> resources deployment.v1.apps/nginx-deployment -c<span style=color:#666>=</span>nginx --limits<span style=color:#666>=</span><span style=color:#b8860b>cpu</span><span style=color:#666>=</span>200m,memory<span style=color:#666>=</span>512Mi
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment resource requirements updated
</code></pre><p>一時停止する前の初期状態では更新処理は機能しますが、Deploymentが一時停止されている間は新しい更新処理は反映されません。</p></li><li><p>最後に、Deploymentの稼働を再開させ、新しいReplicaSetが更新内容を全て反映させているのを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout resume deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment resumed
</code></pre></li><li><p>更新処理が完了するまでロールアウトのステータスを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs -w
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   2         2         2         2m
nginx-3926361531   2         2         0         6s
nginx-3926361531   2         2         1         18s
nginx-2142116321   1         2         2         2m
nginx-2142116321   1         2         2         2m
nginx-3926361531   3         2         1         18s
nginx-3926361531   3         2         1         18s
nginx-2142116321   1         1         1         2m
nginx-3926361531   3         3         1         18s
nginx-3926361531   3         3         2         19s
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         20s
</code></pre></li><li><p>最新のロールアウトのステータスを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         28s
</code></pre></li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentの稼働を再開させない限り、一時停止したDeploymentをロールバックすることはできません。</div><h2 id=deployment-status>Deploymentのステータス</h2><p>Deploymentは、そのライフサイクルの間に様々な状態に遷移します。新しいReplicaSetへのロールアウト中は<a href=#progressing-deployment>進行中</a>になり、その後は<a href=#complete-deployment>完了</a>し、また<a href=#failed-deployment>失敗</a>にもなります。</p><h3 id=progressing-deployment>Deploymentの更新処理</h3><p>以下のタスクが実行中のとき、KubernetesはDeploymentの状態を <em>進行中</em> にします。</p><ul><li>Deploymentが新しいReplicaSetを作成します。</li><li>Deploymentが新しいReplicaSetをスケールアップさせています。</li><li>Deploymentが古いReplicaSetをスケールダウンさせています。</li><li>新しいPodが準備中もしくは利用可能な状態になります(少なくとも<a href=#min-ready-seconds>MinReadySeconds</a>の間は準備中になります)。</li></ul><p><code>kubectl rollout status</code>を実行すると、Deploymentの進行状態を確認できます。</p><h3 id=complete-deployment>Deploymentの更新処理の完了</h3><p>Deploymentが以下の状態になったとき、KubernetesはDeploymentのステータスを <em>完了</em> にします。</p><ul><li>Deploymentの全てのレプリカが、指定された最新のバージョンに更新されます。これは指定した更新処理が完了したことを意味します。</li><li>Deploymentの全てのレプリカが利用可能になります。</li><li>Deploymentの古いレプリカが1つも稼働していません。</li></ul><p><code>kubectl rollout status</code>を実行して、Deploymentの更新が完了したことを確認できます。ロールアウトが正常に完了すると<code>kubectl rollout status</code>の終了コードが0で返されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Waiting for rollout to finish: 2 of 3 updated replicas are available...
deployment &#34;nginx-deployment&#34; successfully rolled out
</code></pre><p>そして<code>kubectl rollout</code>の終了ステータスが0となります（成功です）:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$?</span>
</span></span></code></pre></div><pre tabindex=0><code>0
</code></pre><h3 id=failed-deployment>Deploymentの更新処理の失敗</h3><p>新しいReplicaSetのデプロイが完了せず、更新処理が止まる場合があります。これは主に以下の要因によるものです。</p><ul><li>不十分なリソースの割り当て</li><li>ReadinessProbeの失敗</li><li>コンテナイメージの取得ができない</li><li>不十分なパーミッション</li><li>リソースリミットのレンジ</li><li>アプリケーションランタイムの設定の不備</li></ul><p>このような状況を検知する1つの方法として、Deploymentのリソース定義でデッドラインのパラメータを指定します(<a href=#progress-deadline-seconds><code>.spec.progressDeadlineSeconds</code></a>)。<code>.spec.progressDeadlineSeconds</code>はDeploymentの更新が停止したことを示す前にDeploymentコントローラーが待つ秒数を示します。</p><p>以下の<code>kubectl</code>コマンドでリソース定義に<code>progressDeadlineSeconds</code>を設定します。これはDeploymentの更新が止まってから10分後に、コントローラーが失敗を通知させるためです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch deployment.v1.apps/nginx-deployment -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;progressDeadlineSeconds&#34;:600}}&#39;</span>
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment patched
</code></pre><p>一度デッドラインを超過すると、DeploymentコントローラーはDeploymentの<code>.status.conditions</code>に以下のDeploymentConditionを追加します。</p><ul><li>Type=Progressing</li><li>Status=False</li><li>Reason=ProgressDeadlineExceeded</li></ul><p>ステータスの状態に関するさらなる情報は<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties>Kubernetes APIの規則</a>を参照してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Kubernetesは停止状態のDeploymentに対して、ステータス状態を報告する以外のアクションを実行しません。高レベルのオーケストレーターはこれを利用して、状態に応じて行動できます。例えば、前のバージョンへのDeploymentのロールバックが挙げられます。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentを停止すると、Kubernetesは指定したデッドラインを超えたかどうかチェックしません。
ロールアウトの途中でもDeploymentを安全に一時停止でき、デッドラインを超えたイベントをトリガーすることなく再開できます。</div><p>設定したタイムアウトの秒数が小さかったり、一時的なエラーとして扱える他の種類のエラーが原因となり、Deploymentで一時的なエラーが出る場合があります。例えば、リソースの割り当てが不十分な場合を考えます。Deploymentの詳細情報を確認すると、以下のセクションが表示されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>&lt;...&gt;
Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     True    ReplicaSetUpdated
  ReplicaFailure  True    FailedCreate
&lt;...&gt;
</code></pre><p><code>kubectl get deployment nginx-deployment -o yaml</code>を実行すると、Deploymentのステータスは以下のようになります。</p><pre tabindex=0><code>status:
  availableReplicas: 2
  conditions:
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: Replica set &#34;nginx-deployment-4262182780&#34; is progressing.
    reason: ReplicaSetUpdated
    status: &#34;True&#34;
    type: Progressing
  - lastTransitionTime: 2016-10-04T12:25:42Z
    lastUpdateTime: 2016-10-04T12:25:42Z
    message: Deployment has minimum availability.
    reason: MinimumReplicasAvailable
    status: &#34;True&#34;
    type: Available
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: &#39;Error creating: pods &#34;nginx-deployment-4262182780-&#34; is forbidden: exceeded quota:
      object-counts, requested: pods=1, used: pods=3, limited: pods=2&#39;
    reason: FailedCreate
    status: &#34;True&#34;
    type: ReplicaFailure
  observedGeneration: 3
  replicas: 2
  unavailableReplicas: 2
</code></pre><p>最後に、一度Deploymentの更新処理のデッドラインを越えると、KubernetesはDeploymentのステータスと進行中の状態を更新します。</p><pre tabindex=0><code>Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     False   ProgressDeadlineExceeded
  ReplicaFailure  True    FailedCreate
</code></pre><p>Deploymentか他のリソースコントローラーのスケールダウンを行うか、使用している名前空間内でリソースの割り当てを増やすことで、リソースの割り当て不足の問題に対処できます。割り当て条件を満たすと、DeploymentコントローラーはDeploymentのロールアウトを完了させ、Deploymentのステータスが成功状態になるのを確認できます(<code>Status=True</code>と<code>Reason=NewReplicaSetAvailable</code>)。</p><pre tabindex=0><code>Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
</code></pre><p><code>Status=True</code>の<code>Type=Available</code>は、Deploymentが最小可用性の状態であることを意味します。最小可用性は、Deploymentの更新戦略において指定されているパラメータにより決定されます。<code>Status=True</code>の<code>Type=Progressing</code>は、Deploymentのロールアウトの途中で、更新処理が進行中であるか、更新処理が完了し、必要な最小数のレプリカが利用可能であることを意味します(各TypeのReason項目を確認してください。このケースでは、<code>Reason=NewReplicaSetAvailable</code>はDeploymentの更新が完了したことを意味します)。</p><p><code>kubectl rollout status</code>を実行してDeploymentが更新に失敗したかどうかを確認できます。<code>kubectl rollout status</code>はDeploymentが更新処理のデッドラインを超えたときに0以外の終了コードを返します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
error: deployment &#34;nginx&#34; exceeded its progress deadline
</code></pre><p>そして<code>kubectl rollout</code>の終了ステータスが1となります(エラーを示しています):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$?</span>
</span></span></code></pre></div><pre tabindex=0><code>1
</code></pre><h3 id=失敗したdeploymentの操作>失敗したDeploymentの操作</h3><p>更新完了したDeploymentに適用した全てのアクションは、更新失敗したDeploymentに対しても適用されます。スケールアップ、スケールダウンができ、前のリビジョンへのロールバックや、Deploymentのテンプレートに複数の更新を適用させる必要があるときは一時停止もできます。</p><h2 id=clean-up-policy>古いリビジョンのクリーンアップポリシー</h2><p>Deploymentが管理する古いReplicaSetをいくつ保持するかを指定するために、<code>.spec.revisionHistoryLimit</code>フィールドを設定できます。この値を超えた古いReplicaSetはバックグラウンドでガーベージコレクションの対象となって削除されます。デフォルトではこの値は10です。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> このフィールドを明示的に0に設定すると、Deploymentの全ての履歴を削除します。従って、Deploymentはロールバックできません。</div><h2 id=カナリアパターンによるデプロイ>カナリアパターンによるデプロイ</h2><p>Deploymentを使って一部のユーザーやサーバーに対してリリースのロールアウトをしたい場合、<a href=/ja/docs/concepts/cluster-administration/manage-deployment/#canary-deployments-%E3%82%AB%E3%83%8A%E3%83%AA%E3%82%A2%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4>リソースの管理</a>に記載されているカナリアパターンに従って、リリース毎に1つずつ、複数のDeploymentを作成できます。</p><h2 id=deployment-specの記述>Deployment Specの記述</h2><p>他の全てのKubernetesの設定と同様に、Deploymentは<code>.apiVersion</code>、<code>.kind</code>や<code>.metadata</code>フィールドを必要とします。
設定ファイルの利用に関する情報は<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>アプリケーションのデプロイ</a>を参照してください。コンテナーの設定に関しては<a href=/ja/docs/concepts/overview/working-with-objects/object-management/>リソースを管理するためのkubectlの使用</a>を参照してください。
Deploymentオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>でなければなりません。
Deploymentは<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code>セクション</a>も必要とします。</p><h3 id=podテンプレート>Podテンプレート</h3><p><code>.spec.template</code>と<code>.spec.selector</code>は<code>.spec</code>における必須のフィールドです。</p><p><code>.spec.template</code>は<a href=/docs/concepts/workloads/pods/#pod-templates>Podテンプレート</a>です。これは.spec内でネストされていないことと、<code>apiVersion</code>や<code>kind</code>を持たないことを除いては<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>と同じスキーマとなります。</p><p>Podの必須フィールドに加えて、Deployment内のPodテンプレートでは適切なラベルと再起動ポリシーを設定しなくてはなりません。ラベルは他のコントローラーと重複しないようにしてください。ラベルについては、<a href=#selector>セレクター</a>を参照してください。</p><p><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>.spec.template.spec.restartPolicy</code></a>が<code>Always</code>に等しいときのみ許可されます。これはテンプレートで指定されていない場合のデフォルト値です。</p><h3 id=レプリカ数>レプリカ数</h3><p><code>.spec.replias</code>は理想的なPodの数を指定するオプションのフィールドです。デフォルトは1です。</p><h3 id=selector>セレクター</h3><p><code>.spec.selector</code>は必須フィールドで、Deploymentによって対象とされるPodの<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルセレクター</a>を指定します。</p><p><code>.spec.selector</code>は<code>.spec.template.metadata.labels</code>と一致している必要があり、一致しない場合はAPIによって拒否されます。</p><p><code>apps/v1</code>バージョンにおいて、<code>.spec.selector</code>と<code>.metadata.labels</code>が指定されていない場合、<code>.spec.template.metadata.labels</code>の値に初期化されません。そのため<code>.spec.selector</code>と<code>.metadata.labels</code>を明示的に指定する必要があります。また<code>apps/v1</code>のDeploymentにおいて<code>.spec.selector</code>は作成後に不変になります。</p><p>Deploymentのテンプレートが<code>.spec.template</code>と異なる場合や、<code>.spec.replicas</code>の値を超えてPodが稼働している場合、Deploymentはセレクターに一致するラベルを持つPodを削除します。Podの数が理想状態より少ない場合Deploymentは<code>.spec.template</code>をもとに新しいPodを作成します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentのセレクターに一致するラベルを持つPodを直接作成したり、他のDeploymentやReplicaSetやReplicationControllerによって作成するべきではありません。作成してしまうと、最初のDeploymentがラベルに一致する新しいPodを作成したとみなされます。こうなったとしても、Kubernetesは処理を止めません。</div><p>セレクターが重複する複数のコントローラーを持つとき、そのコントローラーは互いに競合状態となり、正しくふるまいません。</p><h3 id=更新戦略>更新戦略</h3><p><code>.spec.strategy</code>は古いPodから新しいPodに置き換える際の更新戦略を指定します。<code>.spec.strategy.type</code>は"Recreate"もしくは"RollingUpdate"を指定できます。デフォルトは"RollingUpdate"です。</p><h4 id=deploymentの再作成>Deploymentの再作成</h4><p><code>.spec.strategy.type==Recreate</code>と指定されているとき、既存の全てのPodは新しいPodが作成される前に削除されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> これは更新のための作成の前にPodを停止する事を保証するだけです。Deploymentを更新する場合、古いリビジョンのPodは全てすぐに停止されます。削除に成功するまでは、新しいリビジョンのPodは作成されません。手動でPodを削除すると、ライフサイクルがReplicaSetに制御されているのですぐに置き換えが実施されます（たとえ古いPodがまだ停止中のステータスでも）。Podに"高々この程度の"保証を求めるならば<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>の使用を検討してください。</div><h4 id=deploymentのローリングアップデート>Deploymentのローリングアップデート</h4><p><code>.spec.strategy.type==RollingUpdate</code>と指定されているとき、DeploymentはローリングアップデートによりPodを更新します。ローリングアップデートの処理をコントロールするために<code>maxUnavailable</code>と<code>maxSurge</code>を指定できます。</p><h5 id=max-unavailable>Max Unavailable</h5><p><code>.spec.strategy.rollingUpdate.maxUnavailable</code>はオプションのフィールドで、更新処理において利用不可となる最大のPod数を指定します。値は絶対値(例: 5)を指定するか、理想状態のPodのパーセンテージを指定します(例: 10%)。パーセンテージを指定した場合、絶対値は小数切り捨てされて計算されます。<code>.spec.strategy.rollingUpdate.maxSurge</code>が0に指定されている場合、この値を0にできません。デフォルトでは25%です。</p><p>例えば、この値が30%と指定されているとき、ローリングアップデートが開始すると古いReplicaSetはすぐに理想状態の70%にスケールダウンされます。一度新しいPodが稼働できる状態になると、古いReplicaSetはさらにスケールダウンされ、続いて新しいReplicaSetがスケールアップされます。この間、利用可能なPodの総数は理想状態のPodの少なくとも70%以上になるように保証されます。</p><h5 id=max-surge>Max Surge</h5><p><code>.spec.strategy.rollingUpdate.maxSurge</code>はオプションのフィールドで、理想状態のPod数を超えて作成できる最大のPod数を指定します。値は絶対値(例: 5)を指定するか、理想状態のPodのパーセンテージを指定します(例: 10%)。パーセンテージを指定した場合、絶対値は小数切り上げで計算されます。<code>MaxUnavailable</code>が0に指定されている場合、この値を0にできません。デフォルトでは25%です。</p><p>例えば、この値が30%と指定されているとき、ローリングアップデートが開始すると新しいReplicaSetはすぐに更新されます。このとき古いPodと新しいPodの総数は理想状態の130%を超えないように更新されます。一度古いPodが削除されると、新しいReplicaSetはさらにスケールアップされます。この間、利用可能なPodの総数は理想状態のPodに対して最大130%になるように保証されます。</p><h3 id=progress-deadline-seconds>Progress Deadline Seconds</h3><p><code>.spec.progressDeadlineSeconds</code>はオプションのフィールドで、システムがDeploymentの<a href=#failed-deployment>更新に失敗</a>したと判断するまでに待つ秒数を指定します。更新に失敗したと判断されたとき、リソースのステータスは<code>Type=Progressing</code>、<code>Status=False</code>かつ<code>Reason=ProgressDeadlineExceeded</code>となるのを確認できます。DeploymentコントローラーはDeploymentの更新のリトライし続けます。デフォルト値は600です。今後、自動的なロールバックが実装されたとき、更新失敗状態になるとすぐにDeploymentコントローラーがロールバックを行うようになります。</p><p>この値が指定されているとき、<code>.spec.minReadySeconds</code>より大きい値を指定する必要があります。</p><h3 id=min-ready-seconds>Min Ready Seconds</h3><p><code>.spec.minReadySeconds</code>はオプションのフィールドで、新しく作成されたPodが利用可能となるために、最低どれくらいの秒数コンテナーがクラッシュすることなく稼働し続ければよいかを指定するものです。デフォルトでは0です(Podは作成されるとすぐに利用可能と判断されます)。Podが利用可能と判断された場合についてさらに学ぶために<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>Container Probes</a>を参照してください。</p><h3 id=リビジョン履歴の保持上限>リビジョン履歴の保持上限</h3><p>Deploymentのリビジョン履歴は、Deploymentが管理するReplicaSetに保持されています。</p><p><code>.spec.revisionHistoryLimit</code>はオプションのフィールドで、ロールバック可能な古いReplicaSetの数を指定します。この古いReplicaSetは<code>etcd</code>内のリソースを消費し、<code>kubectl get rs</code>の出力結果を見にくくします。Deploymentの各リビジョンの設定はReplicaSetに保持されます。このため一度古いReplicaSetが削除されると、そのリビジョンのDeploymentにロールバックすることができなくなります。デフォルトでは10もの古いReplicaSetが保持されます。しかし、この値の最適値は新しいDeploymentの更新頻度と安定性に依存します。</p><p>さらに詳しく言うと、この値を0にすると、0のレプリカを持つ古い全てのReplicaSetが削除されます。このケースでは、リビジョン履歴が完全に削除されているため新しいDeploymentのロールアウトを元に戻すことができません。</p><h3 id=paused>paused</h3><p><code>.spec.paused</code>はオプションのboolean値で、Deploymentの一時停止と再開のための値です。一時停止されているものと、そうでないものとの違いは、一時停止されているDeploymentはPodTemplateSpecのいかなる変更があってもロールアウトがトリガーされないことです。デフォルトではDeploymentは一時停止していない状態で作成されます。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d459b930218774655fa7fd1620625539>4.2.2 - ReplicaSet</h1><p>ReplicaSetの目的は、どのような時でも安定したレプリカPodのセットを維持することです。これは、理想的なレプリカ数のPodが利用可能であることを保証するものとして使用されます。</p><h2 id=how-a-replicaset-works>ReplicaSetがどのように動くか</h2><p>ReplicaSetは、ReplicaSetが対象とするPodをどう特定するかを示すためのセレクターや、稼働させたいPodのレプリカ数、Podテンプレート(理想のレプリカ数の条件を満たすために作成される新しいPodのデータを指定するために用意されるもの)といったフィールドとともに定義されます。ReplicaSetは、指定された理想のレプリカ数にするためにPodの作成と削除を行うことにより、その目的を達成します。ReplicaSetが新しいPodを作成するとき、ReplicaSetはそのPodテンプレートを使用します。</p><p>ReplicaSetがそのPod群と連携するためのリンクは、Podの<a href=/ja/docs/concepts/architecture/garbage-collection/#owners-dependents>metadata.ownerReferences</a>というフィールド(現在のオブジェクトが所有されているリソースを指定する)を介して作成されます。ReplicaSetによって所持された全てのPodは、それらの<code>ownerReferences</code>フィールドにReplicaSetを特定する情報を保持します。このリンクを通じて、ReplicaSetは管理しているPodの状態を把握したり、その後の実行計画を立てます。</p><p>ReplicaSetは、そのセレクターを使用することにより、所有するための新しいPodを特定します。もし<code>ownerReference</code>フィールドの値を持たないPodか、<code>ownerReference</code>フィールドの値が <a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>でないPodで、そのPodがReplicaSetのセレクターとマッチした場合に、そのPodは即座にそのReplicaSetによって所有されます。</p><h2 id=replicasetを使うとき>ReplicaSetを使うとき</h2><p>ReplicaSetはどんな時でも指定された数のPodのレプリカが稼働することを保証します。しかし、DeploymentはReplicaSetを管理する、より上位レベルの概念で、Deploymentはその他の多くの有益な機能と共に、宣言的なPodのアップデート機能を提供します。それゆえ、我々はユーザーが独自のアップデートオーケストレーションを必要としたり、アップデートを全く必要としないような場合を除いて、ReplicaSetを直接使うよりも代わりにDeploymentを使うことを推奨します。</p><p>これは、ユーザーがReplicaSetのオブジェクトを操作する必要が全く無いことを意味します。
代わりにDeploymentを使用して、<code>spec</code>セクションにユーザーのアプリケーションを定義してください。</p><h2 id=replicasetの使用例>ReplicaSetの使用例</h2><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/frontend.yaml download=controllers/frontend.yaml><code>controllers/frontend.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-frontend-yaml")' title="Copy controllers/frontend.yaml to clipboard"></img></div><div class=includecode id=controllers-frontend-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ケースに応じてレプリカを修正する</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-frontend:v3<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>上記のマニフェストを<code>frontend.yaml</code>ファイルに保存しKubernetesクラスターに適用すると、マニフェストに定義されたReplicaSetとそれが管理するPod群を作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f http://k8s.io/examples/controllers/frontend.yaml
</span></span></code></pre></div><p>ユーザーはデプロイされた現在のReplicaSetの情報も取得できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>そして、ユーザーが作成したfrontendリソースについての情報も取得できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME       DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>frontend   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       6s
</span></span></code></pre></div><p>ユーザーはまたReplicaSetの状態も確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe rs/frontend
</span></span></code></pre></div><p>その結果は以下のようになります。</p><pre tabindex=0><code>Name:		frontend
Namespace:	default
Selector:	tier=frontend
Labels:		app=guestbook
		tier=frontend
Annotations:	kubectl.kubernetes.io/last-applied-configuration:
                {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;ReplicaSet&#34;,&#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;labels&#34;:{&#34;app&#34;:&#34;guestbook&#34;,&#34;tier&#34;:&#34;frontend&#34;},&#34;name&#34;:&#34;frontend&#34;,...
Replicas:	3 current / 3 desired
Pods Status:	3 Running / 0 Waiting / 0 Succeeded / 0 Failed
Pod Template:
  Labels:  tier=frontend
  Containers:
   php-redis:
    Image:        gcr.io/google_samples/gb-frontend:v3
    Port:         &lt;none&gt;
    Host Port:    &lt;none&gt;
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Events:
  Type    Reason            Age   From                   Message
  ----    ------            ----  ----                   -------
  Normal  SuccessfulCreate  117s  replicaset-controller  Created pod: frontend-wtsmm
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-b2zdv
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-vcmts
</code></pre><p>そして最後に、ユーザーはReplicaSetによって作成されたPodもチェックできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>表示されるPodに関する情報は以下のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME             READY   STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>frontend-b2zdv   1/1     Running   <span style=color:#666>0</span>          6m36s
</span></span><span style=display:flex><span>frontend-vcmts   1/1     Running   <span style=color:#666>0</span>          6m36s
</span></span><span style=display:flex><span>frontend-wtsmm   1/1     Running   <span style=color:#666>0</span>          6m36s
</span></span></code></pre></div><p>ユーザーはまた、それらのPodの<code>ownerReferences</code>が<code>frontend</code>ReplicaSetに設定されていることも確認できます。
これを確認するためには、稼働しているPodの中のどれかのyamlファイルを取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods frontend-b2zdv -o yaml
</span></span></code></pre></div><p>その表示結果は、以下のようになります。その<code>frontend</code>ReplicaSetの情報が<code>metadata</code>の<code>ownerReferences</code>フィールドにセットされています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-12T07:06:16Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>generateName</span>:<span style=color:#bbb> </span>frontend-<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-b2zdv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ownerReferences</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>blockOwnerDeletion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>f391f6db-bb9b-4c09-ae74-6a1f77f3d5cf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=テンプレートなしのpodの所有>テンプレートなしのPodの所有</h2><p>ユーザーが問題なくベアPod(Bare Pod: ここではPodテンプレート無しのPodのこと)を作成しているとき、そのベアPodがユーザーのReplicaSetの中のいずれのセレクターともマッチしないことを確認することを強く推奨します。
この理由として、ReplicaSetは、所有対象のPodがReplicaSetのテンプレートによって指定されたPodのみに限定されていないからです(ReplicaSetは前のセクションで説明した方法によって他のPodも所有できます)。</p><p>前のセクションで取り上げた<code>frontend</code>ReplicaSetと、下記のマニフェストのPodをみてみます。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-rs.yaml download=pods/pod-rs.yaml><code>pods/pod-rs.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-rs-yaml")' title="Copy pods/pod-rs.yaml to clipboard"></img></div><div class=includecode id=pods-pod-rs-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:2.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:1.0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>これらのPodは<code>ownerReferences</code>に何のコントローラー(もしくはオブジェクト)も指定されておらず、そして<code>frontend</code>ReplicaSetにマッチするセレクターをもっており、これらのPodは即座に<code>frontend</code>ReplicaSetによって所有されます。</p><p>この<code>frontend</code>ReplicaSetがデプロイされ、初期のPodレプリカがレプリカ数の要求を満たすためにセットアップされた後で、ユーザーがそのPodを作成することを考えます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f http://k8s.io/examples/pods/pod-rs.yaml
</span></span></code></pre></div><p>新しいPodはそのReplicaSetによって所有され、そのReplicaSetのレプリカ数が、設定された理想のレプリカ数を超えた場合すぐにそれらのPodは削除されます。</p><p>下記のコマンドでPodを取得できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>その表示結果で、新しいPodがすでに削除済みか、削除中のステータスになっているのを確認できます。</p><pre tabindex=0><code>NAME             READY   STATUS        RESTARTS   AGE
frontend-b2zdv   1/1     Running       0          10m
frontend-vcmts   1/1     Running       0          10m
frontend-wtsmm   1/1     Running       0          10m
pod1             0/1     Terminating   0          1s
pod2             0/1     Terminating   0          1s
</code></pre><p>もしユーザーがそのPodを最初に作成する場合</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f http://k8s.io/examples/pods/pod-rs.yaml
</span></span></code></pre></div><p>そしてその後に<code>frontend</code>ReplicaSetを作成すると、</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f http://k8s.io/examples/controllers/frontend.yaml
</span></span></code></pre></div><p>ユーザーはそのReplicaSetが作成したPodを所有し、さらにもともと存在していたPodと今回新たに作成されたPodの数が、理想のレプリカ数になるまでPodを作成するのを確認できます。
ここでまたPodの状態を取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>取得結果は下記のようになります。</p><pre tabindex=0><code>NAME             READY   STATUS    RESTARTS   AGE
frontend-hmmj2   1/1     Running   0          9s
pod1             1/1     Running   0          36s
pod2             1/1     Running   0          36s
</code></pre><p>この方法で、ReplicaSetはテンプレートで指定されたもの以外のPodを所有することができます。</p><h2 id=replicasetのマニフェストを記述する>ReplicaSetのマニフェストを記述する。</h2><p>他の全てのKubernetes APIオブジェクトのように、ReplicaSetは<code>apiVersion</code>、<code>kind</code>と<code>metadata</code>フィールドを必要とします。
ReplicaSetでは、<code>kind</code>フィールドの値は<code>ReplicaSet</code>です。</p><p>ReplicaSetオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><p>また、ReplicaSetは<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> セクション</a>も必須です。</p><h3 id=pod-テンプレート>Pod テンプレート</h3><p><code>.spec.template</code>はラベルを持つことが必要な<a href=/ja/docs/concepts/workloads/pods/#pod-template>Podテンプレート</a> です。先ほど作成した<code>frontend.yaml</code>の例では、<code>tier: frontend</code>というラベルを1つ持っています。
他のコントローラーがこのPodを所有しようとしないためにも、他のコントローラーのセレクターでラベルを上書きしないように注意してください。</p><p>テンプレートの<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy>再起動ポリシー</a>のためのフィールドである<code>.spec.template.spec.restartPolicy</code>は<code>Always</code>のみ許可されていて、そしてそれがデフォルト値です。</p><h3 id=pod-セレクター>Pod セレクター</h3><p><code>.spec.selector</code>フィールドは<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルセレクター</a>です。
<a href=#how-a-replicaset-works>先ほど</a>議論したように、ReplicaSetが所有するPodを指定するためにそのラベルが使用されます。
先ほどの<code>frontend.yaml</code>の例では、そのセレクターは下記のようになっていました</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span></code></pre></div><p>そのReplicaSetにおいて、<code>.spec.template.metadata.labels</code>フィールドの値は<code>spec.selector</code>と一致しなくてはならず、一致しない場合はAPIによって拒否されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 2つのReplicaSetが同じ<code>.spec.selector</code>の値を設定しているが、それぞれ異なる<code>.spec.template.metadata.labels</code>と<code>.spec.template.spec</code>フィールドの値を持っていたとき、それぞれのReplicaSetはもう一方のReplicaSetによって作成されたPodを無視します。</div><h3 id=レプリカ数について>レプリカ数について</h3><p>ユーザーは<code>.spec.replicas</code>フィールドの値を設定することにより、いくつのPodを同時に稼働させるか指定できます。そのときReplicaSetはレプリカ数がこの値に達するまでPodを作成、または削除します。</p><p>もしユーザーが<code>.spec.replicas</code>を指定しない場合、デフォルト値として1がセットされます。</p><h2 id=replicasetを利用する>ReplicaSetを利用する</h2><h3 id=replicasetとpodの削除>ReplicaSetとPodの削除</h3><p>ReplicaSetとそれが所有する全てのPod削除したいときは、<a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>コマンドを使ってください。<br><a href=/ja/docs/concepts/architecture/garbage-collection/>ガベージコレクター</a>がデフォルトで自動的に全ての依存するPodを削除します。</p><p>REST APIもしくは<code>client-go</code>ライブラリーを使用するとき、ユーザーは<code>-d</code>オプションで<code>propagationPolicy</code>を<code>Background</code>か<code>Foreground</code>と指定しなくてはなりません。例えば下記のように実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><h3 id=replicasetのみを削除する>ReplicaSetのみを削除する</h3><p>ユーザーは<a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>コマンドで<code>--cascade=false</code>オプションを付けることにより、所有するPodに影響を与えることなくReplicaSetを削除できます。
REST APIもしくは<code>client-go</code>ライブラリーを使用するとき、ユーザーは<code>-d</code>オプションで<code>propagationPolicy</code>を<code>Orphan</code>と指定しなくてはなりません。
例えば下記のように実行します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>一度元のReplicaSetが削除されると、ユーザーは新しいものに置き換えるため新しいReplicaSetを作ることができます。新旧のReplicaSetの<code>.spec.selector</code>の値が同じである間、新しいReplicaSetは古いReplicaSetで稼働していたPodを取り入れます。
しかし、存在するPodが新しく異なるPodテンプレートとマッチさせようとするとき、この仕組みは機能しません。
ReplicaSetはローリングアップデートを直接サポートしないため、ユーザーのコントロール下においてPodを新しいspecにアップデートしたい場合は、<a href=/ja/docs/concepts/workloads/controllers/deployment/#creating-a-deployment>Deployment</a>を使用してください。</p><h3 id=podをreplicasetから分離させる>PodをReplicaSetから分離させる</h3><p>ユーザーはPodのラベルを変更することにより、ReplicaSetからそのPodを削除できます。この手法はデバッグや、データ修復などのためにサービスからPodを削除したいときに使用できます。
この方法で削除されたPodは自動的に新しいものに置き換えられます。(レプリカ数は変更されないものと仮定します。)</p><h3 id=replicasetのスケーリング>ReplicaSetのスケーリング</h3><p>ReplicaSetは、ただ<code>.spec.replicas</code>フィールドを更新することによって簡単にスケールアップまたはスケールダウンできます。ReplicaSetコントローラーは、ラベルセレクターにマッチするような指定した数のPodが利用可能であり、操作可能であることを保証します。</p><p>スケールダウンする場合、ReplicaSetコントローラーは以下の一般的なアルゴリズムに基づき、利用可能なPodをソートし、スケールダウンするPodの優先順位を付け、削除するPodを選択します:</p><ol><li>保留している(またはスケジュール不可な)Podが先にスケールダウンされます。</li><li><code>controller.kubernetes.io/pod-deletion-cost</code>アノテーションが設定されている場合、値の小さいPodが優先されます。</li><li>レプリカ数の多いノード上のPodが、レプリカ数の少ないノード上のPodより優先されます。</li><li>Podの作成時間が異なる場合、より新しく作成されたPodが古いPodより優先されます(<code>LogarithmicScaleDown</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>が有効の場合、作成時間は整数対数スケールでバケット化されます)。</li></ol><p>上記条件のすべてに該当する場合は、ランダム選択となります。</p><h3 id=pod削除コスト>Pod削除コスト</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code></div><p><a href=/docs/reference/labels-annotations-taints/#pod-deletion-cost><code>controller.kubernetes.io/pod-deletion-cost</code></a>アノテーションを使用すると、ReplicaSetをスケールダウンする際に、どのPodを最初に削除するかについて、ユーザーが優先順位を設定することができます。</p><p>アノテーションはPodに設定する必要があり、範囲は[-2147483647, 2147483647]になります。同じReplicaSetに属する他のPodと比較して、Podを削除する際のコストを表しています。削除コストの低いPodは、削除コストの高いPodより優先的に削除されます。</p><p>このアノテーションを設定しないPodは暗黙的に0と設定され、負の値は許容されます。
無効な値はAPIサーバーによって拒否されます。</p><p>この機能はbeta版で、デフォルトで有効になっています。kube-apiserverとkube-controller-managerで<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a><code>PodDeletionCost</code>を設定することで無効にすることができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><ul><li>これはベストエフォートで実行されているもので、Pod削除の順番を保証するものではありません。</li><li>ユーザーは、メトリック値に基づいてアノテーションを更新するなど、頻繁に更新することは避けるべきです。APIサーバー上で大量のPodの更新操作を発生させることになるためです。</li></ul></div><h4 id=使用事例>使用事例</h4><p>アプリケーションの異なるPodは、異なる使用レベルになる可能性があります。スケールダウンする場合、アプリケーションは使用率の低いPodを削除することを優先しています。Podを頻繁に更新することを避けるため、アプリケーションはスケールダウンする前に一度<code>controller.kubernetes.io/pod-deletion-cost</code>を更新する必要があります(アノテーションをPod使用レベルに比例する値に設定します)。Spark DeploymentのドライバーPodのように、アプリケーション自体がスケールダウンを制御する場合も機能します。</p><h3 id=horizontalpodautoscaler-hpa-のターゲットとしてのreplicaset>HorizontalPodAutoscaler(HPA)のターゲットとしてのReplicaSet</h3><p>ReplicaSetはまた、<a href=/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscalers (HPA)</a>のターゲットにもなることができます。
これはつまりReplicaSetがHPAによってオートスケールされうることを意味します。
ここではHPAが、前の例で作成したReplicaSetをターゲットにする例を示します。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/hpa-rs.yaml download=controllers/hpa-rs.yaml><code>controllers/hpa-rs.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-hpa-rs-yaml")' title="Copy controllers/hpa-rs.yaml to clipboard"></img></div><div class=includecode id=controllers-hpa-rs-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-scaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>このマニフェストを<code>hpa-rs.yaml</code>に保存し、Kubernetesクラスターに適用すると、レプリケートされたPodのCPU使用量にもとづいてターゲットのReplicaSetをオートスケールするHPAを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/hpa-rs.yaml
</span></span></code></pre></div><p>同様のことを行うための代替案として、<code>kubectl autoscale</code>コマンドも使用できます。(こちらの方がより簡単です。)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale rs frontend --max<span style=color:#666>=</span><span style=color:#666>10</span> --min<span style=color:#666>=</span><span style=color:#666>3</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span>
</span></span></code></pre></div><h2 id=replicasetの代替案>ReplicaSetの代替案</h2><h3 id=deployment-推奨>Deployment (推奨)</h3><p><a href=/ja/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>はReplicaSetを所有することのできるオブジェクトで、宣言的なサーバサイドのローリングアップデートを介してReplicaSetとPodをアップデートできます。
ReplicaSetは単独で使用可能ですが、現在では、ReplicaSetは主にPodの作成、削除とアップデートを司るためのメカニズムとしてDeploymentによって使用されています。ユーザーがDeploymentを使用するとき、Deploymentによって作成されるReplicaSetの管理について心配する必要はありません。DeploymentはReplicaSetを所有し、管理します。
このため、もしユーザーがReplicaSetを必要とするとき、Deploymentの使用を推奨します。</p><h3 id=ベアpod-bare-pods>ベアPod(Bare Pods)</h3><p>ユーザーがPodを直接作成するケースとは異なり、ReplicaSetはNodeの故障やカーネルのアップグレードといった破壊的なNodeのメンテナンスなど、どのような理由に限らず削除または停止されたPodを置き換えます。
このため、我々はもしユーザーのアプリケーションが単一のPodのみ必要とする場合でもReplicaSetを使用することを推奨します。プロセスのスーパーバイザーについても同様に考えると、それは単一Node上での独立したプロセスの代わりに複数のNodeにまたがった複数のPodを監視します。
ReplicaSetは、KubeletのようなNode上のいくつかのエージェントに対して、ローカルのコンテナ再起動を移譲します。</p><h3 id=job>Job</h3><p>PodをPodそれ自身で停止させたいような場合(例えば、バッチ用のジョブなど)は、ReplicaSetの代わりに<a href=/ja/docs/concepts/workloads/controllers/job/><code>Job</code></a>を使用してください。</p><h3 id=daemonset>DaemonSet</h3><p>マシンの監視やロギングなど、マシンレベルの機能を提供したい場合は、ReplicaSetの代わりに<a href=/ja/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>を使用してください。
これらのPodはマシン自体のライフタイムに紐づいています: そのPodは他のPodが起動する前に、そのマシン上で稼働される必要があり、マシンが再起動またはシャットダウンされるときには、安全に停止されます。</p><h3 id=replicationcontroller>ReplicationController</h3><p>ReplicaSetは<a href=/docs/concepts/workloads/controllers/replicationcontroller/><em>ReplicationControllers</em></a>の後継となるものです。
この2つは、ReplicationControllerが<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルについてのユーザーガイド</a>に書かれているように、集合ベース(set-based)のセレクター要求をサポートしていないことを除いては、同じ目的を果たし、同じようにふるまいます。<br>このように、ReplicaSetはReplicationControllerよりも好まれます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/workloads/pods/>Pod</a>について学ぶ。</li><li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>について学ぶ。</li><li>ReplicaSetsに依存した<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>Deploymentを使用してステートレスアプリケーションを実行する</a>。</li><li><code>ReplicaSet</code>はKubernetes REST APIのトップレベルのリソースです。
<a href=/docs/reference/kubernetes-api/workload-resources/replica-set-v1/>ReplicaSet</a>オブジェクトの定義を読み、レプリカセットのAPIを理解する。</li><li><a href=/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>について、またPodDisruptionBudgetで障害発生時のアプリケーションの可用性を管理する方法について読む。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6d72299952c37ca8cc61b416e5bdbcd4>4.2.3 - StatefulSet</h1><p>StatefulSetはステートフルなアプリケーションを管理するためのワークロードAPIです。</p><p>StatefulSetはDeploymentと<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>のセットのスケーリングを管理し、それらのPodの<em>順序と一意性を保証</em> します。</p><p><a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>のように、StatefulSetは指定したコンテナのspecに基づいてPodを管理します。Deploymentとは異なり、StatefulSetは各Podにおいて管理が大変な同一性を維持します。これらのPodは同一のspecから作成されますが、それらは交換可能ではなく、リスケジュール処理をまたいで維持される永続的な識別子を持ちます。</p><p>ワークロードに永続性を持たせるためにストレージボリュームを使いたい場合は、解決策の1つとしてStatefulSetが利用できます。StatefulSet内の個々のPodは障害の影響を受けやすいですが、永続化したPodの識別子は既存のボリュームと障害によって置換された新しいPodの紐付けを簡単にします。</p><h2 id=statefulsetの使用>StatefulSetの使用</h2><p>StatefulSetは下記の1つ以上の項目を要求するアプリケーションにおいて最適です。</p><ul><li>安定した一意のネットワーク識別子</li><li>安定した永続ストレージ</li><li>規則的で安全なデプロイとスケーリング</li><li>規則的で自動化されたローリングアップデート</li></ul><p>上記において安定とは、Podのスケジュール(または再スケジュール)をまたいでも永続的であることと同義です。
もしアプリケーションが安定したネットワーク識別子と規則的なデプロイや削除、スケーリングを全く要求しない場合、ユーザーはステートレスなレプリカのセットを提供するワークロードを使ってアプリケーションをデプロイするべきです。
<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>や<a href=/ja/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>のようなコントローラーはこのようなステートレスな要求に対して最適です。</p><h2 id=制限事項>制限事項</h2><ul><li>提供されたPodのストレージは、要求された<code>storage class</code>にもとづいて<a href=https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/README.md>PersistentVolume Provisioner</a>によってプロビジョンされるか、管理者によって事前にプロビジョンされなくてはなりません。</li><li>StatefulSetの削除もしくはスケールダウンをすることにより、StatefulSetに関連したボリュームは削除<em>されません</em> 。 これはデータ安全性のためで、関連するStatefulSetのリソース全てを自動的に削除するよりもたいてい有効です。</li><li>StatefulSetは現在、Podのネットワークアイデンティティーに責務をもつために<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless Service</a>を要求します。ユーザーはこのServiceを作成する責任があります。</li><li>StatefulSetは、StatefulSetが削除されたときにPodの停止を行うことを保証していません。StatefulSetにおいて、規則的で安全なPodの停止を行う場合、削除のために事前にそのStatefulSetの数を0にスケールダウンさせることが可能です。</li><li>デフォルト設定の<a href=#pod-management-policies>Pod管理ポリシー</a> (<code>OrderedReady</code>)によって<a href=#rolling-updates>ローリングアップデート</a>を行う場合、<a href=#forced-rollback>修復のための手動介入</a>を要求するようなブロークンな状態に遷移させることが可能です。</li></ul><h2 id=コンポーネント>コンポーネント</h2><p>下記の例は、StatefulSetのコンポーネントのデモンストレーションとなります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># .spec.template.metadata.labelsの値と一致する必要があります</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginx&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># by default is 1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># .spec.selector.matchLabelsの値と一致する必要があります</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/nginx-slim:0.8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-storage-class&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>上記の例では、</p><ul><li>nginxという名前のHeadlessServiceは、ネットワークドメインをコントロールするために使われます。</li><li>webという名前のStatefulSetは、specで3つのnginxコンテナのレプリカを持ち、そのコンテナはそれぞれ別のPodで稼働するように設定されています。</li><li>volumeClaimTemplatesは、PersistentVolumeプロビジョナーによってプロビジョンされた<a href=/ja/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>を使って安定したストレージを提供します。</li></ul><p>StatefulSetの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>名前</a>である必要があります。</p><h2 id=podセレクター>Podセレクター</h2><p>ユーザーは、StatefulSetの<code>.spec.template.metadata.labels</code>のラベルと一致させるため、StatefulSetの<code>.spec.selector</code>フィールドをセットしなくてはなりません。Kubernetes1.8以前では、<code>.spec.selector</code>フィールドは省略された場合デフォルト値になります。Kubernetes1.8とそれ以降のバージョンでは、ラベルに一致するPodセレクターの指定がない場合はStatefulSetの作成時にバリデーションエラーになります。</p><h2 id=podアイデンティティー>Podアイデンティティー</h2><p>StatefulSetのPodは、順番を示す番号、安定したネットワークアイデンティティー、安定したストレージからなる一意なアイデンティティーを持ちます。
そのアイデンティティーはどのNode上にスケジュール(もしくは再スケジュール)されるかに関わらず、そのPodに紐付きます。</p><h3 id=順序インデックス>順序インデックス</h3><p>N個のレプリカをもったStatefulSetにおいて、StatefulSet内の各Podは、0からはじまりN-1までの整数値を順番に割り当てられ、そのStatefulSetにおいては一意となります。</p><h3 id=安定したネットワークid>安定したネットワークID</h3><p>StatefulSet内の各Podは、そのStatefulSet名とPodの順序番号から派生してホストネームが割り当てられます。
作成されたホストネームの形式は<code>$(StatefulSet名)-$(順序番号)</code>となります。先ほどの上記の例では、<code>web-0,web-1,web-2</code>という3つのPodが作成されます。
StatefulSetは、Podのドメインをコントロールするために<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless Service</a>を使うことができます。
このHeadless Serviceによって管理されたドメインは<code>$(Service名).$(ネームスペース).svc.cluster.local</code>形式となり、"cluster.local"というのはそのクラスターのドメインとなります。
各Podが作成されると、Podは<code>$(Pod名).$(管理するServiceドメイン名)</code>に一致するDNSサブドメインを取得し、管理するServiceはStatefulSetの<code>serviceName</code>で定義されます。</p><p>クラスターでのDNSの設定方法によっては、新たに起動されたPodのDNS名をすぐに検索できない場合があります。
この動作は、クラスター内の他のクライアントが、Podが作成される前にそのPodのホスト名に対するクエリーをすでに送信していた場合に発生する可能性があります。
(DNSでは通常)ネガティブキャッシュは、Podの起動後でも、少なくとも数秒間、以前に失敗したルックアップの結果が記憶され、再利用されることを意味します。</p><p>Podが作成された後、速やかにPodを検出する必要がある場合は、いくつかのオプションがあります。</p><ul><li>DNSルックアップに依存するのではなく、Kubernetes APIに直接(例えばwatchを使って)問い合わせる。</li><li>Kubernetes DNS プロバイダーのキャッシュ時間を短縮する(これは現在30秒キャッシュされるようになっているCoreDNSのConfigMapを編集することを意味しています。)。</li></ul><p><a href=#%E5%88%B6%E9%99%90%E4%BA%8B%E9%A0%85>制限事項</a>セクションで言及したように、ユーザーはPodのネットワークアイデンティティーのために<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless Service</a>を作成する責任があります。</p><p>ここで、クラスタードメイン、Service名、StatefulSet名の選択と、それらがStatefulSetのPodのDNS名にどう影響するかの例をあげます。</p><table><thead><tr><th>Cluster Domain</th><th>Service (ns/name)</th><th>StatefulSet (ns/name)</th><th>StatefulSet Domain</th><th>Pod DNS</th><th>Pod Hostname</th></tr></thead><tbody><tr><td>cluster.local</td><td>default/nginx</td><td>default/web</td><td>nginx.default.svc.cluster.local</td><td>web-{0..N-1}.nginx.default.svc.cluster.local</td><td>web-{0..N-1}</td></tr><tr><td>cluster.local</td><td>foo/nginx</td><td>foo/web</td><td>nginx.foo.svc.cluster.local</td><td>web-{0..N-1}.nginx.foo.svc.cluster.local</td><td>web-{0..N-1}</td></tr><tr><td>kube.local</td><td>foo/nginx</td><td>foo/web</td><td>nginx.foo.svc.kube.local</td><td>web-{0..N-1}.nginx.foo.svc.kube.local</td><td>web-{0..N-1}</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>備考:</strong> クラスタードメインは<a href=/ja/docs/concepts/services-networking/dns-pod-service/>その他の設定</a>がされない限り、<code>cluster.local</code>にセットされます。</div><h3 id=安定したストレージ>安定したストレージ</h3><p>Kubernetesは各VolumeClaimTemplateに対して、1つの<a href=/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>を作成します。上記のnginxの例において、各Podは<code>my-storage-class</code>というStorageClassをもち、1Gibのストレージ容量を持った単一のPersistentVolumeを受け取ります。もしStorageClassが指定されていない場合、デフォルトのStorageClassが使用されます。PodがNode上にスケジュール(もしくは再スケジュール)されたとき、その<code>volumeMounts</code>はPersistentVolume Claimに関連したPersistentVolumeをマウントします。
注意点として、PodのPersistentVolume Claimと関連したPersistentVolumeは、PodやStatefulSetが削除されたときに削除されません。
削除する場合は手動で行わなければなりません。</p><h3 id=podのネームラベル>Podのネームラベル</h3><p>StatefulSet <a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a> がPodを作成したとき、Podの名前として、<code>statefulset.kubernetes.io/pod-name</code>にラベルを追加します。このラベルによってユーザーはServiceにStatefulSet内の指定したPodを割り当てることができます。</p><h2 id=デプロイとスケーリングの保証>デプロイとスケーリングの保証</h2><ul><li>N個のレプリカをもつStatefulSetにおいて、Podがデプロイされるとき、それらのPodは{0..N-1}の番号で順番に作成されます。</li><li>Podが削除されるとき、それらのPodは{N-1..0}の番号で降順に削除されます。</li><li>Podに対してスケーリングオプションが適用される前に、そのPodの前の順番の全てのPodがRunningかつReady状態になっていなくてはなりません。</li><li>Podが停止される前に、そのPodの番号より大きい番号を持つの全てのPodは完全にシャットダウンされていなくてはなりません。</li></ul><p>StatefulSetは<code>pod.Spec.TerminationGracePeriodSeconds</code>を0に指定すべきではありません。これは不安全で、やらないことを強く推奨します。さらなる説明としては、<a href=/ja/docs/tasks/run-application/force-delete-stateful-set-pod/>StatefulSetのPodの強制削除</a>を参照してください。</p><p>上記の例のnginxが作成されたとき、3つのPodは<code>web-0</code>、<code>web-1</code>、<code>web-2</code>の順番でデプロイされます。<code>web-1</code>は<code>web-0</code>が<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>RunningかつReady状態</a>になるまでは決してデプロイされないのと、同様に<code>web-2</code>は<code>web-1</code>がRunningかつReady状態にならないとデプロイされません。もし<code>web-0</code>が<code>web-1</code>がRunningかつReady状態になった後だが、<code>web-2</code>が起動する前に失敗した場合、<code>web-2</code>は<code>web-0</code>の再起動が成功し、RunningかつReady状態にならないと再起動されません。</p><p>もしユーザーが<code>replicas=1</code>といったようにStatefulSetにパッチをあてることにより、デプロイされたものをスケールすることになった場合、<code>web-2</code>は最初に停止されます。<code>web-1</code>は<code>web-2</code>が完全にシャットダウンされ削除されるまでは、停止されません。もし<code>web-0</code>が、<code>web-2</code>が完全に停止され削除された後だが、<code>web-1</code>の停止の前に失敗した場合、<code>web-1</code>は<code>web-0</code>がRunningかつReady状態になるまでは停止されません。</p><h3 id=podの管理ポリシー>Podの管理ポリシー</h3><p>Kubernetes1.7とそれ以降のバージョンでは、StatefulSetは<code>.spec.podManagementPolicy</code>フィールドを介して、Podの一意性とアイデンティティーを保証します。</p><h4 id=orderedreadyなpod管理>OrderedReadyなPod管理</h4><p><code>OrderedReady</code>なPod管理はStatefulSetにおいてデフォルトです。これは<a href=#deployment-and-scaling-guarantees>デプロイとスケーリングの保証</a>に記載されている項目の振る舞いを実装します。</p><h4 id=並行なpod管理>並行なPod管理</h4><p><code>Parallel</code>なPod管理は、StatefulSetコントローラーに対して、他のPodが起動や停止される前にそのPodが完全に起動し準備完了になるか停止するのを待つことなく、Podが並行に起動もしくは停止するように指示します。</p><h2 id=アップデートストラテジー>アップデートストラテジー</h2><p>Kubernetes1.7とそれ以降のバージョンにおいて、StatefulSetの<code>.spec.updateStrategy</code>フィールドで、コンテナの自動のローリングアップデートの設定やラベル、リソースのリクエストとリミットや、StatefulSet内のPodのアノテーションを指定できます。</p><h3 id=ondelete>OnDelete</h3><p><code>OnDelete</code>というアップデートストラテジーは、レガシーな(Kubernetes1.6以前)振る舞いとなります。StatefulSetの<code>.spec.updateStrategy.type</code>が<code>OnDelete</code>にセットされていたとき、そのStatefulSetコントローラーはStatefulSet内でPodを自動的に更新しません。StatefulSetの<code>.spec.template</code>項目の修正を反映した新しいPodの作成をコントローラーに支持するためには、ユーザーは手動でPodを削除しなければなりません。</p><h3 id=rollingupdate>RollingUpdate</h3><p><code>RollingUpdate</code>というアップデートストラテジーは、StatefulSet内のPodに対する自動化されたローリングアップデートの機能を実装します。これは<code>.spec.updateStrategy</code>フィールドが未指定の場合のデフォルトのストラテジーです。StatefulSetの<code>.spec.updateStrategy.type</code>が<code>RollingUpdate</code>にセットされたとき、そのStatefulSetコントローラーは、StatefulSet内のPodを削除し、再作成します。これはPodの停止(Podの番号の降順)と同じ順番で、一度に1つのPodを更新します。コントローラーは、その前のPodの状態がRunningかつReady状態になるまで次のPodの更新を待ちます。</p><h4 id=パーティション>パーティション</h4><p><code>RollingUpdate</code>というアップデートストラテジーは、<code>.spec.updateStrategy.rollingUpdate.partition</code>を指定することにより、パーティションに分けることができます。もしパーティションが指定されていたとき、そのパーティションの値と等しいか、大きい番号を持つPodが更新されます。パーティションの値より小さい番号を持つPodは更新されず、たとえそれらのPodが削除されたとしても、それらのPodは以前のバージョンで再作成されます。もしStatefulSetの<code>.spec.updateStrategy.rollingUpdate.partition</code>が、<code>.spec.replicas</code>より大きい場合、<code>.spec.template</code>への更新はPodに反映されません。
多くのケースの場合、ユーザーはパーティションを使う必要はありませんが、もし一部の更新を行う場合や、カナリー版のバージョンをロールアウトする場合や、段階的ロールアウトを行う場合に最適です。</p><h4 id=強制ロールバック>強制ロールバック</h4><p>デフォルトの<a href=#pod-management-policies>Pod管理ポリシー</a>(<code>OrderedReady</code>)による<a href=#rolling-updates>ローリングアップデート</a>を行う際、修復のために手作業が必要な状態にすることが可能です。</p><p>もしユーザーが、決してRunningかつReady状態にならないような設定になるようにPodテンプレートを更新した場合(例えば、不正なバイナリや、アプリケーションレベルの設定エラーなど)、StatefulSetはロールアウトを停止し、待機します。</p><p>この状態では、Podテンプレートを正常な状態に戻すだけでは不十分です。<a href=https://github.com/kubernetes/kubernetes/issues/67250>既知の問題</a>によって、StatefulSetは元の正常な状態へ戻す前に、壊れたPodがReady状態(決して起こりえない)に戻るのを待ち続けます。</p><p>そのテンプレートを戻したあと、ユーザーはまたStatefulSetが異常状態で稼働しようとしていたPodをすべて削除する必要があります。StatefulSetはその戻されたテンプレートを使ってPodの再作成を始めます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/tutorials/stateful-application/basic-stateful-set/>ステートフルなアプリケーションのデプロイ</a>の例を参考にしてください。</li><li><a href=/ja/docs/tutorials/stateful-application/cassandra/>StatefulSetを使ったCassandraのデプロイ</a>の例を参考にしてください。</li><li><a href=/ja/docs/tasks/run-application/run-replicated-stateful-application/>レプリカを持つステートフルアプリケーションを実行する</a>の例を参考にしてください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-41600eb8b6631c88848156f381e9d588>4.2.4 - DaemonSet</h1><p><em>DaemonSet</em> は全て(またはいくつか)のNodeが単一のPodのコピーを稼働させることを保証します。Nodeがクラスターに追加されるとき、PodがNode上に追加されます。Nodeがクラスターから削除されたとき、それらのPodはガーベージコレクターにより除去されます。DaemonSetの削除により、DaemonSetが作成したPodもクリーンアップします。</p><p>DaemonSetのいくつかの典型的な使用例は以下の通りです。</p><ul><li>クラスターのストレージデーモンを全てのNode上で稼働させる。</li><li>ログ集計デーモンを全てのNode上で稼働させる。</li><li>Nodeのモニタリングデーモンを全てのNode上で稼働させる。</li></ul><p>シンプルなケースとして、各タイプのデーモンにおいて、全てのNodeをカバーする1つのDaemonSetが使用されるケースがあります。さらに複雑な設定では、単一のタイプのデーモン用ですが、異なるフラグや、異なるハードウェアタイプに対するメモリー、CPUリクエストを要求する複数のDaemonSetを使用するケースもあります。</p><h2 id=daemonset-specの記述>DaemonSet Specの記述</h2><h3 id=daemonsetの作成>DaemonSetの作成</h3><p>ユーザーはYAMLファイル内でDaemonSetの設定を記述することができます。例えば、下記の<code>daemonset.yaml</code>ファイルでは<code>fluentd-elasticsearch</code>というDockerイメージを稼働させるDaemonSetの設定を記述します。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/daemonset.yaml download=controllers/daemonset.yaml><code>controllers/daemonset.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-daemonset-yaml")' title="Copy controllers/daemonset.yaml to clipboard"></img></div><div class=includecode id=controllers-daemonset-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>fluentd-logging<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>quay.io/fluentd_elasticsearch/fluentd:v2.5.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>YAMLファイルに基づいてDaemonSetを作成します。</p><pre tabindex=0><code>kubectl apply -f https://k8s.io/examples/controllers/daemonset.yaml
</code></pre><h3 id=必須のフィールド>必須のフィールド</h3><p>他の全てのKubernetesの設定と同様に、DaemonSetは<code>apiVersion</code>、<code>kind</code>と<code>metadata</code>フィールドが必須となります。設定ファイルの活用法に関する一般的な情報は、<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>ステートレスアプリケーションの稼働</a>、<a href=/ja/docs/tasks/>コンテナの設定</a>、<a href=/ja/docs/concepts/overview/working-with-objects/object-management/>kubectlを用いたオブジェクトの管理</a>といったドキュメントを参照ください。</p><p>DaemonSetオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><p>また、DaemonSetにおいて<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code></a>セクションも必須となります。</p><h3 id=podテンプレート>Podテンプレート</h3><p><code>.spec.template</code>は<code>.spec</code>内での必須のフィールドの1つです。</p><p><code>.spec.template</code>は<a href=/docs/concepts/workloads/pods/#pod-templates>Podテンプレート</a>となります。これはフィールドがネストされていて、<code>apiVersion</code>や<code>kind</code>をもたないことを除いては、<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>のテンプレートと同じスキーマとなります。</p><p>Podに対する必須のフィールドに加えて、DaemonSet内のPodテンプレートは適切なラベルを指定しなくてはなりません(<a href=#pod-selector>Podセレクター</a>の項目を参照ください)。</p><p>DaemonSet内のPodテンプレートでは、<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>RestartPolicy</code></a>フィールドを指定せずにデフォルトの<code>Always</code>を使用するか、明示的に<code>Always</code>を設定するかのどちらかである必要があります。</p><h3 id=podセレクター>Podセレクター</h3><p><code>.spec.selector</code>フィールドはPodセレクターとなります。これは<a href=/docs/concepts/workloads/controllers/job/>Job</a>の<code>.spec.selector</code>と同じものです。</p><p>Kubernetes1.8のように、ユーザーは<code>.spec.template</code>のラベルにマッチするPodセレクターを指定しなくてはいけません。Podセレクターは、値を空のままにしてもデフォルト設定にならなくなりました。セレクターのデフォルト化は<code>kubectl apply</code>と互換性はありません。また、一度DaemonSetが作成されると、その<code>.spec.selector</code>は変更不可能になります。Podセレクターの変更は、意図しないPodの孤立を引き起こし、ユーザーにとってやっかいなものとなります。</p><p><code>.spec.selector</code>は2つのフィールドからなるオブジェクトです。</p><ul><li><code>matchLabels</code> - <a href=/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>の<code>.spec.selector</code>と同じように機能します。</li><li><code>matchExpressions</code> - キーと、値のリストとさらにはそれらのキーとバリューに関連したオペレーターを指定することにより、より洗練された形式のセレクターを構成できます。</li></ul><p>上記の2つが指定された場合は、2つの条件をANDでどちらも満たすものを結果として返します。</p><p>もし<code>spec.selector</code>が指定されたとき、<code>.spec.template.metadata.labels</code>とマッチしなければなりません。この2つの値がマッチしない設定をした場合、APIによってリジェクトされます。</p><h3 id=選択したnode上でpodを稼働させる>選択したNode上でPodを稼働させる</h3><p>もしユーザーが<code>.spec.template.spec.nodeSelector</code>を指定したとき、DaemonSetコントローラーは、その<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>node selector</a>にマッチするNode上にPodを作成します。同様に、もし<code>.spec.template.spec.affinity</code>を指定したとき、DaemonSetコントローラーは<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>node affinity</a>にマッチするNode上にPodを作成します。
もしユーザーがどちらも指定しないとき、DaemonSetコントローラーは全てのNode上にPodを作成します。</p><h2 id=daemon-podがどのようにスケジューリングされるか>Daemon Podがどのようにスケジューリングされるか</h2><h3 id=デフォルトスケジューラーによってスケジューリングされる場合>デフォルトスケジューラーによってスケジューリングされる場合</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.17 [stable]</code></div><p>DaemonSetは全ての利用可能なNodeが単一のPodのコピーを稼働させることを保証します。通常、Podが稼働するNodeはKubernetesスケジューラーによって選択されます。しかし、DaemonSetのPodは代わりにDaemonSetコントローラーによって作成され、スケジューリングされます。<br>下記の問題について説明します:</p><ul><li>矛盾するPodのふるまい: スケジューリングされるのを待っている通常のPodは、作成されているが<code>Pending</code>状態となりますが、DaemonSetのPodは<code>Pending</code>状態で作成されません。これはユーザーにとって困惑するものです。</li><li><a href=/docs/concepts/configuration/pod-priority-preemption/>Podプリエンプション(Pod preemption)</a>はデフォルトスケジューラーによってハンドルされます。もしプリエンプションが有効な場合、そのDaemonSetコントローラーはPodの優先順位とプリエンプションを考慮することなくスケジューリングの判断を行います。</li></ul><p><code>ScheduleDaemonSetPods</code>は、DaemonSetのPodに対して<code>NodeAffinity</code>項目を追加することにより、DaemonSetコントローラーの代わりにデフォルトスケジューラーを使ってDaemonSetのスケジュールを可能にします。その際に、デフォルトスケジューラーはPodをターゲットのホストにバインドします。もしDaemonSetのNodeAffinityが存在するとき、それは新しいものに置き換えられます(ターゲットホストを選択する前に、元のNodeAffinityが考慮されます)。DaemonSetコントローラーはDaemonSetのPodの作成や修正を行うときのみそれらの操作を実施します。そしてDaemonSetの<code>.spec.template</code>フィールドに対しては何も変更が加えられません。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>matchFields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- target-host-name<span style=color:#bbb>
</span></span></span></code></pre></div><p>さらに、<code>node.kubernetes.io/unschedulable:NoSchedule</code>というtolarationがDaemonSetのPodに自動的に追加されます。デフォルトスケジューラーは、DaemonSetのPodのスケジューリングのときに、<code>unschedulable</code>なNodeを無視します。</p><h3 id=taintsとtolerations>TaintsとTolerations</h3><p>DaemonSetのPodは<a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>TaintsとTolerations</a>の設定を尊重します。下記のTolerationsは、関連する機能によって自動的にDaemonSetのPodに追加されます。</p><table><thead><tr><th>Toleration Key</th><th>Effect</th><th>Version</th><th>Description</th></tr></thead><tbody><tr><td><code>node.kubernetes.io/not-ready</code></td><td>NoExecute</td><td>1.13+</td><td>DaemonSetのPodはネットワーク分割のようなNodeの問題が発生したときに除外されません。</td></tr><tr><td><code>node.kubernetes.io/unreachable</code></td><td>NoExecute</td><td>1.13+</td><td>DaemonSetのPodはネットワーク分割のようなNodeの問題が発生したときに除外されません。</td></tr><tr><td><code>node.kubernetes.io/disk-pressure</code></td><td>NoSchedule</td><td>1.8+</td><td></td></tr><tr><td><code>node.kubernetes.io/memory-pressure</code></td><td>NoSchedule</td><td>1.8+</td><td></td></tr><tr><td><code>node.kubernetes.io/unschedulable</code></td><td>NoSchedule</td><td>1.12+</td><td>DaemonSetのPodはデフォルトスケジューラーによってスケジュール不可能な属性を許容(tolerate)します。</td></tr><tr><td><code>node.kubernetes.io/network-unavailable</code></td><td>NoSchedule</td><td>1.12+</td><td>ホストネットワークを使うDaemonSetのPodはデフォルトスケジューラーによってネットワーク利用不可能な属性を許容(tolerate)します。</td></tr></tbody></table><h2 id=daemon-podとのコミュニケーション>Daemon Podとのコミュニケーション</h2><p>DaemonSet内のPodとのコミュニケーションをする際に考えられるパターンは以下の通りです。:</p><ul><li><strong>Push</strong>: DaemonSet内のPodは他のサービスに対して更新情報を送信するように設定されます。</li><li><strong>NodeIPとKnown Port</strong>: PodがNodeIPを介して疎通できるようにするため、DaemonSet内のPodは<code>hostPort</code>を使用できます。慣例により、クライアントはNodeIPのリストとポートを知っています。</li><li><strong>DNS</strong>: 同じPodセレクターを持つ<a href=/ja/docs/concepts/services-networking/service/#headless-service>HeadlessService</a>を作成し、<code>endpoints</code>リソースを使ってDaemonSetを探すか、DNSから複数のAレコードを取得します。</li><li><strong>Service</strong>: 同じPodセレクターを持つServiceを作成し、複数のうちのいずれかのNode上のDaemonに疎通させるためにそのServiceを使います。</li></ul><h2 id=daemonsetの更新>DaemonSetの更新</h2><p>もしNodeラベルが変更されたとき、そのDaemonSetは直ちに新しくマッチしたNodeにPodを追加し、マッチしなくなったNodeからPodを削除します。</p><p>ユーザーはDaemonSetが作成したPodを修正可能です。しかし、Podは全てのフィールドの更新を許可していません。また、DaemonSetコントローラーは次のNode(同じ名前でも)が作成されたときにオリジナルのテンプレートを使ってPodを作成します。</p><p>ユーザーはDaemonSetを削除可能です。<code>kubectl</code>コマンドで<code>--cascade=false</code>を指定するとDaemonSetのPodはNode上に残り続けます。その後、同じセレクターで新しいDaemonSetを作成すると、新しいDaemonSetは既存のPodを再利用します。PodでDaemonSetを置き換える必要がある場合は、<code>updateStrategy</code>に従ってそれらを置き換えます。</p><p>ユーザーはDaemonSet上で<a href=/docs/tasks/manage-daemon/update-daemon-set/>ローリングアップデートの実施</a>が可能です。</p><h2 id=daemonsetの代替案>DaemonSetの代替案</h2><h3 id=initスクリプト>Initスクリプト</h3><p>Node上で直接起動することにより(例: <code>init</code>、<code>upstartd</code>、<code>systemd</code>を使用する)、デーモンプロセスを稼働することが可能です。この方法は非常に良いですが、このようなプロセスをDaemonSetを介して起動することはいくつかの利点があります。</p><ul><li>アプリケーションと同じ方法でデーモンの監視とログの管理ができる。</li><li>デーモンとアプリケーションで同じ設定用の言語とツール(例: Podテンプレート、<code>kubectl</code>)を使える。</li><li>リソースリミットを使ったコンテナ内でデーモンを稼働させることにより、デーモンとアプリケーションコンテナの分離を促進します。しかし、これはPod内でなく、コンテナ内でデーモンを稼働させることにより可能です(Dockerを介して直接起動する)。</li></ul><h3 id=ベアpod>ベアPod</h3><p>特定のNode上で稼働するように指定したPodを直接作成することは可能です。しかし、DaemonSetはNodeの故障やNodeの破壊的なメンテナンスやカーネルのアップグレードなど、どのような理由に限らず、削除されたもしくは停止されたPodを置き換えます。このような理由で、ユーザーはPod単体を作成するよりもむしろDaemonSetを使うべきです。</p><h3 id=静的pod-pods>静的Pod Pods</h3><p>Kubeletによって監視されているディレクトリに対してファイルを書き込むことによって、Podを作成することが可能です。これは<a href=/ja/docs/tasks/configure-pod-container/static-pod/>静的Pod</a>と呼ばれます。DaemonSetと違い、静的Podはkubectlや他のKubernetes APIクライアントで管理できません。静的PodはApiServerに依存しておらず、クラスターの自立起動時に最適です。また、静的Podは将来的には廃止される予定です。</p><h3 id=deployment>Deployment</h3><p>DaemonSetは、Podの作成し、そのPodが停止されることのないプロセスを持つことにおいて<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>と同様です(例: webサーバー、ストレージサーバー)。</p><p>フロントエンドのようなServiceのように、どのホスト上にPodが稼働するか制御するよりも、レプリカ数をスケールアップまたはスケールダウンしたりローリングアップデートする方が重要であるような、状態をもたないServiceに対してDeploymentを使ってください。
Podのコピーが全てまたは特定のホスト上で常に稼働していることが重要な場合や、他のPodの前に起動させる必要があるときにDaemonSetを使ってください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-cc7cc3c4907039d9f863162e20bfbbef>4.2.5 - Jobs</h1><p>Jobは一つ以上のPodを作成し、指定された数のPodが正常に終了するまで、Podの実行を再試行し続けます。Podが正常に終了すると、Jobは成功したPodの数を追跡します。指定された完了数に達すると、そのタスク(つまりJob)は完了したとみなされます。Jobを削除すると、作成されたPodも一緒に削除されます。Jobを一時停止すると、再開されるまで、稼働しているPodは全部削除されます。</p><p>単純なケースを言うと、確実に一つのPodが正常に完了するまで実行されるよう、一つのJobオブジェクトを作成します。
一つ目のPodに障害が発生したり、(例えばノードのハードウェア障害またノードの再起動が原因で)削除されたりすると、Jobオブジェクトは新しいPodを作成します。</p><p>Jobで複数のPodを並列で実行することもできます。</p><p>スケジュールに沿ってJob(単一のタスクか複数タスク並列のいずれか)を実行したい場合は <a href=/ja/docs/concepts/workloads/controllers/cron-jobs/>CronJob</a>を参照してください。</p><h2 id=running-an-example-job>実行例</h2><p>下記にJobの定義例を記載しています。πを2000桁まで計算して出力するJobで、完了するまで約10秒かかります。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/job.yaml download=controllers/job.yaml><code>controllers/job.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-job-yaml")' title="Copy controllers/job.yaml to clipboard"></img></div><div class=includecode id=controllers-job-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl:5.34.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>backoffLimit</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>このコマンドで実行できます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/controllers/job.yaml
</span></span></code></pre></div><p>実行結果はこのようになります:</p><pre tabindex=0><code>job.batch/pi created
</code></pre><p><code>kubectl</code>でJobの状態を確認できます:</p><ul class="nav nav-tabs" id=check-status-of-job role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#check-status-of-job-0 role=tab aria-controls=check-status-of-job-0 aria-selected=true>kubectl describe job pi</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#check-status-of-job-1 role=tab aria-controls=check-status-of-job-1>kubectl get job pi -o yaml</a></li></ul><div class=tab-content id=check-status-of-job><div id=check-status-of-job-0 class="tab-pane show active" role=tabpanel aria-labelledby=check-status-of-job-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>Name:           pi
</span></span><span style=display:flex><span>Namespace:      default
</span></span><span style=display:flex><span>Selector:       controller-uid<span style=color:#666>=</span>c9948307-e56d-4b5d-8302-ae2d7b7da67c
</span></span><span style=display:flex><span>Labels:         controller-uid<span style=color:#666>=</span>c9948307-e56d-4b5d-8302-ae2d7b7da67c
</span></span><span style=display:flex><span>                job-name<span style=color:#666>=</span>pi
</span></span><span style=display:flex><span>Annotations:    kubectl.kubernetes.io/last-applied-configuration:
</span></span><span style=display:flex><span>                  <span style=color:#666>{</span><span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;batch/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Job&#34;</span>,<span style=color:#b44>&#34;metadata&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;annotations&#34;</span>:<span style=color:#666>{}</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;pi&#34;</span>,<span style=color:#b44>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span><span style=color:#666>}</span>,<span style=color:#b44>&#34;spec&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;backoffLimit&#34;</span>:4,<span style=color:#b44>&#34;template&#34;</span>:...
</span></span><span style=display:flex><span>Parallelism:    <span style=color:#666>1</span>
</span></span><span style=display:flex><span>Completions:    <span style=color:#666>1</span>
</span></span><span style=display:flex><span>Start Time:     Mon, <span style=color:#666>02</span> Dec <span style=color:#666>2019</span> 15:20:11 +0200
</span></span><span style=display:flex><span>Completed At:   Mon, <span style=color:#666>02</span> Dec <span style=color:#666>2019</span> 15:21:16 +0200
</span></span><span style=display:flex><span>Duration:       65s
</span></span><span style=display:flex><span>Pods Statuses:  <span style=color:#666>0</span> Running / <span style=color:#666>1</span> Succeeded / <span style=color:#666>0</span> Failed
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>  Labels:  controller-uid<span style=color:#666>=</span>c9948307-e56d-4b5d-8302-ae2d7b7da67c
</span></span><span style=display:flex><span>           job-name<span style=color:#666>=</span>pi
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   pi:
</span></span><span style=display:flex><span>    Image:      perl:5.34.0
</span></span><span style=display:flex><span>    Port:       &lt;none&gt;
</span></span><span style=display:flex><span>    Host Port:  &lt;none&gt;
</span></span><span style=display:flex><span>    Command:
</span></span><span style=display:flex><span>      perl
</span></span><span style=display:flex><span>      -Mbignum<span style=color:#666>=</span>bpi
</span></span><span style=display:flex><span>      -wle
</span></span><span style=display:flex><span>      print bpi<span style=color:#666>(</span>2000<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    Environment:  &lt;none&gt;
</span></span><span style=display:flex><span>    Mounts:       &lt;none&gt;
</span></span><span style=display:flex><span>  Volumes:        &lt;none&gt;
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type    Reason            Age   From            Message
</span></span><span style=display:flex><span>  ----    ------            ----  ----            -------
</span></span><span style=display:flex><span>  Normal  SuccessfulCreate  14m   job-controller  Created pod: pi-5rwd7
</span></span></code></pre></div></div><div id=check-status-of-job-1 class=tab-pane role=tabpanel aria-labelledby=check-status-of-job-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>apiVersion: batch/v1
</span></span><span style=display:flex><span>kind: Job
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  annotations:
</span></span><span style=display:flex><span>    kubectl.kubernetes.io/last-applied-configuration: |
</span></span><span style=display:flex><span>      <span style=color:#666>{</span><span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;batch/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Job&#34;</span>,<span style=color:#b44>&#34;metadata&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;annotations&#34;</span>:<span style=color:#666>{}</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;pi&#34;</span>,<span style=color:#b44>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span><span style=color:#666>}</span>,<span style=color:#b44>&#34;spec&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;backoffLimit&#34;</span>:4,<span style=color:#b44>&#34;template&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;spec&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;containers&#34;</span>:<span style=color:#666>[{</span><span style=color:#b44>&#34;command&#34;</span>:<span style=color:#666>[</span><span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#b44>&#34;print bpi(2000)&#34;</span><span style=color:#666>]</span>,<span style=color:#b44>&#34;image&#34;</span>:<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;pi&#34;</span><span style=color:#666>}]</span>,<span style=color:#b44>&#34;restartPolicy&#34;</span>:<span style=color:#b44>&#34;Never&#34;</span><span style=color:#666>}}}}</span>
</span></span><span style=display:flex><span>  creationTimestamp: <span style=color:#b44>&#34;2022-06-15T08:40:15Z&#34;</span>
</span></span><span style=display:flex><span>  generation: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    controller-uid: 863452e6-270d-420e-9b94-53a54146c223
</span></span><span style=display:flex><span>    job-name: pi
</span></span><span style=display:flex><span>  name: pi
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>  resourceVersion: <span style=color:#b44>&#34;987&#34;</span>
</span></span><span style=display:flex><span>  uid: 863452e6-270d-420e-9b94-53a54146c223
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  backoffLimit: <span style=color:#666>4</span>
</span></span><span style=display:flex><span>  completionMode: NonIndexed
</span></span><span style=display:flex><span>  completions: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  parallelism: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    matchLabels:
</span></span><span style=display:flex><span>      controller-uid: 863452e6-270d-420e-9b94-53a54146c223
</span></span><span style=display:flex><span>  suspend: <span style=color:#a2f>false</span>
</span></span><span style=display:flex><span>  template:
</span></span><span style=display:flex><span>    metadata:
</span></span><span style=display:flex><span>      creationTimestamp: null
</span></span><span style=display:flex><span>      labels:
</span></span><span style=display:flex><span>        controller-uid: 863452e6-270d-420e-9b94-53a54146c223
</span></span><span style=display:flex><span>        job-name: pi
</span></span><span style=display:flex><span>    spec:
</span></span><span style=display:flex><span>      containers:
</span></span><span style=display:flex><span>      - command:
</span></span><span style=display:flex><span>        - perl
</span></span><span style=display:flex><span>        - -Mbignum<span style=color:#666>=</span>bpi
</span></span><span style=display:flex><span>        - -wle
</span></span><span style=display:flex><span>        - print bpi<span style=color:#666>(</span>2000<span style=color:#666>)</span>
</span></span><span style=display:flex><span>        image: perl:5.34.0
</span></span><span style=display:flex><span>        imagePullPolicy: Always
</span></span><span style=display:flex><span>        name: pi
</span></span><span style=display:flex><span>        resources: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>        terminationMessagePath: /dev/termination-log
</span></span><span style=display:flex><span>        terminationMessagePolicy: File
</span></span><span style=display:flex><span>      dnsPolicy: ClusterFirst
</span></span><span style=display:flex><span>      restartPolicy: Never
</span></span><span style=display:flex><span>      schedulerName: default-scheduler
</span></span><span style=display:flex><span>      securityContext: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>      terminationGracePeriodSeconds: <span style=color:#666>30</span>
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  active: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  ready: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  startTime: <span style=color:#b44>&#34;2022-06-15T08:40:15Z&#34;</span>
</span></span></code></pre></div></div></div><p>Jobの完了したPodを確認するには、<code>kubectl get pods</code>を使います。</p><p>Jobに属するPodの一覧を機械可読形式で出力するには、下記のコマンドを使います:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span>job-name<span style=color:#666>=</span>pi --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$pods</span>
</span></span></code></pre></div><p>出力結果はこのようになります:</p><pre tabindex=0><code>pi-5rwd7
</code></pre><p>ここのセレクターはJobのセレクターと同じです。<code>--output=jsonpath</code>オプションは、返されたリストからPodのnameフィールドを指定するための表現です。</p><p>その中の一つのPodの標準出力を確認するには:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs <span style=color:#b8860b>$pods</span>
</span></span></code></pre></div><p>出力結果はこのようになります:</p><pre tabindex=0><code>3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275901
</code></pre><h2 id=writing-a-job-spec>Job spec(仕様)の書き方</h2><p>他のKubernetesオブジェクト設定ファイルと同様に、Jobにも<code>apiVersion</code>、<code>kind</code>または<code>metadata</code>フィールドが必要です。
Jobの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><p>Jobには<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code>セクション</a>も必要です。</p><h3 id=pod-template>Podテンプレート</h3><p><code>.spec.template</code>は<code>.spec</code>の唯一の必須フィールドです。</p><p><code>.spec.template</code>は<a href=/ja/docs/concepts/workloads/pods/#pod-template>podテンプレート</a>です。ネストされていることと<code>apiVersion</code>や<code>kind</code>フィールドが不要になったことを除いて、仕様の定義が<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>と全く同じです。</p><p>Podの必須フィールドに加えて、Job定義ファイルにあるPodテンプレートでは、適切なラベル(<a href=#pod-selector>podセレクター</a>を参照)と適切な再起動ポリシーを指定する必要があります。</p><p><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>RestartPolicy</code></a>は<code>Never</code>か<code>OnFailure</code>のみ設定可能です。</p><h3 id=pod-selector>Podセレクター</h3><p><code>.spec.selector</code>フィールドはオプションです。ほとんどの場合はむしろ指定しないほうがよいです。
<a href=#specifying-your-own-pod-selector>独自のPodセレクターを指定</a>セクションを参照してください。</p><h3 id=parallel-jobs>Jobの並列実行</h3><p>Jobで実行するのに適したタスクは主に3種類あります:</p><ol><li>非並列Job<ul><li>通常、Podに障害が発生しない限り、一つのPodのみが起動されます。</li><li>Podが正常に終了すると、Jobはすぐに完了します。</li></ul></li><li><em>固定の完了数</em>を持つ並列Job:<ul><li><code>.spec.completions</code>に0以外の正の値を指定します。</li><li>Jobは全体的なタスクを表し、<code>.spec.completions</code>個のPodが成功すると、Jobの完了となります。</li><li><code>.spec.completionMode="Indexed"</code>を利用する場合、各Podは0から<code>.spec.completions-1</code>までの範囲内のインデックスがアサインされます。</li></ul></li><li><em>ワークキュー</em>を利用した並列Job:<ul><li><code>.spec.completions</code>の指定をしない場合、デフォルトは<code>.spec.parallelism</code>となります。</li><li>Pod間で調整する、または外部サービスを使う方法で、それぞれ何のタスクに着手するかを決めます。例えば、一つのPodはワークキューから最大N個のタスクを一括で取得できます。</li><li>各Podは他のPodがすべて終了したかどうか、つまりJobが完了したかどうかを単独で判断できます。</li><li>Jobに属する <em>任意</em> のPodが正常に終了すると、新しいPodは作成されません。</li><li>一つ以上のPodが正常に終了し、すべてのPodが終了すると、Jobは正常に完了します。</li><li>一つのPodが正常に終了すると、他のPodは同じタスクの作業を行ったり、出力を書き込んだりすることはできません。すべてのPodが終了プロセスに進む必要があります。</li></ul></li></ol><p><em>非並列</em> Jobの場合、<code>.spec.completions</code>と<code>.spec.parallelism</code>の両方を未設定のままにしておくことも可能です。未設定の場合、両方がデフォルトで1になります。</p><p><em>完了数固定</em> Jobの場合、<code>.spec.completions</code>を必要完了数に設定する必要があります。
<code>.spec.parallelism</code>を設定してもいいですし、未設定の場合、デフォルトで1になります。</p><p><em>ワークキュー</em> 並列Jobの場合、<code>.spec.completions</code>を未設定のままにし、<code>.spec.parallelism</code>を非負の整数に設定する必要があります。</p><p>各種類のJobの使用方法の詳細については、<a href=#job-patterns>Jobパターン</a>セクションを参照してください。</p><h4 id=controlling-parallelism>並列処理の制御</h4><p>必要並列数(<code>.spec.parallelism</code>)は任意の非負の値に設定できます。
未設定の場合は、デフォルトで1になります。
0に設定した際には、増加するまでJobは一時停止されます。</p><p>実際の並列数(任意の瞬間に実行されているPod数)は、さまざまな理由により、必要並列数と異なる可能性があります:</p><ul><li><em>完了数固定</em> Jobの場合、実際に並列して実行されるPodの数は、残りの完了数を超えることはありません。 <code>.spec.parallelism</code>の値が高い場合は無視されます。</li><li><em>ワークキュー</em> Jobの場合、任意のPodが成功すると、新しいPodは作成されません。ただし、残りのPodは終了まで実行し続けられます。</li><li>Job<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>の応答する時間がなかった場合。</li><li>Jobコントローラーが何らかの理由で(<code>ResourceQuota</code>の不足、権限の不足など)、Podを作成できない場合、
実際の並列数は必要並列数より少なくなる可能性があります。</li><li>同じJobで過去に発生した過度のPod障害が原因で、Jobコントローラーは新しいPodの作成を抑制することがあります。</li><li>Podがグレースフルシャットダウンされた場合、停止するのに時間がかかります。</li></ul><h3 id=completion-mode>完了モード</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [stable]</code></div><p><em>完了数固定</em> Job、つまり<code>.spec.completions</code>の値がnullではないJobは<code>.spec.completionMode</code>で完了モードを指定できます:</p><ul><li><p><code>NonIndexed</code>(デフォルト): <code>.spec.completions</code>個のPodが成功した場合、Jobの完了となります。言い換えれば、各Podの完了状態は同質です。ここで要注意なのは、<code>.spec.completions</code>の値がnullの場合、暗黙的に<code>NonIndexed</code>として指定されることです。</p></li><li><p><code>Indexed</code>: Jobに属するPodはそれぞれ、0から<code>.spec.completions-1</code>の範囲内の完了インデックスを取得できます。インデックスは下記の三つの方法で取得できます。</p><ul><li>Podアノテーション<code>batch.kubernetes.io/job-completion-index</code>。</li><li>Podホスト名の一部として、<code>$(job-name)-$(index)</code>の形式になっています。
インデックス付きJob(Indexed Job)と<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を一緒に使用すると、Jobに属するPodはお互いにDNSを介して確定的ホスト名で通信できます。</li><li>コンテナ化されたタスクの環境変数<code>JOB_COMPLETION_INDEX</code>。</li></ul><p>インデックスごとに、成功したPodが一つ存在すると、Jobの完了となります。完了モードの使用方法の詳細については、
<a href=/ja/docs/tasks/job/indexed-parallel-processing-static/>静的な処理の割り当てを使用した並列処理のためのインデックス付きJob</a>を参照してください。めったに発生しませんが、同じインデックスを取得して稼働し始めるPodも存在する可能性があります。ただし、完了数にカウントされるのはそのうちの一つだけです。</p></li></ul><h2 id=handling-pod-and-container-failures>Podとコンテナの障害対策</h2><p>Pod内のコンテナは、その中のプロセスが0以外の終了コードで終了した、またはメモリ制限を超えたためにコンテナが強制終了されたなど、様々な理由で失敗することがあります。この場合、もし<code>.spec.template.spec.restartPolicy = "OnFailure"</code>と設定すると、Podはノード上に残りますが、コンテナは再実行されます。そのため、プログラムがローカルで再起動した場合の処理を行うか、<code>.spec.template.spec.restartPolicy = "Never"</code>と指定する必要があります。
<code>restartPolicy</code>の詳細については<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>を参照してください。</p><p>Podがノードからキックされた(ノードがアップグレード、再起動、削除されたなど)、または<code>.spec.template.spec.restartPolicy = "Never"</code>と設定されたときにPodに属するコンテナが失敗したなど、様々な理由でPod全体が故障することもあります。Podに障害が発生すると、Jobコントローラーは新しいPodを起動します。つまりアプリケーションは新しいPodで再起動された場合の処理を行う必要があります。特に、過去に実行した際に生じた一時ファイル、ロック、不完全な出力などを処理する必要があります。</p><p><code>.spec.parallelism = 1</code>、<code>.spec.completions = 1</code>と<code>.spec.template.spec.restartPolicy = "Never"</code>を指定しても、同じプログラムが2回起動されることもありますので注意してください。</p><p><code>.spec.parallelism</code>と<code>.spec.completions</code>を両方とも2以上指定した場合、複数のPodが同時に実行される可能性があります。そのため、Podは並行処理を行えるようにする必要があります。</p><h3 id=pod-backoff-failure-policy>Pod失敗のバックオフポリシー</h3><p>設定の論理エラーなどにより、Jobが数回再試行した後に失敗状態にしたい場合があります。<code>.spec.backoffLimit</code>を設定すると、失敗したと判断するまでの再試行回数を指定できます。バックオフ制限はデフォルトで6に設定されています。Jobに属していて失敗したPodはJobコントローラーにより再作成され、バックオフ遅延は指数関数的に増加し(10秒、20秒、40秒…)、最大6分まで増加します。</p><p>再実行回数の算出方法は以下の2通りです:</p><ul><li><code>.status.phase = "Failed"</code>で設定されたPod数を計算します。</li><li><code>restartPolicy = "OnFailure"</code>と設定された場合、<code>.status.phase</code>が<code>Pending</code>または<code>Running</code>であるPodに属するすべてのコンテナで再試行する回数を計算します。</li></ul><p>どちらかの計算が<code>.spec.backoffLimit</code>に達した場合、Jobは失敗とみなされます。</p><p><a href=#job-tracking-with-finalizers><code>JobTrackingWithFinalizers</code></a>機能が無効な場合、
失敗したPodの数は、API内にまだ存在するPodのみに基づいています。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>restartPolicy = "OnFailure"</code>が設定されたJobはバックオフ制限に達すると、属するPodは全部終了されるので注意してください。これにより、Jobの実行ファイルのデバッグ作業が難しくなる可能性があります。失敗したJobからの出力が不用意に失われないように、Jobのデバッグ作業をする際は<code>restartPolicy = "Never"</code>を設定するか、ロギングシステムを使用することをお勧めします。</div><h2 id=job-termination-and-cleanup>Jobの終了とクリーンアップ</h2><p>Jobが完了すると、それ以上Podは作成されませんが、<a href=#pod-backoff-failure-policy>通常</a>Podが削除されることもありません。
これらを残しておくと、完了したPodのログを確認でき、エラーや警告などの診断出力を確認できます。
またJobオブジェクトはJob完了後も残っているため、状態を確認することができます。古いJobの状態を把握した上で、削除するかどうかはユーザー次第です。Jobを削除するには<code>kubectl</code> (例:<code>kubectl delete jobs/pi</code>または<code>kubectl delete -f ./job.yaml</code>)を使います。<code>kubectl</code>でJobを削除する場合、Jobが作成したPodも全部削除されます。</p><p>デフォルトでは、Jobは中断されることなく実行できますが、Podが失敗した場合(<code>restartPolicy=Never</code>)、またはコンテナがエラーで終了した場合(<code>restartPolicy=OnFailure</code>)のみ、前述の<code>.spec.backoffLimit</code>で決まった回数まで再試行します。<code>.spec.backoffLimit</code>に達すると、Jobが失敗とマークされ、実行中のPodもすべて終了されます。</p><p>Jobを終了させるもう一つの方法は、活動期間を設定することです。
Jobの<code>.spec.activeDeadlineSeconds</code>フィールドに秒数を設定することで、活動期間を設定できます。
Podがいくつ作成されても、<code>activeDeadlineSeconds</code>はJobの存続する時間に適用されます。
Jobが<code>activeDeadlineSeconds</code>に達すると、実行中のすべてのPodは終了され、Jobの状態は<code>type: Failed</code>になり、理由は<code>reason: DeadlineExceeded</code>になります。</p><p>ここで要注意なのは、Jobの<code>.spec.activeDeadlineSeconds</code>は<code>.spec.backoffLimit</code>よりも優先されます。したがって、失敗して再試行しているPodが一つ以上持っているJobは、<code>backoffLimit</code>に達していなくても、<code>activeDeadlineSeconds</code>で指定された設定時間に達すると、追加のPodをデプロイしなくなります。</p><p>例えば:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi-with-timeout<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>backoffLimit</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>activeDeadlineSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl:5.34.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><p>Job仕様と、Jobに属する<a href=/ja/docs/concepts/workloads/pods/init-containers/#detailed-behavior>Podテンプレートの仕様</a>は両方とも<code>activeDeadlineSeconds</code>フィールドを持っているので注意してください。適切なレベルで設定していることを確認してください。</p><p>また<code>restartPolicy</code>はJob自体ではなく、Podに適用されることも注意してください: Jobの状態は<code>type: Failed</code>になると、自動的に再起動されることはありません。
つまり、<code>.spec.activeDeadlineSeconds</code>と<code>.spec.backoffLimit</code>によって引き起こされるJob終了メカニズムは、永久的なJob失敗につながり、手動で介入して解決する必要があります。</p><h2 id=clean-up-finished-jobs-automatically>終了したJobの自動クリーンアップ</h2><p>終了したJobは通常システムに残す必要はありません。残ったままにしておくとAPIサーバーに負担をかけることになります。Jobが上位コントローラーにより直接管理されている場合、例えば<a href=/ja/docs/concepts/workloads/controllers/cron-jobs/>CronJobs</a>の場合、Jobは指定された容量ベースのクリーンアップポリシーに基づき、CronJobによりクリーンアップされます。</p><h3 id=ttl-mechanism-for-finished-jobs>終了したJobのTTLメカニズム</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code></div><p>終了したJob(状態が<code>Complete</code>か<code>Failed</code>になったJob)を自動的にクリーンアップするもう一つの方法は
<a href=/ja/docs/concepts/workloads/controllers/ttlafterfinished/>TTLコントローラー</a>より提供されたTTLメカニズムです。<code>.spec.ttlSecondsAfterFinished</code>フィールドを指定することで、終了したリソースをクリーンアップすることができます。</p><p>TTLコントローラーでJobをクリーンアップする場合、Jobはカスケード的に削除されます。つまりJobを削除する際に、Jobに属しているオブジェクト、例えばPodなども一緒に削除されます。Jobが削除される場合、Finalizerなどの、Jobのライフサイクル保証は守られることに注意してください。</p><p>例えば:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi-with-ttl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ttlSecondsAfterFinished</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl:5.34.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><p>Job <code>pi-with-ttl</code>は終了してからの<code>100</code>秒後に自動的に削除されるようになっています。</p><p>このフィールドに<code>0</code>を設定すると、Jobは終了後すぐに自動削除の対象になります。このフィールドに何も設定しないと、Jobが終了してもTTLコントローラーによるクリーンアップはされません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p><code>ttlSecondsAfterFinished</code>フィールドを設定することが推奨されます。管理されていないJob(CronJobなどの、他のワークロードAPIを経由せずに、直接作成したJob)は<code>orphanDependents</code>というデフォルトの削除ポリシーがあるため、Jobが完全に削除されても、属しているPodが残ってしまうからです。
<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>は最終的に、失敗または完了して削除されたJobに属するPodを<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>ガベージコレクション</a>しますが、Podが残っていると、クラスターのパフォーマンスが低下することがあり、最悪の場合、この低下によりクラスターがオフラインになることがあります。</p><p><a href=/ja/docs/concepts/policy/limit-range/>LimitRanges</a>と<a href=/ja/docs/concepts/policy/resource-quotas/>リソースクォータ</a>で、指定する名前空間が消費できるリソースの量に上限を設定することができます。</p></div><h2 id=job-patterns>Jobパターン</h2><p>Jobオブジェクトは、Podの確実な並列実行をサポートするために使用されます。科学技術計算でよく見られるような、密接に通信を行う並列処理をサポートするようには設計されていません。独立だが関連性のある一連の<em>作業項目</em>の並列処理をサポートします。例えば送信すべき電子メール、レンダリングすべきフレーム、トランスコードすべきファイル、スキャンすべきNoSQLデータベースのキーの範囲、などです。</p><p>複雑なシステムでは、異なる作業項目のセットが複数存在する場合があります。ここでは、ユーザーが一斉に管理したい作業項目のセットが一つだけの場合 — つまり<em>バッチJob</em>だけを考えます。</p><p>並列計算にはいくつかのパターンがあり、それぞれに長所と短所があります。
トレードオフの関係にあるのは:</p><ul><li>各作業項目に1つのJobオブジェクト vs. すべての作業項目に1つのJobオブジェクト。<br>　後者は大量の作業項目を処理する場合に適しています。<br>　前者は大量のJobオブジェクトを管理するため、ユーザーとシステムにオーバーヘッドをかけることになります。</li><li>作成されるPod数が作業項目数と等しい、 vs. 各Podが複数の作業項目を処理する。
　前者は通常、既存のコードやコンテナへの変更が少なくて済みます。
後者は上記と同じ理由で、大量の作業項目を処理する場合に適しています。</li><li>ワークキューを利用するアプローチもいくつかあります。それを使うためには、キューサービスを実行し、既存のプログラムやコンテナにワークキューを利用させるための改造を行う必要があります。
他のアプローチは既存のコンテナ型アプリケーションに適用しやすいです。</li></ul><p>ここでは、上記のトレードオフをまとめてあり、それぞれ2～4列目に対応しています。
またパターン名のところは、例やより詳しい説明が書いてあるページへのリンクになっています。</p><table><thead><tr><th>パターン</th><th style=text-align:center>単一Jobオブジェクト</th><th style=text-align:center>Podが作業項目より少ない？</th><th style=text-align:center>アプリを修正せずに使用できる？</th></tr></thead><tbody><tr><td><a href=/docs/tasks/job/coarse-parallel-processing-work-queue/>作業項目ごとにPodを持つキュー</a></td><td style=text-align:center>✓</td><td style=text-align:center></td><td style=text-align:center>時々</td></tr><tr><td><a href=/docs/tasks/job/fine-parallel-processing-work-queue/>Pod数可変のキュー</a></td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center></td></tr><tr><td><a href=/ja/docs/tasks/job/indexed-parallel-processing-static/>静的な処理の割り当てを使用したインデックス付きJob</a></td><td style=text-align:center>✓</td><td style=text-align:center></td><td style=text-align:center>✓</td></tr><tr><td><a href=/docs/tasks/job/parallel-processing-expansion/>Jobテンプレート拡張</a></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>✓</td></tr></tbody></table><p><code>.spec.completions</code>で完了数を指定する場合、Jobコントローラーより作成された各Podは同一の<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>spec</code></a>を持ちます。これは、このタスクのすべてのPodが同じコマンドライン、同じイメージ、同じボリューム、そして(ほぼ)同じ環境変数を持つことを意味します。これらのパターンは、Podが異なる作業をするためのさまざまな配置方法になります。</p><p>この表は、各パターンで必要な<code>.spec.parallelism</code>と<code>.spec.completions</code>の設定を示しています。
ここで、<code>W</code>は作業項目の数を表しています。</p><table><thead><tr><th>パターン</th><th style=text-align:center><code>.spec.completions</code></th><th style=text-align:center><code>.spec.parallelism</code></th></tr></thead><tbody><tr><td><a href=/docs/tasks/job/coarse-parallel-processing-work-queue/>作業項目ごとにPodを持つキュー</a></td><td style=text-align:center>W</td><td style=text-align:center>任意</td></tr><tr><td><a href=/docs/tasks/job/fine-parallel-processing-work-queue/>Pod数可変のキュー</a></td><td style=text-align:center>null</td><td style=text-align:center>任意</td></tr><tr><td><a href=/ja/docs/tasks/job/indexed-parallel-processing-static/>静的な処理の割り当てを使用したインデックス付きJob</a></td><td style=text-align:center>W</td><td style=text-align:center>任意</td></tr><tr><td><a href=/docs/tasks/job/parallel-processing-expansion/>Jobテンプレート拡張</a></td><td style=text-align:center>1</td><td style=text-align:center>1であるべき</td></tr></tbody></table><h2 id=advanced-usage>高度な使い方</h2><h3 id=suspending-a-job>Jobの一時停止</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [stable]</code></div><p>Jobが作成されると、JobコントローラーはJobの要件を満たすために直ちにPodの作成を開始し、Jobが完了するまで作成し続けます。しかし、Jobの実行を一時的に中断して後で再開したい場合、または一時停止状態のJobを再開し、再開時間は後でカスタムコントローラーに判断させたい場合はあると思います。</p><p>Jobを一時停止するには、Jobの<code>.spec.suspend</code>フィールドをtrueに修正し、後でまた再開したい場合にはfalseに修正すればよいです。
<code>.spec.suspend</code>をtrueに設定してJobを作成すると、一時停止状態のままで作成されます。</p><p>一時停止状態のJobを再開すると、<code>.status.startTime</code>フィールドの値は現在時刻にリセットされます。これはつまり、Jobが一時停止して再開すると、<code>.spec.activeDeadlineSeconds</code>タイマーは停止してリセットされることになります。</p><p>Jobを中断すると、稼働中のPodは全部削除されることを忘れないでください。Jobが中断されると、PodはSIGTERMシグナルを受信して<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>終了されます</a>。Podのグレースフル終了の猶予期間がカウントダウンされ、この期間内に、Podはこのシグナルを処理しなければなりません。場合により、その後のために処理状況を保存したり、変更を元に戻したりする処理が含まれます。この方法で終了したPodは<code>completions</code>数にカウントされません。</p><p>下記は一時停止状態のままで作成されたJobの定義例になります:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get job myjob -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myjob<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>suspend</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>Jobのstatusセクションで、Jobが停止中なのか、過去に停止したことがあるかを判断できます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get jobs/myjob -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># .metadata and .spec omitted</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-02-05T13:14:33Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-02-05T13:14:33Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Suspended<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>startTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-02-05T13:13:48Z&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Jobのcondition.typeが"Suspended"で、statusが"True"になった場合、Jobは一時停止中になります。<code>lastTransitionTime</code>フィールドで、どのぐらい中断されたかを判断できます。statusが"False"になった場合、Jobは一時停止状態でしたが、今は実行されていることになります。conditionが書いていない場合、Jobは一度も停止していないことになります。</p><p>Jobが一時停止して再開した場合、Eventsも作成されます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe jobs/myjob
</span></span></code></pre></div><pre tabindex=0><code>Name:           myjob
...
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  12m   job-controller  Created pod: myjob-hlrpl
  Normal  SuccessfulDelete  11m   job-controller  Deleted pod: myjob-hlrpl
  Normal  Suspended         11m   job-controller  Job suspended
  Normal  SuccessfulCreate  3s    job-controller  Created pod: myjob-jvb44
  Normal  Resumed           3s    job-controller  Job resumed
</code></pre><p>最後の4つのイベント、特に"Suspended"と"Resumed"のイベントは、<code>.spec.suspend</code>フィールドの値を切り替えた直接の結果です。この2つのイベントの間に、Podは作成されていないことがわかりますが、Jobが再開されるとすぐにPodの作成も再開されました。</p><h3 id=mutable-scheduling-directives>可変スケジューリング命令</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> この機能を使うためには、<a href=/docs/reference/command-line-tools-reference/kube-apiserver/>APIサーバー</a>上で<code>JobMutableNodeSchedulingDirectives</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にする必要があります。
デフォルトで有効になっています。</div><p>ほとんどの場合、並列Jobは、すべてのPodが同じゾーン、またはすべてのGPUモデルxかyのいずれかであるが、両方の混在ではない、などの制約付きで実行することが望ましいです。</p><p><a href=#suspending-a-job>suspend</a>フィールドは、これらの機能を実現するための第一歩です。Suspendは、カスタムキューコントローラーがJobをいつ開始すべきかを決定することができます。しかし、Jobの一時停止が解除されると、カスタムキューコントローラーは、Job内のPodの実際の配置場所には影響を与えません。</p><p>この機能により、Jobが開始される前にスケジューリング命令を更新でき、カスタムキューコントローラーがPodの配置に影響を与えることができると同時に、実際のPodとノードの割り当てをkube-schedulerにオフロードすることができます。これは一時停止されたJobの中で、一度も一時停止解除されたことのないJobに対してのみ許可されます。</p><p>JobのPodテンプレートで更新可能なフィールドはnodeAffinity、nodeSelector、tolerations、labelsとannotationsです。</p><h3 id=specifying-your-own-pod-selector>独自のPodセレクターを指定</h3><p>Jobオブジェクトを作成する際には通常、<code>.spec.selector</code>を指定しません。Jobが作成された際に、システムのデフォルトロジックは、他のJobと重ならないようなセレクターの値を選択し、このフィールドに追加します。</p><p>しかし、場合によっては、この自動設定されたセレクターをオーバーライドする必要があります。そのためには、Jobの<code>.spec.selector</code>を指定します。</p><p>その際には十分な注意が必要です。そのJobの他のPodと重なったラベルセレクターを指定し、無関係のPodにマッチした場合、無関係のJobのPodが削除されたり、無関係のPodが完了されてもこのJobの完了数とカウントしたり、片方または両方のJobがPodの作成または完了までの実行を拒否する可能性があります。
一意でないセレクターを選択した場合、他のコントローラー(例えばReplicationController)や属しているPodが予測できない挙動をする可能性があります。Kubernetesは<code>.spec.selector</code>を間違って設定しても止めることはしません。</p><p>下記はこの機能の使用例を紹介しています。</p><p><code>old</code>と名付けたJobがすでに実行されていると仮定します。既存のPodをそのまま実行し続けてほしい一方で、作成する残りのPodには別のテンプレートを使用し、そのJobには新しい名前を付けたいとしましょう。これらのフィールドは更新できないため、Jobを直接更新できません。そのため、<code>kubectl delete jobs/old --cascade=orphan</code>で、<em>属しているPodが実行されたまま</em>、<code>old</code>Jobを削除します。削除する前に、どのセレクターを使用しているかをメモしておきます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get job old -o yaml
</span></span></code></pre></div><p>出力結果はこのようになります:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>old<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-uid</span>:<span style=color:#bbb> </span>a8f3d00d-c6d2-11e5-9f87-42010af00002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>次に、<code>new</code>という名前で新しくJobを作成し、同じセレクターを明示的に指定します。既存のPodも<code>controller-uid=a8f3d00d-c6d2-11e5-9f87-42010af00002</code>ラベルが付いているので、同じく<code>new</code>Jobによってコントロールされます。</p><p>通常システムが自動的に生成するセレクターを使用しないため、新しいJobで <code>manualSelector: true</code>を指定する必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>manualSelector</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-uid</span>:<span style=color:#bbb> </span>a8f3d00d-c6d2-11e5-9f87-42010af00002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>新しいJobは<code>a8f3d00d-c6d2-11e5-9f87-42010af00002</code>ではなく、別のuidを持つことになります。<code>manualSelector: true</code>を設定することで、自分は何をしているかを知っていて、またこのミスマッチを許容することをシステムに伝えます。</p><h3 id=job-tracking-with-finalizers>FinalizerによるJob追跡</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>この機能を使うためには、<a href=/docs/reference/command-line-tools-reference/kube-apiserver/>APIサーバー</a>と<a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>コントローラーマネージャー</a>で<code>JobTrackingWithFinalizers</code>
<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にする必要があります。</p><p>有効にした場合、コントロールプレーンは下記に示す機能で新しいJobを追跡します。この機能が有効になる前に作成されたJobは影響を受けません。ユーザーとして実感できる唯一の違いは、コントロールプレーンのJob完了ステータス追跡がより正確になるということだけです。</p></div><p>この機能が有効でない場合、Job <a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=Controller>Controller</a>はクラスター内に存在するPodを数えてJobステータスを追跡します。つまり<code>succeeded</code>Podと<code>failed</code>Podのカウンターを保持します。
しかし、Podは以下のような理由で削除されることもあります:</p><ul><li>Nodeがダウンしたときに、孤立した(Orphan)Podを削除するガベージコレクター。</li><li>閾値に達すると、(<code>Succeeded</code>または<code>Failed</code>フェーズで)終了したPodを削除するガベージコレクター。</li><li>Jobに属するPodの人為的な削除。</li><li>外部コントローラー(Kubernetesの一部として提供されていない)によるPodの削除や置き換え。</li></ul><p>クラスターで<code>JobTrackingWithFinalizers</code>機能を有効にすると、コントロールプレーンは任意のJobに属するPodを追跡し、そのようなPodがAPIサーバーから削除された場合に通知します。そのために、Jobコントローラーは<code>batch.kubernetes.io/job-tracking</code>Finalizerを持つPodを作成します。コントローラーはPodがJobステータスに計上された後にのみFinalizerを削除し、他のコントローラーやユーザーによるPodの削除を可能にします。</p><p>Jobコントローラーは、新しいJobに対してのみ新しいアルゴリズムを使用します。この機能が有効になる前に作成されたJobは影響を受けません。JobコントローラーがPod FinalizerでJob追跡しているかどうかは、Jobが<code>batch.kubernetes.io/job-tracking</code>というアノテーションを持っているかどうかで判断できます。
このアノテーションを手動で追加または削除しては<strong>いけません</strong>。</p><h2 id=alternatives>代替案</h2><h3 id=bare-pods>単なるPod</h3><p>Podが動作しているノードが再起動または故障した場合、Podは終了し、再起動されません。しかし、終了したPodを置き換えるため、Jobが新しいPodを作成します。このため、たとえアプリケーションが1つのPodしか必要としない場合でも、単なるPodではなくJobを使用することをお勧めします。</p><h3 id=replication-controller>Replication Controller</h3><p>Jobは<a href=/docs/concepts/workloads/controllers/replicationcontroller/>Replication Controllers</a>を補完するものです。
Replication Controllerは、終了することが想定されていないPod(Webサーバーなど)を管理し、Jobは終了することが想定されているPod(バッチタスクなど)を管理します。</p><p><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>で説明したように、<code>Job</code>は<code>RestartPolicy</code>が<code>OnFailure</code>か<code>Never</code>と設定されているPodに<em>のみ</em>適用されます。(注意:<code>RestartPolicy</code>が設定されていない場合、デフォルト値は<code>Always</code>になります)</p><h3 id=single-job-starts-controller-pod>シングルJobによるコントローラーPodの起動</h3><p>もう一つのパターンは、一つのJobが一つPodを作り、そのPodがカスタムコントローラーのような役割を果たし、他のPodを作ります。これは最も柔軟性がありますが、使い始めるにはやや複雑で、Kubernetesとの統合もあまりできません。</p><p>このパターンの一例としては、Sparkマスターコントローラーを起動し、sparkドライバーを実行してクリーンアップするスクリプトを実行するPodをJobで起動する(<a href=https://github.com/kubernetes/examples/tree/master/staging/spark/README.md>sparkの例</a>を参照)が挙げられます。</p><p>この方法のメリットは、全処理過程でJobオブジェクトが完了する保証がありながらも、どのPodを作成し、どのように作業を割り当てるかを完全に制御できることです。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/workloads/pods/>Pods</a>について学ぶ。</li><li>Jobのさまざまな実行方法について学ぶ:<ul><li><a href=/docs/tasks/job/coarse-parallel-processing-work-queue/>ワークキューを用いた粒度の粗い並列処理</a></li><li><a href=/docs/tasks/job/fine-parallel-processing-work-queue/>ワークキューを用いた粒度の細かい並列処理</a></li><li><a href=/ja/docs/tasks/job/indexed-parallel-processing-static/>静的な処理の割り当てを使用した並列処理のためのインデックス付きJob</a> を使う</li><li>テンプレートを元に複数のJobを作成: <a href=/docs/tasks/job/parallel-processing-expansion/>拡張機能を用いた並列処理</a></li></ul></li><li><a href=#clean-up-finished-jobs-automatically>終了したJobの自動クリーンアップ</a>のリンクから、クラスターが完了または失敗したJobをどのようにクリーンアップするかをご確認ください。</li><li><code>Job</code>はKubernetes REST APIの一部です。JobのAPIを理解するために、
<a href=/docs/reference/kubernetes-api/workload-resources/job-v1/>Job</a>オブジェクトの定義をお読みください。</li><li>UNIXツールの<code>cron</code>と同様に、スケジュールに基づいて実行される一連のJobを定義するために使用できる<a href=/ja/docs/concepts/workloads/controllers/cron-jobs/><code>CronJob</code></a>についてお読みください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-9add0d2120634b63073ad08dc8683bd6>4.2.6 - ガベージコレクション</h1><p>Kubernetesのガベージコレクターの役割は、かつてオーナーがいたが、現時点でもはやオーナーがいないようなオブジェクトの削除を行うことです。</p><h2 id=owners-and-dependents>オーナーとその従属オブジェクト</h2><p>いくつかのKubernetesオブジェクトは他のオブジェクトのオーナーとなります。例えば、ReplicaSetはPodのセットに対するオーナーです。オーナーによって所有されたオブジェクトは、オーナーオブジェクトの<em>従属オブジェクト(Dependents)</em> と呼ばれます。全ての従属オブジェクトは、オーナーオブジェクトを指し示す<code>metadata.ownerReferences</code>というフィールドを持ちます。</p><p>時々、Kubernetesは<code>ownerReference</code>フィールドに値を自動的にセットします。例えば、ユーザーがReplicaSetを作成したとき、KubernetesはReplicaSet内の各Podの<code>ownerReference</code>フィールドに自動的に値をセットします。Kubernetes1.8において、KubernetesはReplicaController、ReplicaSet、StatefulSet、DaemonSet、Deployment、Job、CronJobによって作成され、適用されたオブジェクトの<code>ownerReference</code>フィールドに自動的にその値をセットします。</p><p>ユーザーはまた<code>ownerReference</code>フィールドに手動で値をセットすることにより、オーナーと従属オブジェクト間の関係を指定することができます。</p><p>下記の例は、3つのPodを持つReplicaSetの設定ファイルとなります。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/replicaset.yaml download=controllers/replicaset.yaml><code>controllers/replicaset.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-replicaset-yaml")' title="Copy controllers/replicaset.yaml to clipboard"></img></div><div class=includecode id=controllers-replicaset-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-repset<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pod-is-for</span>:<span style=color:#bbb> </span>garbage-collection-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pod-is-for</span>:<span style=color:#bbb> </span>garbage-collection-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>もしユーザーがReplicaSetを作成し、Podのメタデータを見る時、<code>ownerReference</code>フィールドの値を確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/replicaset.yaml
</span></span><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>その出力結果によると、そのPodのオーナーは<code>my-repset</code>という名前のReplicaSetです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ownerReferences</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>blockOwnerDeletion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-repset<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>d9607e19-f88f-11e6-a518-42010a800195<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>ネームスペースをまたいだownerReferenceは意図的に許可されていません。これは以下のことを意味します。</p><ol><li>ネームスペース内のスコープの従属オブジェクトは、同一のネームスペース内のオーナーと、クラスターのスコープ内のオーナーのみ指定できます。</li><li>クラスターのスコープ内の従属オブジェクトは、クラスターのスコープ内のオーナーオブジェクトのみ指定でき、ネームスペース内のスコープのオーナーオブジェクトは指定できません。</li></ol></div><h2 id=ガベージコレクターがどのように従属オブジェクトの削除をするかを制御する>ガベージコレクターがどのように従属オブジェクトの削除をするかを制御する</h2><p>ユーザーがオブジェクトを削除するとき、それに紐づく従属オブジェクトも自動で削除するか指定できます。従属オブジェクトの自動削除は、<em>カスケード削除(Cascading deletion)</em> と呼ばれます。<em>カスケード削除</em> には2つのモードがあり、<em>バックグラウンド</em> と<em>フォアグラウンド</em> があります。</p><p>もしユーザーが、従属オブジェクトの自動削除なしにあるオブジェクトを削除する場合、その従属オブジェクトは<em>みなしご(orphaned)</em> と呼ばれます。</p><h3 id=フォアグラウンドのカスケード削除>フォアグラウンドのカスケード削除</h3><p><em>フォアグラウンドのカスケード削除</em> において、そのルートオブジェクトは最初に"削除処理中"という状態に遷移します。その<em>削除処理中</em> 状態において、下記の項目は正となります。</p><ul><li>そのオブジェクトはREST APIを介して確認可能です。</li><li>そのオブジェクトの<code>deletionTimestamp</code>がセットされます。</li><li>そのオブジェクトの<code>metadata.finalizers</code>フィールドは、<code>foregroundDeletion</code>という値を含みます。</li></ul><p>一度"削除処理中"状態に遷移すると、そのガベージコレクターはオブジェクトの従属オブジェクトを削除します。一度そのガベージコレクターが全ての”ブロッキングしている”従属オブジェクトを削除すると(<code>ownerReference.blockOwnerDeletion=true</code>という値を持つオブジェクト)、それはオーナーのオブジェクトも削除します。</p><p>注意点として、"フォアグラウンドのカスケード削除"において、<code>ownerReference.blockOwnerDeletion=true</code>フィールドを持つ従属オブジェクトのみ、そのオーナーオブジェクトの削除をブロックします。
Kubernetes1.7では、認証されていない従属オブジェクトがオーナーオブジェクトの削除を遅らせることができないようにするために<a href=/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement>アドミッションコントローラー</a>が追加され、それは、オーナーオブジェクトの削除パーミッションに基づいて<code>blockOwnerDeletion</code>の値がtrueに設定してユーザーアクセスをコントロールします。</p><p>もしオブジェクトの<code>ownerReferences</code>フィールドがコントローラー(DeploymentやReplicaSetなど)によってセットされている場合、<code>blockOwnerDeletion</code>は自動的にセットされ、ユーザーはこのフィールドを手動で修正する必要はありません。</p><h3 id=バックグラウンドのカスケード削除>バックグラウンドのカスケード削除</h3><p><em>バックグラウンドのカスケード削除</em> において、Kubernetesはそのオーナーオブジェクトを即座に削除し、ガベージコレクションはその従属オブジェクトをバックグラウンドで削除します。</p><h3 id=カスケード削除ポリシーの設定>カスケード削除ポリシーの設定</h3><p>カスケード削除ポリシーを制御するためには、オブジェクトをいつ設定するか<code>deleteOptions</code>引数上の<code>propagationPolicy</code>フィールドに設定してください。設定可能な値は<code>Orphan</code>、<code>Foreground</code>、もしくは<code>Background</code>のどれかです。</p><p>下記のコマンドは従属オブジェクトをバックグラウンドで削除する例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Background&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>下記のコマンドは従属オブジェクトをフォアグラウンドで削除する例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>下記のコマンドは従属オブジェクトをみなしご状態になった従属オブジェクトの例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>kubectlもまたカスケード削除をサポートしています。<br>kubectlを使って従属オブジェクトを自動的に削除するためには、<code>--cascade</code>をtrueにセットしてください。
従属オブジェクトを削除せず、みなしご状態にするには<code>--cascade</code>をfalseにセットしてください。
<code>--cascade</code>オプションのデフォルト値はtrueになります。</p><p>下記のコマンドは、ReplicaSetを削除し、その従属オブジェクトをみなしご状態にします。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete replicaset my-repset --cascade<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h3 id=deploymentsに関する追記事項>Deploymentsに関する追記事項</h3><p>Kubernetes1.7以前では、Deploymentに対するカスケード削除において、作成されたReplicaSetだけでなく、それらのPodも削除するためには、ユーザーは<code>propagationPolicy: Foreground</code>と指定<em>しなくてはなりません</em> 。もしこのタイプの<em>propagationPolicy</em>が使われなかった場合、そのReplicaSetは削除されますが、そのPodは削除されずみなしご状態になります。<br>さらなる詳細に関しては<a href=https://github.com/kubernetes/kubeadm/issues/149#issuecomment-284766613>kubeadm/#149</a>を参照してください。</p><h2 id=既知の問題について>既知の問題について</h2><p><a href=https://github.com/kubernetes/kubernetes/issues/26120>#26120</a>にてイシューがトラックされています。</p><h2 id=次の項目>次の項目</h2><p><a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/garbage-collection.md>Design Doc 1</a></p><p><a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/synchronous-garbage-collection.md>Design Doc 2</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-4de50a37ebb6f2340484192126cb7a04>4.2.7 - 終了したリソースのためのTTLコントローラー(TTL Controller for Finished Resources)</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code></div><p>TTLコントローラーは実行を終えたリソースオブジェクトのライフタイムを制御するためのTTL (time to live) メカニズムを提供します。<br>TTLコントローラーは現在<a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>のみ扱っていて、将来的にPodやカスタムリソースなど、他のリソースの実行終了を扱えるように拡張される予定です。</p><p>α版の免責事項: この機能は現在α版の機能で、kube-apiserverとkube-controller-managerの<a href=/docs/reference/command-line-tools-reference/feature-gates/>Feature Gate</a>の<code>TTLAfterFinished</code>を有効にすることで使用可能です。</p><h2 id=ttlコントローラー>TTLコントローラー</h2><p>TTLコントローラーは現在Jobに対してのみサポートされています。クラスターオペレーターはこの<a href=/ja/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically>例</a>のように、Jobの<code>.spec.ttlSecondsAfterFinished</code>フィールドを指定することにより、終了したJob(<code>完了した</code>もしくは<code>失敗した</code>)を自動的に削除するためにこの機能を使うことができます。<br>TTLコントローラーは、そのリソースが終了したあと指定したTTLの秒数後に削除できるか推定します。言い換えると、そのTTLが期限切れになると、TTLコントローラーがリソースをクリーンアップするときに、そのリソースに紐づく従属オブジェクトも一緒に連続で削除します。注意点として、リソースが削除されるとき、ファイナライザーのようなライフサイクルに関する保証は尊重されます。</p><p>TTL秒はいつでもセット可能です。下記はJobの<code>.spec.ttlSecondsAfterFinished</code>フィールドのセットに関するいくつかの例です。</p><ul><li>Jobがその終了後にいくつか時間がたった後に自動的にクリーンアップできるように、そのリソースマニフェストにこの値を指定します。</li><li>この新しい機能を適用させるために、存在していてすでに終了したリソースに対してこのフィールドをセットします。</li><li>リソース作成時に、このフィールドを動的にセットするために、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>管理webhookの変更</a>をさせます。クラスター管理者は、終了したリソースに対して、このTTLポリシーを強制するために使うことができます。</li><li>リソースが終了した後に、このフィールドを動的にセットしたり、リソースステータスやラベルなどの値に基づいて異なるTTL値を選択するために、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>管理webhookの変更</a>をさせます。</li></ul><h2 id=注意>注意</h2><h3 id=ttl秒の更新>TTL秒の更新</h3><p>注意点として、Jobの<code>.spec.ttlSecondsAfterFinished</code>フィールドといったTTL期間はリソースが作成された後、もしくは終了した後に変更できます。しかし、一度Jobが削除可能(TTLの期限が切れたとき)になると、それがたとえTTLを伸ばすような更新に対してAPIのレスポンスで成功したと返されたとしても、そのシステムはJobが稼働し続けることをもはや保証しません。</p><h3 id=タイムスキュー-time-skew>タイムスキュー(Time Skew)</h3><p>TTLコントローラーが、TTL値が期限切れかそうでないかを決定するためにKubernetesリソース内に保存されたタイムスタンプを使うため、この機能はクラスター内のタイムスキュー(時刻のずれ)に対してセンシティブとなります。タイムスキューは、誤った時間にTTLコントローラーに対してリソースオブジェクトのクリーンアップしてしまうことを引き起こすものです。</p><p>Kubernetesにおいてタイムスキューを避けるために、全てのNode上でNTPの稼働を必須とします(<a href=https://github.com/kubernetes/kubernetes/issues/6159#issuecomment-93844058>#6159</a>を参照してください)。クロックは常に正しいものではありませんが、Node間におけるその差はとても小さいものとなります。TTLに0でない値をセットするときにこのリスクに対して注意してください。</p><h2 id=次の項目>次の項目</h2><ul><li><p><a href=/ja/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically>Jobの自動クリーンアップ</a></p></li><li><p><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-apps/592-ttl-after-finish/README.md>設計ドキュメント</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2e4cec01c525b45eccd6010e21cc76d9>4.2.8 - CronJob</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.8 [beta]</code></div><p><em>CronJob</em> は繰り返しのスケジュールによって<a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>を作成します。</p><p><em>CronJob</em> オブジェクトとは <em>crontab</em> (cron table)ファイルでみられる一行のようなものです。
<a href=https://ja.wikipedia.org/wiki/Cron>Cron</a>形式で記述された指定のスケジュールの基づき、定期的にジョブが実行されます。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong><p>すべての<strong>CronJob</strong><code>スケジュール</code>: 時刻はジョブが開始された<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>のタイムゾーンに基づいています。</p><p>コントロールプレーンがkube-controller-managerをPodもしくは素のコンテナで実行している場合、CronJobコントローラーのタイムゾーンとして、kube-controller-managerコンテナに設定されたタイムゾーンを使用します。</p></div><p>CronJobリソースのためのマニフェストを作成する場合、その名前が有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>か確認してください。
名前は52文字を超えることはできません。これはCronJobコントローラーが自動的に、与えられたジョブ名に11文字を追加し、ジョブ名の長さは最大で63文字以内という制約があるためです。</p><h2 id=cronjob>CronJob</h2><p>CronJobは、バックアップの実行やメール送信のような定期的であったり頻発するタスクの作成に役立ちます。
CronJobは、クラスターがアイドル状態になりそうなときにJobをスケジューリングするなど、特定の時間に個々のタスクをスケジュールすることもできます。</p><h3 id=例>例</h3><p>このCronJobマニフェスト例は、毎分ごとに現在の時刻とhelloメッセージを表示します。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/job/cronjob.yaml download=application/job/cronjob.yaml><code>application/job/cronjob.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-cronjob-yaml")' title="Copy application/job/cronjob.yaml to clipboard"></img></div><div class=includecode id=application-job-cronjob-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronJob<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * *&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jobTemplate</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- date; echo Hello from the Kubernetes cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>(<a href=/ja/docs/tasks/job/automated-tasks-with-cron-jobs/>Running Automated Tasks with a CronJob</a>ではこの例をより詳しく説明しています。).</p><h2 id=cron-job-limitations>CronJobの制限</h2><p>cronジョブは一度のスケジュール実行につき、 <em>おおよそ</em> 1つのジョブオブジェクトを作成します。ここで <em>おおよそ</em> と言っているのは、ある状況下では2つのジョブが作成される、もしくは1つも作成されない場合があるためです。通常、このようなことが起こらないようになっていますが、完全に防ぐことはできません。したがって、ジョブは <em>冪等</em> であるべきです。</p><p><code>startingDeadlineSeconds</code>が大きな値、もしくは設定されていない(デフォルト)、そして、<code>concurrencyPolicy</code>を<code>Allow</code>に設定している場合には、少なくとも一度、ジョブが実行されることを保証します。</p><p>最後にスケジュールされた時刻から現在までの間に、CronJob<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>はどれだけスケジュールが間に合わなかったのかをCronJobごとにチェックします。もし、100回以上スケジュールが失敗していると、ジョブは開始されずに、ログにエラーが記録されます。</p><pre tabindex=0><code>Cannot determine if job needs to be started. Too many missed start time (&gt; 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.
</code></pre><p><code>startingDeadlineSeconds</code>フィールドが設定されると(<code>nil</code>ではない)、最後に実行された時刻から現在までではなく、<code>startingDeadlineSeconds</code>の値から現在までで、どれだけジョブを逃したのかをコントローラーが数えます。 <code>startingDeadlineSeconds</code>が<code>200</code>の場合、過去200秒間にジョブが失敗した回数を記録します。</p><p>スケジュールされた時間にCronJobが作成できないと、失敗したとみなされます。たとえば、<code>concurrencyPolicy</code>が<code>Forbid</code>に設定されている場合、前回のスケジュールがまだ実行中にCronJobをスケジュールしようとすると、CronJobは作成されません。</p><p>例として、CronJobが<code>08:30:00</code>を開始時刻として1分ごとに新しいJobをスケジュールするように設定され、<code>startingDeadlineSeconds</code>フィールドが設定されていない場合を想定します。CronJobコントローラーが<code>08:29:00</code> から<code>10:21:00</code>の間にダウンしていた場合、スケジューリングを逃したジョブの数が100を超えているため、ジョブは開始されません。</p><p>このコンセプトをさらに掘り下げるために、CronJobが<code>08:30:00</code>から1分ごとに新しいJobを作成し、<code>startingDeadlineSeconds</code>が200秒に設定されている場合を想定します。CronJobコントローラーが前回の例と同じ期間(<code>08:29:00</code> から<code>10:21:00</code>まで)にダウンしている場合でも、10:22:00時点でJobはまだ動作しています。このようなことは、過去200秒間(言い換えると、3回の失敗)に何回スケジュールが間に合わなかったをコントローラーが確認するときに発生します。これは最後にスケジュールされた時間から今までのものではありません。</p><p>CronJobはスケジュールに一致するJobの作成にのみ関与するのに対して、JobはJobが示すPod管理を担います。</p><h2 id=次の項目>次の項目</h2><p><a href=https://en.wikipedia.org/wiki/Cron>Cron表現形式</a>では、CronJobの<code>schedule</code>フィールドのフォーマットを説明しています。</p><p>cronジョブの作成や動作の説明、CronJobマニフェストの例については、<a href=/docs/tasks/job/automated-tasks-with-cron-jobs>Running automated tasks with cron jobs</a>を見てください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0a0a7eca3e302a3c08f8c85e15d337fd>5 - Service、負荷分散とネットワーキング</h1><div class=lead>Kubernetesにおけるネットワーキングの概念とリソース。</div><p>Kubernetesのネットワーキングは4つの懸念事項に対処します。</p><ul><li>Pod内のコンテナは、ネットワーキングを利用してループバック経由の通信を行います。</li><li>クラスターネットワーキングは、異なるPod間の通信を提供します。</li><li>Serviceリソースは、Pod内で動作しているアプリケーションへクラスターの外部から到達可能なように露出を許可します。</li><li>Serviceを利用して、クラスタ内部のみで使用するServiceの公開も可能です。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5701136fd2ce258047b6ddc389112352>5.1 - Service</h1><a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>の集合で実行されているアプリケーションをネットワークサービスとして公開する抽象的な方法です。<p>Kubernetesでは、なじみのないサービスディスカバリーのメカニズムを使用するためにユーザーがアプリケーションの修正をする必要はありません。
KubernetesはPodにそれぞれのIPアドレス割り振りや、Podのセットに対する単一のDNS名を提供したり、それらのPodのセットに対する負荷分散が可能です。</p><h2 id=serviceを利用する動機>Serviceを利用する動機</h2><p>Kubernetes <a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>はクラスターの状態に合わせて作成され削除されます。Podは揮発的なリソースです。
<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>をアプリケーションを稼働させるために使用すると、Podを動的に作成・削除してくれます。</p><p>各Podはそれ自身のIPアドレスを持ちます。しかしDeploymentでは、ある時点において同時に稼働しているPodのセットは、その後のある時点において稼働しているPodのセットとは異なる場合があります。</p><p>この仕組みはある問題を引き起こします。もし、あるPodのセット(ここでは"バックエンド"と呼びます)がクラスター内で他のPodのセット(ここでは"フロントエンド"と呼びます)に対して機能を提供する場合、フロントエンドのPodがワークロードにおけるバックエンドを使用するために、バックエンドのPodのIPアドレスを探し出したり、記録し続けるためにはどうすればよいでしょうか?</p><p>ここで <em>Service</em> について説明します。</p><h2 id=service-resource>Serviceリソース</h2><p>Kubernetesにおいて、ServiceはPodの論理的なセットや、そのPodのセットにアクセスするためのポリシーを定義します(このパターンはよくマイクロサービスと呼ばることがあります)。
ServiceによってターゲットとされたPodのセットは、たいてい <a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=セレクター>セレクター</a>によって定義されます。
その他の方法について知りたい場合は<a href=#services-without-selectors>セレクターなしのService</a>を参照してください。</p><p>例えば、3つのレプリカが稼働しているステートレスな画像処理用のバックエンドを考えます。これらのレプリカは代替可能です。— フロントエンドはバックエンドが何であろうと気にしません。バックエンドのセットを構成する実際のPodのセットが変更された際、フロントエンドクライアントはその変更を気にしたり、バックエンドのPodのセットの情報を記録しておく必要はありません。</p><p>Serviceによる抽象化は、クライアントからバックエンドのPodの管理する責務を分離することを可能にします。</p><h3 id=クラウドネイティブのサービスディスカバリー>クラウドネイティブのサービスディスカバリー</h3><p>アプリケーション内でサービスディスカバリーのためにKubernetes APIが使える場合、ユーザーはエンドポイントを<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API Server'>API Server</a>に問い合わせることができ、またService内のPodのセットが変更された時はいつでも更新されたエンドポイントの情報を取得できます。</p><p>非ネイティブなアプリケーションのために、KubernetesはアプリケーションとバックエンドPodの間で、ネットワークポートやロードバランサーを配置する方法を提供します。</p><h2 id=serviceの定義>Serviceの定義</h2><p>KubernetesのServiceはPodと同様にRESTのオブジェクトです。他のRESTオブジェクトと同様に、ユーザーはServiceの新しいインスタンスを作成するためにAPIサーバーに対してServiceの定義を<code>POST</code>できます。Serviceオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-label-names>DNSラベル名</a>である必要があります。</p><p>例えば、TCPで9376番ポートで待ち受けていて、<code>app=Myapp</code>というラベルをもつPodのセットがあるとします。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>この定義では、"my-service"という名前のついた新しいServiceオブジェクトを作成します。これは<code>app=Myapp</code>ラベルのついた各Pod上でTCPの9376番ポートをターゲットとします。</p><p>Kubernetesは、このServiceに対してIPアドレス("clusterIP"とも呼ばれます)を割り当てます。これはServiceのプロキシーによって使用されます(下記の<a href=#virtual-ips-and-service-proxies>仮想IPとServiceプロキシー</a>を参照ください)。</p><p>Serviceセレクターのコントローラーはセレクターに一致するPodを継続的にスキャンし、“my-service”という名前のEndpointsオブジェクトに対して変更をPOSTします。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Serviceは<code>port</code>から<code>targetPort</code>へのマッピングを行います。デフォルトでは、利便性のために<code>targetPort</code>フィールドは<code>port</code>フィールドと同じ値で設定されます。</div><p>Pod内のポートの定義は名前を設定でき、Serviceの<code>targetPort</code>属性にてその名前を参照できます。これは単一の設定名をもつService内で、複数の種類のPodが混合していたとしても有効で、異なるポート番号を介することによって利用可能な、同一のネットワークプロトコルを利用します。
この仕組みはServiceをデプロイしたり、設定を追加する場合に多くの点でフレキシブルです。例えば、バックエンドソフトウェアにおいて、次のバージョンでPodが公開するポート番号を変更するときに、クライアントの変更なしに行えます。</p><p>ServiceのデフォルトプロトコルはTCPです。また、他の<a href=#protocol-support>サポートされているプロトコル</a>も利用可能です。</p><p>多くのServiceが、1つ以上のポートを公開する必要があるように、Kubernetesは1つのServiceオブジェクトに対して複数のポートの定義をサポートしています。
各ポート定義は同一の<code>protocol</code>または異なる値を設定できます。</p><h3 id=services-without-selectors>セレクターなしのService</h3><p>Serviceは多くの場合、KubernetesのPodに対するアクセスを抽象化しますが、他の種類のバックエンドも抽象化できます。
例えば:</p><ul><li>プロダクション環境で外部のデータベースクラスターを利用したいが、テスト環境では、自身のクラスターが持つデータベースを利用したい場合</li><li>Serviceを、異なる<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=Namespace>Namespace</a>のServiceや他のクラスターのServiceに向ける場合</li><li>ワークロードをKubernetesに移行するとき、アプリケーションに対する処理をしながら、バックエンドの一部をKubernetesで実行する場合</li></ul><p>このような場合において、ユーザーはPodセレクター<em>なしで</em>Serviceを定義できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>このServiceはセレクターがないため、対応するEndpointsオブジェクトは自動的に作成されません。
ユーザーはEndpointsオブジェクトを手動で追加することにより、向き先のネットワークアドレスとポートを手動でマッピングできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subsets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>192.0.2.42</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Endpointsオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>Endpointsのipは、loopback (127.0.0.0/8 for IPv4, ::1/128 for IPv6), や
link-local (169.254.0.0/16 and 224.0.0.0/24 for IPv4, fe80::/64 for IPv6)に設定することができません。</p><p><a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>が仮想IPを最終的な到達先に設定することをサポートしていないため、Endpointsのipアドレスは他のKubernetes ServiceのClusterIPにすることができません。</p></div><p>セレクターなしのServiceへのアクセスは、セレクターをもっているServiceと同じようにふるまいます。上記の例では、トラフィックはYAMLファイル内で<code>192.0.2.42:9376</code> (TCP)で定義された単一のエンドポイントにルーティングされます。</p><p>ExternalName Serviceはセレクターの代わりにDNS名を使用する特殊なケースのServiceです。さらなる情報は、このドキュメントの後で紹介する<a href=#externalname>ExternalName</a>を参照ください。</p><h3 id=エンドポイントスライス>エンドポイントスライス</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p>エンドポイントスライスは、Endpointsに対してよりスケーラブルな代替手段を提供できるAPIリソースです。概念的にはEndpointsに非常に似ていますが、エンドポイントスライスを使用すると、ネットワークエンドポイントを複数のリソースに分割できます。デフォルトでは、エンドポイントスライスは、100個のエンドポイントに到達すると「いっぱいである」と見なされ、その時点で追加のエンドポイントスライスが作成され、追加のエンドポイントが保存されます。</p><p>エンドポイントスライスは、<a href=/ja/docs/concepts/services-networking/endpoint-slices/>エンドポイントスライスのドキュメント</a>にて詳しく説明されている追加の属性と機能を提供します。</p><h3 id=アプリケーションプロトコル>アプリケーションプロトコル</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p><code>AppProtocol</code>フィールドによってServiceの各ポートに対して特定のアプリケーションプロトコルを指定することができます。
この値は、対応するEndpointsオブジェクトとEndpointSliceオブジェクトに反映されます。</p><h2 id=virtual-ips-and-service-proxies>仮想IPとサービスプロキシー</h2><p>Kubernetesクラスターの各Nodeは<code>kube-proxy</code>を稼働させています。<code>kube-proxy</code>は<a href=#externalname><code>ExternalName</code></a>タイプ以外の<code>Service</code>用に仮想IPを実装する責務があります。</p><h3 id=なぜ-dnsラウンドロビンを使わないのでしょうか>なぜ、DNSラウンドロビンを使わないのでしょうか。</h3><p>ここで湧き上がる質問として、なぜKubernetesは内部のトラフィックをバックエンドへ転送するためにプロキシーに頼るのでしょうか。
他のアプローチはどうなのでしょうか。例えば、複数のAバリュー(もしくはIPv6用にAAAAバリューなど)をもつDNSレコードを設定し、ラウンドロビン方式で名前を解決することは可能でしょうか。</p><p>Serviceにおいてプロキシーを使う理由はいくつかあります。</p><ul><li>DNSの実装がレコードのTTLをうまく扱わず、期限が切れた後も名前解決の結果をキャッシュするという長い歴史がある。</li><li>いくつかのアプリケーションではDNSルックアップを1度だけ行い、その結果を無期限にキャッシュする。</li><li>アプリケーションとライブラリーが適切なDNS名の再解決を行ったとしても、DNSレコード上の0もしくは低い値のTTLがDNSに負荷をかけることがあり、管理が難しい。</li></ul><h3 id=proxy-mode-userspace>user-spaceプロキシーモード</h3><p>このモードでは、kube-proxyはServiceやEndpointsオブジェクトの追加・削除をチェックするために、Kubernetes Masterを監視します。
各Serviceは、ローカルのNode上でポート(ランダムに選ばれたもの)を公開します。この"プロキシーポート"に対するどのようなリクエストも、そのServiceのバックエンドPodのどれか1つにプロキシーされます(Endpointsを介して通知されたPodに対して)。
kube-proxyは、どのバックエンドPodを使うかを決める際にServiceの<code>SessionAffinity</code>項目の設定を考慮に入れます。</p><p>最後に、user-spaceプロキシーはServiceの<code>clusterIP</code>(仮想IP)と<code>port</code>に対するトラフィックをキャプチャするiptablesルールをインストールします。
そのルールは、トラフィックをバックエンドPodにプロキシーするためのプロキシーポートにリダイレクトします。</p><p>デフォルトでは、user-spaceモードにおけるkube-proxyはラウンドロビンアルゴリズムによってバックエンドPodを選択します。</p><p><img src=/images/docs/services-userspace-overview.svg alt=user-spaceプロキシーのService概要ダイアグラム></p><h3 id=proxy-mode-iptables><code>iptables</code>プロキシーモード</h3><p>このモードでは、kube-proxyはServiceやEndpointsオブジェクトの追加・削除のチェックのためにKubernetesコントロールプレーンを監視します。
各Serviceでは、そのServiceの<code>clusterIP</code>と<code>port</code>に対するトラフィックをキャプチャするiptablesルールをインストールし、そのトラフィックをServiceのあるバックエンドのセットに対してリダイレクトします。
各Endpointsオブジェクトは、バックエンドのPodを選択するiptablesルールをインストールします。</p><p>デフォルトでは、iptablesモードにおけるkube-proxyはバックエンドPodをランダムで選択します。</p><p>トラフィックのハンドリングのためにiptablesを使用すると、システムのオーバーヘッドが少なくなります。これは、トラフィックがLinuxのnetfilterによってuser-spaceとkernel-spaceを切り替える必要がないためです。
このアプローチは、オーバーヘッドが少ないことに加えて、より信頼できる方法でもあります。</p><p>kube-proxyがiptablesモードで稼働し、最初に選択されたPodが応答しない場合、そのコネクションは失敗します。
これはuser-spaceモードでの挙動と異なります: user-spaceモードにおいては、kube-proxyは最初のPodに対するコネクションが失敗したら、自動的に他のバックエンドPodに対して再接続を試みます。</p><p>iptablesモードのkube-proxyが正常なバックエンドPodのみをリダイレクト対象とするために、Podの<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>ReadinessProbe</a>を使用してバックエンドPodが正常に動作しているか確認できます。これは、ユーザーがkube-proxyを介して、コネクションに失敗したPodに対してトラフィックをリダイレクトするのを除外することを意味します。</p><p><img src=/images/docs/services-iptables-overview.svg alt=iptablesプロキシーのService概要ダイアグラム></p><h3 id=proxy-mode-ipvs>IPVSプロキシーモード</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [stable]</code></div><p><code>ipvs</code>モードにおいて、kube-proxyはServiceとEndpointsオブジェクトを監視し、IPVSルールを作成するために<code>netlink</code>インターフェースを呼び出し、定期的にKubernetesのServiceとEndpointsとIPVSルールを同期させます。
このコントロールループはIPVSのステータスが理想的な状態になることを保証します。
Serviceにアクセスするとき、IPVSはトラフィックをバックエンドのPodに向けます。</p><p>IPVSプロキシーモードはiptablesモードと同様に、netfilterのフック関数に基づいています。ただし、基礎となるデータ構造としてハッシュテーブルを使っているのと、kernel-spaceで動作します。
これは、IPVSモードにおけるkube-proxyはiptablesモードに比べてより低いレイテンシーでトラフィックをリダイレクトし、プロキシーのルールを同期する際にはよりパフォーマンスがよいことを意味します。
他のプロキシーモードと比較して、IPVSモードはより高いネットワークトラフィックのスループットをサポートしています。</p><p>IPVSはバックエンドPodに対するトラフィックのバランシングのために多くのオプションを下記のとおりに提供します。</p><ul><li><code>rr</code>: ラウンドロビン</li><li><code>lc</code>: 最低コネクション数(オープンされているコネクション数がもっとも小さいもの)</li><li><code>dh</code>: 送信先IPによって割り当てられたハッシュ値をもとに割り当てる(Destination Hashing)</li><li><code>sh</code>: 送信元IPによって割り当てられたハッシュ値をもとに割り当てる(Source Hashing)</li><li><code>sed</code>: 見込み遅延が最小なもの</li><li><code>nq</code>: キューなしスケジューリング</li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>IPVSモードでkube-proxyを稼働させるためには、kube-proxyを稼働させる前にNode上でIPVSを有効にしなければなりません。</p><p>kube-proxyはIPVSモードで起動する場合、IPVSカーネルモジュールが利用可能かどうかを確認します。
もしIPVSカーネルモジュールが見つからなかった場合、kube-proxyはiptablesモードで稼働するようにフォールバックされます。</p></div><p><img src=/images/docs/services-ipvs-overview.svg alt=IPVSプロキシーのService概要ダイアグラム></p><p>このダイアグラムのプロキシーモデルにおいて、ServiceのIP:Portに対するトラフィックは、クライアントがKubernetesのServiceやPodについて何も知ることなく適切にバックエンドにプロキシーされています。</p><p>特定のクライアントからのコネクションが、毎回同一のPodにリダイレクトされるようにするためには、<code>service.spec.sessionAffinity</code>に"ClientIP"を設定することにより、クライアントのIPアドレスに基づいたSessionAffinityを選択することができます(デフォルトは"None")。
また、<code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code>を適切に設定することにより、セッションのタイムアウト時間を設定できます(デフォルトではこの値は18,000で、3時間となります)。</p><h2 id=複数のポートを公開するservice>複数のポートを公開するService</h2><p>いくつかのServiceにおいて、ユーザーは1つ以上のポートを公開する必要があります。Kubernetesは、Serviceオブジェクト上で複数のポートを定義するように設定できます。
Serviceで複数のポートを使用するとき、どのポートかを明確にするために、複数のポート全てに対して名前をつける必要があります。
例えば:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>https<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>KubernetesのPod名と同様に、ポート名は小文字の英数字と<code>-</code>のみ含める必要があります。また、ポート名の最初と最後の文字は英数字である必要があります。</p><p>例えば、<code>123-abc</code>や<code>web</code>という名前は有効で、<code>123_abc</code>や<code>-web</code>は無効です。</p></div><h2 id=ユーザー所有のipアドレスを選択する>ユーザー所有のIPアドレスを選択する</h2><p><code>Service</code>を作成するリクエストの一部として、ユーザー所有のclusterIPアドレスを指定することができます。
これを行うためには<code>.spec.clusterIP</code>フィールドにセットします。
使用例として、もしすでに再利用したいDNSエントリーが存在していた場合や、特定のIPアドレスを設定されたレガシーなシステムや、IPの再設定が難しい場合です。</p><p>ユーザーが指定したIPアドレスは、そのAPIサーバーのために設定されている<code>service-cluster-ip-range</code>というCIDRレンジ内の有効なIPv4またはIPv6アドレスである必要があります。
もし無効なclusterIPアドレスの値を設定してServiceを作成した場合、問題があることを示すためにAPIサーバーはHTTPステータスコード422を返します。</p><h2 id=サービスディスカバリー>サービスディスカバリー</h2><p>Kubernetesは、Serviceオブジェクトを見つけ出すために2つの主要なモードをサポートしています。 - それは環境変数とDNSです。</p><h3 id=環境変数>環境変数</h3><p>PodがNode上で稼働するとき、kubeletはアクティブな各Serviceに対して、環境変数のセットを追加します。
これは<a href=https://docs.docker.com/userguide/dockerlinks/>Docker links互換性</a>のある変数(
<a href=https://releases.k8s.io/v1.25.0/pkg/kubelet/envvars/envvars.go#L72>makeLinkVariables関数</a>を確認してください)や、より簡単な<code>{SVCNAME}_SERVICE_HOST</code>や、<code>{SVCNAME}_SERVICE_PORT</code>変数をサポートします。この変数名で使われるService名は大文字に変換され、<code>-</code>は<code>_</code>に変換されます。</p><p>例えば、TCPポート6379番を公開していて、さらにclusterIPが10.0.0.11に割り当てられている<code>redis-master</code>というServiceは、下記のような環境変数を生成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_SERVICE_HOST</span><span style=color:#666>=</span>10.0.0.11
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_SERVICE_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PROTO</span><span style=color:#666>=</span>tcp
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_ADDR</span><span style=color:#666>=</span>10.0.0.11
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>Serviceにアクセスする必要のあるPodがあり、クライアントであるそのPodに対して環境変数を使ってポートとclusterIPを公開する場合、クライアントのPodが存在する<em>前に</em> Serviceを作成しなくてはなりません。
そうでない場合、クライアントのPodはそれらの環境変数を作成しません。</p><p>ServiceのclusterIPを発見するためにDNSのみを使う場合、このような問題を心配する必要はありません。</p></div><h3 id=dns>DNS</h3><p>ユーザーは<a href=/ja/docs/concepts/cluster-administration/addons/>アドオン</a>を使ってKubernetesクラスターにDNS Serviceをセットアップできます(常にセットアップすべきです)。</p><p>CoreDNSなどのクラスター対応のDNSサーバーは新しいServiceや、各Service用のDNSレコードのセットのためにKubernetes APIを常に監視します。
もしクラスターを通してDNSが有効になっている場合、全てのPodはDNS名によって自動的にServiceに対する名前解決をするようにできるはずです。</p><p>例えば、Kubernetesの<code>my-ns</code>というNamespace内で<code>my-service</code>というServiceがある場合、KubernetesコントロールプレーンとDNS Serviceが協調して動作し、<code>my-service.my-ns</code>というDNSレコードを作成します。
<code>my-ns</code>というNamespace内のPodは<code>my-service</code>という名前で簡単に名前解決できるはずです(<code>my-service.my-ns</code>でも動作します)。</p><p>他のNamespace内でのPodは<code>my-service.my-ns</code>といった形で指定しなくてはなりません。これらのDNS名は、そのServiceのclusterIPに名前解決されます。</p><p>Kubernetesは名前付きのポートに対するDNS SRV(Service)レコードもサポートしています。もし<code>my-service.my-ns</code>というServiceが<code>http</code>という名前のTCPポートを持っていた場合、IPアドレスと同様に、<code>http</code>のポート番号を探すために<code>_http._tcp.my-service.my-ns</code>というDNS SRVクエリを実行できます。</p><p>KubernetesのDNSサーバーは<code>ExternalName</code> Serviceにアクセスする唯一の方法です。
<a href=/ja/docs/concepts/services-networking/dns-pod-service/>DNS Pods と Service</a>にて<code>ExternalName</code>による名前解決に関するさらなる情報を確認できます。</p><h2 id=headless-service>Headless Service</h2><p>場合によっては、負荷分散と単一のService IPは不要です。このケースにおいて、clusterIP(<code>.spec.clusterIP</code>)の値を<code>"None"</code>に設定することにより、"Headless"とよばれるServiceを作成できます。</p><p>ユーザーは、Kubernetesの実装と紐づくことなく、他のサービスディスカバリーのメカニズムと連携するためにHeadless Serviceを使用できます。
例えば、ユーザーはこのAPI上でカスタム<a class=glossary-tooltip title='A specialized controller used to manage a custom resource' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=オペレーター>オペレーター</a>を実装することができます。</p><p>この<code>Service</code>においては、clusterIPは割り当てられず、kube-proxyはこのServiceをハンドリングしないのと、プラットフォームによって行われるはずの
ロードバランシングやプロキシーとしての処理は行われません。DNSがどのように自動で設定されるかは、定義されたServiceが定義されたラベルセレクターを持っているかどうかに依存します。</p><h3 id=ラベルセレクターの利用>ラベルセレクターの利用</h3><p>ラベルセレクターを定義したHeadless Serviceにおいて、EndpointsコントローラーはAPIにおいて<code>Endpoints</code>レコードを作成し、<code>Service</code>のバックエンドにある<code>Pod</code>へのIPを直接指し示すためにDNS設定を修正します。</p><h3 id=ラベルセレクターなしの場合>ラベルセレクターなしの場合</h3><p>ラベルセレクターを定義しないHeadless Serviceにおいては、Endpointsコントローラーは<code>Endpoints</code>レコードを作成しません。
しかしDNSのシステムは下記の2つ両方を探索し、設定します。</p><ul><li><a href=#externalname><code>ExternalName</code></a>タイプのServiceに対するCNAMEレコード</li><li>他の全てのServiceタイプを含む、Service名を共有している全ての<code>Endpoints</code>レコード</li></ul><h2 id=publishing-services-service-types>Serviceの公開 (Serviceのタイプ)</h2><p>ユーザーのアプリケーションのいくつかの部分において(例えば、frontendsなど)、ユーザーのクラスターの外部にあるIPアドレス上でServiceを公開したい場合があります。</p><p>Kubernetesの<code>ServiceTypes</code>によって、ユーザーがどのような種類のServiceを使いたいかを指定することが可能です。
デフォルトでは<code>ClusterIP</code>となります。</p><p><code>Type</code>項目の値と、そのふるまいは以下のようになります。</p><ul><li><code>ClusterIP</code>: クラスター内部のIPでServiceを公開する。このタイプではServiceはクラスター内部からのみ疎通性があります。このタイプはデフォルトの<code>ServiceType</code>です。</li><li><a href=#nodeport><code>NodePort</code></a>: 各NodeのIPにて、静的なポート(<code>NodePort</code>)上でServiceを公開します。その<code>NodePort</code> のServiceが転送する先の<code>ClusterIP</code> Serviceが自動的に作成されます。<code>&lt;NodeIP>:&lt;NodePort></code>にアクセスすることによって<code>NodePort</code> Serviceにアクセスできるようになります。</li><li><a href=#loadbalancer><code>LoadBalancer</code></a>: クラウドプロバイダーのロードバランサーを使用して、Serviceを外部に公開します。クラスター外部にあるロードバランサーが転送する先の<code>NodePort</code>と<code>ClusterIP</code> Serviceは自動的に作成されます。</li><li><a href=#externalname><code>ExternalName</code></a>: <code>CNAME</code>レコードを返すことにより、<code>externalName</code>フィールドに指定したコンテンツ(例: <code>foo.bar.example.com</code>)とServiceを紐づけます。しかし、いかなる種類のプロキシーも設定されません。<div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>ExternalName</code>タイプのServiceを利用するためには、kube-dnsのバージョン1.7かCoreDNSのバージョン0.0.8以上が必要となります。</div></li></ul><p>また、Serviceを公開するために<a href=/ja/docs/concepts/services-networking/ingress/>Ingress</a>も利用可能です。IngressはServiceのタイプではありませんが、クラスターに対するエントリーポイントとして動作します。
Ingressは同一のIPアドレスにおいて、複数のServiceを公開するように、ユーザーの設定した転送ルールを1つのリソースにまとめることができます。</p><h3 id=nodeport>NodePort タイプ</h3><p>もし<code>type</code>フィールドの値を<code>NodePort</code>に設定すると、Kubernetesコントロールプレーンは<code>--service-node-port-range</code>フラグによって指定されたレンジのポート(デフォルト: 30000-32767)を割り当てます。
各Nodeはそのポート(各Nodeで同じポート番号)への通信をServiceに転送します。
作成したServiceは、<code>.spec.ports[*].nodePort</code>フィールド内に割り当てられたポートを記述します。</p><p>もしポートへの通信を転送する特定のIPを指定したい場合、特定のIPブロックをkube-proxyの<code>--nodeport-address</code>フラグで指定できます。これはKubernetes v1.10からサポートされています。
このフラグは、コンマ区切りのIPブロックのリスト(例: 10.0.0./8, 192.0.2.0/25)を使用し、kube-proxyがこのNodeに対してローカルとみなすべきIPアドレスの範囲を指定します。</p><p>例えば、<code>--nodeport-addresses=127.0.0.0/8</code>というフラグによってkube-proxyを起動した時、kube-proxyはNodePort Serviceのためにループバックインターフェースのみ選択します。<code>--nodeport-addresses</code>のデフォルト値は空のリストになります。これはkube-proxyがNodePort Serviceに対して全てのネットワークインターフェースを利用可能とするべきということを意味します(これは以前のKubernetesのバージョンとの互換性があります)。</p><p>もしポート番号を指定したい場合、<code>nodePort</code>フィールドに値を指定できます。コントロールプレーンは指定したポートを割り当てるか、APIトランザクションが失敗したことを知らせるかのどちらかになります。
これは、ユーザーが自分自身で、ポート番号の衝突に関して気をつける必要があることを意味します。
また、ユーザーは有効なポート番号を指定する必要があり、NodePortの使用において、設定された範囲のポートを指定する必要があります。</p><p>NodePortの使用は、Kubernetesによって完全にサポートされていないようなユーザー独自の負荷分散を設定をするための有効な方法や、1つ以上のNodeのIPを直接公開するための方法となりえます。</p><p>注意点として、このServiceは<code>&lt;NodeIP>:spec.ports[*].nodePort</code>と、<code>.spec.clusterIP:spec.ports[*].port</code>として疎通可能です。
(もしkube-proxyにおいて<code>--nodeport-addressses</code>が設定された場合、<nodeip>はフィルターされたNodeIPとなります。)</p><p>例えば:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># デフォルトでは利便性のため、 `targetPort` は `port` と同じ値にセットされます。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 省略可能なフィールド</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># デフォルトでは利便性のため、Kubernetesコントロールプレーンはある範囲から1つポートを割り当てます(デフォルト値の範囲:30000-32767)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodePort</span>:<span style=color:#bbb> </span><span style=color:#666>30007</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=loadbalancer>LoadBalancer タイプ</h3><p>外部のロードバランサーをサポートするクラウドプロバイダー上で、<code>type</code>フィールドに<code>LoadBalancer</code>を設定すると、Service用にロードバランサーがプロビジョニングされます。
実際のロードバランサーの作成は非同期で行われ、プロビジョンされたバランサーの情報は、Serviceの<code>.status.loadBalancer</code>フィールドに記述されます。
例えば:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.171.239</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>192.0.2.127</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>外部のロードバランサーからのトラフィックはバックエンドのPodに直接転送されます。クラウドプロバイダーはどのようにそのリクエストをバランシングするかを決めます。</p><p>LoadBalancerタイプのサービスで複数のポートが定義されている場合、すべてのポートが同じプロトコルである必要があり、さらにそのプロトコルは<code>TCP</code>、<code>UDP</code>、<code>SCTP</code>のいずれかである必要があります。</p><p>いくつかのクラウドプロバイダーにおいて、<code>loadBalancerIP</code>の設定をすることができます。このようなケースでは、そのロードバランサーはユーザーが指定した<code>loadBalancerIP</code>に対してロードバランサーを作成します。
もし<code>loadBalancerIP</code>フィールドの値が指定されていない場合、そのロードバランサーはエフェメラルなIPアドレスに対して作成されます。もしユーザーが<code>loadBalancerIP</code>を指定したが、使っているクラウドプロバイダーがその機能をサポートしていない場合、その<code>loadBalancerIP</code>フィールドに設定された値は無視されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> もしSCTPを使っている場合、<code>LoadBalancer</code> タイプのServiceに関する<a href=#caveat-sctp-loadbalancer-service-type>使用上の警告</a>を参照してください。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p><strong>Azure</strong> において、もしユーザーが指定する<code>loadBalancerIP</code>を使用したい場合、最初に静的なパブリックIPアドレスのリソースを作成する必要があります。
このパブリックIPアドレスのリソースは、クラスター内で自動的に作成された他のリソースと同じグループに作られるべきです。
例: <code>MC_myResourceGroup_myAKSCluster_eastus</code></p><p>割り当てられたIPアドレスをloadBalancerIPとして指定してください。クラウドプロバイダーの設定ファイルにおいてsecurityGroupNameを更新したことを確認してください。
<code>CreatingLoadBalancerFailed</code>というパーミッションの問題に対するトラブルシューティングの情報は、<a href=https://docs.microsoft.com/en-us/azure/aks/static-ip>Azure Kubernetes Service(AKS)のロードバランサーで静的IPアドレスを使用する</a> や、<a href=https://github.com/Azure/AKS/issues/357>高度なネットワークを使用したAKSクラスターでのCreatingLoadBalancerFailed</a>を参照してください。</p></div><h4 id=内部のロードバランサー>内部のロードバランサー</h4><p>複雑な環境において、同一の(仮想)ネットワークアドレスブロック内のServiceからのトラフィックを転送する必要がでてきます。</p><p>Split-HorizonなDNS環境において、ユーザーは2つのServiceを外部と内部の両方からのトラフィックをエンドポイントに転送させる必要がでてきます。</p><p>ユーザーは、Serviceに対して下記のアノテーションを1つ追加することでこれを実現できます。
追加するアノテーションは、ユーザーが使っているクラウドプロバイダーに依存しています。</p><ul class="nav nav-tabs" id=service-tabs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#service-tabs-0 role=tab aria-controls=service-tabs-0 aria-selected=true>Default</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-1 role=tab aria-controls=service-tabs-1>GCP</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-2 role=tab aria-controls=service-tabs-2>AWS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-3 role=tab aria-controls=service-tabs-3>Azure</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-4 role=tab aria-controls=service-tabs-4>IBM Cloud</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-5 role=tab aria-controls=service-tabs-5>OpenStack</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-6 role=tab aria-controls=service-tabs-6>Baidu Cloud</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-7 role=tab aria-controls=service-tabs-7>Tencent Cloud</a></li></ul><div class=tab-content id=service-tabs><div id=service-tabs-0 class="tab-pane show active" role=tabpanel aria-labelledby=service-tabs-0><p><p>タブを選択してください。</p></div><div id=service-tabs-1 class=tab-pane role=tabpanel aria-labelledby=service-tabs-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cloud.google.com/load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Internal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-2 class=tab-pane role=tabpanel aria-labelledby=service-tabs-2><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#666>0.0.0.0</span>/0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-3 class=tab-pane role=tabpanel aria-labelledby=service-tabs-3><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/azure-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-4 class=tab-pane role=tabpanel aria-labelledby=service-tabs-4><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/ibm-load-balancer-cloud-provider-ip-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;private&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-5 class=tab-pane role=tabpanel aria-labelledby=service-tabs-5><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/openstack-internal-load-balancer</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-6 class=tab-pane role=tabpanel aria-labelledby=service-tabs-6><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/cce-load-balancer-internal-vpc</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-7 class=tab-pane role=tabpanel aria-labelledby=service-tabs-7><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internal-subnetid</span>:<span style=color:#bbb> </span>subnet-xxxxx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h4 id=ssl-support-on-aws>AWSにおけるTLSのサポート</h4><p>AWS上で稼働しているクラスターにおいて、部分的なTLS/SSLのサポートをするには、<code>LoadBalancer</code> Serviceに対して3つのアノテーションを追加できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-cert</span>:<span style=color:#bbb> </span>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012<span style=color:#bbb>
</span></span></span></code></pre></div><p>1つ目は、使用する証明書のARNです。これはIAMにアップロードされたサードパーティーが発行した証明書か、AWS Certificate Managerで作成された証明書になります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>(https|http|ssl|tcp)<span style=color:#bbb>
</span></span></span></code></pre></div><p>2つ目のアノテーションはPodが利用するプロトコルを指定するものです。HTTPSとSSLの場合、ELBはそのPodが証明書を使って暗号化されたコネクションを介して自分自身のPodを認証すると推測します。</p><p>HTTPとHTTPSでは、レイヤー7でのプロキシーを選択します。ELBはユーザーとのコネクションを切断し、リクエストを転送するときにリクエストヘッダーをパースして、<code>X-Forwarded-For</code>ヘッダーにユーザーのIPを追加します(Podは接続相手のELBのIPアドレスのみ確認可能です)。</p><p>TCPとSSLでは、レイヤー4でのプロキシーを選択します。ELBはヘッダーの値を変更せずにトラフィックを転送します。</p><p>いくつかのポートがセキュアに保護され、他のポートではセキュアでないような混合した環境において、下記のようにアノテーションを使うことができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-ports</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;443,8443&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>上記の例では、もしServiceが<code>80</code>、<code>443</code>、<code>8443</code>と3つのポートを含んでいる場合、<code>443</code>と<code>8443</code>はSSL証明書を使いますが、<code>80</code>では単純にHTTPでのプロキシーとなります。</p><p>Kubernetes v1.9以降のバージョンからは、Serviceのリスナー用にHTTPSやSSLと<a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-policy-table.html>事前定義されたAWS SSLポリシー</a>を使用できます。
どのポリシーが使用できるかを確認するために、<code>aws</code>コマンドラインツールを使用できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>aws elb describe-load-balancer-policies --query <span style=color:#b44>&#39;PolicyDescriptions[].PolicyName&#39;</span>
</span></span></code></pre></div><p>ユーザーは"<code>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</code>"というアノテーションを使用することにより、複数のポリシーの中からどれか1つを指定できます。
例えば:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ELBSecurityPolicy-TLS-1-2-2017-01&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=aws上でのproxyプロトコルのサポート>AWS上でのPROXYプロトコルのサポート</h4><p>AWS上で稼働するクラスターで<a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>PROXY protocol</a>のサポートを有効にするために、下記のServiceのアノテーションを使用できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-proxy-protocol</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Kubernetesバージョン1.3.0からは、このアノテーションを使用するとELBによってプロキシーされた全てのポートが対象になり、そしてそれ以外の場合は構成されません。</p><h4 id=aws上でのelbのアクセスログ>AWS上でのELBのアクセスログ</h4><p>AWS上でのELB Service用のアクセスログを管理するためにはいくつかのアノテーションが使用できます。</p><p><code>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</code>というアノテーションはアクセスログを有効にするかを設定できます。</p><p><code>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</code>というアノテーションはアクセスログをパブリッシュするためのインターバル(分)を設定できます。
ユーザーはそのインターバルで5分もしくは60分で設定できます。</p><p><code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</code>というアノテーションはロードバランサーのアクセスログが保存されるAmazon S3のバケット名を設定できます。</p><p><code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</code>というアノテーションはユーザーが作成したAmazon S3バケットの論理的な階層を指定します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ロードバランサーのアクセスログが有効かどうか。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># アクセスログをパブリッシュするためのインターバル(分)。ユーザーはそのインターバルで5分もしくは60分で設定できます。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ロードバランサーのアクセスログが保存されるAmazon S3のバケット名。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket-prefix/prod&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ユーザーが作成したAmazon S3バケットの論理的な階層。例えば: `my-bucket-prefix/prod`</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=awsでの接続の中断>AWSでの接続の中断</h4><p>古いタイプのELBでの接続の中断は、<code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</code>というアノテーションを<code>"true"</code>に設定することで管理できます。
<code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</code>というアノテーションで、インスタンスを登録解除するまえに既存の接続をオープンにし続けるための最大時間(秒)を指定できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=他のelbアノテーション>他のELBアノテーション</h4><p>古いタイプのELBを管理するためのアノテーションは他にもあり、下記で紹介します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ロードバランサーによってクローズされる前にアイドル状態(コネクションでデータは送信されない)になれる秒数</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ゾーンを跨いだロードバランシングが有効かどうか</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;environment=prod,owner=devops&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ELBにおいて追加タグとして保存されるキー・バリューのペアのコンマ区切りのリスト</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># バックエンドへのトラフィックが正常になったと判断するために必要なヘルスチェックの連続成功数</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># デフォルトでは2 この値は2から10の間で設定可能</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># バックエンドへのトラフィックが異常になったと判断するために必要なヘルスチェックの連続失敗数</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># デフォルトでは6 この値は2から10の間で設定可能</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 各インスタンスのヘルスチェックのおよそのインターバル(秒)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># デフォルトでは10 この値は5から300の間で設定可能</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ヘルスチェックが失敗したと判断されるレスポンスタイムのリミット(秒)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># この値はservice.beta.kubernetes.io/aws-load-balancer-healthcheck-intervalの値以下である必要があります。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># デフォルトでは5 この値は2から60の間で設定可能</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-security-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sg-53fae93f&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ELBが作成される際に追加されるセキュリティグループのリスト</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># service.beta.kubernetes.io/aws-load-balancer-extra-security-groupsアノテーションと異なり</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 元々ELBに付与されていたセキュリティグループを置き換えることになります。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-extra-security-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sg-53fae93f,sg-42efd82e&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ELBに追加される予定のセキュリティーグループのリスト</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-target-node-labels</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ingress-gw,gw-name=public-api&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ロードバランサーがターゲットノードを指定する際に利用するキーバリューのペアのコンマ区切りリストです。</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=aws-nlb-support>AWSでのNetwork Load Balancerのサポート</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code></div><p>AWSでNetwork Load Balancerを使用するには、値を<code>nlb</code>に設定してアノテーション<code>service.beta.kubernetes.io/aws-load-balancer-type</code>を付与します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nlb&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> NLBは特定のインスタンスクラスでのみ稼働します。サポートされているインスタンスタイプを確認するためには、ELBに関する<a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-register-targets.html#register-deregister-targets>AWS documentation</a>を参照してください。</div><p>古いタイプのElastic Load Balancersとは異なり、Network Load Balancers (NLBs)はクライアントのIPアドレスをNodeに転送します。
もしServiceの<code>.spec.externalTrafficPolicy</code>の値が<code>Cluster</code>に設定されていた場合、クライアントのIPアドレスは末端のPodに伝播しません。</p><p><code>.spec.externalTrafficPolicy</code>を<code>Local</code>に設定することにより、クライアントIPアドレスは末端のPodに伝播します。しかし、これにより、トラフィックの分配が不均等になります。
特定のLoadBalancer Serviceに紐づいたPodがないNodeでは、自動的に割り当てられた<code>.spec.healthCheckNodePort</code>に対するNLBのターゲットグループのヘルスチェックが失敗し、トラフィックを全く受信しません。</p><p>均等なトラフィックの分配を実現するために、DaemonSetの使用や、同一のNodeに配備しないように<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity>Podのanti-affinity</a>を設定します。</p><p>また、<a href=/ja/docs/concepts/services-networking/service/#internal-load-balancer>内部のロードバランサー</a>のアノテーションとNLB Serviceを使用できます。</p><p>NLBの背後にあるインスタンスに対してクライアントのトラフィックを転送するために、Nodeのセキュリティーグループは下記のようなIPルールに従って変更されます。</p><table><thead><tr><th>Rule</th><th>Protocol</th><th>Port(s)</th><th>IpRange(s)</th><th>IpRange Description</th></tr></thead><tbody><tr><td>ヘルスチェック</td><td>TCP</td><td>NodePort(s) (<code>.spec.healthCheckNodePort</code> for <code>.spec.externalTrafficPolicy = Local</code>)</td><td>VPC CIDR</td><td>kubernetes.io/rule/nlb/health=&lt;loadBalancerName></td></tr><tr><td>クライアントのトラフィック</td><td>TCP</td><td>NodePort(s)</td><td><code>.spec.loadBalancerSourceRanges</code> (デフォルト: <code>0.0.0.0/0</code>)</td><td>kubernetes.io/rule/nlb/client=&lt;loadBalancerName></td></tr><tr><td>MTUによるサービスディスカバリー</td><td>ICMP</td><td>3,4</td><td><code>.spec.loadBalancerSourceRanges</code> (デフォルト: <code>0.0.0.0/0</code>)</td><td>kubernetes.io/rule/nlb/mtu=&lt;loadBalancerName></td></tr></tbody></table><p>どのクライアントIPがNLBにアクセス可能かを制限するためには、<code>loadBalancerSourceRanges</code>を指定してください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancerSourceRanges</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;143.231.0.0/16&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> もし<code>.spec.loadBalancerSourceRanges</code>が設定されていない場合、KubernetesはNodeのセキュリティーグループに対して<code>0.0.0.0/0</code>からのトラフィックを許可します。
もしNodeがパブリックなIPアドレスを持っていた場合、NLBでないトラフィックも修正されたセキュリティーグループ内の全てのインスタンスにアクセス可能になってしまうので注意が必要です。</div><h4 id=tencent-kubernetes-engine-tke-におけるその他のclbアノテーション>Tencent Kubernetes Engine(TKE)におけるその他のCLBアノテーション</h4><p>以下に示すように、TKEでCloud Load Balancerを管理するためのその他のアノテーションがあります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 指定したノードでロードバランサーをバインドします</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-backends-label</span>:<span style=color:#bbb> </span>key in (value1, value2)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 既存のロードバランサーのID</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/tke-existed-lbid</span>:<span style=color:#bbb> </span>lb-6swtxxxx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ロードバランサー(LB)のカスタムパラメーターは、LBタイプの変更をまだサポートしていません</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/service.extensiveParameters</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># LBリスナーのカスタムパラメーター</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/service.listenerParameters</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ロードバランサーのタイプを指定します</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 有効な値: classic(Classic Cloud Load Balancer)またはapplication(Application Cloud Load Balancer)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/loadbalance-type</span>:<span style=color:#bbb> </span>xxxxx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># パブリックネットワーク帯域幅の課金方法を指定します</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 有効な値: TRAFFIC_POSTPAID_BY_HOUR(bill-by-traffic)およびBANDWIDTH_POSTPAID_BY_HOUR(bill-by-bandwidth)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internet-charge-type</span>:<span style=color:#bbb> </span>xxxxxx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 帯域幅の値を指定します(値の範囲:[1-2000] Mbps)。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internet-max-bandwidth-out</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># この注釈が設定されている場合、ロードバランサーはポッドが実行されているノードのみを登録します</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># そうでない場合、すべてのノードが登録されます</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/local-svc-only-bind-node-with-pod</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=externalname>ExternalName タイプ</h3><p>ExternalNameタイプのServiceは、ServiceをDNS名とマッピングし、<code>my-service</code>や<code>cassandra</code>というような従来のラベルセレクターとはマッピングしません。
ユーザーはこれらのServiceにおいて<code>spec.externalName</code>フィールドの値を指定します。</p><p>このServiceの定義では、例えば<code>prod</code>というNamespace内の<code>my-service</code>というServiceを<code>my.database.example.com</code>にマッピングします。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>prod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ExternalName<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalName</span>:<span style=color:#bbb> </span>my.database.example.com<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ExternalNameはIpv4のアドレスの文字列のみ受け付けますが、IPアドレスではなく、数字で構成されるDNS名として受け入れます。
IPv4アドレスに似ているExternalNamesはCoreDNSもしくはIngress-Nginxによって名前解決されず、これはExternalNameは正規のDNS名を指定することを目的としているためです。
IPアドレスをハードコードする場合、<a href=#headless-service>Headless Service</a>の使用を検討してください。</div><p><code>my-service.prod.svc.cluster.local</code>というホストをルックアップするとき、クラスターのDNS Serviceは<code>my.database.example.com</code>という値をもつ<code>CNAME</code>レコードを返します。
<code>my-service</code>へのアクセスは、他のServiceと同じ方法ですが、再接続する際はプロキシーや転送を介して行うよりも、DNSレベルで行われることが決定的に異なる点となります。
後にユーザーが使用しているデータベースをクラスター内に移行することになった場合は、Podを起動させ、適切なラベルセレクターやEndpointsを追加し、Serviceの<code>type</code>を変更します。</p><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong><p>HTTPやHTTPSなどの一般的なプロトコルでExternalNameを使用する際に問題が発生する場合があります。ExternalNameを使用する場合、クラスター内のクライアントが使用するホスト名は、ExternalNameが参照する名前とは異なります。</p><p>ホスト名を使用するプロトコルの場合、この違いによりエラーまたは予期しない応答が発生する場合があります。HTTPリクエストがオリジンサーバーが認識しない<code>Host:</code>ヘッダーを持っていたなら、TLSサーバーはクライアントが接続したホスト名に一致する証明書を提供できません。</p></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> このセクションは、<a href=https://akomljen.com/>Alen Komljen</a>による<a href=https://akomljen.com/kubernetes-tips-part-1/>Kubernetes Tips - Part1</a>というブログポストを参考にしています。</div><h3 id=external-ips>External IPs</h3><p>もし1つ以上のクラスターNodeに転送するexternalIPが複数ある場合、Kubernetes Serviceは<code>externalIPs</code>に指定したIPで公開されます。
そのexternalIP(到達先のIPとして扱われます)のServiceのポートからトラフィックがクラスターに入って来る場合、ServiceのEndpointsのどれか1つに対して転送されます。
<code>externalIPs</code>はKubernetesによって管理されず、それを管理する責任はクラスターの管理者にあります。</p><p>Serviceのspecにおいて、<code>externalIPs</code>は他のどの<code>ServiceTypes</code>と併用して設定できます。
下記の例では、"<code>my-service</code>"は"<code>80.11.12.10:80</code>" (<code>externalIP:port</code>)のクライアントからアクセス可能です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalIPs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#666>80.11.12.10</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=serviceの欠点>Serviceの欠点</h2><p>仮想IP用にuserspaceモードのプロキシーを使用すると、小規模もしくは中規模のスケールでうまく稼働できますが、1000以上のServiceがあるようなとても大きなクラスターではうまくスケールしません。
これについては、<a href=https://github.com/kubernetes/kubernetes/issues/1107>Serviceのデザインプロポーザル</a>にてさらなる詳細を確認できます。</p><p>userspaceモードのプロキシーの使用は、Serviceにアクセスするパケットの送信元IPアドレスが不明瞭になります。
これは、いくつかの種類のネットワークフィルタリング(ファイアウォールによるフィルタリング)を不可能にします。
iptablesプロキシーモードはクラスター内の送信元IPを不明瞭にはしませんが、依然としてロードバランサーやNodePortへ疎通するクライアントに影響があります。</p><p><code>Type</code>フィールドはネストされた機能としてデザインされています。 - 各レベルの値は前のレベルに対して追加します。
これは全てのクラウドプロバイダーにおいて厳密に要求されていません(例: Google Compute Engineは<code>LoadBalancer</code>を動作させるために<code>NodePort</code>を割り当てる必要はありませんが、AWSではその必要があります)が、現在のAPIでは要求しています。</p><h2 id=the-gory-details-of-virtual-ips>仮想IPの実装について</h2><p>これより前の情報は、ただServiceを使いたいという多くのユーザーにとっては有益かもしれません。しかし、その裏側では多くのことが行われており、理解する価値があります。</p><h3 id=衝突の回避>衝突の回避</h3><p>Kubernetesの主要な哲学のうちの一つは、ユーザーは、ユーザー自身のアクションによるミスでないものによって、ユーザーのアクションが失敗するような状況に晒されるべきでないことです。
Serviceリソースの設計において、これはユーザーの指定したポートが衝突する可能性がある場合はそのポートのServiceを作らないことを意味します。これは障害を分離することとなります。</p><p>Serviceのポート番号を選択できるようにするために、我々はどの2つのServiceでもポートが衝突しないことを保証します。
Kubernetesは各Serviceに、それ自身のIPアドレスを割り当てることで実現しています。</p><p>各Serviceが固有のIPを割り当てられるのを保証するために、内部のアロケーターは、Serviceを作成する前に、etcd内のグローバルの割り当てマップをアトミックに更新します。
そのマップオブジェクトはServiceのIPアドレスの割り当てのためにレジストリー内に存在しなくてはならず、そうでない場合は、Serviceの作成時にIPアドレスが割り当てられなかったことを示すエラーメッセージが表示されます。</p><p>コントロールプレーンにおいて、バックグラウンドのコントローラーはそのマップを作成する責務があります(インメモリーのロックが使われていた古いバージョンのKubernetesからのマイグレーションをサポートすることも必要です)。
また、Kubernetesは(例えば、管理者の介入によって)無効な割り当てがされているかをチェックすることと、現時点でどのServiceにも使用されていない割り当て済みIPアドレスのクリーンアップのためにコントローラーを使用します。</p><h3 id=ips-and-vips>ServiceのIPアドレス</h3><p>実際に固定された向き先であるPodのIPアドレスとは異なり、ServiceのIPは実際には単一のホストによって応答されません。
その代わり、kube-proxyは必要な時に透過的にリダイレクトされる<em>仮想</em>IPアドレスを定義するため、iptables(Linuxのパケット処理ロジック)を使用します。
クライアントがVIPに接続する時、そのトラフィックは自動的に適切なEndpointsに転送されます。
Service用の環境変数とDNSは、Serviceの仮想IPアドレス(とポート)の面において、自動的に生成されます。</p><p>kube-proxyは3つの微妙に異なった動作をするプロキシーモード— userspace、iptablesとIPVS — をサポートしています。</p><h4 id=userspace>Userspace</h4><p>例として、上記で記述されている画像処理のアプリケーションを考えます。
バックエンドのServiceが作成されたとき、KubernetesのMasterは仮想IPを割り当てます。例えば10.0.0.1などです。
そのServiceのポートが1234で、そのServiceはクラスター内の全てのkube-proxyインスタンスによって監視されていると仮定します。
kube-proxyが新しいServiceを見つけた時、kube-proxyは新しいランダムポートをオープンし、その仮想IPアドレスの新しいポートにリダイレクトするようにiptablesを更新し、そのポート上で新しい接続を待ち受けを開始します。</p><p>クライアントがServiceの仮想IPアドレスに接続したとき、iptablesルールが有効になり、そのパケットをプロキシー自身のポートにリダイレクトします。
その"Service プロキシー"はバックエンドPodの対象を選択し、クライアントのトラフィックをバックエンドPodに転送します。</p><p>これはServiceのオーナーは、衝突のリスクなしに、求めるどのようなポートも選択できることを意味します。
クライアントは単純にそのIPとポートに対して接続すればよく、実際にどのPodにアクセスしているかを意識しません。</p><h4 id=iptables>iptables</h4><p>また画像処理のアプリケーションについて考えます。バックエンドServiceが作成された時、そのKubernetesコントロールプレーンは仮想IPアドレスを割り当てます。例えば10.0.0.1などです。
Serviceのポートが1234で、そのServiceがクラスター内のすべてのkube-proxyインスタンスによって監視されていると仮定します。
kube-proxyが新しいServiceを見つけた時、kube-proxyは仮想IPから各Serviceのルールにリダイレクトされるような、iptablesルールのセットをインストールします。
Service毎のルールは、トラフィックをバックエンドにリダイレクト(Destination NATを使用)しているEndpoints毎のルールに対してリンクしています。</p><p>クライアントがServiceの仮想IPアドレスに対して接続しているとき、そのiptablesルールが有効になります。
バックエンドのPodが選択され(SessionAffinityに基づくか、もしくはランダムで選択される)、パケットはバックエンドにリダイレクトされます。
userspaceモードのプロキシーとは異なり、パケットは決してuserspaceにコピーされず、kube-proxyは仮想IPのために稼働される必要はなく、またNodeでは変更されていないクライアントIPからトラフィックがきます。</p><p>このように同じ基本的なフローは、NodePortまたはLoadBalancerを介してトラフィックがきた場合に、実行され、ただクライアントIPは変更されます。</p><h4 id=ipvs>IPVS</h4><p>iptablesの処理は、大規模なクラスターの場合劇的に遅くなります。例としてはServiceが10,000ほどある場合です。
IPVSは負荷分散のために設計され、カーネル内のハッシュテーブルに基づいています。そのためIPVSベースのkube-proxyによって、多数のServiceがある場合でも一貫して高パフォーマンスを実現できます。
次第に、IPVSベースのkube-proxyは負荷分散のアルゴリズムはさらに洗練されています(最小接続数、位置ベース、重み付け、永続性など)。</p><h2 id=apiオブジェクト>APIオブジェクト</h2><p>ServiceはKubernetesのREST APIにおいてトップレベルのリソースです。ユーザーはそのAPIオブジェクトに関して、<a href=/docs/reference/generated/kubernetes-api/v1.25/#service-v1-core>Service API object</a>でさらなる情報を確認できます。</p><h2 id=protocol-support>サポートされているプロトコル</h2><h3 id=tcp>TCP</h3><p>ユーザーはどの種類のServiceにおいてもTCPを利用できます。これはデフォルトのネットワークプロトコルです。</p><h3 id=udp>UDP</h3><p>ユーザーは多くのServiceにおいてUDPを利用できます。 type=LoadBalancerのServiceにおいては、UDPのサポートはこの機能を提供しているクラウドプロバイダーに依存しています。</p><h3 id=http>HTTP</h3><p>もしクラウドプロバイダーがサポートしている場合、ServiceのEndpointsに転送される外部のHTTP/HTTPSでのリバースプロキシーをセットアップするために、LoadBalancerモードでServiceを作成可能です。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ユーザーはまた、HTTP/HTTPS Serviceを公開するために、Serviceの代わりに<a class=glossary-tooltip title=クラスター内のServiceに対する外部からのアクセス(主にHTTP)を管理するAPIオブジェクトです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/ingress/ target=_blank aria-label=Ingress>Ingress</a>を利用することもできます。</div><h3 id=proxy-プロトコル>PROXY プロトコル</h3><p>もしクラウドプロバイダーがサポートしている場合、Kubernetesクラスターの外部のロードバランサーを設定するためにLoadBalancerモードでServiceを利用できます。これは<a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>PROXY protocol</a>がついた接続を転送します。</p><p>ロードバランサーは、最初の一連のオクテットを送信します。
下記のような例となります。</p><pre tabindex=0><code>PROXY TCP4 192.0.2.202 10.0.42.7 12345 7\r\n
</code></pre><p>クライアントからのデータのあとに追加されます。</p><h3 id=sctp>SCTP</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p>KubernetesはService、Endpoints、EndpointSlice、NetworkPolicyとPodの定義において<code>protocol</code>フィールドの値でSCTPをサポートしています。ベータ版の機能のため、この機能はデフォルトで有効になっています。SCTPをクラスターレベルで無効にするには、クラスター管理者はAPI Serverにおいて<code>SCTPSupport</code> <a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を<code>--feature-gates=SCTPSupport=false,…</code>と設定して無効にする必要があります。</p><p>そのフィーチャーゲートが有効になった時、ユーザーはService、Endpoints、EndpointSlice、NetworkPolicy、またはPodの<code>protocol</code>フィールドに<code>SCTP</code>を設定できます。
Kubernetesは、TCP接続と同様に、SCTPアソシエーションに応じてネットワークをセットアップします。</p><h4 id=caveat-sctp-overview>警告</h4><h5 id=caveat-sctp-multihomed>マルチホームSCTPアソシエーションのサポート</h5><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong><p>マルチホームSCTPアソシエーションのサポートは、複数のインターフェースとPodのIPアドレスの割り当てをサポートできるCNIプラグインを要求します。</p><p>マルチホームSCTPアソシエーションにおけるNATは、対応するカーネルモジュール内で特別なロジックを要求します。</p></div><h5 id=caveat-sctp-loadbalancer-service-type>type=LoadBalancer Service について</h5><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> クラウドプロバイダーのロードバランサーの実装がプロトコルとしてSCTPをサポートしている場合は、<code>type</code> がLoadBalancerで<code> protocol</code>がSCTPの場合でのみサービスを作成できます。
そうでない場合、Serviceの作成要求はリジェクトされます。現時点でのクラウドのロードバランサーのプロバイダー(Azure、AWS、CloudStack、GCE、OpenStack)は全てSCTPのサポートをしていません。</div><h5 id=caveat-sctp-windows-os>Windows</h5><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> SCTPはWindowsベースのNodeではサポートされていません。</div><h5 id=caveat-sctp-kube-proxy-userspace>Userspace kube-proxy</h5><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> kube-proxyはuserspaceモードにおいてSCTPアソシエーションの管理をサポートしません。</div><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>Connecting Applications with Services</a>を参照してください。</li><li><a href=/ja/docs/concepts/services-networking/ingress/>Ingress</a>を参照してください。</li><li><a href=/ja/docs/concepts/services-networking/endpoint-slices/>EndpointSlices</a>を参照してください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3a38878244d862dfdb8d7adb32f77584>5.2 - Serviceトポロジー</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code></div><p><em>Serviceトポロジー</em>を利用すると、Serviceのトラフィックをクラスターのノードトポロジーに基づいてルーティングできるようになります。たとえば、あるServiceのトラフィックに対して、できるだけ同じノードや同じアベイラビリティゾーン上にあるエンドポイントを優先してルーティングするように指定できます。</p><h2 id=はじめに>はじめに</h2><p>デフォルトでは、<code>ClusterIP</code>や<code>NodePort</code>Serviceに送信されたトラフィックは、Serviceに対応する任意のバックエンドのアドレスにルーティングされる可能性があります。しかし、Kubernetes 1.7以降では、「外部の」トラフィックをそのトラフィックを受信したノード上のPodにルーティングすることが可能になりました。しかし、この機能は<code>ClusterIP</code>Serviceでは対応しておらず、ゾーン内ルーティングなどのより複雑なトポロジーは実現不可能でした。<em>Serviceトポロジー</em>の機能を利用すれば、Serviceの作者が送信元ノードと送信先ノードのNodeのラベルに基づいてトラフィックをルーティングするためのポリシーを定義できるようになるため、この問題を解決できます。</p><p>送信元と送信先の間のNodeラベルのマッチングを使用することにより、オペレーターは、そのオペレーターの要件に適したメトリクスを使用して、お互いに「より近い」または「より遠い」ノードのグループを指定できます。たとえば、パブリッククラウド上のさまざまなオペレーターでは、Serviceのトラフィックを同一ゾーン内に留めようとする傾向があります。パブリッククラウドでは、ゾーンをまたぐトラフィックでは関連するコストがかかる一方、ゾーン内のトラフィックにはコストがかからない場合があるからです。その他のニーズとしては、DaemonSetが管理するローカルのPodにトラフィックをルーティングできるようにしたり、レイテンシーを低く抑えるために同じラック上のスイッチに接続されたノードにトラフィックを限定したいというものがあります。</p><h2 id=serviceトポロジーを利用する>Serviceトポロジーを利用する</h2><p>クラスターのServiceトポロジーが有効になっていれば、Serviceのspecに<code>topologyKeys</code>フィールドを指定することで、Serviceのトラフィックのルーティングを制御できます。このフィールドは、Nodeラベルの優先順位リストで、このServiceにアクセスするときにエンドポイントをソートするために使われます。トラフィックは、最初のラベルの値が送信元Nodeのものと一致するNodeに送信されます。一致したノード上にServiceに対応するバックエンドが存在しなかった場合は、2つ目のラベルについて検討が行われ、同様に、残っているラベルが順番に検討されまます。</p><p>一致するキーが1つも見つからなかった場合、トラフィックは、Serviceに対応するバックエンドが存在しなかったかのように拒否されます。言い換えると、エンドポイントは、利用可能なバックエンドが存在する最初のトポロジーキーに基づいて選択されます。このフィールドが指定され、すべてのエントリーでクライアントのトポロジーに一致するバックエンドが存在しない場合、そのクライアントに対するバックエンドが存在しないものとしてコネクションが失敗します。「任意のトポロジー」を意味する特別な値<code>"*"</code>を指定することもできます。任意の値にマッチするこの値に意味があるのは、リストの最後の値として使った場合だけです。</p><p><code>topologyKeys</code>が未指定または空の場合、トポロジーの制約は適用されません。</p><p>ホスト名、ゾーン名、リージョン名のラベルが付いたNodeを持つクラスターについて考えてみましょう。このとき、Serviceの<code>topologyKeys</code>の値を設定することで、トラフィックの向きを以下のように制御できます。</p><ul><li>トラフィックを同じノード上のエンドポイントのみに向け、同じノード上にエンドポイントが1つも存在しない場合には失敗するようにする: <code>["kubernetes.io/hostname"]</code>。</li><li>同一ノード上のエンドポイントを優先し、失敗した場合には同一ゾーン上のエンドポイント、同一リージョンゾーンのエンドポイントへとフォールバックし、それ以外の場合には失敗する: <code>["kubernetes.io/hostname", "topology.kubernetes.io/zone", "topology.kubernetes.io/region"]</code>。これは、たとえばデータのローカリティが非常に重要である場合などに役に立ちます。</li><li>同一ゾーンを優先しますが、ゾーン内に利用可能なノードが存在しない場合は、利用可能な任意のエンドポイントにフォールバックする: <code>["topology.kubernetes.io/zone", "*"]</code>。</li></ul><h2 id=制約>制約</h2><ul><li><p>Serviceトポロジーは<code>externalTrafficPolicy=Local</code>と互換性がないため、Serviceは2つの機能を同時に利用できません。2つの機能を同じクラスター上の異なるServiceでそれぞれ利用することは可能ですが、同一のService上では利用できません。</p></li><li><p>有効なトポロジーキーは、現在は<code>kubernetes.io/hostname</code>、<code>topology.kubernetes.io/zone</code>、および<code>topology.kubernetes.io/region</code>に限定されています。しかし、将来は一般化され、他のノードラベルも使用できるようになる予定です。</p></li><li><p>トポロジーキーは有効なラベルのキーでなければならず、最大で16個のキーまで指定できます。</p></li><li><p>すべての値をキャッチする<code>"*"</code>を使用する場合は、トポロジーキーの最後の値として指定しなければなりません。</p></li></ul><h2 id=例>例</h2><p>以下では、Serviceトポロジーの機能を利用したよくある例を紹介します。</p><h3 id=ノードローカルのエンドポイントだけを使用する>ノードローカルのエンドポイントだけを使用する</h3><p>ノードローカルのエンドポイントのみにルーティングするServiceの例です。もし同一ノード上にエンドポイントが存在しない場合、トラフィックは損失します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=ノードローカルのエンドポイントを優先して使用する>ノードローカルのエンドポイントを優先して使用する</h3><p>ノードローカルのエンドポイントを優先して使用しますが、ノードローカルのエンドポイントが存在しない場合にはクラスター全体のエンドポイントにフォールバックするServiceの例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=同一ゾーンや同一リージョンのエンドポイントだけを使用する>同一ゾーンや同一リージョンのエンドポイントだけを使用する</h3><p>同一リージョンのエンドポイントより同一ゾーンのエンドポイントを優先するServiceの例です。もしいずれのエンドポイントも存在しない場合、トラフィックは損失します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/region&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=ノードローカル-同一ゾーン-同一リーションのエンドポイントを優先して使用する>ノードローカル、同一ゾーン、同一リーションのエンドポイントを優先して使用する</h3><p>ノードローカル、同一ゾーン、同一リージョンのエンドポイントを順番に優先し、クラスター全体のエンドポイントにフォールバックするServiceの例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/region&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/tasks/administer-cluster/enabling-service-topology>Serviceトポトジーを有効にする</a>を読む。</li><li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>サービスとアプリケーションの接続</a>を読む。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-91cb8a4438b003df11bc1c426a81b756>5.3 - ServiceとPodに対するDNS</h1><p>このページではKubernetesによるDNSサポートについて概観します。</p><h2 id=イントロダクション>イントロダクション</h2><p>KubernetesのDNSはクラスター上でDNS PodとServiceをスケジュールし、DNSの名前解決をするために各コンテナに対してDNS ServiceのIPを使うようにKubeletを設定します。</p><h3 id=何がdns名を取得するか>何がDNS名を取得するか</h3><p>クラスター内(DNSサーバーそれ自体も含む)で定義された全てのServiceはDNS名を割り当てられます。デフォルトでは、クライアントPodのDNSサーチリストはPod自身のネームスペースと、クラスターのデフォルトドメインを含みます。<br>下記の例でこの仕組みを説明します。</p><p>Kubernetesの<code>bar</code>というネームスペース内で<code>foo</code>という名前のServiceがあると仮定します。<code>bar</code>ネームスペース内で稼働しているPodは、<code>foo</code>に対してDNSクエリを実行するだけでこのServiceを探すことができます。<code>bar</code>とは別の<code>quux</code>ネームスペース内で稼働しているPodは、<code>foo.bar</code>に対してDNSクエリを実行するだけでこのServiceを探すことができます。</p><p>下記のセクションでは、サポートされているレコードタイプとレイアウトについて詳しくまとめています。
うまく機能する他のレイアウト、名前、またはクエリーは、実装の詳細を考慮し、警告なしに変更されることがあります。<br>最新の仕様に関する詳細は、<a href=https://github.com/kubernetes/dns/blob/master/docs/specification.md>KubernetesにおけるDNSベースのServiceディスカバリ</a>を参照ください。</p><h2 id=services>Service</h2><h3 id=a-aaaaレコード>A/AAAAレコード</h3><p>"通常の"(Headlessでない)Serviceは、<code>my-svc.my-namespace.svc.cluster.local</code>という形式のDNS A(AAAA)レコードを、ServiceのIPバージョンに応じて割り当てられます。このAレコードはそのServiceのClusterIPへと名前解決されます。</p><p>"Headless"(ClusterIPなしの)Serviceもまた<code>my-svc.my-namespace.svc.cluster.local</code>という形式のDNS A(AAAA)レコードを、ServiceのIPバージョンに応じて割り当てられます。通常のServiceとは異なり、このレコードはServiceによって選択されたPodのIPの一覧へと名前解決されます。クライアントはこの一覧のIPを使うか、その一覧から標準のラウンドロビン方式によって選択されたIPを使います。</p><h3 id=srvレコード>SRVレコード</h3><p>SRVレコードは、通常のServiceもしくは<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless
Services</a>の一部である名前付きポート向けに作成されます。それぞれの名前付きポートに対して、そのSRVレコードは<code>_my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster.local</code>という形式となります。<br>通常のServiceに対しては、このSRVレコードは<code>my-svc.my-namespace.svc.cluster.local</code>という形式のドメイン名とポート番号へ名前解決します。<br>Headless Serviceに対しては、このSRVレコードは複数の結果を返します。それはServiceの背後にある各Podの1つを返すのと、<code>auto-generated-name.my-svc.my-namespace.svc.cluster.local</code>という形式のPodのドメイン名とポート番号を含んだ結果を返します。</p><h2 id=pod>Pod</h2><h3 id=a-aaaaレコード-1>A/AAAAレコード</h3><p>一般的にPodは下記のDNS解決となります。</p><p><code>pod-ip-address.my-namespace.pod.cluster-domain.example</code></p><p>例えば、<code>default</code>ネームスペースのpodのIPアドレスが172.17.0.3で、クラスターのドメイン名が<code>cluster.local</code>の場合、PodのDNS名は以下になります。</p><p><code>172-17-0-3.default.pod.cluster.local</code></p><p>DeploymentかDaemonSetに作成され、Serviceに公開されるどのPodも以下のDNS解決が利用できます。</p><p><code>pod-ip-address.deployment-name.my-namespace.svc.cluster-domain.example</code></p><h3 id=podのhostnameとsubdomainフィールド>Podのhostnameとsubdomainフィールド</h3><p>現在、Podが作成されたとき、そのPodのホスト名はPodの<code>metadata.name</code>フィールドの値となります。</p><p>Pod Specは、オプションである<code>hostname</code>フィールドを持ち、Podのホスト名を指定するために使うことができます。<code>hostname</code>が指定されたとき、<code>hostname</code>はそのPodの名前よりも優先されます。例えば、<code>hostname</code>フィールドが"<code>my-host</code>"にセットされたPodを考えると、Podはそのhostnameが"<code>my-host</code>"に設定されます。</p><p>Pod Specはまた、オプションである<code>subdomain</code>フィールドも持ち、Podのサブドメイン名を指定するために使うことができます。例えば、"<code>my-namespace</code>"というネームスペース内で<code>hostname</code>が<code>foo</code>とセットされていて、<code>subdomain</code>が<code>bar</code>とセットされているPodの場合、そのPodは"<code>foo.bar.my-namespace.svc.cluster.local</code>"という名前の完全修飾ドメイン名(FQDN)を持つことになります。</p><p>例:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 実際は、portは必要ありません。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span></code></pre></div><p>もしそのPodと同じネームスペース内で、同じサブドメインを持ったHeadless Serviceが存在していた場合、クラスターのDNSサーバーもまた、そのPodの完全修飾ドメイン名(FQDN)に対するA(AAAA)レコードを返します。
例えば、"<code>busybox-1</code>"というホスト名で、"<code>default-subdomain</code>"というサブドメインを持ったPodと、そのPodと同じネームスペース内にある"<code>default-subdomain</code>"という名前のHeadless Serviceがあると考えると、そのPodは自身の完全修飾ドメイン名(FQDN)を"<code>busybox-1.default-subdomain.my-namespace.svc.cluster.local</code>"として扱います。DNSはそのPodのIPを指し示すA(AAAA)レコードを返します。"<code>busybox1</code>"と"<code>busybox2</code>"の両方のPodはそれぞれ独立したA(AAAA)レコードを持ちます。</p><p>そのエンドポイントオブジェクトはそのIPに加えて<code>hostname</code>を任意のエンドポイントアドレスに対して指定できます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> A(AAAA)レコードはPodの名前に対して作成されないため、<code>hostname</code>はPodのA(AAAA)レコードが作成されるために必須となります。<code>hostname</code>を持たないが<code>subdomain</code>を持つようなPodは、そのPodのIPアドレスを指し示すHeadless Service(<code>default-subdomain.my-namespace.svc.cluster.local</code>)に対するA(AAAA)レコードのみ作成します。</div><h3 id=podのsethostnameasfqdnフィールド>PodのsetHostnameAsFQDNフィールド</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [alpha]</code></div><p><strong>前提条件</strong>: <a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API Server'>API Server</a>に対して<code>SetHostnameAsFQDN</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にする必要があります。</p><p>Podが完全修飾ドメイン名(FQDN)を持つように構成されている場合、そのホスト名は短いホスト名です。
例えば、FQDNが<code>busybox-1.default-subdomain.my-namespace.svc.cluster-domain.example</code>のPodがある場合、
デフォルトではそのPod内の<code>hostname</code>コマンドは<code>busybox-1</code>を返し、<code>hostname --fqdn</code>コマンドはFQDNを返します。</p><p>Podのspecで<code>setHostnameAsFQDN: true</code>を設定した場合、そのPodの名前空間に対してkubeletはPodのFQDNをホスト名に書き込みます。
この場合、<code>hostname</code>と<code>hostname --fqdn</code>の両方がPodのFQDNを返します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>Linuxでは、カーネルのホスト名のフィールド(<code>struct utsname</code>の<code>nodename</code>フィールド)は64文字に制限されています。</p><p>Podがこの機能を有効にしていて、そのFQDNが64文字より長い場合、Podは起動に失敗します。
Podは<code>Pending</code>ステータス(<code>kubectl</code>でみられる<code>ContainerCreating</code>)のままになり、「Podのホスト名とクラスタードメインからFQDNを作成できなかった」や、「FQDN<code>long-FQDN</code>が長すぎる(64文字が最大, 70文字が要求された)」などのエラーイベントが生成されます。</p><p>このシナリオのユーザー体験を向上させる1つの方法は、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>admission webhook controller</a>を作成して、ユーザーがDeploymentなどのトップレベルのオブジェクトを作成するときにFQDNのサイズを制御することです。</p></div><h3 id=podのdnsポリシー>PodのDNSポリシー</h3><p>DNSポリシーはPod毎に設定できます。現在のKubernetesでは次のようなPod固有のDNSポリシーをサポートしています。これらのポリシーはPod Specの<code>dnsPolicy</code>フィールドで指定されます。</p><ul><li>"<code>Default</code>": そのPodはPodが稼働しているNodeから名前解決の設定を継承します。詳細に関しては、<a href=/docs/tasks/administer-cluster/dns-custom-nameservers/#inheriting-dns-from-the-node>関連する議論</a>を参照してください。</li><li>"<code>ClusterFirst</code>": "<code>www.kubernetes.io</code>"のようなクラスタードメインのサフィックスにマッチしないようなDNSクエリーは、Nodeから継承された上流のネームサーバーにフォワーディングされます。クラスター管理者は、追加のstubドメインと上流のDNSサーバーを設定できます。このような場合におけるDNSクエリー処理の詳細に関しては、<a href=/docs/tasks/administer-cluster/dns-custom-nameservers/#effects-on-pods>関連する議論</a>を参照してください。</li><li>"<code>ClusterFirstWithHostNet</code>": hostNetworkによって稼働しているPodに対しては、ユーザーは明示的にDNSポリシーを"<code>ClusterFirstWithHostNet</code>"とセットするべきです。</li><li>"<code>None</code>": この設定では、Kubernetesの環境からDNS設定を無視することができます。全てのDNS設定は、Pod Spec内の<code>dnsConfig</code>フィールドを指定して提供することになっています。下記のセクションの<a href=#pod-dns-config>Pod's DNS config</a>を参照ください。</li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong> "Default"は、デフォルトのDNSポリシーではありません。もし<code>dnsPolicy</code>が明示的に指定されていない場合、"ClusterFirst"が使用されます。</div><p>下記の例では、<code>hostNetwork</code>フィールドが<code>true</code>にセットされているため、<code>dnsPolicy</code>が"<code>ClusterFirstWithHostNet</code>"とセットされているPodを示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirstWithHostNet<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=pod-dns-config>PodのDNS設定</h3><p>PodのDNS設定は、ユーザーがPodに対してそのDNS設定上でさらに制御するための手段を提供します。</p><p><code>dnsConfig</code>フィールドはオプションで、どのような設定の<code>dnsPolicy</code>でも共に機能することができます。しかし、Podの<code>dnsPolicy</code>が"<code>None</code>"にセットされていたとき、<code>dnsConfig</code>フィールドは必ず指定されなくてはなりません。</p><p>下記の項目は、ユーザーが<code>dnsConfig</code>フィールドに指定可能なプロパティーとなります。</p><ul><li><code>nameservers</code>: そのPodに対するDNSサーバーとして使われるIPアドレスのリストです。これは最大で3つのIPアドレスを指定することができます。Podの<code>dnsPolicy</code>が"<code>None</code>"に指定されていたとき、そのリストは最低1つのIPアドレスを指定しなければならず、もし指定されていなければ、それ以外の<code>dnsPolicy</code>の値の場合は、このプロパティーはオプションとなります。</li><li><code>searches</code>: Pod内のホスト名のルックアップのためのDNSサーチドメインのリストです。このプロパティーはオプションです。指定されていたとき、このリストは選択されたDNSポリシーから生成されたサーチドメイン名のベースとなるリストにマージされます。重複されているドメイン名は削除されます。Kubernetesでは最大6つのサーチドメインの設定を許可しています。</li><li><code>options</code>: <code>name</code>プロパティー(必須)と<code>value</code>プロパティー(オプション)を持つような各オプジェクトのリストで、これはオプションです。このプロパティー内の内容は指定されたDNSポリシーから生成されたオプションにマージされます。重複されたエントリーは削除されます。</li></ul><p>下記のファイルはカスタムDNS設定を持ったPodの例です。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/custom-dns.yaml download=service/networking/custom-dns.yaml><code>service/networking/custom-dns.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-custom-dns-yaml")' title="Copy service/networking/custom-dns.yaml to clipboard"></img></div><div class=includecode id=service-networking-custom-dns-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dns-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;None&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nameservers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#666>1.2.3.4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>searches</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- ns1.svc.cluster.local<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- my.dns.search.suffix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>options</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ndots<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>edns0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>上記のPodが作成されたとき、<code>test</code>コンテナは、コンテナ内の<code>/etc/resolv.conf</code>ファイル内にある下記の内容を取得します。</p><pre tabindex=0><code>nameserver 1.2.3.4
search ns1.svc.cluster.local my.dns.search.suffix
options ndots:2 edns0
</code></pre><p>IPv6用のセットアップのためには、サーチパスとname serverは下記のようにセットアップするべきです。</p><pre tabindex=0><code>$ kubectl exec -it dns-example -- cat /etc/resolv.conf
nameserver 2001:db8:30::a
search default.svc.cluster.local svc.cluster.local cluster.local
options ndots:5
</code></pre><h3 id=dns機能を利用可用なバージョン>DNS機能を利用可用なバージョン</h3><p>PodのDNS設定と"<code>None</code>"というDNSポリシーの利用可能なバージョンに関しては下記の通りです。</p><table><thead><tr><th style=text-align:center>k8s version</th><th style=text-align:center>Feature support</th></tr></thead><tbody><tr><td style=text-align:center>1.14</td><td style=text-align:center>ステーブル</td></tr><tr><td style=text-align:center>1.10</td><td style=text-align:center>β版 (デフォルトで有効)</td></tr><tr><td style=text-align:center>1.9</td><td style=text-align:center>α版</td></tr></tbody></table><h2 id=次の項目>次の項目</h2><p>DNS設定の管理方法に関しては、<a href=/docs/tasks/administer-cluster/dns-custom-nameservers/>DNS Serviceの設定</a>
を確認してください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f804ac0532fcade3966ea2e3769ca031>5.4 - サービスとアプリケーションの接続</h1><h2 id=コンテナを接続するためのkubernetesモデル>コンテナを接続するためのKubernetesモデル</h2><p>継続的に実行され、複製されたアプリケーションの準備ができたので、ネットワーク上で公開することが可能になります。
Kubernetesのネットワークのアプローチについて説明する前に、Dockerの「通常の」ネットワーク手法と比較することが重要です。</p><p>デフォルトでは、Dockerはホストプライベートネットワーキングを使用するため、コンテナは同じマシン上にある場合にのみ他のコンテナと通信できます。
Dockerコンテナがノード間で通信するには、マシンのIPアドレスにポートを割り当ててから、コンテナに転送またはプロキシする必要があります。
これは明らかに、コンテナが使用するポートを非常に慎重に調整するか、ポートを動的に割り当てる必要があることを意味します。</p><p>コンテナを提供する複数の開発者やチーム間でポートの割り当てを調整することは、規模的に大変困難であり、ユーザが制御できないクラスターレベルの問題にさらされます。
Kubernetesでは、どのホストで稼働するかに関わらず、Podが他のPodと通信できると想定しています。
すべてのPodに独自のクラスタープライベートIPアドレスを付与するため、Pod間のリンクを明示的に作成したり、コンテナポートをホストポートにマップしたりする必要はありません。
これは、Pod内のコンテナがすべてlocalhostの相互のポートに到達でき、クラスター内のすべてのPodがNATなしで相互に認識できることを意味します。
このドキュメントの残りの部分では、このようなネットワークモデルで信頼できるサービスを実行する方法について詳しく説明します。</p><p>このガイドでは、シンプルなnginxサーバーを使用して概念実証を示します。</p><h2 id=podをクラスターに公開する>Podをクラスターに公開する</h2><p>前の例でネットワークモデルを紹介しましたが、再度ネットワークの観点に焦点を当てましょう。
nginx Podを作成し、コンテナポートの仕様を指定していることに注意してください。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/run-my-nginx.yaml download=service/networking/run-my-nginx.yaml><code>service/networking/run-my-nginx.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-run-my-nginx-yaml")' title="Copy service/networking/run-my-nginx.yaml to clipboard"></img></div><div class=includecode id=service-networking-run-my-nginx-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>これにより、クラスター内のどのノードからでもアクセスできるようになります。
Podが実行されているノードを確認します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./run-my-nginx.yaml
</span></span><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o wide
</span></span></code></pre></div><pre tabindex=0><code>NAME                        READY     STATUS    RESTARTS   AGE       IP            NODE
my-nginx-3800858182-jr4a2   1/1       Running   0          13s       10.244.3.4    kubernetes-minion-905m
my-nginx-3800858182-kna2y   1/1       Running   0          13s       10.244.2.5    kubernetes-minion-ljyd
</code></pre><p>PodのIPを確認します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o yaml | grep podIP
</span></span><span style=display:flex><span>    podIP: 10.244.3.4
</span></span><span style=display:flex><span>    podIP: 10.244.2.5
</span></span></code></pre></div><p>クラスター内の任意のノードにSSH接続し、両方のIPにcurl接続できるはずです。
コンテナはノードでポート80を使用<strong>していない</strong>ことに注意してください。
また、Podにトラフィックをルーティングする特別なNATルールもありません。
つまり、同じcontainerPortを使用して同じノードで複数のnginx Podを実行し、IPを使用してクラスター内の他のPodやノードからそれらにアクセスできます。
Dockerと同様に、ポートは引き続きホストノードのインターフェイスに公開できますが、ネットワークモデルにより、この必要性は根本的に減少します。</p><p>興味があれば、これを<a href=/ja/docs/concepts/cluster-administration/networking/#how-to-achieve-this>どのように達成するか</a>について詳しく読むことができます。</p><h2 id=serviceを作成する>Serviceを作成する</h2><p>そのため、フラットでクラスター全体のアドレス空間でnginxを実行するPodがあります。
理論的には、これらのPodと直接通信することができますが、ノードが停止するとどうなりますか？
Podはそれで死に、Deploymentは異なるIPを持つ新しいものを作成します。
これは、Serviceが解決する問題です。</p><p>Kubernetes Serviceは、クラスター内のどこかで実行されるPodの論理セットを定義する抽象化であり、すべて同じ機能を提供します。
作成されると、各Serviceには一意のIPアドレス(clusterIPとも呼ばれます)が割り当てられます。
このアドレスはServiceの有効期間に関連付けられており、Serviceが動作している間は変更されません。
Podは、Serviceと通信するように構成でき、Serviceへの通信は、ServiceのメンバーであるPodに自動的に負荷分散されることを認識できます。</p><p>2つのnginxレプリカのサービスを<code>kubectl expose</code>で作成できます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment/my-nginx
</span></span></code></pre></div><pre tabindex=0><code>service/my-nginx exposed
</code></pre><p>これは次のyamlを<code>kubectl apply -f</code>することと同等です:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/nginx-svc.yaml download=service/networking/nginx-svc.yaml><code>service/networking/nginx-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-nginx-svc-yaml")' title="Copy service/networking/nginx-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-nginx-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>この仕様は、<code>run：my-nginx</code>ラベルを持つ任意のPodのTCPポート80をターゲットとするサービスを作成し、抽象化されたサービスポートでPodを公開します(<code>targetPort</code>:はコンテナがトラフィックを受信するポート、<code>port</code>:は抽象化されたServiceのポートであり、他のPodがServiceへのアクセスに使用する任意のポートにすることができます)。
サービス定義でサポートされているフィールドのリストは<a href=/docs/reference/generated/kubernetes-api/v1.25/#service-v1-core>Service</a> APIオブジェクトを参照してください。</p><p>Serviceを確認します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get svc my-nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
my-nginx   ClusterIP   10.0.162.149   &lt;none&gt;        80/TCP    21s
</code></pre><p>前述のように、ServiceはPodのグループによってサポートされています。
これらのPodはエンドポイントを通じて公開されます。
Serviceのセレクターは継続的に評価され、結果は<code>my-nginx</code>という名前のEndpointsオブジェクトにPOSTされます。
Podが終了すると、エンドポイントから自動的に削除され、Serviceのセレクターに一致する新しいPodが自動的にエンドポイントに追加されます。
エンドポイントを確認し、IPが最初のステップで作成されたPodと同じであることを確認します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe svc my-nginx
</span></span></code></pre></div><pre tabindex=0><code>Name:                my-nginx
Namespace:           default
Labels:              run=my-nginx
Annotations:         &lt;none&gt;
Selector:            run=my-nginx
Type:                ClusterIP
IP:                  10.0.162.149
Port:                &lt;unset&gt; 80/TCP
Endpoints:           10.244.2.5:80,10.244.3.4:80
Session Affinity:    None
Events:              &lt;none&gt;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ep my-nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME       ENDPOINTS                     AGE
my-nginx   10.244.2.5:80,10.244.3.4:80   1m
</code></pre><p>クラスター内の任意のノードから、<code>&lt;CLUSTER-IP>:&lt;PORT></code>でnginx Serviceにcurl接続できるようになりました。
Service IPは完全に仮想的なもので、ホスト側のネットワークには接続できないことに注意してください。
この仕組みに興味がある場合は、<a href=/ja/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>サービスプロキシー</a>の詳細をお読みください。</p><h2 id=serviceにアクセスする>Serviceにアクセスする</h2><p>Kubernetesは、環境変数とDNSの2つの主要なService検索モードをサポートしています。
前者はそのまま使用でき、後者は<a href=https://releases.k8s.io/v1.25.0/cluster/addons/dns/coredns>CoreDNSクラスタアドオン</a>を必要とします。<div class="alert alert-info note callout" role=alert><strong>備考:</strong> サービス環境変数が望ましくない場合(予想されるプログラム変数と衝突する可能性がある、処理する変数が多すぎる、DNSのみを使用するなど)、<a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>Pod仕様</a>で<code>enableServiceLinks</code>フラグを<code>false</code>に設定することでこのモードを無効にできます。</div></p><h3 id=環境変数>環境変数</h3><p>ノードでPodが実行されると、kubeletはアクティブな各サービスの環境変数のセットを追加します。
これにより、順序付けの問題が発生します。
理由を確認するには、実行中のnginx Podの環境を調べます(Pod名は環境によって異なります):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-nginx-3800858182-jr4a2 -- printenv | grep SERVICE
</span></span></code></pre></div><pre tabindex=0><code>KUBERNETES_SERVICE_HOST=10.0.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><p>サービスに言及がないことに注意してください。これは、サービスの前にレプリカを作成したためです。
これのもう1つの欠点は、スケジューラーが両方のPodを同じマシンに配置し、サービスが停止した場合にサービス全体がダウンする可能性があることです。
2つのPodを強制終了し、Deploymentがそれらを再作成するのを待つことで、これを正しい方法で実行できます。
今回は、サービスはレプリカの「前」に存在します。
これにより、スケジューラーレベルのサービスがPodに広がり(すべてのノードの容量が等しい場合)、適切な環境変数が提供されます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment my-nginx --replicas<span style=color:#666>=</span>0; kubectl scale deployment my-nginx --replicas<span style=color:#666>=</span>2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o wide
</span></span></code></pre></div><pre tabindex=0><code>NAME                        READY     STATUS    RESTARTS   AGE     IP            NODE
my-nginx-3800858182-e9ihh   1/1       Running   0          5s      10.244.2.7    kubernetes-minion-ljyd
my-nginx-3800858182-j4rm4   1/1       Running   0          5s      10.244.3.8    kubernetes-minion-905m
</code></pre><p>Podは強制終了されて再作成されるため、異なる名前が付いていることに気付くでしょう。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-nginx-3800858182-e9ihh -- printenv | grep SERVICE
</span></span></code></pre></div><pre tabindex=0><code>KUBERNETES_SERVICE_PORT=443
MY_NGINX_SERVICE_HOST=10.0.162.149
KUBERNETES_SERVICE_HOST=10.0.0.1
MY_NGINX_SERVICE_PORT=80
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><h3 id=dns>DNS</h3><p>Kubernetesは、DNS名を他のServiceに自動的に割り当てるDNSクラスターアドオンサービスを提供します。
クラスターで実行されているかどうかを確認できます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services kube-dns --namespace<span style=color:#666>=</span>kube-system
</span></span></code></pre></div><pre tabindex=0><code>NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE
kube-dns   ClusterIP   10.0.0.10    &lt;none&gt;        53/UDP,53/TCP   8m
</code></pre><p>このセクションの残りの部分は、寿命の長いIP(my-nginx)を持つServiceと、そのIPに名前を割り当てたDNSサーバーがあることを前提にしています。ここではCoreDNSクラスターアドオン(アプリケーション名: <code>kube-dns</code>)を使用しているため、標準的なメソッド(<code>gethostbyname()</code>など) を使用してクラスター内の任意のPodからServiceに通信できます。CoreDNSが起動していない場合、<a href=https://github.com/coredns/deployment/tree/master/kubernetes>CoreDNS README</a>または<a href=/ja/docs/tasks/administer-cluster/coredns/#installing-coredns>Installing CoreDNS</a>を参照し、有効にする事ができます。curlアプリケーションを実行して、これをテストしてみましょう。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run curl --image<span style=color:#666>=</span>radial/busyboxplus:curl -i --tty
</span></span></code></pre></div><pre tabindex=0><code>Waiting for pod default/curl-131556218-9fnch to be running, status is Pending, pod ready: false
Hit enter for command prompt
</code></pre><p>次に、Enterキーを押して<code>nslookup my-nginx</code>を実行します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#666>[</span> root@curl-131556218-9fnch:/ <span style=color:#666>]</span>$ nslookup my-nginx
</span></span><span style=display:flex><span>Server:    10.0.0.10
</span></span><span style=display:flex><span>Address 1: 10.0.0.10
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Name:      my-nginx
</span></span><span style=display:flex><span>Address 1: 10.0.162.149
</span></span></code></pre></div><h2 id=serviceを安全にする>Serviceを安全にする</h2><p>これまでは、クラスター内からnginxサーバーにアクセスしただけでした。
サービスをインターネットに公開する前に、通信チャネルが安全であることを確認する必要があります。
これには、次のものが必要です:</p><ul><li>https用の自己署名証明書(既にID証明書を持っている場合を除く)</li><li>証明書を使用するように構成されたnginxサーバー</li><li>Podが証明書にアクセスできるようにする<a href=/ja/docs/concepts/configuration/secret/>Secret</a></li></ul><p>これらはすべて<a href=https://github.com/kubernetes/examples/tree/master/staging/https-nginx/>nginx httpsの例</a>から取得できます。
これにはツールをインストールする必要があります。
これらをインストールしたくない場合は、後で手動の手順に従ってください。つまり:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>make keys <span style=color:#b8860b>KEY</span><span style=color:#666>=</span>/tmp/nginx.key <span style=color:#b8860b>CERT</span><span style=color:#666>=</span>/tmp/nginx.crt
</span></span><span style=display:flex><span>kubectl create secret tls nginxsecret --key /tmp/nginx.key --cert /tmp/nginx.crt
</span></span></code></pre></div><pre tabindex=0><code>secret/nginxsecret created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secrets
</span></span></code></pre></div><pre tabindex=0><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           kubernetes.io/tls                     2         1m
</code></pre><p>configmapも作成します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap nginxconfigmap --from-file<span style=color:#666>=</span>default.conf
</span></span></code></pre></div><pre tabindex=0><code>configmap/nginxconfigmap created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmaps
</span></span></code></pre></div><pre tabindex=0><code>NAME             DATA   AGE
nginxconfigmap   1      114s
</code></pre><p>以下は、(Windows上など)makeの実行で問題が発生した場合に実行する手動の手順です:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 公開秘密鍵ペアを作成します</span>
</span></span><span style=display:flex><span>openssl req -x509 -nodes -days <span style=color:#666>365</span> -newkey rsa:2048 -keyout /d/tmp/nginx.key -out /d/tmp/nginx.crt -subj <span style=color:#b44>&#34;/CN=my-nginx/O=my-nginx&#34;</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># キーをbase64エンコードに変換します</span>
</span></span><span style=display:flex><span>cat /d/tmp/nginx.crt | base64
</span></span><span style=display:flex><span>cat /d/tmp/nginx.key | base64
</span></span></code></pre></div><p>前のコマンドの出力を使用して、次のようにyamlファイルを作成します。
base64でエンコードされた値はすべて1行である必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;v1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Secret&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginxsecret&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;default&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nginx.crt</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURIekNDQWdlZ0F3SUJBZ0lKQUp5M3lQK0pzMlpJTUEwR0NTcUdTSWIzRFFFQkJRVUFNQ1l4RVRBUEJnTlYKQkFNVENHNW5hVzU0YzNaak1SRXdEd1lEVlFRS0V3aHVaMmx1ZUhOMll6QWVGdzB4TnpFd01qWXdOekEzTVRKYQpGdzB4T0RFd01qWXdOekEzTVRKYU1DWXhFVEFQQmdOVkJBTVRDRzVuYVc1NGMzWmpNUkV3RHdZRFZRUUtFd2h1CloybHVlSE4yWXpDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBSjFxSU1SOVdWM0IKMlZIQlRMRmtobDRONXljMEJxYUhIQktMSnJMcy8vdzZhU3hRS29GbHlJSU94NGUrMlN5ajBFcndCLzlYTnBwbQppeW1CL3JkRldkOXg5UWhBQUxCZkVaTmNiV3NsTVFVcnhBZW50VWt1dk1vLzgvMHRpbGhjc3paenJEYVJ4NEo5Ci82UVRtVVI3a0ZTWUpOWTVQZkR3cGc3dlVvaDZmZ1Voam92VG42eHNVR0M2QURVODBpNXFlZWhNeVI1N2lmU2YKNHZpaXdIY3hnL3lZR1JBRS9mRTRqakxCdmdONjc2SU90S01rZXV3R0ljNDFhd05tNnNTSzRqYUNGeGpYSnZaZQp2by9kTlEybHhHWCtKT2l3SEhXbXNhdGp4WTRaNVk3R1ZoK0QrWnYvcW1mMFgvbVY0Rmo1NzV3ajFMWVBocWtsCmdhSXZYRyt4U1FVQ0F3RUFBYU5RTUU0d0hRWURWUjBPQkJZRUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjcKTUI4R0ExVWRJd1FZTUJhQUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjdNQXdHQTFVZEV3UUZNQU1CQWY4dwpEUVlKS29aSWh2Y05BUUVGQlFBRGdnRUJBRVhTMW9FU0lFaXdyMDhWcVA0K2NwTHI3TW5FMTducDBvMm14alFvCjRGb0RvRjdRZnZqeE04Tzd2TjB0clcxb2pGSW0vWDE4ZnZaL3k4ZzVaWG40Vm8zc3hKVmRBcStNZC9jTStzUGEKNmJjTkNUekZqeFpUV0UrKzE5NS9zb2dmOUZ3VDVDK3U2Q3B5N0M3MTZvUXRUakViV05VdEt4cXI0Nk1OZWNCMApwRFhWZmdWQTRadkR4NFo3S2RiZDY5eXM3OVFHYmg5ZW1PZ05NZFlsSUswSGt0ejF5WU4vbVpmK3FqTkJqbWZjCkNnMnlwbGQ0Wi8rUUNQZjl3SkoybFIrY2FnT0R4elBWcGxNSEcybzgvTHFDdnh6elZPUDUxeXdLZEtxaUMwSVEKQ0I5T2wwWW5scE9UNEh1b2hSUzBPOStlMm9KdFZsNUIyczRpbDlhZ3RTVXFxUlU9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nginx.key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRQ2RhaURFZlZsZHdkbFIKd1V5eFpJWmVEZWNuTkFhbWh4d1NpeWF5N1AvOE9ta3NVQ3FCWmNpQ0RzZUh2dGtzbzlCSzhBZi9WemFhWm9zcApnZjYzUlZuZmNmVUlRQUN3WHhHVFhHMXJKVEVGSzhRSHA3VkpMcnpLUC9QOUxZcFlYTE0yYzZ3MmtjZUNmZitrCkU1bEVlNUJVbUNUV09UM3c4S1lPNzFLSWVuNEZJWTZMMDUrc2JGQmd1Z0ExUE5JdWFubm9UTWtlZTRuMG4rTDQKb3NCM01ZUDhtQmtRQlAzeE9JNHl3YjREZXUraURyU2pKSHJzQmlIT05Xc0RadXJFaXVJMmdoY1kxeWIyWHI2UAozVFVOcGNSbC9pVG9zQngxcHJHclk4V09HZVdPeGxZZmcvbWIvNnBuOUYvNWxlQlkrZStjSTlTMkQ0YXBKWUdpCkwxeHZzVWtGQWdNQkFBRUNnZ0VBZFhCK0xkbk8ySElOTGo5bWRsb25IUGlHWWVzZ294RGQwci9hQ1Zkank4dlEKTjIwL3FQWkUxek1yall6Ry9kVGhTMmMwc0QxaTBXSjdwR1lGb0xtdXlWTjltY0FXUTM5SjM0VHZaU2FFSWZWNgo5TE1jUHhNTmFsNjRLMFRVbUFQZytGam9QSFlhUUxLOERLOUtnNXNrSE5pOWNzMlY5ckd6VWlVZWtBL0RBUlBTClI3L2ZjUFBacDRuRWVBZmI3WTk1R1llb1p5V21SU3VKdlNyblBESGtUdW1vVlVWdkxMRHRzaG9reUxiTWVtN3oKMmJzVmpwSW1GTHJqbGtmQXlpNHg0WjJrV3YyMFRrdWtsZU1jaVlMbjk4QWxiRi9DSmRLM3QraTRoMTVlR2ZQegpoTnh3bk9QdlVTaDR2Q0o3c2Q5TmtEUGJvS2JneVVHOXBYamZhRGR2UVFLQmdRRFFLM01nUkhkQ1pKNVFqZWFKClFGdXF4cHdnNzhZTjQyL1NwenlUYmtGcVFoQWtyczJxWGx1MDZBRzhrZzIzQkswaHkzaE9zSGgxcXRVK3NHZVAKOWRERHBsUWV0ODZsY2FlR3hoc0V0L1R6cEdtNGFKSm5oNzVVaTVGZk9QTDhPTm1FZ3MxMVRhUldhNzZxelRyMgphRlpjQ2pWV1g0YnRSTHVwSkgrMjZnY0FhUUtCZ1FEQmxVSUUzTnNVOFBBZEYvL25sQVB5VWs1T3lDdWc3dmVyClUycXlrdXFzYnBkSi9hODViT1JhM05IVmpVM25uRGpHVHBWaE9JeXg5TEFrc2RwZEFjVmxvcG9HODhXYk9lMTAKMUdqbnkySmdDK3JVWUZiRGtpUGx1K09IYnRnOXFYcGJMSHBzUVpsMGhucDBYSFNYVm9CMUliQndnMGEyOFVadApCbFBtWmc2d1BRS0JnRHVIUVV2SDZHYTNDVUsxNFdmOFhIcFFnMU16M2VvWTBPQm5iSDRvZUZKZmcraEppSXlnCm9RN3hqWldVR3BIc3AyblRtcHErQWlSNzdyRVhsdlhtOElVU2FsbkNiRGlKY01Pc29RdFBZNS9NczJMRm5LQTQKaENmL0pWb2FtZm1nZEN0ZGtFMXNINE9MR2lJVHdEbTRpb0dWZGIwMllnbzFyb2htNUpLMUI3MkpBb0dBUW01UQpHNDhXOTVhL0w1eSt5dCsyZ3YvUHM2VnBvMjZlTzRNQ3lJazJVem9ZWE9IYnNkODJkaC8xT2sybGdHZlI2K3VuCnc1YytZUXRSTHlhQmd3MUtpbGhFZDBKTWU3cGpUSVpnQWJ0LzVPbnlDak9OVXN2aDJjS2lrQ1Z2dTZsZlBjNkQKckliT2ZIaHhxV0RZK2Q1TGN1YSt2NzJ0RkxhenJsSlBsRzlOZHhrQ2dZRUF5elIzT3UyMDNRVVV6bUlCRkwzZAp4Wm5XZ0JLSEo3TnNxcGFWb2RjL0d5aGVycjFDZzE2MmJaSjJDV2RsZkI0VEdtUjZZdmxTZEFOOFRwUWhFbUtKCnFBLzVzdHdxNWd0WGVLOVJmMWxXK29xNThRNTBxMmk1NVdUTThoSDZhTjlaMTltZ0FGdE5VdGNqQUx2dFYxdEYKWSs4WFJkSHJaRnBIWll2NWkwVW1VbGc9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>ファイルを使用してSecretを作成します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f nginxsecrets.yaml
</span></span><span style=display:flex><span>kubectl get secrets
</span></span></code></pre></div><pre tabindex=0><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           kubernetes.io/tls                     2         1m
</code></pre><p>次に、nginxレプリカを変更して、シークレットの証明書とServiceを使用してhttpsサーバーを起動し、両方のポート(80と443)を公開します:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/nginx-secure-app.yaml download=service/networking/nginx-secure-app.yaml><code>service/networking/nginx-secure-app.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-nginx-secure-app-yaml")' title="Copy service/networking/nginx-secure-app.yaml to clipboard"></img></div><div class=includecode id=service-networking-nginx-secure-app-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>https<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>nginxsecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginxhttps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>bprashanth/nginxhttps:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/ssl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>nginx-secure-appマニフェストに関する注目すべき点:</p><ul><li>同じファイルにDeploymentとServiceの両方が含まれています。</li><li><a href=https://github.com/kubernetes/examples/tree/master/staging/https-nginx/default.conf>nginxサーバー</a>はポート80のHTTPトラフィックと443のHTTPSトラフィックを処理し、nginx Serviceは両方のポートを公開します。</li><li>各コンテナは<code>/etc/nginx/ssl</code>にマウントされたボリュームを介してキーにアクセスできます。
これは、nginxサーバーが起動する<em>前に</em>セットアップされます。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployments,svc my-nginx; kubectl create -f ./nginx-secure-app.yaml
</span></span></code></pre></div><p>この時点で、任意のノードからnginxサーバーに到達できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o custom-columns<span style=color:#666>=</span>POD_IP:.status.podIPs
</span></span><span style=display:flex><span>    POD_IP
</span></span><span style=display:flex><span>    <span style=color:#666>[</span>map<span style=color:#666>[</span>ip:10.244.3.5<span style=color:#666>]]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>node $ curl -k https://10.244.3.5
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</span></span></code></pre></div><p>最後の手順でcurlに<code>-k</code>パラメーターを指定したことに注意してください。
これは、証明書の生成時にnginxを実行しているPodについて何も知らないためです。
CNameの不一致を無視するようcurlに指示する必要があります。
Serviceを作成することにより、証明書で使用されるCNameを、Service検索中にPodで使用される実際のDNS名にリンクしました。
これをPodからテストしましょう(簡単にするために同じシークレットを再利用しています。PodはServiceにアクセスするためにnginx.crtのみを必要とします):</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/curlpod.yaml download=service/networking/curlpod.yaml><code>service/networking/curlpod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-curlpod-yaml")' title="Copy service/networking/curlpod.yaml to clipboard"></img></div><div class=includecode id=service-networking-curlpod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>curl-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>nginxsecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- while true; do sleep 1; done<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>radial/busyboxplus:curl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/ssl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./curlpod.yaml
</span></span><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>curlpod
</span></span></code></pre></div><pre tabindex=0><code>NAME                               READY     STATUS    RESTARTS   AGE
curl-deployment-1515033274-1410r   1/1       Running   0          1m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> curl-deployment-1515033274-1410r -- curl https://my-nginx --cacert /etc/nginx/ssl/tls.crt
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=serviceを公開する>Serviceを公開する</h2><p>アプリケーションの一部では、Serviceを外部IPアドレスに公開したい場合があります。
Kubernetesは、NodePortとLoadBalancerの2つの方法をサポートしています。
前のセクションで作成したServiceはすでに<code>NodePort</code>を使用しているため、ノードにパブリックIPがあれば、nginx HTTPSレプリカはインターネット上のトラフィックを処理する準備ができています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get svc my-nginx -o yaml | grep nodePort -C <span style=color:#666>5</span>
</span></span><span style=display:flex><span>  uid: 07191fb3-f61a-11e5-8ae5-42010af00002
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  clusterIP: 10.0.162.149
</span></span><span style=display:flex><span>  ports:
</span></span><span style=display:flex><span>  - name: http
</span></span><span style=display:flex><span>    nodePort: <span style=color:#666>31704</span>
</span></span><span style=display:flex><span>    port: <span style=color:#666>8080</span>
</span></span><span style=display:flex><span>    protocol: TCP
</span></span><span style=display:flex><span>    targetPort: <span style=color:#666>80</span>
</span></span><span style=display:flex><span>  - name: https
</span></span><span style=display:flex><span>    nodePort: <span style=color:#666>32453</span>
</span></span><span style=display:flex><span>    port: <span style=color:#666>443</span>
</span></span><span style=display:flex><span>    protocol: TCP
</span></span><span style=display:flex><span>    targetPort: <span style=color:#666>443</span>
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    run: my-nginx
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes -o yaml | grep ExternalIP -C <span style=color:#666>1</span>
</span></span><span style=display:flex><span>    - address: 104.197.41.11
</span></span><span style=display:flex><span>      type: ExternalIP
</span></span><span style=display:flex><span>    allocatable:
</span></span><span style=display:flex><span>--
</span></span><span style=display:flex><span>    - address: 23.251.152.56
</span></span><span style=display:flex><span>      type: ExternalIP
</span></span><span style=display:flex><span>    allocatable:
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ curl https://&lt;EXTERNAL-IP&gt;:&lt;NODE-PORT&gt; -k
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</span></span></code></pre></div><p>クラウドロードバランサーを使用するようにサービスを再作成しましょう。
<code>my-nginx</code>サービスの<code>Type</code>を<code>NodePort</code>から<code>LoadBalancer</code>に変更するだけです:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit svc my-nginx
</span></span><span style=display:flex><span>kubectl get svc my-nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME       TYPE           CLUSTER-IP     EXTERNAL-IP        PORT(S)               AGE
my-nginx   LoadBalancer   10.0.162.149     xx.xxx.xxx.xxx     8080:30163/TCP        21s
</code></pre><pre tabindex=0><code>curl https://&lt;EXTERNAL-IP&gt; -k
...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</code></pre><p><code>EXTERNAL-IP</code>列のIPアドレスは、パブリックインターネットで利用可能なものです。
<code>CLUSTER-IP</code>は、クラスター/プライベートクラウドネットワーク内でのみ使用できます。</p><p>AWSでは、type <code>LoadBalancer</code>はIPではなく(長い)ホスト名を使用するELBが作成されます。
実際、標準の<code>kubectl get svc</code>の出力に収まるには長すぎるので、それを確認するには<code>kubectl describe service my-nginx</code>を実行する必要があります。
次のようなものが表示されます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe service my-nginx
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>LoadBalancer Ingress:   a320587ffd19711e5a37606cf4a74574-1142138393.us-east-1.elb.amazonaws.com
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=次の項目>次の項目</h2><ul><li>詳細: <a href=/ja/docs/tasks/access-application-cluster/service-access-application-cluster/>Serviceを利用したクラスター内のアプリケーションへのアクセス</a></li><li>詳細: <a href=/ja/docs/tasks/access-application-cluster/connecting-frontend-backend/>Serviceを使用してフロントエンドをバックエンドに接続する</a></li><li>詳細: <a href=/docs/tasks/access-application-cluster/create-external-load-balancer/>Creating an External Load Balancer</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f51db1097575de8072afe1f5b156a70c>5.5 - EndpointSlice</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p><em>EndpointSlice</em>は、Kubernetesクラスター内にあるネットワークエンドポイントを追跡するための単純な手段を提供します。EndpointSliceは、よりスケーラブルでより拡張可能な、Endpointの代わりとなるものです。</p><h2 id=動機>動機</h2><p>Endpoint APIはKubernetes内のネットワークエンドポイントを追跡する単純で直観的な手段を提供してきました。
残念ながら、Kubernetesクラスターや<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>が大規模になり、より多くのトラフィックを処理し、より多くのバックエンドPodに送信するようになるにしたがって、Endpoint APIの限界が明らかになってきました。
最も顕著な問題の1つに、ネットワークエンドポイントの数が大きくなったときのスケーリングの問題があります。</p><p>Serviceのすべてのネットワークエンドポイントが単一のEndpointリソースに格納されていたため、リソースのサイズが非常に大きくなる場合がありました。これがKubernetesのコンポーネント(特に、マスターコントロールプレーン)の性能に悪影響を与え、結果として、Endpointに変更があるたびに、大量のネットワークトラフィックと処理が発生するようになってしまいました。EndpointSliceは、この問題を緩和するとともに、トポロジカルルーティングなどの追加機能のための拡張可能なプラットフォームを提供します。</p><h2 id=endpointslice-resource>EndpointSliceリソース</h2><p>Kubernetes内ではEndpointSliceにはネットワークエンドポイントの集合へのリファレンスが含まれます。
コントロールプレーンは、<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=セレクター>セレクター</a>が指定されているKubernetes ServiceのEndpointSliceを自動的に作成します。
これらのEndpointSliceには、Serviceセレクターに一致するすべてのPodへのリファレンスが含まれています。
EndpointSliceは、プロトコル、ポート番号、およびサービス名の一意の組み合わせによってネットワークエンドポイントをグループ化します。
EndpointSliceオブジェクトの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><p>一例として、以下に<code>example</code>というKubernetes Serviceに対するサンプルのEndpointSliceリソースを示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>discovery.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EndpointSlice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-abc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>addressType</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>endpoints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>pod-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topology</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/hostname</span>:<span style=color:#bbb> </span>node-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>topology.kubernetes.io/zone</span>:<span style=color:#bbb> </span>us-west2-a<span style=color:#bbb>
</span></span></span></code></pre></div><p>デフォルトでは、コントロールプレーンはEndpointSliceを作成・管理し、それぞれのエンドポイント数が100以下になるようにします。<code>--max-endpoints-per-slice</code><a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>フラグを設定することで、最大1000個まで設定可能です。</p><p>EndpointSliceは内部トラフィックのルーティング方法に関して、<a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>に対する唯一のソース(source of truth)として振る舞うことができます。EndpointSliceを有効にすれば、非常に多数のエンドポイントを持つServiceに対して性能向上が得られるはずです。</p><h3 id=アドレスの種類>アドレスの種類</h3><p>EndpointSliceは次の3種類のアドレスをサポートします。</p><ul><li>IPv4</li><li>IPv6</li><li>FQDN (Fully Qualified Domain Name、完全修飾ドメイン名)</li></ul><h3 id=topology>トポロジー</h3><p>EndpointSliceに属する各エンドポイントは、関連するトポロジーの情報を持つことができます。この情報は、エンドポイントの場所を示すために使われ、対応するNode、ゾーン、リージョンに関する情報が含まれます。
値が利用できる場合には、コントロールプレーンはEndpointSliceコントローラーに次のようなTopologyラベルを設定します。</p><ul><li><code>kubernetes.io/hostname</code> - このエンドポイントが存在するNodeの名前。</li><li><code>topology.kubernetes.io/zone</code> - このエンドポイントが存在するゾーン。</li><li><code>topology.kubernetes.io/region</code> - このエンドポイントが存在するリージョン。</li></ul><p>これらのラベルの値はスライス内の各エンドポイントと関連するリソースから継承したものです。hostnameラベルは対応するPod上のNodeNameフィールドの値を表します。zoneとregionラベルは対応するNode上の同じ名前のラベルの値を表します。</p><h3 id=管理>管理</h3><p>ほとんどの場合、コントロールプレーン（具体的には、EndpointSlice <a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>）は、EndpointSliceオブジェクトを作成および管理します。EndpointSliceには、サービスメッシュの実装など、他のさまざまなユースケースがあり、他のエンティティまたはコントローラーがEndpointSliceの追加セットを管理する可能性があります。</p><p>複数のエンティティが互いに干渉することなくEndpointSliceを管理できるようにするために、KubernetesはEndpointSliceを管理するエンティティを示す<code>endpointslice.kubernetes.io/managed-by</code>という<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>を定義します。
EndpointSliceを管理するその他のエンティティも同様に、このラベルにユニークな値を設定する必要があります。</p><h3 id=所有権>所有権</h3><p>ほとんどのユースケースでは、EndpointSliceはエンドポイントスライスオブジェクトがエンドポイントを追跡するServiceによって所有されます。
これは、各EndpointSlice上のownerリファレンスと<code>kubernetes.io/service-name</code>ラベルによって示されます。これにより、Serviceに属するすべてのEndpointSliceを簡単に検索できるようになっています。</p><h3 id=endpointsliceのミラーリング>EndpointSliceのミラーリング</h3><p>場合によっては、アプリケーションはカスタムEndpointリソースを作成します。これらのアプリケーションがEndpointリソースとEndpointSliceリソースの両方に同時に書き込む必要がないようにするために、クラスターのコントロールプレーンは、ほとんどのEndpointリソースを対応するEndpointSliceにミラーリングします。</p><p>コントロールプレーンは、次の場合を除いて、Endpointリソースをミラーリングします。</p><ul><li>Endpointリソースの<code>endpointslice.kubernetes.io/skip-mirror</code>ラベルが<code>true</code>に設定されています。</li><li>Endpointリソースが<code>control-plane.alpha.kubernetes.io/leader</code>アノテーションを持っています。</li><li>対応するServiceリソースが存在しません。</li><li>対応するServiceリソースには、nil以外のセレクターがあります。</li></ul><p>個々のEndpointリソースは、複数のEndpointSliceに変換される場合があります。これは、Endpointリソースに複数のサブセットがある場合、または複数のIPファミリ（IPv4およびIPv6）を持つエンドポイントが含まれている場合に発生します。サブセットごとに最大1000個のアドレスがEndpointSliceにミラーリングされます。</p><h3 id=endpointsliceの分散>EndpointSliceの分散</h3><p>それぞれのEndpointSliceにはポートの集合があり、リソース内のすべてのエンドポイントに適用されます。サービスが名前付きポートを使用した場合、Podが同じ名前のポートに対して、結果的に異なるターゲットポート番号が使用されて、異なるEndpointSliceが必要になる場合があります。これはサービスの部分集合がEndpointにグループ化される場合と同様です。</p><p>コントロールプレーンはEndpointSliceをできる限り充填しようとしますが、積極的にリバランスを行うことはありません。コントローラーのロジックは極めて単純で、以下のようになっています。</p><ol><li>既存のEndpointSliceをイテレートし、もう必要のないエンドポイントを削除し、変更があったエンドポイントを更新する。</li><li>前のステップで変更されたEndpointSliceをイテレートし、追加する必要がある新しいエンドポイントで充填する。</li><li>まだ追加するべき新しいエンドポイントが残っていた場合、これまで変更されなかったスライスに追加を試み、その後、新しいスライスを作成する。</li></ol><p>ここで重要なのは、3番目のステップでEndpointSliceを完全に分散させることよりも、EndpointSliceの更新を制限することを優先していることです。たとえば、もし新しい追加するべきエンドポイントが10個あり、2つのEndpointSliceにそれぞれ5個の空きがあった場合、このアプローチでは2つの既存のEndpointSliceを充填する代わりに、新しいEndpointSliceが作られます。言い換えれば、1つのEndpointSliceを作成する方が複数のEndpointSliceを更新するよりも好ましいということです。</p><p>各Node上で実行されているkube-proxyはEndpointSliceを監視しており、EndpointSliceに加えられた変更はクラスター内のすべてのNodeに送信されるため、比較的コストの高い処理になります。先ほどのアプローチは、たとえ複数のEndpointSliceが充填されない結果となるとしても、すべてのNodeへ送信しなければならない変更の数を抑制することを目的としています。</p><p>現実的には、こうしたあまり理想的ではない分散が発生することは稀です。EndpointSliceコントローラーによって処理されるほとんどの変更は、既存のEndpointSliceに収まるほど十分小さくなるためです。そうでなかったとしても、すぐに新しいEndpointSliceが必要になる可能性が高いです。また、Deploymentのローリングアップデートが行われれば、自然な再充填が行われます。Podとそれに対応するエンドポイントがすべて置換されるためです。</p><h3 id=エンドポイントの重複>エンドポイントの重複</h3><p>EndpointSliceの変更の性質上、エンドポイントは同時に複数のEndpointSliceで表される場合があります。
これは、さまざまなEndpointSliceオブジェクトへの変更が、さまざまな時間にKubernetesクライアントのウォッチ/キャッシュに到達する可能性があるために自然に発生します。
EndpointSliceを使用する実装では、エンドポイントを複数のスライスに表示できる必要があります。
エンドポイント重複排除を実行する方法のリファレンス実装は、<code>kube-proxy</code>の<code>EndpointSliceCache</code>実装にあります。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/tasks/administer-cluster/enabling-endpointslices>EndpointSliceの有効化</a>について学ぶ</li><li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>サービスとアプリケーションの接続</a>を読む</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-199bcc92443dbc9bed44819467d7eb75>5.6 - Ingress</h1><p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code></div><p>クラスター内のServiceに対する外部からのアクセス(主にHTTP)を管理するAPIオブジェクトです。</p><p>Ingressは負荷分散、SSL終端、名前ベースの仮想ホスティングの機能を提供します。</p></p><h2 id=用語>用語</h2><p>簡単のために、このガイドでは次の用語を定義します。</p><ul><li>ノード: Kubernetes内のワーカーマシンで、クラスターの一部です。</li><li>クラスター: Kubernetesによって管理されているコンテナ化されたアプリケーションを実行させるノードの集合です。この例や、多くのKubernetesによるデプロイでは、クラスター内のノードはインターネットに公開されていません。</li><li>エッジルーター: クラスターでファイアウォールのポリシーを強制するルーターです。クラウドプロバイダーが管理するゲートウェイや、物理的なハードウェアの一部である場合もあります。</li><li>クラスターネットワーク: 物理的または論理的な繋がりの集合で、Kubernetesの<a href=/ja/docs/concepts/cluster-administration/networking/>ネットワークモデル</a>によって、クラスター内でのコミュニケーションを司るものです。</li><li>Service: <a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>セレクターを使ったPodの集合を特定するKubernetes <a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>です。特に指定がない限り、Serviceはクラスターネットワーク内でのみ疎通可能な仮想IPを持つものとして扱われます。</li></ul><h2 id=ingressとは何か>Ingressとは何か</h2><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#ingress-v1-networking-k8s-io>Ingress</a>はクラスター外からクラスター内<a href=/ja/docs/concepts/services-networking/service/ target=_blank>Service</a>へのHTTPとHTTPSのルートを公開します。トラフィックのルーティングはIngressリソース上で定義されるルールによって制御されます。</p><p>全てのトラフィックを単一のServiceに送る単純なIngressの例を示します。</p><figure class=diagram-large><a href=https://mermaid.live/edit#pako:eNqNkstKAzEUhl8lpBuFGan1gqTSlS4EF6LLTheZScaGzo0k4wV14QyI4qav4GUjYhVEUBB8mAh9DTNNalvcuEnCn_P95-TknMAgJRQi6CX7HGddsL3b9BIAgojRRM61VfGsygdV3KviVpWvqrzszLsLYEtHUyGGg5th_-L7_VqdD8C6z1tAlU-q_FTllSr7FaiR4k0rYMFtMQO1LdwZJbKi67ZOVfk4Yi9UcTcCX8bK46mg_IAFtL1ndsOK3DdFB1EuJOW_1X6o4kuDnakEBjC0TpalZLG9k5LOX70x0WlCTDOwEBs0BFmEWQJCFkWoRghxhORpj6JaGIb27B4yIrtoOTtygjRKOarV6_XmjElvTViLpcZqQFf-5aLvZl3sk63TBEU13_dnbRoTG5Nx4jTujmM74FR9qZZGVeZUnJkH04AZ2VRhd33jJdCBMeUxZkSP1UkV60HZpTH1INJHQkOcR9LTE3emQ3Eu073jJIBI8pw6MM8IlnSDYf2zMUQhjsSvukmYTLkVz34Au18T9A><img src=/ja/docs/images/ingress.svg alt=ingress-diagram></a><figcaption><p>図. Ingress</p></figcaption></figure><p>IngressはServiceに対して、外部疎通できるURL、負荷分散トラフィック、SSL/TLS終端の機能や、名前ベースの仮想ホスティングを提供するように設定できます。<a href=/ja/docs/concepts/services-networking/ingress-controllers/>Ingressコントローラー</a>は通常はロードバランサーを使用してIngressの機能を実現しますが、エッジルーターや、追加のフロントエンドを構成してトラフィックの処理を支援することもできます。</p><p>Ingressは任意のポートやプロトコルを公開しません。HTTPやHTTPS以外のServiceをインターネットに公開する場合、<a href=/ja/docs/concepts/services-networking/service/#nodeport>Service.Type=NodePort</a>や<a href=/ja/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a>のServiceタイプを一般的には使用します。</p><h2 id=ingressを使用する上での前提条件>Ingressを使用する上での前提条件</h2><p>Ingressを提供するためには<a href=/ja/docs/concepts/services-networking/ingress-controllers>Ingressコントローラー</a>が必要です。Ingressリソースを作成するのみでは何の効果もありません。</p><p><a href=https://kubernetes.github.io/ingress-nginx/deploy/>ingress-nginx</a>のようなIngressコントローラーのデプロイが必要な場合があります。いくつかの<a href=/ja/docs/concepts/services-networking/ingress-controllers>Ingressコントローラー</a>の中から選択してください。</p><p>理想的には、全てのIngressコントローラーはリファレンスの仕様を満たすはずです。しかし実際には、各Ingressコントローラーは微妙に異なる動作をします。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Ingressコントローラーのドキュメントを確認して、選択する際の注意点について理解してください。</div><h2 id=ingressリソース>Ingressリソース</h2><p>Ingressリソースの最小構成の例は以下のとおりです。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/minimal-ingress.yaml download=service/networking/minimal-ingress.yaml><code>service/networking/minimal-ingress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-minimal-ingress-yaml")' title="Copy service/networking/minimal-ingress.yaml to clipboard"></img></div><div class=includecode id=service-networking-minimal-ingress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>minimal-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingressClassName</span>:<span style=color:#bbb> </span>nginx-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/testpath<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Ingressには<code>apiVersion</code>、<code>kind</code>、<code>metadata</code>や<code>spec</code>フィールドが必要です。Ingressオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。設定ファイルに関する一般的な情報は、<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>アプリケーションのデプロイ</a>、<a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>コンテナの設定</a>、<a href=/ja/docs/concepts/cluster-administration/manage-deployment/>リソースの管理</a>を参照してください。Ingressでは、Ingressコントローラーに依存しているいくつかのオプションの設定をするためにアノテーションを一般的に使用します。例としては、<a href=https://github.com/kubernetes/ingress-nginx/blob/master/docs/examples/rewrite/README.md>rewrite-targetアノテーション</a>などがあります。<a href=/ja/docs/concepts/services-networking/ingress-controllers>Ingressコントローラー</a>の種類が異なれば、サポートするアノテーションも異なります。サポートされているアノテーションについて学ぶためには、使用するIngressコントローラーのドキュメントを確認してください。</p><p>Ingress <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>Spec</a>は、ロードバランサーやプロキシーサーバーを設定するために必要な全ての情報を持っています。最も重要なものとして、外部からくる全てのリクエストに対して一致したルールのリストを含みます。IngressリソースはHTTP(S)トラフィックに対してのルールのみサポートしています。</p><p><code>ingressClassName</code>が省略された場合、<a href=#default-ingress-class>デフォルトのIngressClass</a>を定義する必要があります。</p><p>デフォルトの<code>IngressClass</code>を定義しなくても動作するIngressコントローラーがいくつかあります。例えば、Ingress-NGINXコントローラーは<a href=https://kubernetes.github.io/ingress-nginx/#what-is-the-flag-watch-ingress-without-class>フラグ</a>
<code>--watch-ingress-without-class</code>で設定できます。ただし、<a href=#default-ingress-class>下記</a>のようにデフォルトの<code>IngressClass</code>を指定することを<a href=https://kubernetes.github.io/ingress-nginx/#i-have-only-one-instance-of-the-ingresss-nginx-controller-in-my-cluster-what-should-i-do>推奨します</a>。</p><h3 id=ingressのルール>Ingressのルール</h3><p>各HTTPルールは以下の情報を含みます。</p><ul><li>オプションで設定可能なホスト名。上記のリソースの例では、ホスト名が指定されていないので、そのルールは指定されたIPアドレスを経由する全てのインバウンドHTTPトラフィックに適用されます。ホスト名が指定されていると(例: foo.bar.com)、そのルールは指定されたホストに対して適用されます。</li><li>パスのリスト(例: <code>/testpath</code>)。各パスには<code>service.name</code>と<code>service.port.name</code>または<code>service.port.number</code>で定義されるバックエンドが関連づけられます。ロードバランサーがトラフィックを関連づけられたServiceに転送するために、外部からくるリクエストのホスト名とパスが条件と一致させる必要があります。</li><li>バックエンドは<a href=/ja/docs/concepts/services-networking/service/>Serviceドキュメント</a>に書かれているようなService名とポート名の組み合わせ、または<a class=glossary-tooltip title='Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server.' data-toggle=tooltip data-placement=top href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CRD>CRD</a>による<a href=#resource-backend>カスタムリソースバックエンド</a>です。Ingressで設定されたホスト名とパスのルールに一致するHTTP(とHTTPS)のリクエストは、リスト内のバックエンドに対して送信されます。</li></ul><p>Ingressコントローラーでは、<code>defaultBackend</code>が設定されていることがあります。これはSpec内で指定されているパスに一致しないようなリクエストのためのバックエンドです。</p><h3 id=default-backend>デフォルトのバックエンド</h3><p>ルールが設定されていないIngressは、全てのトラフィックを単一のデフォルトのバックエンドに転送します。<code>.spec.defaultBackend</code>はその場合にリクエストを処理するバックエンドになります。<code>defaultBackend</code>は、<a href=/ja/docs/concepts/services-networking/ingress-controllers>Ingressコントローラー</a>のオプション設定であり、Ingressリソースでは指定されていません。<code>.spec.rules</code>を設定しない場合、<code>.spec.defaultBackend</code>の設定は必須です。<code>defaultBackend</code>が設定されていない場合、どのルールにもマッチしないリクエストの処理は、Ingressコントローラーに任されます(このケースをどう処理するかは、お使いのIngressコントローラーのドキュメントを参照してください)。</p><p>HTTPリクエストがIngressオブジェクトのホスト名とパスの条件に1つも一致しない時、そのトラフィックはデフォルトのバックエンドに転送されます。</p><h3 id=resource-backend>リソースバックエンド</h3><p><code>Resource</code>バックエンドはIngressオブジェクトと同じnamespaceにある他のKubernetesリソースを指すObjectRefです。
<code>Resource</code>はServiceの設定とは排他であるため、両方を指定するとバリデーションに失敗します。
<code>Resource</code>バックエンドの一般的な用途は、静的なアセットが入ったオブジェクトストレージバックエンドにデータを導入することです。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/ingress-resource-backend.yaml download=service/networking/ingress-resource-backend.yaml><code>service/networking/ingress-resource-backend.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-ingress-resource-backend-yaml")' title="Copy service/networking/ingress-resource-backend.yaml to clipboard"></img></div><div class=includecode id=service-networking-ingress-resource-backend-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ingress-resource-backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultBackend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageBucket<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>static-assets<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/icons<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>ImplementationSpecific<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageBucket<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>icon-assets<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>上記のIngressを作成した後に、次のコマンドで参照することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe ingress ingress-resource-backend
</span></span></code></pre></div><pre tabindex=0><code>Name:             ingress-resource-backend
Namespace:        default
Address:
Default backend:  APIGroup: k8s.example.com, Kind: StorageBucket, Name: static-assets
Rules:
  Host        Path  Backends
  ----        ----  --------
  *
              /icons   APIGroup: k8s.example.com, Kind: StorageBucket, Name: icon-assets
Annotations:  &lt;none&gt;
Events:       &lt;none&gt;
</code></pre><h3 id=パスのタイプ>パスのタイプ</h3><p>Ingressのそれぞれのパスは対応するパスのタイプを持ちます。<code>pathType</code>が明示的に指定されていないパスはバリデーションに通りません。サポートされているパスのタイプは3種類あります。</p><ul><li><p><code>ImplementationSpecific</code>(実装に特有): このパスタイプでは、パスとの一致はIngressClassに依存します。Ingressの実装はこれを独立した<code>pathType</code>と扱うことも、<code>Prefix</code>や<code>Exact</code>と同一のパスタイプと扱うこともできます。</p></li><li><p><code>Exact</code>: 大文字小文字を区別して完全に一致するURLパスと一致します。</p></li><li><p><code>Prefix</code>: <code>/</code>で分割されたURLと前方一致で一致します。大文字小文字は区別され、パスの要素対要素で比較されます。パス要素は<code>/</code>で分割されたパスの中のラベルのリストを参照します。リクエストがパス <em>p</em> に一致するのは、Ingressのパス <em>p</em> がリクエストパス <em>p</em> と要素単位で前方一致する場合です。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> パスの最後の要素がリクエストパスの最後の要素の部分文字列である場合、これは一致しません（例えば、<code>/foo/bar</code>は<code>/foo/bar/baz</code>と一致しますが、<code>/foo/barbaz</code>とは一致しません）。</div></li></ul><h3 id=例>例</h3><table><thead><tr><th>タイプ</th><th>パス</th><th>リクエストパス</th><th>一致するか</th></tr></thead><tbody><tr><td>Prefix</td><td><code>/</code></td><td>（全てのパス）</td><td>はい</td></tr><tr><td>Exact</td><td><code>/foo</code></td><td><code>/foo</code></td><td>はい</td></tr><tr><td>Exact</td><td><code>/foo</code></td><td><code>/bar</code></td><td>いいえ</td></tr><tr><td>Exact</td><td><code>/foo</code></td><td><code>/foo/</code></td><td>いいえ</td></tr><tr><td>Exact</td><td><code>/foo/</code></td><td><code>/foo</code></td><td>いいえ</td></tr><tr><td>Prefix</td><td><code>/foo</code></td><td><code>/foo</code>, <code>/foo/</code></td><td>はい</td></tr><tr><td>Prefix</td><td><code>/foo/</code></td><td><code>/foo</code>, <code>/foo/</code></td><td>はい</td></tr><tr><td>Prefix</td><td><code>/aaa/bb</code></td><td><code>/aaa/bbb</code></td><td>いいえ</td></tr><tr><td>Prefix</td><td><code>/aaa/bbb</code></td><td><code>/aaa/bbb</code></td><td>はい</td></tr><tr><td>Prefix</td><td><code>/aaa/bbb/</code></td><td><code>/aaa/bbb</code></td><td>はい、末尾のスラッシュは無視</td></tr><tr><td>Prefix</td><td><code>/aaa/bbb</code></td><td><code>/aaa/bbb/</code></td><td>はい、末尾のスラッシュと一致</td></tr><tr><td>Prefix</td><td><code>/aaa/bbb</code></td><td><code>/aaa/bbb/ccc</code></td><td>はい、パスの一部と一致</td></tr><tr><td>Prefix</td><td><code>/aaa/bbb</code></td><td><code>/aaa/bbbxyz</code></td><td>いいえ、接頭辞と一致しない</td></tr><tr><td>Prefix</td><td><code>/</code>, <code>/aaa</code></td><td><code>/aaa/ccc</code></td><td>はい、接頭辞<code>/aaa</code>と一致</td></tr><tr><td>Prefix</td><td><code>/</code>, <code>/aaa</code>, <code>/aaa/bbb</code></td><td><code>/aaa/bbb</code></td><td>はい、接頭辞<code>/aaa/bbb</code>と一致</td></tr><tr><td>Prefix</td><td><code>/</code>, <code>/aaa</code>, <code>/aaa/bbb</code></td><td><code>/ccc</code></td><td>はい、接頭辞<code>/</code>と一致</td></tr><tr><td>Prefix</td><td><code>/aaa</code></td><td><code>/ccc</code></td><td>いいえ、デフォルトバックエンドを使用</td></tr><tr><td>Mixed</td><td><code>/foo</code> (Prefix), <code>/foo</code> (Exact)</td><td><code>/foo</code></td><td>はい、Exactが優先</td></tr></tbody></table><h4 id=複数のパスとの一致>複数のパスとの一致</h4><p>リクエストがIngressの複数のパスと一致することがあります。そのような場合は、最も長くパスが一致したものが優先されます。2つのパスが同等に一致した場合は、完全一致が前方一致よりも優先されます。</p><h2 id=ホスト名のワイルドカード>ホスト名のワイルドカード</h2><p>ホストは正確に一致する（例えば<code>foo.bar.com</code>）かワイルドカード（例えば<code>*.foo.com</code>）とすることができます。
正確な一致ではHTTPヘッダーの<code>host</code>が<code>host</code>フィールドと一致することが必要です。
ワイルドカードによる一致では、HTTPヘッダーの<code>host</code>がワイルドカードルールに沿って後方一致することが必要です。</p><table><thead><tr><th>Host</th><th>Hostヘッダー</th><th>一致するか</th></tr></thead><tbody><tr><td><code>*.foo.com</code></td><td><code>bar.foo.com</code></td><td>共通の接尾辞により一致</td></tr><tr><td><code>*.foo.com</code></td><td><code>baz.bar.foo.com</code></td><td>一致しない。ワイルドカードは単一のDNSラベルのみを対象とする</td></tr><tr><td><code>*.foo.com</code></td><td><code>foo.com</code></td><td>一致しない。ワイルドカードは単一のDNSラベルのみを対象とする</td></tr></tbody></table><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/ingress-wildcard-host.yaml download=service/networking/ingress-wildcard-host.yaml><code>service/networking/ingress-wildcard-host.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-ingress-wildcard-host-yaml")' title="Copy service/networking/ingress-wildcard-host.yaml to clipboard"></img></div><div class=includecode id=service-networking-ingress-wildcard-host-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ingress-wildcard-host<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;foo.bar.com&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/bar&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*.foo.com&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h2 id=ingress-class>Ingress Class</h2><p>Ingressは異なったコントローラーで実装されうるため、しばしば異なった設定を必要とします。
各Ingressはクラス、つまりIngressClassリソースへの参照を指定する必要があります。IngressClassリソースには、このクラスを実装するコントローラーの名前などの追加設定が含まれています。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/external-lb.yaml download=service/networking/external-lb.yaml><code>service/networking/external-lb.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-external-lb-yaml")' title="Copy service/networking/external-lb.yaml to clipboard"></img></div><div class=includecode id=service-networking-external-lb-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span>example.com/ingress-controller<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressParameters<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>IngressClassの<code>.spec.parameters</code>フィールドを使って、そのIngressClassに関連する設定を持っている別のリソースを参照することができます。</p><p>使用するパラメーターの種類は、IngressClassの<code>.spec.controller</code>フィールドで指定したIngressコントローラーに依存します。</p><h3 id=ingressclassスコープ>IngressClassスコープ</h3><p>Ingressコントローラーによっては、クラスター全体で設定したパラメーターを使用できる場合もあれば、1つのNamespaceに対してのみ設定したパラメーターを使用できる場合もあります。</p><ul class="nav nav-tabs" id=tabs-ingressclass-parameter-scope role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabs-ingressclass-parameter-scope-0 role=tab aria-controls=tabs-ingressclass-parameter-scope-0 aria-selected=true>クラスタースコープ</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tabs-ingressclass-parameter-scope-1 role=tab aria-controls=tabs-ingressclass-parameter-scope-1>Namespaceスコープ</a></li></ul><div class=tab-content id=tabs-ingressclass-parameter-scope><div id=tabs-ingressclass-parameter-scope-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabs-ingressclass-parameter-scope-0><p><p>IngressClassパラメーターのデフォルトのスコープは、クラスター全体です。</p><p><code>.spec.parameters</code>フィールドを設定して<code>.spec.parameters.scope</code>フィールドを設定しなかった場合、または<code>.spec.parameters.scope</code>を<code>Cluster</code>に設定した場合、IngressClassはクラスタースコープのリソースを参照します。
パラーメーターの<code>kind</code>(および<code>apiGroup</code>)はクラスタースコープのAPI(カスタムリソースの場合もあり)を指し、パラメーターの<code>name</code>はそのAPIの特定のクラスタースコープのリソースを特定します。</p><p>例えば:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span>example.com/ingress-controller<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># このIngressClassのパラメーターは「external-config-1」という名前の</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ClusterIngressParameter(APIグループk8s.example.net)で指定されています。この定義は、Kubernetesに</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># クラスタースコープのパラメーターリソースを探すように指示しています。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.net<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterIngressParameter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-config-1<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=tabs-ingressclass-parameter-scope-1 class=tab-pane role=tabpanel aria-labelledby=tabs-ingressclass-parameter-scope-1><p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code></div><p><code>.spec.parameters</code>フィールドを設定して<code>.spec.parameters.scope</code>フィールドを<code>Namespace</code>に設定した場合、IngressClassはNamespaceスコープのリソースを参照します。また<code>.spec.parameters</code>内の<code>namespace</code>フィールドには、使用するパラメーターが含まれているNamespaceを設定する必要があります。</p><p>パラメーターの<code>kind</code>(および<code>apiGroup</code>)はNamespaceスコープのAPI(例えば:ConfigMap)を指し、パラメーターの<code>name</code>は<code>namespace</code>で指定したNamespace内の特定のリソースを特定します。</p><p>Namespaceスコープのパラメーターはクラスターオペレーターがワークロードに使用される設定(例えば:ロードバランサー設定、APIゲートウェイ定義)に対する制御を委譲するのに役立ちます。クラスタースコープパラメーターを使用した場合は以下のいずれかになります:</p><ul><li>クラスターオペレーターチームは、新しい設定変更が適用されるたびに、別のチームの変更内容を承認する必要があります。</li><li>クラスターオペレーターは、アプリケーションチームがクラスタースコープのパラメーターリソースに変更を加えることができるように、<a href=/ja/docs/reference/access-authn-authz/rbac/>RBAC</a>のRoleやRoleBindingといった、特定のアクセス制御を定義する必要があります。</li></ul><p>IngressClass API自体は常にクラスタースコープです。</p><p>以下はNamespaceスコープのパラメーターを参照しているIngressClassの例です:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span>example.com/ingress-controller<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># このIngressClassのパラメーターは「external-config」という名前の</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># IngressParameter(APIグループk8s.example.com)で指定されています。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># このリソースは「external-configuration」というNamespaceにあります。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressParameter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>external-configuration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-config<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h3 id=非推奨のアノテーション>非推奨のアノテーション</h3><p>Kubernetes 1.18でIngressClassリソースと<code>ingressClassName</code>フィールドが追加される前は、Ingressの種別はIngressの<code>kubernetes.io/ingress.class</code>アノテーションにより指定されていました。
このアノテーションは正式に定義されたことはありませんが、Ingressコントローラーに広くサポートされています。</p><p>Ingressの新しい<code>ingressClassName</code>フィールドはこのアノテーションを置き換えるものですが、完全に等価ではありません。
アノテーションは一般にIngressを実装すべきIngressのコントローラーの名称を示していましたが、フィールドはIngressClassリソースへの参照であり、Ingressのコントローラーの名称を含む追加のIngressの設定情報を含んでいます。</p><h3 id=default-ingress-class>デフォルトのIngressClass</h3><p>特定のIngressClassをクラスターのデフォルトとしてマークすることができます。
IngressClassリソースの<code>ingressclass.kubernetes.io/is-default-class</code>アノテーションを<code>true</code>に設定すると、<code>ingressClassName</code>フィールドが指定されないIngressにはこのデフォルトIngressClassが割り当てられるようになります。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> 複数のIngressClassをクラスターのデフォルトに設定すると、アドミッションコントローラーは<code>ingressClassName</code>が指定されていない新しいIngressオブジェクトを作成できないようにします。クラスターのデフォルトIngressClassを1つ以下にすることで、これを解消することができます。</div><p>Ingressコントローラーの中には、デフォルトの<code>IngressClass</code>を定義しなくても動作するものがあります。 例えば、Ingress-NGINXコントローラーは<a href=https://kubernetes.github.io/ingress-nginx/#what-is-the-flag-watch-ingress-without-class>フラグ</a>
<code>--watch-ingress-without-class</code>で設定することができます。ただし、デフォルト<code>IngressClass</code>を指定することを<a href=https://kubernetes.github.io/ingress-nginx/#i-have-only-one-instance-of-the-ingresss-nginx-controller-in-my-cluster-what-should-i-do>推奨します</a>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/default-ingressclass.yaml download=service/networking/default-ingressclass.yaml><code>service/networking/default-ingressclass.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-default-ingressclass-yaml")' title="Copy service/networking/default-ingressclass.yaml to clipboard"></img></div><div class=includecode id=service-networking-default-ingressclass-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>controller<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ingressclass.kubernetes.io/is-default-class</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span>k8s.io/ingress-nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h2 id=ingressのタイプ>Ingressのタイプ</h2><h3 id=single-service-ingress>単一ServiceのIngress</h3><p>Kubernetesには、単一のServiceを公開できるようにする既存の概念があります（<a href=#alternatives>Ingressの代替案</a>を参照してください）。ルールなしで<em>デフォルトのバックエンド</em> を指定することにより、Ingressでこれを実現することもできます。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/test-ingress.yaml download=service/networking/test-ingress.yaml><code>service/networking/test-ingress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-test-ingress-yaml")' title="Copy service/networking/test-ingress.yaml to clipboard"></img></div><div class=includecode id=service-networking-test-ingress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultBackend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p><code>kubectl apply -f</code>を実行してIngressを作成すると、その作成したIngressの状態を確認することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get ingress test-ingress
</span></span></code></pre></div><pre tabindex=0><code>NAME           CLASS         HOSTS   ADDRESS         PORTS   AGE
test-ingress   external-lb   *       203.0.113.123   80      59s
</code></pre><p><code>203.0.113.123</code>はIngressコントローラーによって割り当てられたIPで、作成したIngressを利用するためのものです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> IngressコントローラーとロードバランサーがIPアドレス割り当てるのに1、2分ほどかかります。この間、ADDRESSの情報は<code>&lt;pending></code>となっているのを確認できます。</div><h3 id=リクエストのシンプルなルーティング>リクエストのシンプルなルーティング</h3><p>ファンアウト設定では単一のIPアドレスのトラフィックを、リクエストされたHTTP URIに基づいて1つ以上のServiceに転送します。Ingressによってロードバランサーの数を少なくすることができます。例えば、以下のように設定します。</p><figure class=diagram-large><a href=https://mermaid.live/edit#pako:eNqNUk1v1DAQ_SuW9wJSEhJngcWL9lQOSBwQPW724MRO12o2jmyHD7U9kEgIxKV_AcSFA-WAkEBC4scYqX8Dp3a6XQoSF3s0b96bmac5goWgDGJ4IEmzBo-ezLMagKLirNY3lqb7bPqPpvtguvem_2L616ubYQQe1geSKXV-9u789NWvb2_NyzNwP5cLYPpPpv9h-jemPx2IltJ9tRkQhQvuSEtPDkBydxbdS6IEpVGSotVFY18UhovjW6UQx4rJp7xgyXLfBWBM4CmK4-ucnMiRg_7kIDyLZ56j2twtXFSt0kxebvrddD_twKsrwo7g-9oujaDJ8rGgq78A6BqAHJD-C5huAVZTZz5Rao-VoKkIr0HJqwpPKKWB0lIcMjwpy9LH4TNO9RpPm-dBISoh8SSO4_mOyOFMeYkU3SnY7f9SsdiuirfJK22peJLn-a4M2sq4jlul0dFgNG0MUDCYOjwXUTo802H0K1x3k86UnbSbzP9zGMANkxvCqT3qo6Eug3rNNiyD2IaUlaStdAaz-sSWklaL_Rd1AbGWLQtg21Ci2R4n9jo2EJekUpfZB5RrIX3y5DdQxjHm><img src=/ja/docs/images/ingressFanOut.svg alt=ingress-fanout-diagram></a><figcaption><p>図. Ingressファンアウト</p></figcaption></figure><p>Ingressを以下のように設定します。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/simple-fanout-example.yaml download=service/networking/simple-fanout-example.yaml><code>service/networking/simple-fanout-example.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-simple-fanout-example-yaml")' title="Copy service/networking/simple-fanout-example.yaml to clipboard"></img></div><div class=includecode id=service-networking-simple-fanout-example-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>simple-fanout-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>4200</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Ingressを<code>kubectl apply -f</code>によって作成したとき:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe ingress simple-fanout-example
</span></span></code></pre></div><pre tabindex=0><code>Name:             simple-fanout-example
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:4200 (10.8.0.90:4200)
               /bar   service2:8080 (10.8.0.91:8080)
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     22s                loadbalancer-controller  default/test
</code></pre><p>IngressコントローラーはService(<code>service1</code>、<code>service2</code>)が存在する限り、Ingressの条件を満たす実装固有のロードバランサーを構築します。
構築が完了すると、ADDRESSフィールドでロードバランサーのアドレスを確認できます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用する<a href=/ja/docs/concepts/services-networking/ingress-controllers/>Ingressコントローラー</a>に依存しますが、default-http-backend<a href=/ja/docs/concepts/services-networking/service/>Service</a>の作成が必要な場合があります。</div><h3 id=名前ベースのバーチャルホスティング>名前ベースのバーチャルホスティング</h3><p>名前ベースのバーチャルホストは、HTTPトラフィックを同一のIPアドレスの複数のホスト名に転送することをサポートしています。</p><figure class=diagram-large><a href=https://mermaid.live/edit#pako:eNqNks1u1DAQx1_F8l5ASqKNs8Dioj0VCSQOiB43e3Bip2s1iSPb4UNtDyQSAnHpK4B66YFyQEggIfEwRupr4NTeL6ASF2c0__n9ZzzxMcwFZRDDQ0maJXjybC-tAchLzmp9a266z6a_MN256T6a_ovp3y5uhxF4XB9KptTV5Yersze_vr03ry_Bg0zOgOk_mf6H6d-Z_mwALdJ9tRkQhTPuoLmHAxDfm0b34yhGSRQnaHHd2BeF4ezkkVAag0KIKCMyykV1oph8znMWzw9cAFYJPB3fgA_oYLGFoz9xtMZVm7k15GWrNJPr-3833U97jcVWDwf4AWzDRtB4_lTQxT8E9JeAnJDcJEw2Aqup-yVEqX1WgKYkvAYFL0s8opQGSktxxPCoKAofhy841Us8aV4GuSiFxKPxeLy3Y3I0Vd4iQXdzdue_XKy26-LX5J02KB5lWbZrgzY2ruPGabXRYLW0VYCCYanDcR0lwzEZRt9i3Ut1S9lJu8n81yowgBWTFeHUPvbjoTKFeskqlkJsQ8oK0pY6hWl9aktJq8XBqzqHWMuWBbBtKNFsnxP7PiqIC1KqdfYh5VpInzz9DRXUOys><img src=/ja/docs/images/ingressNameBased.svg alt=ingress-namebase-diagram></a><figcaption><p>図. Ingress名前ベースのバーチャルホスティング</p></figcaption></figure><p>以下のIngress設定は、ロードバランサーに対して、<a href=https://tools.ietf.org/html/rfc7230#section-5.4>Hostヘッダー</a>に基づいてリクエストを転送するように指示するものです。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/name-virtual-host-ingress.yaml download=service/networking/name-virtual-host-ingress.yaml><code>service/networking/name-virtual-host-ingress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-name-virtual-host-ingress-yaml")' title="Copy service/networking/name-virtual-host-ingress.yaml to clipboard"></img></div><div class=includecode id=service-networking-name-virtual-host-ingress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>rules項目でのホストの設定がないIngressを作成すると、IngressコントローラーのIPアドレスに対するwebトラフィックは、要求されている名前ベースのバーチャルホストなしにマッチさせることができます。</p><p>例えば、以下のIngressは<code>first.bar.com</code>に対するトラフィックを<code>service1</code>へ、<code>second.foo.com</code>に対するトラフィックを<code>service2</code>へ、リクエストにおいてホスト名が指定されていない(リクエストヘッダーがないことを意味します)トラフィックは<code>service3</code>へ転送します。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/name-virtual-host-ingress-no-third-host.yaml download=service/networking/name-virtual-host-ingress-no-third-host.yaml><code>service/networking/name-virtual-host-ingress-no-third-host.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-name-virtual-host-ingress-no-third-host-yaml")' title="Copy service/networking/name-virtual-host-ingress-no-third-host.yaml to clipboard"></img></div><div class=includecode id=service-networking-name-virtual-host-ingress-no-third-host-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress-no-third-host<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>first.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>second.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h3 id=tls>TLS</h3><p>TLSの秘密鍵と証明書を含んだ<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>を指定することにより、Ingressをセキュアにできます。Ingressは単一のTLSポートである443番ポートのみサポートし、IngressでTLS終端を行うことを想定しています。IngressからServiceやPodへのトラフィックは平文です。IngressのTLS設定のセクションで異なるホストを指定すると、それらのホストはSNI TLSエクステンション(IngressコントローラーがSNIをサポートしている場合)を介して指定されたホスト名に対し、同じポート上で多重化されます。TLSのSecretは<code>tls.crt</code>と<code>tls.key</code>というキーを含む必要があり、TLSを使用するための証明書と秘密鍵を含む値となります。以下がその例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>base64 encoded cert<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>base64 encoded key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></span></span></code></pre></div><p>IngressでこのSecretを参照すると、クライアントとロードバランサー間の通信にTLSを使用するようIngressコントローラーに指示することになります。作成したTLS Secretは、<code>https-example.foo.com</code>の完全修飾ドメイン名(FQDN)とも呼ばれる共通名(CN)を含む証明書から作成したものであることを確認する必要があります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> デフォルトルールではTLSが機能しない可能性があることに注意してください。
これは取り得る全てのサブドメインに対する証明書を発行する必要があるからです。
そのため、<code>tls</code>セクションの<code>hosts</code>は<code>rules</code>セクションの<code>host</code>と明示的に一致する必要があります。</div><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/tls-example-ingress.yaml download=service/networking/tls-example-ingress.yaml><code>service/networking/tls-example-ingress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-tls-example-ingress-yaml")' title="Copy service/networking/tls-example-ingress.yaml to clipboard"></img></div><div class=includecode id=service-networking-tls-example-ingress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>tls-example-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>hosts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- https-example.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>https-example.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> サポートされるTLSの機能はIngressコントローラーによって違いがあります。利用する環境でTLSがどのように動作するかを理解するためには、<a href=https://kubernetes.github.io/ingress-nginx/user-guide/tls/>nginx</a>や、<a href=https://git.k8s.io/ingress-gce/README.md#frontend-https>GCE</a>、または他のプラットフォーム固有のIngressコントローラーのドキュメントを確認してください。</div><h3 id=load-balancing>負荷分散</h3><p>Ingressコントローラーは、負荷分散アルゴリズムやバックエンドの重みスキームなど、すべてのIngressに適用されるいくつかの負荷分散ポリシーの設定とともにブートストラップされます。発展した負荷分散のコンセプト(例: セッションの永続化、動的重み付けなど)はIngressによってサポートされていません。代わりに、それらの機能はService用のロードバランサーを介して利用できます。</p><p>ヘルスチェックの機能はIngressによって直接には公開されていませんが、Kubernetesにおいて、同等の機能を提供する<a href=/ja/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>Readiness Probe</a>のようなコンセプトが存在することは注目に値します。コントローラーがどのようにヘルスチェックを行うかについては、コントローラーのドキュメントを参照してください(例えば<a href=https://git.k8s.io/ingress-nginx/README.md>nginx</a>、または<a href=https://git.k8s.io/ingress-gce/README.md#health-checks>GCE</a>)。</p><h2 id=ingressの更新>Ingressの更新</h2><p>リソースを編集することで、既存のIngressに対して新しいホストを追加することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe ingress <span style=color:#a2f>test</span>
</span></span></code></pre></div><pre tabindex=0><code>Name:             test
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:80 (10.8.0.90:80)
Annotations:
  nginx.ingress.kubernetes.io/rewrite-target:  /
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     35s                loadbalancer-controller  default/test
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit ingress <span style=color:#a2f>test</span>
</span></span></code></pre></div><p>このコマンドを実行すると既存の設定をYAMLフォーマットで編集するエディターが表示されます。新しいホストを追加するには、リソースを修正してください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.baz.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>..<span style=color:#bbb>
</span></span></span></code></pre></div><p>変更を保存した後、kubectlはAPIサーバー内のリソースを更新し、Ingressコントローラーに対してロードバランサーの再設定を指示します。</p><p>変更内容を確認してください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe ingress <span style=color:#a2f>test</span>
</span></span></code></pre></div><pre tabindex=0><code>Name:             test
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:80 (10.8.0.90:80)
  bar.baz.com
               /foo   service2:80 (10.8.0.91:80)
Annotations:
  nginx.ingress.kubernetes.io/rewrite-target:  /
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     45s                loadbalancer-controller  default/test
</code></pre><p>修正されたIngressのYAMLファイルに対して<code>kubectl replace -f</code>を実行することで、同様の結果を得られます。</p><h2 id=アベイラビリティーゾーンをまたいだ障害について>アベイラビリティーゾーンをまたいだ障害について</h2><p>障害のあるドメインをまたいでトラフィックを分散する手法は、クラウドプロバイダーによって異なります。詳細に関して、<a href=/ja/docs/concepts/services-networking/ingress-controllers>Ingress コントローラー</a>のドキュメントを参照してください。</p><h2 id=alternatives>Ingressの代替案</h2><p>Ingressリソースを直接含まずにサービスを公開する方法は複数あります。</p><ul><li><a href=/ja/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a></li><li><a href=/ja/docs/concepts/services-networking/service/#nodeport>Service.Type=NodePort</a></li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/reference/kubernetes-api/service-resources/ingress-v1/>Ingress</a>APIについて学ぶ</li><li><a href=/ja/docs/concepts/services-networking/ingress-controllers/>Ingressコントローラー</a>について学ぶ</li><li><a href=/ja/docs/tasks/access-application-cluster/ingress-minikube/>MinikubeにNGINXコントローラーでIngressのセットアップを行う</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5a8edeb1f2dc8e38cd6d561bb08b0d78>5.7 - Ingressコントローラー</h1><p>Ingressリソースが動作するためには、クラスターでIngressコントローラーが実行されている必要があります。</p><p><code>kube-controller-manager</code>バイナリの一部として実行される他のタイプのコントローラーとは異なり、Ingressコントローラーはクラスターで自動的に起動されません。このページを使用して、クラスターに最適なIngressコントローラーの実装を選択してください。</p><p>プロジェクトとしてのKubernetesは現在、<a href=https://github.com/kubernetes-sigs/aws-load-balancer-controller#readme>AWS</a>、<a href=https://git.k8s.io/ingress-gce/README.md#readme>GCE</a>、および<a href=https://git.k8s.io/ingress-nginx/README.md#readme>nginx</a>のIngressコントローラーをサポート・保守しています。</p><h2 id=additional-controllers>追加のコントローラー</h2><div class="alert alert-secondary callout third-party-content" role=alert><strong>備考:</strong>
このセクションでは、Kubernetesが必要とする機能を提供するサードパーティープロジェクトにリンクしています。これらのプロジェクトはアルファベット順に記載されていて、Kubernetesプロジェクトの作者は責任を持ちません。このリストにプロジェクトを追加するには、変更を提出する前に<a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a>をお読みください。<a href=#third-party-content-disclaimer>詳細はこちら。</a></div><ul><li><a href=https://github.com/Azure/application-gateway-kubernetes-ingress>AKS Application Gateway Ingress Controller</a>は、<a href=https://docs.microsoft.com/azure/application-gateway/overview>Azure Application Gateway</a>を設定するIngressコントローラーです。</li><li><a href=https://www.getambassador.io/>Ambassador</a> API Gatewayは<a href=https://www.envoyproxy.io>Envoy</a>ベースのIngressコントローラーです。</li><li><a href=https://github.com/citrix/citrix-k8s-ingress-controller#readme>Citrix ingress controller</a>は、Citrix Application Delivery Controllerで動作します。</li><li><a href=https://projectcontour.io/>Contour</a>は、<a href=https://www.envoyproxy.io/>Envoy</a>ベースのIngressコントローラーです。</li><li>F5 BIG-IPの<a href=https://clouddocs.f5.com/containers/latest/userguide/kubernetes/>Container Ingress Services for Kubernetes</a>はF5 BIG-IPの仮想サーバー上でIngressの設定を可能にします。</li><li><a href=https://gloo.solo.io>Gloo</a>は<a href=https://www.envoyproxy.io>Envoy</a>をベースにしたオープンソースのIngressコントローラーで、API Gateway機能を提供しています。</li><li><a href=https://haproxy-ingress.github.io>HAProxy Ingress</a>は、<a href=http://www.haproxy.org/#desc>HAProxy</a>用のIngressコントローラーです。</li><li><a href=https://github.com/haproxytech/kubernetes-ingress>HAProxy Ingress Controller for Kubernetes</a>も、<a href=http://www.haproxy.org/#desc>HAProxy</a>用のIngressコントローラーです。</li><li><a href=https://istio.io/latest/docs/tasks/traffic-management/ingress/kubernetes-ingress/>Istio Ingress</a>は、<a href=https://istio.io/>Istio</a>ベースのIngressコントローラーです。</li><li><a href=https://github.com/Kong/kubernetes-ingress-controller#readme>Kong Ingress Controller for Kubernetes</a>は、<a href=https://konghq.com/kong/>Kong Gateway</a>向けのIngressコントローラーです。</li><li><a href=https://www.nginx.com/products/nginx/kubernetes-ingress-controller>NGINX Ingress Controller for Kubernetes</a>は、<a href=https://www.nginx.com/resources/glossary/nginx/>NGINX</a>ウェブサーバーで(プロキシとして)動作します。</li><li><a href=https://opensource.zalando.com/skipper/kubernetes/ingress-controller/>Skipper</a>は、カスタムプロキシーを構築するためのライブラリーとして設計された、Kubernetes Ingressなどのユースケースを含む、サービス構成用のHTTPルーターとリバースプロキシーです。</li><li><a href=https://doc.traefik.io/traefik/providers/kubernetes-ingress/>Traefik Kubernetes Ingress provider</a>は、<a href=https://github.com/containous/traefik>Traefik</a> proxy向けのIngressコントローラーです。</li><li><a href=https://appscode.com/products/voyager>Voyager</a>は、<a href=http://www.haproxy.org/#desc>HAProxy</a>向けのIngressコントローラーです。</li></ul><h2 id=using-multiple-ingress-controllers>複数のIngressコントローラーの使用</h2><p><a href=https://git.k8s.io/ingress-nginx/docs/user-guide/multiple-ingress.md#multiple-ingress-controllers>Ingressコントローラーは、好きな数だけ</a>クラスターにデプロイすることができます。Ingressを作成する際には、クラスター内に複数のIngressコントローラーが存在する場合にどのIngressコントローラーを使用するかを示すために適切な<a href=https://git.k8s.io/ingress-gce/docs/faq/README.md#how-do-i-run-multiple-ingress-controllers-in-the-same-cluster><code>ingress.class</code></a>のアノテーションを指定する必要があります。</p><p>クラスを定義しない場合、クラウドプロバイダーはデフォルトのIngressコントローラーを使用する場合があります。</p><p>理想的には、すべてのIngressコントローラーはこの仕様を満たすべきですが、いくつかのIngressコントローラーはわずかに異なる動作をします。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Ingressコントローラーのドキュメントを確認して、選択する際の注意点を理解してください。</div><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/services-networking/ingress/>Ingress</a>についてさらに学ぶ。</li><li><a href=/ja/docs/tasks/access-application-cluster/ingress-minikube>Minikube上でNGINX Ingressコントローラーを使用してIngressをセットアップする</a>。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-cd7657b1056ad32451974db57a951ba5>5.8 - サービス内部トラフィックポリシー</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code></div><p><em>サービス内部トラフィックポリシー</em>を使用すると、内部トラフィック制限により、トラフィックが発信されたノード内のエンドポイントにのみ内部トラフィックをルーティングできます。
ここでの「内部」トラフィックとは、現在のクラスターのPodから発信されたトラフィックを指します。これは、コストを削減し、パフォーマンスを向上させるのに役立ちます。</p><h2 id=serviceinternaltrafficpolicyの使用>ServiceInternalTrafficPolicyの使用</h2><p><code>ServiceInternalTrafficPolicy</code> <a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にすると、<code>.spec.internalTrafficPolicy</code>を<code>Local</code>に設定して、<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>内部のみのトラフィックポリシーを有効にすることができます。
これにより、kube-proxyは、クラスター内部トラフィックにノードローカルエンドポイントのみを使用するようになります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 特定のServiceのエンドポイントがないノード上のPodの場合、Serviceに他のノードのエンドポイントがある場合でも、Serviceは(このノード上のポッドの)エンドポイントがゼロであるかのように動作します。</div><p>次の例は、<code>.spec.internalTrafficPolicy</code>を<code>Local</code>に設定した場合のServiceの様子を示しています：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>internalTrafficPolicy</span>:<span style=color:#bbb> </span>Local<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=使い方>使い方</h2><p>kube-proxyは、<code>spec.internalTrafficPolicy</code>の設定に基づいて、ルーティング先のエンドポイントをフィルタリングします。
<code>spec.internalTrafficPolicy</code>が<code>Local</code>であれば、ノードのローカルエンドポイントにのみルーティングできるようにします。<code>Cluster</code>または未設定であればすべてのエンドポイントにルーティングできるようにします。
<code>ServiceInternalTrafficPolicy</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>が有効な場合、<code>spec.internalTrafficPolicy</code>のデフォルトは<code>Cluster</code>です。</p><h2 id=制約>制約</h2><ul><li>Serviceで<code>externalTrafficPolicy</code>が<code>Local</code>に設定されている場合、サービス内部トラフィックポリシーは使用されません。同じServiceだけではなく、同じクラスター内の異なるServiceで両方の機能を使用することができます。</li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/concepts/services-networking/topology-aware-hints>Topology Aware Hints</a>を読む</li><li><a href=/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip>Service External Traffic Policy</a>を読む</li><li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>サービスとアプリケーションの接続</a>を読む</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-374e5c954990aec58a0797adc70a5039>5.9 - トポロジーを意識したヒント</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code></div><p><em>Topology Aware Hint</em>は、クライアントがendpointをどのように使用するかについての提案を含めることにより、トポロジーを考慮したルーティングを可能にします。このアプローチでは、EndpointSliceおよび/またはEndpointオブジェクトの消費者が、これらのネットワークエンドポイントへのトラフィックを、それが発生した場所の近くにルーティングできるように、メタデータを追加します。</p><p>たとえば、局所的にトラフィックをルーティングすることで、コストを削減したり、ネットワークパフォーマンスを向上させたりできます。</p><h2 id=動機>動機</h2><p>Kubernetesクラスターは、マルチゾーン環境で展開されることが多くなっています。
<em>Topology Aware Hint</em>は、トラフィックを発信元のゾーン内に留めておくのに役立つメカニズムを提供します。このコンセプトは、一般に「Topology Aware Routing」と呼ばれています。EndpointSliceコントローラーは<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>のendpointを計算する際に、各endpointのトポロジー(リージョンとゾーン)を考慮し、ゾーンに割り当てるためのヒントフィールドに値を入力します。
EndpointSliceコントローラーは、各endpointのトポロジー(リージョンとゾーン)を考慮し、ゾーンに割り当てるためのヒントフィールドに入力します。
<a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>のようなクラスターコンポーネントは、次にこれらのヒントを消費し、それらを使用してトラフィックがルーティングされる方法に影響を与えることが可能です(トポロジー的に近いendpointを優先します)。</p><h2 id=topology-aware-hintを使う>Topology Aware Hintを使う</h2><p><code>service.kubernetes.io/topology-aware-hints</code>アノテーションを<code>auto</code>に設定すると、サービスに対してTopology Aware Hintを有効にすることができます。これはEndpointSliceコントローラーが安全と判断した場合に、トポロジーヒントを設定するように指示します。
重要なのは、これはヒントが常に設定されることを保証するものではないことです。</p><h2 id=implementation>使い方</h2><p>この機能を有効にする機能は、EndpointSliceコントローラーとkube-proxyの2つのコンポーネントに分かれています。このセクションでは、各コンポーネントがこの機能をどのように実装しているか、高レベルの概要を説明します。</p><h3 id=implementation-control-plane>EndpointSliceコントローラー</h3><p>この機能が有効な場合、EndpointSliceコントローラーはEndpointSliceにヒントを設定する役割を担います。
コントローラーは、各ゾーンに比例した量のendpointを割り当てます。
この割合は、そのゾーンで実行されているノードの<a href=/ja/docs/task/administer-cluster/reserve-compute-resources/#node-allocatable>割り当て可能な</a>CPUコアを基に決定されます。</p><p>たとえば、あるゾーンに2つのCPUコアがあり、別のゾーンに1つのCPUコアしかない場合、コントローラーは2つのCPUコアを持つゾーンに2倍のendpointを割り当てます。</p><p>次の例は、ヒントが入力されたときのEndpointSliceの様子を示しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>discovery.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EndpointSlice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-hints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-name</span>:<span style=color:#bbb> </span>example-svc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>addressType</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>endpoints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>pod-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>zone</span>:<span style=color:#bbb> </span>zone-a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>forZones</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;zone-a&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=implementation-kube-proxy>kube-proxy</h3><p>kube-proxyは、EndpointSliceコントローラーによって設定されたヒントに基づいて、ルーティング先のendpointをフィルター処理します。ほとんどの場合、これはkube-proxyが同じゾーン内のendpointにトラフィックをルーティングできることを意味します。コントローラーが別のゾーンからendpointを割り当てて、ゾーン間でendpointがより均等に分散されるようにする場合があります。これにより、一部のトラフィックが他のゾーンにルーティングされます。</p><h2 id=セーフガード>セーフガード</h2><p>各ノードのKubernetesコントロールプレーンとkube-proxyは、Topology Aware Hintを使用する前に、いくつかのセーフガードルールを適用します。これらがチェックアウトされない場合、kube-proxyは、ゾーンに関係なく、クラスター内のどこからでもendpointを選択します。</p><ol><li><p><strong>endpointの数が不十分です:</strong> クラスター内のゾーンよりもendpointが少ない場合、コントローラーはヒントを割り当てません。</p></li><li><p><strong>バランスの取れた割り当てを実現できません:</strong> 場合によっては、ゾーン間でendpointのバランスの取れた割り当てを実現できないことがあります。たとえば、ゾーンaがゾーンbの2倍の大きさであるが、endpointが2つしかない場合、ゾーンaに割り当てられたendpointはゾーンbの2倍のトラフィックを受信する可能性があります。この「予想される過負荷」値が各ゾーンの許容しきい値を下回ることができない場合、コントローラーはヒントを割り当てません。重要なことに、これはリアルタイムのフィードバックに基づいていません。それでも、個々のendpointが過負荷になる可能性があります。</p></li><li><p><strong>1つ以上のノードの情報が不十分です:</strong> ノードに<code>topology.kubernetes.io/zone</code>ラベルがないか、割り当て可能なCPUの値を報告していない場合、コントロールプレーンはtopology-aware endpoint hintsを設定しないため、kube-proxyはendpointをゾーンでフィルタリングしません。</p></li><li><p><strong>1つ以上のendpointにゾーンヒントが存在しません:</strong> これが発生すると、kube-proxyはTopology Aware Hintから、またはTopology Aware Hintへの移行が進行中であると見なします。この状態のサービスに対してendpointをフィルタリングすることは危険であるため、kube-proxyはすべてのendpointを使用するようにフォールバックします。</p></li><li><p><strong>ゾーンはヒントで表されません:</strong> kube-proxyが、実行中のゾーンをターゲットとするヒントを持つendpointを1つも見つけることができない場合、すべてのゾーンのendpointを使用することになります。これは既存のクラスターに新しいゾーンを追加するときに発生する可能性が最も高くなります。</p></li></ol><h2 id=制約事項>制約事項</h2><ul><li><p>Serviceで<code>externalTrafficPolicy</code>または<code>internalTrafficPolicy</code>が<code>Local</code>に設定されている場合、Topology Aware Hintは使用されません。同じServiceではなく、異なるServiceの同じクラスターで両方の機能を使用することができます。</p></li><li><p>このアプローチは、ゾーンのサブセットから発信されるトラフィックの割合が高いサービスではうまく機能しません。代わりに、これは着信トラフィックが各ゾーンのノードの容量にほぼ比例することを前提としています。</p></li><li><p>EndpointSliceコントローラーは、各ゾーンの比率を計算するときに、準備ができていないノードを無視します。ノードの大部分の準備ができていない場合、これは意図しない結果をもたらす可能性があります。</p></li><li><p>EndpointSliceコントローラーは、各ゾーンの比率を計算するデプロイ時に<a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Tolerations enable the scheduling of pods on nodes or node groups that have a matching taint.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=toleration>toleration</a>を考慮しません。サービスをバックアップするPodがクラスター内のノードのサブセットに制限されている場合、これは考慮されません。</p></li><li><p>これはオートスケーリングと相性が悪いかもしれません。例えば、多くのトラフィックが1つのゾーンから発信されている場合、そのゾーンに割り当てられたendpointのみがそのトラフィックを処理することになります。その結果、<a class=glossary-tooltip title='An API resource that automatically scales the number of pod replicas based on targeted CPU utilization or custom metric targets.' data-toggle=tooltip data-placement=top href=/docs/tasks/run-application/horizontal-pod-autoscale/ target=_blank aria-label='Horizontal Pod Autoscaler'>Horizontal Pod Autoscaler</a>がこのイベントを拾えなくなったり、新しく追加されたPodが別のゾーンで開始されたりする可能性があります。</p></li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>サービスとアプリケーションの接続</a>を読む。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ded1daafdcd293023ee333728007ca61>5.10 - ネットワークポリシー</h1><p>IPアドレスまたはポートのレベル(OSI参照モデルのレイヤ3または4)でトラフィックフローを制御したい場合、クラスター内の特定のアプリケーションにKubernetesのネットワークポリシーを使用することを検討してください。ネットワークポリシーはアプリケーション中心の構造であり、<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>がネットワークを介して多様な「エンティティ」(「Endpoint」や「Service」のようなKubernetesに含まれる特定の意味を持つ共通の用語との重複を避けるため、ここではエンティティという単語を使用します。)と通信する方法を指定できます。</p><p>Podが通信できるエンティティは以下の3つの識別子の組み合わせによって識別されます。</p><ol><li>許可されている他のPod(例外: Podはそれ自体へのアクセスをブロックできません)</li><li>許可されている名前空間</li><li>IPブロック(例外: PodまたはノードのIPアドレスに関係なく、Podが実行されているノードとの間のトラフィックは常に許可されます。)</li></ol><p>Podベースもしくは名前空間ベースのネットワークポリシーを定義する場合、<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=セレクター>セレクター</a>を使用してセレクターに一致するPodとの間で許可されるトラフィックを指定します。</p><p>一方でIPベースのネットワークポリシーが作成されると、IPブロック(CIDRの範囲)に基づいてポリシーが定義されます。</p><h2 id=前提条件>前提条件</h2><p>ネットワークポリシーは、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>により実装されます。ネットワークポリシーを使用するには、NetworkPolicyをサポートするネットワークソリューションを使用しなければなりません。ネットワークポリシーを実装したコントローラーを使用せずにNetworkPolicyリソースを作成した場合は、何も効果はありません。</p><h2 id=分離されたpodと分離されていないpod>分離されたPodと分離されていないPod</h2><p>デフォルトでは、Podは分離されていない状態(non-isolated)となるため、すべてのソースからのトラフィックを受信します。</p><p>Podを選択するNetworkPolicyが存在すると、Podは分離されるようになります。名前空間内に特定のPodを選択するNetworkPolicyが1つでも存在すると、そのPodはいずれかのNetworkPolicyで許可されていないすべての接続を拒否するようになります。(同じ名前空間内のPodでも、どのNetworkPolicyにも選択されなかった他のPodは、引き続きすべてのトラフィックを許可します。)</p><p>ネットワークポリシーは追加式であるため、競合することはありません。複数のポリシーがPodを選択する場合、そのPodに許可されるトラフィックは、それらのポリシーのingress/egressルールの和集合で制限されます。したがって、評価の順序はポリシーの結果には影響がありません。</p><h2 id=networkpolicy-resource>NetworkPolicyリソース</h2><p>リソースの完全な定義については、リファレンスの<a href=/docs/reference/generated/kubernetes-api/v1.25/#networkpolicy-v1-networking-k8s-io>NetworkPolicy</a>のセクションを参照してください。</p><p>以下は、NetworkPolicyの一例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-network-policy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.0</span>/16<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>except</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#666>172.17.1.0</span>/24<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>project</span>:<span style=color:#bbb> </span>myproject<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>to</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.0.0</span>/24<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>5978</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 選択したネットワークソリューションがネットワークポリシーをサポートしていない場合には、これをクラスターのAPIサーバーにPOSTしても効果はありません。</div><p><strong>必須フィールド</strong>: 他のKubernetesの設定と同様に、NetworkPolicyにも<code>apiVersion</code>、<code>kind</code>、<code>metadata</code>フィールドが必須です。設定ファイルの扱い方に関する一般的な情報については、<a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMapを使用してコンテナを構成する</a>と<a href=/ja/docs/concepts/overview/working-with-objects/object-management>オブジェクト管理</a>を参照してください。</p><p><strong>spec</strong>: NetworkPolicyの<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>spec</a>を見ると、指定した名前空間内で特定のネットワークポリシーを定義するのに必要なすべての情報が確認できます。</p><p><strong>podSelector</strong>: 各NetworkPolicyには、ポリシーを適用するPodのグループを選択する<code>podSelector</code>が含まれます。ポリシーの例では、ラベル"role=db"を持つPodを選択しています。<code>podSelector</code>を空にすると、名前空間内のすべてのPodが選択されます。</p><p><strong>policyTypes</strong>: 各NetworkPolicyには、<code>policyTypes</code>として、<code>Ingress</code>、<code>Egress</code>、またはその両方からなるリストが含まれます。<code>policyTypes</code>フィールドでは、指定したポリシーがどの種類のトラフィックに適用されるかを定めます。トラフィックの種類としては、選択したPodへの内向きのトラフィック(Ingress)、選択したPodからの外向きのトラフィック(Egress)、またはその両方を指定します。<code>policyTypes</code>を指定しなかった場合、デフォルトで常に
<code>Ingress</code>が指定され、NetworkPolicyにegressルールが1つでもあれば<code>Egress</code>も設定されます。</p><p><strong>ingress</strong>: 各NetworkPolicyには、許可する<code>ingress</code>ルールのリストを指定できます。各ルールは、<code>from</code>および<code>ports</code>セクションの両方に一致するトラフィックを許可します。ポリシーの例には1つのルールが含まれ、このルールは、3つのソースのいずれかから送信された1つのポート上のトラフィックに一致します。1つ目のソースは<code>ipBlock</code>で、2つ目のソースは<code>namespaceSelector</code>で、3つ目のソースは<code>podSelector</code>でそれぞれ定められます。</p><p><strong>egress</strong>: 各NetworkPolicyには、許可する<code>egress</code>ルールのリストを指定できます。各ルールは、<code>to</code>および<code>ports</code>セクションの両方に一致するトラフィックを許可します。ポリシーの例には1つのルールが含まれ、このルールは、1つのポート上で<code>10.0.0.0/24</code>の範囲内の任意の送信先へ送られるトラフィックに一致します。</p><p>したがって、上のNetworkPolicyの例では、次のようにネットワークポリシーを適用します。</p><ol><li>"default"名前空間内にある"role=db"のPodを、内向きと外向きのトラフィックに対して分離する(まだ分離されていない場合)</li><li>(Ingressルール) "default"名前空間内の"role=db"ラベルが付いたすべてのPodのTCPの6379番ポートへの接続のうち、次の送信元からのものを許可する<ul><li>"default"名前空間内のラベル"role=frontend"が付いたすべてのPod</li><li>ラベル"project=myproject"が付いた名前空間内のすべてのPod</li><li>172.17.0.0–172.17.0.255および172.17.2.0–172.17.255.255(言い換えれば、172.17.1.0/24の範囲を除く172.17.0.0/16)の範囲内のすべてのIPアドレス</li></ul></li><li>(Egressルール) "role=db"というラベルが付いた"default"名前空間内のすべてのPodからの、TCPの5978番ポート上でのCIDR 10.0.0.0/24への接続を許可する</li></ol><p>追加の例については、<a href=/ja/docs/tasks/administer-cluster/declare-network-policy/>ネットワークポリシーを宣言する</a>の説明を参照してください。</p><h2 id=to-と-from-のセレクターの振る舞い><code>to</code>と<code>from</code>のセレクターの振る舞い</h2><p><code>ingress</code>の<code>from</code>セクションまたは<code>egress</code>の<code>to</code>セクションに指定できるセレクターは4種類あります。</p><p><strong>podSelector</strong>: NetworkPolicyと同じ名前空間内の特定のPodを選択して、ingressの送信元またはegressの送信先を許可します。</p><p><strong>namespaceSelector</strong>: 特定の名前空間を選択して、その名前空間内のすべてのPodについて、ingressの送信元またはegressの送信先を許可します。</p><p><strong>namespaceSelector</strong> <em>および</em> <strong>podSelector</strong>: 1つの<code>to</code>または<code>from</code>エントリーで<code>namespaceSelector</code>と<code>podSelector</code>の両方を指定して、特定の名前空間内の特定のPodを選択します。正しいYAMLの構文を使うように気をつけてください。このポリシーの例を以下に示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>このポリシーには、1つの<code>from</code>要素があり、ラベル<code>user=alice</code>の付いた名前空間内にある、ラベル<code>role=client</code>の付いたPodからの接続を許可します。しかし、<em>以下の</em>ポリシーには注意が必要です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>このポリシーには、<code>from</code>配列の中に2つの要素があります。そのため、ラベル<code>role=client</code>の付いた名前空間内にあるすべてのPodからの接続、<em>または</em>、任意の名前空間内にあるラベル<code>user=alice</code>の付いたすべてのPodからの接続を許可します。</p><p>正しいルールになっているか自信がないときは、<code>kubectl describe</code>を使用すると、Kubernetesがどのようにポリシーを解釈したのかを確認できます。</p><p><strong>ipBlock</strong>: 特定のIPのCIDRの範囲を選択して、ingressの送信元またはegressの送信先を許可します。PodのIPは一時的なもので予測できないため、ここにはクラスター外のIPを指定するべきです。</p><p>クラスターのingressとegressの仕組みはパケットの送信元IPや送信先IPの書き換えを必要とすることがよくあります。その場合、NetworkPolicyの処理がIPの書き換えの前後どちらで行われるのかは定義されていません。そのため、ネットワークプラグイン、クラウドプロバイダー、<code>Service</code>の実装などの組み合わせによっては、動作が異なる可能性があります。</p><p>内向きのトラフィックの場合は、実際のオリジナルの送信元IPに基づいてパケットをフィルタリングできる可能性もあれば、NetworkPolicyが対象とする「送信元IP」が<code>LoadBalancer</code>やPodのノードなどのIPになってしまっている可能性もあることになります。</p><p>外向きのトラフィックの場合は、クラスター外のIPに書き換えられたPodから<code>Service</code>のIPへの接続は、<code>ipBlock</code>ベースのポリシーの対象になる場合とならない場合があることになります。</p><h2 id=デフォルトのポリシー>デフォルトのポリシー</h2><p>デフォルトでは、名前空間にポリシーが存在しない場合、その名前空間内のPodの内向きと外向きのトラフィックはすべて許可されます。以下の例を利用すると、その名前空間内でのデフォルトの振る舞いを変更できます。</p><h3 id=デフォルトですべての内向きのトラフィックを拒否する>デフォルトですべての内向きのトラフィックを拒否する</h3><p>すべてのPodを選択して、そのPodへのすべての内向きのトラフィックを許可しないNetworkPolicyを作成すると、その名前空間に対する「デフォルト」の分離ポリシーを作成できます。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/network-policy-default-deny-ingress.yaml download=service/networking/network-policy-default-deny-ingress.yaml><code>service/networking/network-policy-default-deny-ingress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-network-policy-default-deny-ingress-yaml")' title="Copy service/networking/network-policy-default-deny-ingress.yaml to clipboard"></img></div><div class=includecode id=service-networking-network-policy-default-deny-ingress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>このポリシーを利用すれば、他のいかなるNetworkPolicyにも選択されなかったPodでも分離されることを保証できます。このポリシーは、デフォルトの外向きの分離の振る舞いを変更しません。</p><h3 id=デフォルトで内向きのすべてのトラフィックを許可する>デフォルトで内向きのすべてのトラフィックを許可する</h3><p>(たとえPodを「分離されたもの」として扱うポリシーが追加された場合でも)名前空間内のすべてのPodへのすべてのトラフィックを許可したい場合には、その名前空間内のすべてのトラフィックを明示的に許可するポリシーを作成できます。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/network-policy-allow-all-ingress.yaml download=service/networking/network-policy-allow-all-ingress.yaml><code>service/networking/network-policy-allow-all-ingress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-network-policy-allow-all-ingress-yaml")' title="Copy service/networking/network-policy-allow-all-ingress.yaml to clipboard"></img></div><div class=includecode id=service-networking-network-policy-allow-all-ingress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h3 id=デフォルトで外向きのすべてのトラフィックを拒否する>デフォルトで外向きのすべてのトラフィックを拒否する</h3><p>すべてのPodを選択して、そのPodからのすべての外向きのトラフィックを許可しないNetworkPolicyを作成すると、その名前空間に対する「デフォルト」の外向きの分離ポリシーを作成できます。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/network-policy-default-deny-egress.yaml download=service/networking/network-policy-default-deny-egress.yaml><code>service/networking/network-policy-default-deny-egress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-network-policy-default-deny-egress-yaml")' title="Copy service/networking/network-policy-default-deny-egress.yaml to clipboard"></img></div><div class=includecode id=service-networking-network-policy-default-deny-egress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-egress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>このポリシーを利用すれば、他のいかなるNetworkPolicyにも選択されなかったPodでも、外向きのトラフィックが許可されないことを保証できます。このポリシーは、デフォルトの内向きの分離の振る舞いを変更しません。</p><h3 id=デフォルトで外向きのすべてのトラフィックを許可する>デフォルトで外向きのすべてのトラフィックを許可する</h3><p>(たとえPodを「分離されたもの」として扱うポリシーが追加された場合でも)名前空間内のすべてのPodからのすべてのトラフィックを許可したい場合には、その名前空間内のすべての外向きのトラフィックを明示的に許可するポリシーを作成できます。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/network-policy-allow-all-egress.yaml download=service/networking/network-policy-allow-all-egress.yaml><code>service/networking/network-policy-allow-all-egress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-network-policy-allow-all-egress-yaml")' title="Copy service/networking/network-policy-allow-all-egress.yaml to clipboard"></img></div><div class=includecode id=service-networking-network-policy-allow-all-egress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all-egress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h3 id=デフォルトで内向きと外向きのすべてのトラフィックを拒否する>デフォルトで内向きと外向きのすべてのトラフィックを拒否する</h3><p>名前空間内に以下のNetworkPolicyを作成すると、その名前空間で内向きと外向きのすべてのトラフィックを拒否する「デフォルト」のポリシーを作成できます。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/network-policy-default-deny-all.yaml download=service/networking/network-policy-default-deny-all.yaml><code>service/networking/network-policy-default-deny-all.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-network-policy-default-deny-all-yaml")' title="Copy service/networking/network-policy-default-deny-all.yaml to clipboard"></img></div><div class=includecode id=service-networking-network-policy-default-deny-all-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-all<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>このポリシーを利用すれば、他のいかなるNetworkPolicyにも選択されなかったPodでも、内向きと外向きのトラフィックが許可されないことを保証できます。</p><h2 id=sctpのサポート>SCTPのサポート</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p>ベータ版の機能として、これはデフォルトで有効化されます。
クラスターレベルでSCTPを無効化するために、クラスター管理者はAPIサーバーで<code>--feature-gates=SCTPSupport=false,…</code>と指定して、<code>SCTPSupport</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を無効にする必要があります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> SCTPプロトコルのネットワークポリシーをサポートする<a class=glossary-tooltip title='Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification.' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/ target=_blank aria-label=CNI>CNI</a>プラグインを使用している必要があります。</div><h2 id=ネットワークポリシーでできないこと-少なくともまだ>ネットワークポリシーでできないこと(少なくともまだ)</h2><p>Kubernetes1.20現在、ネットワークポリシーAPIに以下の機能は存在しません。
しかし、オペレーティングシステムのコンポーネント(SELinux、OpenVSwitch、IPTablesなど)、レイヤ7の技術(Ingressコントローラー、サービスメッシュ実装)、もしくはアドミッションコントローラーを使用して回避策を実装できる場合があります。
Kubernetesのネットワークセキュリティを初めて使用する場合は、ネットワークポリシーAPIを使用して以下のユーザーストーリーを(まだ)実装できないことに注意してください。これらのユーザーストーリーの一部(全てではありません)は、ネットワークポリシーAPIの将来のリリースで活発に議論されています。</p><ul><li>クラスター内トラフィックを強制的に共通ゲートウェイを通過させる(これは、サービスメッシュもしくは他のプロキシで提供するのが最適な場合があります)。</li><li>TLS関連のもの(これにはサービスメッシュまたはIngressコントローラを使用します)。</li><li>ノードの固有のポリシー(これらにはCIDR表記を使用できますが、Kubernetesのアイデンティティでノードを指定することはできません)。</li><li>名前空間またはサービスを名前で指定する(ただし、Podまたは名前空間を<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>で指定することができます。これは多くの場合で実行可能な回避策です)。</li><li>サードパーティによって実行される「ポリシー要求」の作成または管理</li><li>全ての名前空間もしくはPodに適用されるデフォルトのポリシー(これを実現できるサードパーティのKubernetesディストリビューションとプロジェクトがいくつか存在します)。</li><li>高度なポリシークエリと到達可能性ツール</li><li>単一のポリシー宣言でポートの範囲を指定する機能</li><li>ネットワークセキュリティイベント(例えばブロックされた接続や受け入れられた接続)をログに記録する機能</li><li>ポリシーを明示的に拒否する機能(現在、ネットワークポリシーのモデルはデフォルトで拒否されており、許可ルールを追加する機能のみが存在します)。</li><li>ループバックまたは内向きのホストトラフィックを拒否する機能(Podは現在localhostのアクセスやそれらが配置されているノードからのアクセスをブロックすることはできません)。</li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/tasks/administer-cluster/declare-network-policy/>ネットワークポリシーを宣言する</a>で追加の例の説明を読む。</li><li>NetworkPolicyリソースで実現できるよくあるシナリオのためのさまざまな<a href=https://github.com/ahmetb/kubernetes-network-policy-recipes>レシピ</a>を確認する。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-21f8d19c60c33914baab66224c3d46a7>5.11 - IPv4/IPv6デュアルスタック</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>IPv4/IPv6デュアルスタックを利用すると、IPv4とIPv6のアドレスの両方を<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>および<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>に指定できるようになります。</p><p>KubernetesクラスターでIPv4/IPv6デュアルスタックのネットワークを有効にすれば、クラスターはIPv4とIPv6のアドレスの両方を同時に割り当てることをサポートするようになります。</p><h2 id=サポートされている機能>サポートされている機能</h2><p>KubernetesクラスターでIPv4/IPv6デュアルスタックを有効にすると、以下の機能が提供されます。</p><ul><li>デュアルスタックのPodネットワーク(PodごとにIPv4とIPv6のアドレスが1つずつ割り当てられます)</li><li>IPv4およびIPv6が有効化されたService(各Serviceは1つのアドレスファミリーでなければなりません)</li><li>IPv4およびIPv6インターフェイスを経由したPodのクラスター外向きの(たとえば、インターネットへの)ルーティング</li></ul><h2 id=前提条件>前提条件</h2><p>IPv4/IPv6デュアルスタックのKubernetesクラスターを利用するには、以下の前提条件を満たす必要があります。</p><ul><li>Kubernetesのバージョンが1.16以降である</li><li>プロバイダーがデュアルスタックのネットワークをサポートしている(クラウドプロバイダーなどが、ルーティング可能なIPv4/IPv6ネットワークインターフェイスが搭載されたKubernetesを提供可能である)</li><li>ネットワークプラグインがデュアルスタックに対応している(KubenetやCalicoなど)</li></ul><h2 id=ipv4-ipv6デュアルスタックを有効にする>IPv4/IPv6デュアルスタックを有効にする</h2><p>IPv4/IPv6デュアルスタックを有効にするには、クラスターの関連コンポーネントで<code>IPv6DualStack</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にして、デュアルスタックのクラスターネットワークの割り当てを以下のように設定します。</p><ul><li>kube-apiserver:<ul><li><code>--feature-gates="IPv6DualStack=true"</code></li><li><code>--service-cluster-ip-range=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li></ul></li><li>kube-controller-manager:<ul><li><code>--feature-gates="IPv6DualStack=true"</code></li><li><code>--cluster-cidr=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li><li><code>--service-cluster-ip-range=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li><li><code>--node-cidr-mask-size-ipv4|--node-cidr-mask-size-ipv6</code> デフォルトのサイズは、IPv4では/24、IPv6では/64です</li></ul></li><li>kubelet:<ul><li><code>--feature-gates="IPv6DualStack=true"</code></li></ul></li><li>kube-proxy:<ul><li><code>--cluster-cidr=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li><li><code>--feature-gates="IPv6DualStack=true"</code></li></ul></li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>IPv4 CIDRの例: <code>10.244.0.0/16</code> (自分のクラスターのアドレス範囲を指定してください)</p><p>IPv6 CIDRの例: <code>fdXY:IJKL:MNOP:15::/64</code> (これはフォーマットを示すための例であり、有効なアドレスではありません。詳しくは<a href=https://tools.ietf.org/html/rfc4193>RFC 4193</a>を参照してください)</p></div><h2 id=service>Service</h2><p>クラスターでIPv4/IPv6デュアルスタックのネットワークを有効にした場合、IPv4またはIPv6のいずれかのアドレスを持つ<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を作成できます。Serviceのcluster IPのアドレスファミリーは、Service上に<code>.spec.ipFamily</code>フィールドを設定することで選択できます。このフィールドを設定できるのは、新しいServiceの作成時のみです。<code>.spec.ipFamily</code>フィールドの指定はオプションであり、<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>と<a class=glossary-tooltip title=クラスター内のServiceに対する外部からのアクセス(主にHTTP)を管理するAPIオブジェクトです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/ingress/ target=_blank aria-label=Ingress>Ingress</a>でIPv4とIPv6を有効にする予定がある場合にのみ使用するべきです。このフィールドの設定は、<a href=#egress-traffic>外向きのトラフィック</a>に対する要件には含まれません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> クラスターのデフォルトのアドレスファミリーは、kube-controller-managerに<code>--service-cluster-ip-range</code>フラグで設定した、最初のservice cluster IPの範囲のアドレスファミリーです。</div><p><code>.spec.ipFamily</code>は、次のいずれかに設定できます。</p><ul><li><code>IPv4</code>: APIサーバーは<code>ipv4</code>の<code>service-cluster-ip-range</code>の範囲からIPアドレスを割り当てます</li><li><code>IPv6</code>: APIサーバーは<code>ipv6</code>の<code>service-cluster-ip-range</code>の範囲からIPアドレスを割り当てます</li></ul><p>次のServiceのspecには<code>ipFamily</code>フィールドが含まれていません。Kubernetesは、最初に設定した<code>service-cluster-ip-range</code>の範囲からこのServiceにIPアドレス(別名「cluster IP」)を割り当てます。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-dual-stack-default-svc-yaml")' title="Copy service/networking/dual-stack-default-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-dual-stack-default-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>次のServiceのspecには<code>ipFamily</code>フィールドが含まれています。Kubernetesは、最初に設定した<code>service-cluster-ip-range</code>の範囲からこのServiceにIPv6のアドレス(別名「cluster IP」)を割り当てます。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-ipv6-svc.yaml download=service/networking/dual-stack-ipv6-svc.yaml><code>service/networking/dual-stack-ipv6-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-dual-stack-ipv6-svc-yaml")' title="Copy service/networking/dual-stack-ipv6-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-dual-stack-ipv6-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamily</span>:<span style=color:#bbb> </span>IPv6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span></span></span></code></pre></div></div></div><p>比較として次のServiceのspecを見ると、このServiceには最初に設定した<code>service-cluster-ip-range</code>の範囲からIPv4のアドレス(別名「cluster IP」)が割り当てられます。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-ipv4-svc.yaml download=service/networking/dual-stack-ipv4-svc.yaml><code>service/networking/dual-stack-ipv4-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-dual-stack-ipv4-svc-yaml")' title="Copy service/networking/dual-stack-ipv4-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-dual-stack-ipv4-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamily</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span></span></span></code></pre></div></div></div><h3 id=type-loadbalancer>Type LoadBalancer</h3><p>IPv6が有効になった外部ロードバランサーをサポートしているクラウドプロバイダーでは、<code>type</code>フィールドに<code>LoadBalancer</code>を指定し、<code>ipFamily</code>フィールドに<code>IPv6</code>を指定することにより、クラウドロードバランサーをService向けにプロビジョニングできます。</p><h2 id=egress-traffic>外向きのトラフィック</h2><p>パブリックおよび非パブリックでのルーティングが可能なIPv6アドレスのブロックを利用するためには、クラスターがベースにしている<a class=glossary-tooltip title='Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification.' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/ target=_blank aria-label=CNI>CNI</a>プロバイダーがIPv6の転送を実装している必要があります。もし非パブリックでのルーティングが可能なIPv6アドレスを使用するPodがあり、そのPodをクラスター外の送信先(例:パブリックインターネット)に到達させたい場合、外向きのトラフィックと応答の受信のためにIPマスカレードを設定する必要があります。<a href=https://github.com/kubernetes-sigs/ip-masq-agent>ip-masq-agent</a>はデュアルスタックに対応しているため、デュアルスタックのクラスター上でのIPマスカレードにはip-masq-agentが利用できます。</p><h2 id=既知の問題>既知の問題</h2><ul><li>Kubenetは、IPv4,IPv6の順番にIPを報告することを強制します(--cluster-cidr)</li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/tasks/network/validate-dual-stack>IPv4/IPv6デュアルスタックのネットワークを検証する</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f018f568c6723865753f150c3c59bdda>6 - ストレージ</h1></div><div class=td-content><h1 id=pg-27795584640a03bd2024f1fe3b3ab754>6.1 - ボリューム</h1><p>コンテナ内のディスク上のファイルは一時的なものであり、コンテナ内で実行する場合、重要なアプリケーションでいくつかの問題が発生します。1つの問題は、コンテナがクラッシュしたときにファイルが失われることです。kubeletはコンテナを再起動しますが、クリーンな状態です。
2番目の問題は、<code>Pod</code>で一緒に実行されているコンテナ間でファイルを共有するときに発生します。
Kubernetes<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>の抽象化は、これらの問題の両方を解決します。
<a href=/ja/docs/concepts/workloads/pods/>Pod</a>に精通していることをお勧めします。</p><h2 id=背景>背景</h2><p>Dockerには<a href=https://docs.docker.com/storage/>ボリューム</a>の概念がありますが、多少緩く、管理も不十分です。Dockerボリュームは、ディスク上または別のコンテナ内のディレクトリです。Dockerはボリュームドライバーを提供しますが、機能は多少制限されています。</p><p>Kubernetesは多くの種類のボリュームをサポートしています。
<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>は任意の数のボリュームタイプを同時に使用できます。
エフェメラルボリュームタイプにはPodの存続期間がありますが、永続ボリュームはPodの存続期間を超えて存在します。
Podが存在しなくなると、Kubernetesはエフェメラルボリュームを破棄します。ただしKubernetesは永続ボリュームを破棄しません。
特定のPod内のあらゆる種類のボリュームについて、データはコンテナの再起動後も保持されます。</p><p>コアとなるボリュームはディレクトリであり、Pod内のコンテナからアクセスできるデータが含まれている可能性があります。
ディレクトリがどのように作成されるか、それをバックアップするメディア、およびそのコンテンツは、使用する特定のボリュームタイプによって決まります。</p><p>ボリュームを使用するには、<code>.spec.volumes</code>でPodに提供するボリュームを指定し、<code>.spec.containers[*].volumeMounts</code>でそれらのボリュームをコンテナにマウントする場所を宣言します。
コンテナ内のプロセスは<a class=glossary-tooltip title=アプリケーションの実行に必要なソフトウェアのセットを持つ、保存されたコンテナの実体です。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-image' target=_blank aria-label=コンテナイメージ>コンテナイメージ</a>の初期コンテンツと、コンテナ内にマウントされたボリューム(定義されている場合)で構成されるファイルシステムビューを確認します。
プロセスは、コンテナイメージのコンテンツと最初に一致するルートファイルシステムを確認します。
そのファイルシステム階層内への書き込みは、もし許可されている場合、後続のファイルシステムアクセスを実行するときにそのプロセスが表示する内容に影響します。
ボリュームはイメージ内の<a href=#using-subpath>指定されたパス</a>へマウントされます。
Pod内で定義されたコンテナごとに、コンテナが使用する各ボリュームをマウントする場所を個別に指定する必要があります。</p><p>ボリュームは他のボリューム内にマウントできません(ただし、関連するメカニズムについては、<a href=#using-subpath>subPathの使用</a>を参照してください)。
またボリュームには、別のボリューム内の何かへのハードリンクを含めることはできません。</p><h2 id=volume-types>ボリュームの種類</h2><p>Kubernetesはいくつかのタイプのボリュームをサポートしています。</p><h3 id=awselasticblockstore>awsElasticBlockStore</h3><p><code>awsElasticBlockStore</code>ボリュームは、Amazon Web Services(AWS)<a href=https://aws.amazon.com/ebs/>EBSボリューム</a>をPodにマウントします。
Podを削除すると消去される<code>emptyDir</code>とは異なり、EBSボリュームのコンテンツは保持されたままボリュームはアンマウントされます。
これは、EBSボリュームにデータを事前入力でき、データをPod間で共有できることを意味します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用する前に、<code>aws ec2 create-volume</code>またはAWSAPIを使用してEBSボリュームを作成する必要があります。</div><p><code>awsElasticBlockStore</code>ボリュームを使用する場合、いくつかの制限があります。</p><ul><li>Podが実行されているノードはAWS EC2インスタンスである必要があります</li><li>これらのインスタンスは、EBSボリュームと同じリージョンおよびアベイラビリティーゾーンにある必要があります</li><li>EBSは、ボリュームをマウントする単一のEC2インスタンスのみをサポートします</li></ul><h4 id=aws-ebsボリュームの作成>AWS EBSボリュームの作成</h4><p>PodでEBSボリュームを使用する前に作成する必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>aws ec2 create-volume --availability-zone<span style=color:#666>=</span>eu-west-1a --size<span style=color:#666>=</span><span style=color:#666>10</span> --volume-type<span style=color:#666>=</span>gp2
</span></span></code></pre></div><p>ゾーンがクラスターを立ち上げたゾーンと一致していることを確認してください。サイズとEBSボリュームタイプが使用に適していることを確認してください。</p><h4 id=aws-ebs設定例>AWS EBS設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This AWS EBS volume must already exist.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>awsElasticBlockStore</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;volume id&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>EBSボリュームがパーティション化されている場合は、オプションのフィールド<code>partition: "&lt;partition number>"</code>を指定して、マウントするパーティションを指定できます。</p><h4 id=aws-ebs-csiの移行>AWS EBS CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p><code>awsElasticBlockStore</code>の<code>CSIMigration</code>機能を有効にすると、すべてのプラグイン操作が既存のツリー内プラグインから<code>ebs.csi.aws.com</code>Container Storage Interface(CSI)ドライバーにリダイレクトされます。
この機能を使用するには、<a href=https://github.com/kubernetes-sigs/aws-ebs-csi-driver>AWS EBS CSIドライバー</a>がクラスターにインストールされ、<code>CSIMigration</code>と<code>CSIMigrationAWS</code>のbeta機能が有効になっている必要があります。</p><h4 id=aws-ebs-csiの移行の完了>AWS EBS CSIの移行の完了</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code></div><p><code>awsElasticBlockStore</code>ストレージプラグインがコントローラーマネージャーとkubeletによって読み込まれないようにするには、<code>InTreePluginAWSUnregister</code>フラグを<code>true</code>に設定します。</p><h3 id=azuredisk>azureDisk</h3><p><code>azureDisk</code>ボリュームタイプは、MicrosoftAzure<a href=https://docs.microsoft.com/en-us/azure/aks/csi-storage-drivers>データディスク</a>をPodにマウントします。</p><p>詳細については、<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_disk/README.md><code>azureDisk</code>ボリュームプラグイン</a>を参照してください。</p><h4 id=azuredisk-csiの移行>azureDisk CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p><code>azureDisk</code>の<code>CSIMigration</code>機能を有効にすると、すべてのプラグイン操作が既存のツリー内プラグインから<code>disk.csi.azure.com</code>Container Storage Interface(CSI)ドライバーにリダイレクトされます。
この機能を利用するには、クラスターに<a href=https://github.com/kubernetes-sigs/azuredisk-csi-driver>Azure Disk CSI Driver</a>をインストールし、<code>CSIMigration</code>および<code>CSIMigrationAzureDisk</code>機能を有効化する必要があります。</p><h3 id=azurefile>azureFile</h3><p><code>azureFile</code>ボリュームタイプは、Microsoft Azureファイルボリューム(SMB 2.1および3.0)をPodにマウントします。</p><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_file/README.md><code>azureFile</code> volume plugin</a>を参照してください。</p><h4 id=azurefile-csiの移行>azureFile CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code></div><p><code>zureFile</code>の<code>CSIMigration</code>機能を有効にすると、既存のツリー内プラグインから<code>file.csi.azure.com</code>Container Storage Interface(CSI)Driverへすべてのプラグイン操作がリダイレクトされます。
この機能を利用するには、クラスターに<a href=https://github.com/kubernetes-sigs/azurefile-csi-driver>Azure File CSI Driver</a>をインストールし、<code>CSIMigration</code>および<code>CSIMigrationAzureFile</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効化する必要があります。</p><p>Azure File CSIドライバーは、異なるfsgroupで同じボリュームを使用することをサポートしていません。AzurefileCSIの移行が有効になっている場合、異なるfsgroupで同じボリュームを使用することはまったくサポートされません。</p><h3 id=cephfs>cephfs</h3><p><code>cephfs</code>ボリュームを使用すると、既存のCephFSボリュームをPodにマウントすることができます。
Podを取り外すと消去される<code>emptyDir</code>とは異なり、<code>cephfs</code>ボリュームは内容を保持したまま単にアンマウントされるだけです。
つまり<code>cephfs</code>ボリュームにあらかじめデータを入れておき、そのデータをPod間で共有することができます。
<code>cephfs</code>ボリュームは複数の書き込み元によって同時にマウントすることができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 事前に共有をエクスポートした状態で、自分のCephサーバーを起動しておく必要があります。</div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/volumes/cephfs/>CephFSの例</a>を参照してください。</p><h3 id=cinder>cinder</h3><div class="alert alert-info note callout" role=alert><strong>備考:</strong> KubernetesはOpenStackクラウドプロバイダーで構成する必要があります。</div><p><code>cinder</code>ボリュームタイプは、PodにOpenStackのCinderのボリュームをマウントするために使用されます。</p><h4 id=cinderボリュームの設定例>Cinderボリュームの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This OpenStack volume must already exist.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cinder</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;volume id&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=openstack-csiの移行>OpenStack CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code></div><p>Cinderの<code>CSIMigration</code>機能は、Kubernetes1.21ではデフォルトで有効になっています。
既存のツリー内プラグインからのすべてのプラグイン操作を<code>cinder.csi.openstack.org</code>Container Storage Interface(CSI) Driverへリダイレクトします。
<a href=https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/cinder-csi-plugin/using-cinder-csi-plugin.md>OpenStack Cinder CSIドライバー</a>をクラスターにインストールする必要があります。
<code>CSIMigrationOpenStack</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を<code>false</code>に設定すると、クラスターのCinder CSIマイグレーションを無効化することができます。
<code>CSIMigrationOpenStack</code>機能を無効にすると、ツリー内のCinderボリュームプラグインがCinderボリュームのストレージ管理のすべての側面に責任を持つようになります。</p><h3 id=configmap>configMap</h3><p><a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>は構成データをPodに挿入する方法を提供します。
ConfigMapに格納されたデータは、タイプ<code>configMap</code>のボリュームで参照され、Podで実行されているコンテナ化されたアプリケーションによって使用されます。</p><p>ConfigMapを参照するときは、ボリューム内のConfigMapの名前を指定します。
ConfigMapの特定のエントリに使用するパスをカスタマイズできます。
次の設定は、<code>log-config</code> ConfigMapを<code>configmap-pod</code>というPodにマウントする方法を示しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>log-config</code>ConfigMapはボリュームとしてマウントされ、その<code>log_level</code>エントリに格納されているすべてのコンテンツは、パス<code>/etc/config/log_level</code>のPodにマウントされます。
このパスはボリュームの<code>mountPath</code>と<code>log_level</code>をキーとする<code>path</code>から派生することに注意してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><ul><li><p>使用する前に<a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>を作成する必要があります。</p></li><li><p><a href=#using-subpath><code>subPath</code></a>ボリュームマウントとしてConfigMapを使用するコンテナはConfigMapの更新を受信しません。</p></li><li><p>テキストデータはUTF-8文字エンコードを使用してファイルとして公開されます。その他の文字エンコードには<code>binaryData</code>を使用します。</p></li></ul></div><h3 id=downwardapi>downwardAPI</h3><p><code>downwardAPI</code>ボリュームは、アプリケーションへのdownward APIデータを利用できるようになります。ディレクトリをマウントし、要求されたデータをプレーンテキストファイルに書き込みます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <a href=#using-subpath><code>subPath</code></a>ボリュームマウントとしてdownward APIを使用するコンテナは、downward APIの更新を受け取りません。</div><p>詳細については<a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>downward API example</a>を参照してください。</p><h3 id=emptydir>emptyDir</h3><p><code>emptyDir</code>ボリュームはPodがノードに割り当てられたときに最初に作成され、そのPodがそのノードで実行されている限り存在します。
名前が示すように<code>emptyDir</code>ボリュームは最初は空です。
Pod内のすべてのコンテナは<code>emptyDir</code>ボリューム内の同じファイルを読み書きできますが、そのボリュームは各コンテナで同じパスまたは異なるパスにマウントされることがあります。
何らかの理由でPodがノードから削除されると、<code>emptyDir</code>内のデータは永久に削除されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> コンテナがクラッシュしても、ノードからPodが削除されることは<em>ありません</em>。<code>emptyDir</code>ボリューム内のデータは、コンテナのクラッシュしても安全です。</div><p><code>emptyDir</code>のいくつかの用途は次の通りです。</p><ul><li>ディスクベースのマージソートなどのスクラッチスペース</li><li>クラッシュからの回復のための長い計算のチェックポイント</li><li>Webサーバーコンテナがデータを提供している間にコンテンツマネージャコンテナがフェッチするファイルを保持する</li></ul><p>環境に応じて、<code>emptyDir</code>ボリュームは、ディスクやSSD、ネットワークストレージなど、ノードをバックアップするあらゆる媒体に保存されます。
ただし、<code>emptyDir.medium</code>フィールドを<code>"Memory"</code>に設定すると、Kubernetesは代わりにtmpfs(RAMベースのファイルシステム)をマウントします。
tmpfsは非常に高速ですが、ディスクと違ってノードのリブート時にクリアされ、書き込んだファイルはコンテナのメモリー制限にカウントされることに注意してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>SizeMemoryBackedVolumes</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>が有効な場合、メモリーバックアップボリュームにサイズを指定することができます。
サイズが指定されていない場合、メモリーでバックアップされたボリュームは、Linuxホストのメモリーの50％のサイズになります。</div><h4 id=emptydirの設定例>emptyDirの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/cache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=fc>fc (fibre channel)</h3><p><code>fc</code>ボリュームタイプを使用すると、既存のファイバーチャネルブロックストレージボリュームをPodにマウントできます。
<code>targetWWNs</code>ボリューム構成のパラメーターを使用して、単一または複数のターゲットWorld Wide Name(WWN)を指定できます。
複数のWWNが指定されている場合、targetWWNは、それらのWWNがマルチパス接続からのものであると想定します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Kubernetesホストがアクセスできるように、事前にこれらのLUN(ボリューム)をターゲットWWNに割り当ててマスクするようにFCSANゾーニングを構成する必要があります。</div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/fibre_channel>fibre channelの例</a>を参照してください。</p><h3 id=flocker>flocker (非推奨)</h3><p><a href=https://github.com/ClusterHQ/flocker>Flocker</a>はオープンソースのクラスター化されたコンテナデータボリュームマネージャーです。
Flockerは、さまざまなストレージバックエンドに支えられたデータボリュームの管理とオーケストレーションを提供します。</p><p><code>flocker</code>ボリュームを使用すると、FlockerデータセットをPodにマウントできます。
もしデータセットがまだFlockerに存在しない場合は、まずFlocker CLIかFlocker APIを使ってデータセットを作成する必要があります。
データセットがすでに存在する場合は、FlockerによってPodがスケジュールされているノードに再アタッチされます。
これは、必要に応じてPod間でデータを共有できることを意味します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用する前に、独自のFlockerインストールを実行する必要があります。</div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/flocker>Flocker example</a>を参照してください。</p><h3 id=gcepersistentdisk>gcePersistentDisk</h3><p><code>gcePersistentDisk</code>ボリュームは、Google Compute Engine (GCE)の<a href=https://cloud.google.com/compute/docs/disks>永続ディスク</a>(PD)をPodにマウントします。
Podを取り外すと消去される<code>emptyDir</code>とは異なり、PDの内容は保持されボリュームは単にアンマウントされるだけです。これはPDにあらかじめデータを入れておくことができ、そのデータをPod間で共有できることを意味します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>gcloud</code>を使用する前に、またはGCE APIまたはUIを使用してPDを作成する必要があります。</div><p><code>gcePersistentDisk</code>を使用する場合、いくつかの制限があります。</p><ul><li>Podが実行されているノードはGCE VMである必要があります</li><li>これらのVMは、永続ディスクと同じGCEプロジェクトおよびゾーンに存在する必要があります</li></ul><p>GCE永続ディスクの機能の1つは、永続ディスクへの同時読み取り専用アクセスです。<code>gcePersistentDisk</code>ボリュームを使用すると、複数のコンシューマーが永続ディスクを読み取り専用として同時にマウントできます。
これはPDにデータセットを事前入力してから、必要な数のPodから並行して提供できることを意味します。
残念ながらPDは読み取り/書き込みモードで1つのコンシューマーのみがマウントできます。同時書き込みは許可されていません。</p><p>PDが読み取り専用であるか、レプリカ数が0または1でない限り、ReplicaSetによって制御されるPodでGCE永続ディスクを使用すると失敗します。</p><h4 id=gce-create-persistent-disk>GCE永続ディスクの作成</h4><p>PodでGCE永続ディスクを使用する前に、それを作成する必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud compute disks create --size<span style=color:#666>=</span>500GB --zone<span style=color:#666>=</span>us-central1-a my-data-disk
</span></span></code></pre></div><h4 id=gce永続ディスクの設定例>GCE永続ディスクの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This GCE PD must already exist.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=リージョン永続ディスク>リージョン永続ディスク</h4><p><a href=https://cloud.google.com/compute/docs/disks/#repds>リージョン永続ディスク</a>機能を使用すると、同じリージョン内の2つのゾーンで使用できる永続ディスクを作成できます。
この機能を使用するには、ボリュームをPersistentVolumeとしてプロビジョニングする必要があります。Podから直接ボリュームを参照することはサポートされていません。</p><h4 id=リージョンpd-persistentvolumeを手動でプロビジョニングする>リージョンPD PersistentVolumeを手動でプロビジョニングする</h4><p><a href=/docs/concepts/storage/storage-classes/#gce-pd>GCE PDのStorageClass</a>を使用して動的プロビジョニングが可能です。
SPDPersistentVolumeを作成する前に、永続ディスクを作成する必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud compute disks create --size<span style=color:#666>=</span>500GB my-data-disk
</span></span><span style=display:flex><span>  --region us-central1
</span></span><span style=display:flex><span>  --replica-zones us-central1-a,us-central1-b
</span></span></code></pre></div><h4 id=リージョン永続ディスクの設定例>リージョン永続ディスクの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>400Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># failure-domain.beta.kubernetes.io/zone should be used prior to 1.21</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- us-central1-a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- us-central1-b<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=gce-csiの移行>GCE CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p>GCE PDの<code>CSIMigration</code>機能を有効にすると、すべてのプラグイン操作が既存のツリー内プラグインから<code>pd.csi.storage.gke.io</code>Container Storage Interface (CSI) Driverにリダイレクトされるようになります。
この機能を使用するには、クラスターに<a href=https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver>GCE PD CSI Driver</a>がインストールされ、<code>CSIMigration</code>と<code>CSIMigrationGCE</code>のbeta機能が有効になっている必要があります。</p><h4 id=gce-csiの移行の完了>GCE CSIの移行の完了</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code></div><p><code>gcePersistentDisk</code>ストレージプラグインがコントローラーマネージャーとkubeletによって読み込まれないようにするには、<code>InTreePluginGCEUnregister</code>フラグを<code>true</code>に設定します。</p><h3 id=gitrepo>gitRepo(非推奨)</h3><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> <code>gitRepo</code>ボリュームタイプは非推奨です。gitリポジトリを使用してコンテナをプロビジョニングするには、Gitを使用してリポジトリのクローンを作成するInitContainerに<a href=#emptydir>EmptyDir</a>をマウントしてから、Podのコンテナに<a href=#emptydir>EmptyDir</a>をマウントします。</div><p><code>gitRepo</code>ボリュームは、ボリュームプラグインの一例です。このプラグインは空のディレクトリをマウントし、そのディレクトリにgitリポジトリをクローンしてPodで使えるようにします。</p><p><code>gitRepo</code>ボリュームの例を次に示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mypath<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gitRepo</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>repository</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;git@somewhere:me/my-git-repository.git&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>revision</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;22f1d8406d464b0c0874075539c1f2e96c253775&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=glusterfs>glusterfs</h3><p><code>glusterfs</code>ボリュームは<a href=https://www.gluster.org>Glusterfs</a>(オープンソースのネットワークファイルシステム)ボリュームをPodにマウントできるようにするものです。
Podを取り外すと消去される<code>emptyDir</code>とは異なり、<code>glusterfs</code>ボリュームの内容は保持され、単にアンマウントされるだけです。
これは、glusterfsボリュームにデータを事前に入力でき、データをPod間で共有できることを意味します。
GlusterFSは複数のライターが同時にマウントすることができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> GlusterFSを使用するためには、事前にGlusterFSのインストールを実行しておく必要があります。</div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/volumes/glusterfs>GlusterFSの例</a>を参照してください。</p><h3 id=hostpath>hostPath</h3><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong><p>HostPathボリュームには多くのセキュリティリスクがあり、可能な場合はHostPathの使用を避けることがベストプラクティスです。HostPathボリュームを使用する必要がある場合は、必要なファイルまたはディレクトリのみにスコープを設定し、読み取り専用としてマウントする必要があります。</p><p>AdmissionPolicyによって特定のディレクトリへのHostPathアクセスを制限する場合、ポリシーを有効にするために<code>volumeMounts</code>は<code>readOnly</code>マウントを使用するように要求されなければなりません。</p></div><p><code>hostPath</code>ボリュームは、ファイルまたはディレクトリをホストノードのファイルシステムからPodにマウントします。
これはほとんどのPodに必要なものではありませんが、一部のアプリケーションには強力なエスケープハッチを提供します。</p><p>たとえば<code>hostPath</code>のいくつかの使用法は次のとおりです。</p><ul><li>Dockerの内部にアクセスする必要があるコンテナを実行する場合:<code>hostPath</code>に<code>/var/lib/docker</code>を使用します。</li><li>コンテナ内でcAdvisorを実行する場合:<code>hostPath</code>に<code>/sys</code>を指定します。</li><li>Podが実行される前に、与えられた<code>hostPath</code>が存在すべきかどうか、作成すべきかどうか、そして何として存在すべきかを指定できるようにします。</li></ul><p>必須の<code>path</code>プロパティに加えて、オプションで<code>hostPath</code>ボリュームに<code>type</code>を指定することができます。</p><p>フィールド<code>type</code>でサポートされている値は次のとおりです。</p><table><thead><tr><th style=text-align:left>値</th><th style=text-align:left>ふるまい</th></tr></thead><tbody><tr><td style=text-align:left></td><td style=text-align:left>空の文字列(デフォルト)は下位互換性のためです。つまり、hostPathボリュームをマウントする前にチェックは実行されません。</td></tr><tr><td style=text-align:left><code>DirectoryOrCreate</code></td><td style=text-align:left>指定されたパスに何も存在しない場合、必要に応じて、権限を0755に設定し、Kubeletと同じグループと所有権を持つ空のディレクトリが作成されます。</td></tr><tr><td style=text-align:left><code>Directory</code></td><td style=text-align:left>指定されたパスにディレクトリが存在する必要があります。</td></tr><tr><td style=text-align:left><code>FileOrCreate</code></td><td style=text-align:left>指定されたパスに何も存在しない場合、必要に応じて、権限を0644に設定し、Kubeletと同じグループと所有権を持つ空のファイルが作成されます。</td></tr><tr><td style=text-align:left><code>File</code></td><td style=text-align:left>指定されたパスにファイルが存在する必要があります。</td></tr><tr><td style=text-align:left><code>Socket</code></td><td style=text-align:left>UNIXソケットは、指定されたパスに存在する必要があります。</td></tr><tr><td style=text-align:left><code>CharDevice</code></td><td style=text-align:left>キャラクターデバイスは、指定されたパスに存在する必要があります。</td></tr><tr><td style=text-align:left><code>BlockDevice</code></td><td style=text-align:left>ブロックデバイスは、指定されたパスに存在する必要があります。</td></tr></tbody></table><p>このタイプのボリュームを使用するときは、以下の理由のため注意してください。</p><ul><li>HostPath は、特権的なシステム認証情報(Kubeletなど)や特権的なAPI(コンテナランタイムソケットなど)を公開する可能性があり、コンテナのエスケープやクラスターの他の部分への攻撃に利用される可能性があります。</li><li>同一構成のPod(PodTemplateから作成されたものなど)は、ノード上のファイルが異なるため、ノードごとに動作が異なる場合があります。</li><li>ホスト上に作成されたファイルやディレクトリは、rootでしか書き込みができません。<a href=/docs/tasks/configure-pod-container/security-context/>特権コンテナ</a>内でrootとしてプロセスを実行するか、ホスト上のファイルのパーミッションを変更して<code>hostPath</code>ボリュームに書き込みができるようにする必要があります。</li></ul><h4 id=hostpathの設定例>hostPathの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># directory location on host</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this field is optional</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Directory<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> <code>FileOrCreate</code>モードでは、ファイルの親ディレクトリは作成されません。マウントされたファイルの親ディレクトリが存在しない場合、Podは起動に失敗します。
このモードが確実に機能するようにするには、<a href=%EF%BC%83hostpath-fileorcreate-example><code>FileOrCreate</code>構成</a>に示すように、ディレクトリとファイルを別々にマウントしてみてください。</div><h4 id=hostpath-fileorcreate-example>hostPath FileOrCreateの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver:latest<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/local/aaa<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/local/aaa/1.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Ensure the file directory is created.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/local/aaa<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/local/aaa/1.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>FileOrCreate<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=iscsi>iscsi</h3><p><code>iscsi</code>ボリュームは、既存のiSCSI(SCSI over IP)ボリュームをPodにマウントすることができます。
Podを取り外すと消去される<code>emptyDir</code>とは異なり、<code>iscsi</code>ボリュームの内容は保持され、単にアンマウントされるだけです。
つまり、iscsiボリュームにはあらかじめデータを入れておくことができ、そのデータをPod間で共有することができるのです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用する前に、ボリュームを作成したiSCSIサーバーを起動する必要があります。</div><p>iSCSIの特徴として、複数のコンシューマーから同時に読み取り専用としてマウントできることが挙げられます。
つまり、ボリュームにあらかじめデータセットを入れておき、必要な数のPodから並行してデータを提供することができます。
残念ながら、iSCSIボリュームは1つのコンシューマによってのみ読み書きモードでマウントすることができます。
同時に書き込みを行うことはできません。</p><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/volumes/iscsi>iSCSIの例</a>を参照してください。</p><h3 id=local>local</h3><p><code>local</code>ボリュームは、ディスク、パーティション、ディレクトリなど、マウントされたローカルストレージデバイスを表します。</p><p>ローカルボリュームは静的に作成されたPersistentVolumeとしてのみ使用できます。動的プロビジョニングはサポートされていません。</p><p><code>hostPath</code>ボリュームと比較して、<code>local</code>ボリュームは手動でノードにPodをスケジューリングすることなく、耐久性と移植性に優れた方法で使用することができます。
システムはPersistentVolume上のノードアフィニティーを見ることで、ボリュームのノード制約を認識します。</p><p>ただし、<code>local</code>ボリュームは、基盤となるノードの可用性に左右されるため、すべてのアプリケーションに適しているわけではありません。
ノードが異常になると、Podは<code>local</code>ボリュームにアクセスできなくなります。
このボリュームを使用しているPodは実行できません。<code>local</code>ボリュームを使用するアプリケーションは、基盤となるディスクの耐久性の特性に応じて、この可用性の低下と潜在的なデータ損失に耐えられる必要があります。</p><p>次の例では、<code>local</code>ボリュームと<code>nodeAffinity</code>を使用したPersistentVolumeを示しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>100Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>local-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>local</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/mnt/disks/ssd1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/hostname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- example-node<span style=color:#bbb>
</span></span></span></code></pre></div><p>ローカルボリュームを使用する場合は、PersistentVolume <code>nodeAffinity</code>を設定する必要があります。
KubernetesのスケジューラはPersistentVolume <code>nodeAffinity</code>を使用して、これらのPodを正しいノードにスケジューリングします。</p><p>PersistentVolume <code>volumeMode</code>を(デフォルト値の「Filesystem」ではなく)「Block」に設定して、ローカルボリュームをrawブロックデバイスとして公開できます。</p><p>ローカルボリュームを使用する場合、<code>volumeBindingMode</code>を<code>WaitForFirstConsumer</code>に設定したStorageClassを作成することをお勧めします。
詳細については、local <a href=/docs/concepts/storage/storage-classes/#local>StorageClass</a>の例を参照してください。
ボリュームバインディングを遅延させると、PersistentVolumeClaimバインディングの決定が、ノードリソース要件、ノードセレクター、Podアフィニティ、Podアンチアフィニティなど、Podが持つ可能性のある他のノード制約も含めて評価されるようになります。</p><p>ローカルボリュームのライフサイクルの管理を改善するために、外部の静的プロビジョナーを個別に実行できます。
このプロビジョナーはまだ動的プロビジョニングをサポートしていないことに注意してください。
外部ローカルプロビジョナーの実行方法の例については、<a href=https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner>ローカルボリュームプロビジョナーユーザーガイド</a>を参照してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ボリュームのライフサイクルを管理するために外部の静的プロビジョナーが使用されていない場合、ローカルのPersistentVolumeは、ユーザーによる手動のクリーンアップと削除を必要とします。</div><h3 id=nfs>nfs</h3><p><code>nfs</code>ボリュームは、既存のNFS(Network File System)共有をPodにマウントすることを可能にします。Podを取り外すと消去される<code>emptyDir</code>とは異なり、<code>nfs</code>ボリュームのコンテンツは保存され、単にアンマウントされるだけです。
つまり、NFSボリュームにはあらかじめデータを入れておくことができ、そのデータをPod間で共有することができます。
NFSは複数のライターによって同時にマウントすることができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用する前に、共有をエクスポートしてNFSサーバーを実行する必要があります。</div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/nfs>NFSの例</a>を参照してください。</p><h3 id=persistentvolumeclaim>persistentVolumeClaim</h3><p><code>PersistentVolumeClaim</code>ボリュームは<a href=/ja/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>をPodにマウントするために使用されます。
PersistentVolumeClaimは、ユーザが特定のクラウド環境の詳細を知らなくても、耐久性のあるストレージ(GCE永続ディスクやiSCSIボリュームなど)を「要求」するための方法です。</p><p>詳細については<a href=/ja/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>を参照してください。</p><h3 id=portworxvolume>portworxVolume</h3><p><code>portworxVolume</code>は、Kubernetesとハイパーコンバージドで動作するエラスティックブロックストレージレイヤーです。
<a href=https://portworx.com/use-case/kubernetes-storage/>Portworx</a>は、サーバー内のストレージをフィンガープリントを作成し、機能に応じて階層化し、複数のサーバーにまたがって容量を集約します。
Portworxは、仮想マシンまたはベアメタルのLinuxノードでゲスト内動作します。</p><p><code>portworxVolume</code>はKubernetesを通して動的に作成することができますが、事前にプロビジョニングしてPodの中で参照することもできます。
以下は、事前にプロビジョニングされたPortworxボリュームを参照するPodの例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-portworx-volume-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This Portworx volume must already exist.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>portworxVolume</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pxvol&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;fs-type&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Podで使用する前に、<code>pxvol</code>という名前の既存のPortworxVolumeがあることを確認してください。</div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/portworx/README.md>Portworxボリューム</a>の例を参照してください。</p><h3 id=投影>投影</h3><p>投影ボリュームは、複数の既存のボリュームソースを同じディレクトリにマッピングします。
詳細については<a href=/docs/concepts/storage/projected-volumes/>投影ボリューム</a>を参照してください。</p><h3 id=quobyte>quobyte(非推奨)</h3><p><code>quobyte</code>ボリュームは、既存の<a href=https://www.quobyte.com>Quobyte</a>ボリュームをPodにマウントすることができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用する前にQuobyteをセットアップして、ボリュームを作成した状態で動作させる必要があります。</div><p>CSIは、Kubernetes内部でQuobyteボリュームを使用するための推奨プラグインです。
QuobyteのGitHubプロジェクトには、CSIを使用してQuobyteをデプロイするための<a href=https://github.com/quobyte/quobyte-csi#quobyte-csi>手順</a>と例があります</p><h3 id=rbd>rbd</h3><p><code>rbd</code>ボリュームは<a href=https://docs.ceph.com/en/latest/rbd/>Rados Block Device</a>(RBD)ボリュームをPodにマウントすることを可能にします。
Podを取り外すと消去される<code>emptyDir</code>とは異なり、<code>rbd</code>ボリュームの内容は保存され、ボリュームはアンマウントされます。つまり、RBDボリュームにはあらかじめデータを入れておくことができ、そのデータをPod間で共有することができるのです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> RBDを使用する前に、Cephのインストールが実行されている必要があります。</div><p>RBDの特徴として、複数のコンシューマーから同時に読み取り専用としてマウントできることが挙げられます。
つまり、ボリュームにあらかじめデータセットを入れておき、必要な数のPodから並行して提供することができるのです。
残念ながら、RBDボリュームは1つのコンシューマーによってのみ読み書きモードでマウントすることができます。
同時に書き込みを行うことはできません。</p><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/volumes/rbd>RBDの例</a>を参照してください。</p><h4 id=rbd-csi-migration>RBD CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code></div><p><code>RBD</code>の<code>CSIMigration</code>機能を有効にすると、既存のツリー内プラグインから<code>rbd.csi.ceph.com</code><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>ドライバーにすべてのプラグイン操作がリダイレクトされます。
この機能を使用するには、クラスターに<a href=https://github.com/ceph/ceph-csi>Ceph CSIドライバー</a>をインストールし、<code>CSIMigration</code>および<code>csiMigrationRBD</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にしておく必要があります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>ストレージを管理するKubernetesクラスターオペレーターとして、RBD CSIドライバーへの移行を試みる前に完了する必要のある前提条件は次のとおりです。</p><ul><li>Ceph CSIドライバー(<code>rbd.csi.ceph.com</code>)v3.5.0以降をKubernetesクラスターにインストールする必要があります。</li><li>CSIドライバーの動作に必要なパラメーターとして<code>clusterID</code>フィールドがありますが、ツリー内StorageClassには<code>monitors</code>フィールドがあるため、Kubernetesストレージ管理者はCSI config mapでモニターハッシュ(例：<code>#echo -n '&lt;monitors_string>' | md5sum</code>)に基づいたclusterIDを作成し、モニターをこのclusterID設定の下に保持しなければなりません。</li><li>また、ツリー内Storageclassの<code>adminId</code>の値が<code>admin</code>と異なる場合、ツリー内Storageclassに記載されている<code>adminSecretName</code>に<code>adminId</code>パラメーター値のbase64値をパッチしなければなりませんが、それ以外はスキップすることが可能です。</li></ul></div><h3 id=secret>secret</h3><p><code>secret</code>ボリュームは、パスワードなどの機密情報をPodに渡すために使用します。
Kubernetes APIにsecretを格納し、Kubernetesに直接結合することなくPodが使用するファイルとしてマウントすることができます。
<code>secret</code>ボリュームはtmpfs(RAM-backed filesystem)によってバックアップされるため、不揮発性ストレージに書き込まれることはありません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用する前にKubernetes APIでSecretを作成する必要があります。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <a href=#using-subpath><code>SubPath</code></a>ボリュームマウントとしてSecretを使用しているコンテナは、Secretの更新を受け取りません。</div><p>詳細については<a href=/ja/docs/concepts/configuration/secret/>Secretの設定</a>を参照してください。</p><h3 id=storageos>storageOS(非推奨)</h3><p><code>storageos</code>ボリュームを使用すると、既存の<a href=https://www.storageos.com>StorageOS</a>ボリュームをPodにマウントできます。</p><p>StorageOSは、Kubernetes環境内でコンテナとして実行され、Kubernetesクラスター内の任意のノードからローカルストレージまたは接続されたストレージにアクセスできるようにします。
データを複製してノードの障害から保護することができます。シンプロビジョニングと圧縮により使用率を向上させ、コストを削減できます。</p><p>根本的にStorageOSは、コンテナにブロックストレージを提供しファイルシステムからアクセスできるようにします。</p><p>StorageOS Containerは64ビットLinuxを必要とし、追加の依存関係はありません。
無償の開発者ライセンスが利用可能です。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> StorageOSボリュームにアクセスする、またはプールにストレージ容量を提供する各ノードでStorageOSコンテナを実行する必要があります。
インストール手順については、<a href=https://docs.storageos.com>StorageOSドキュメント</a>を参照してください。</div><p>次の例は、StorageOSを使用したPodの設定です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-storageos-redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>kubernetes/redis:v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MASTER<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/redis-master-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageos</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The `redis-vol01` volume must already exist within StorageOS in the `default` namespace.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>redis-vol01<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>StorageOS、動的プロビジョニング、およびPersistentVolumeClaimの詳細については、<a href=https://github.com/kubernetes/examples/blob/master/volumes/storageos>StorageOSの例</a>を参照してください。</p><h3 id=vspherevolume>vsphereVolume</h3><div class="alert alert-info note callout" role=alert><strong>備考:</strong> KubernetesvSphereクラウドプロバイダーを設定する必要があります。クラウドプロバイダーの設定については、<a href=https://vmware.github.io/vsphere-storage-for-kubernetes/documentation/>vSphere入門ガイド</a>を参照してください。</div><p><code>vsphereVolume</code>は、vSphereVMDKボリュームをPodにマウントするために使用されます。
ボリュームの内容は、マウント解除されたときに保持されます。VMFSとVSANの両方のデータストアをサポートします。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Podで使用する前に、次のいずれかの方法を使用してvSphereVMDKボリュームを作成する必要があります。</div><h4 id=creating-vmdk-volume>Creating a VMDK volume</h4><p>次のいずれかの方法を選択して、VMDKを作成します。</p><ul class="nav nav-tabs" id=tabs-volumes role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabs-volumes-0 role=tab aria-controls=tabs-volumes-0 aria-selected=true>vmkfstoolsを使用して作成する</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tabs-volumes-1 role=tab aria-controls=tabs-volumes-1>vmware-vdiskmanagerを使用して作成する</a></li></ul><div class=tab-content id=tabs-volumes><div id=tabs-volumes-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabs-volumes-0><p><p>最初にESXにSSHで接続し、次に以下のコマンドを使用してVMDKを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>vmkfstools -c 2G /vmfs/volumes/DatastoreName/volumes/myDisk.vmdk
</span></span></code></pre></div></div><div id=tabs-volumes-1 class=tab-pane role=tabpanel aria-labelledby=tabs-volumes-1><p><p>次のコマンドを使用してVMDKを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>vmware-vdiskmanager -c -t <span style=color:#666>0</span> -s 40GB -a lsilogic myDisk.vmdk
</span></span></code></pre></div></div></div><h4 id=vsphere-vmdk-configuration>vSphere VMDKの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-vmdk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-vmdk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This VMDK volume must already exist.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>vsphereVolume</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumePath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;[DatastoreName] volumes/myDisk&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere>vSphereボリューム</a>の例を参照してください。</p><h4 id=vsphere-csi-migration>vSphere CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p><code>vsphereVolume</code>の<code>CSIMigration</code>機能を有効にすると、既存のツリー内プラグインから<code>csi.vsphere.vmware.com</code><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>ドライバーにすべてのプラグイン操作がリダイレクトされます。
この機能を使用するには、クラスターに<a href=https://github.com/kubernetes-sigs/vsphere-csi-driver>vSphere CSIドライバー</a>がインストールされ、<code>CSIMigration</code>および<code>CSIMigrationvSphere</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>が有効になっていなければなりません。</p><p>また、vSphere vCenter/ESXiのバージョンが7.0u1以上、HWのバージョンがVM version 15以上であることが条件です。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>組み込みの<code>vsphereVolume</code>プラグインの次のStorageClassパラメーターは、vSphere CSIドライバーでサポートされていません。</p><ul><li><code>diskformat</code></li><li><code>hostfailurestotolerate</code></li><li><code>forceprovisioning</code></li><li><code>cachereservation</code></li><li><code>diskstripes</code></li><li><code>objectspacereservation</code></li><li><code>iopslimit</code></li></ul><p>これらのパラメーターを使用して作成された既存のボリュームはvSphere CSIドライバーに移行されますが、vSphere CSIドライバーで作成された新しいボリュームはこれらのパラメーターに従わないことに注意してください。</p></div><h4 id=vsphere-csi-migration-complete>vSphere CSIの移行の完了</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p><code>vsphereVolume</code>プラグインがコントローラーマネージャーとkubeletによって読み込まれないようにするには、<code>InTreePluginvSphereUnregister</code>機能フラグを<code>true</code>に設定する必要があります。すべてのワーカーノードに<code>csi.vsphere.vmware.com</code><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>ドライバーをインストールする必要があります。</p><h4 id=portworx-csiの移行>Portworx CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code></div><p>Portworxの<code>CSIMigration</code>機能が追加されましたが、Kubernetes 1.23ではAlpha状態であるため、デフォルトで無効になっています。
すべてのプラグイン操作を既存のツリー内プラグインから<code>pxd.portworx.com</code>Container Storage Interface(CSI)ドライバーにリダイレクトします。
<a href=https://docs.portworx.com/portworx-install-with-kubernetes/storage-operations/csi/>Portworx CSIドライバー</a>をクラスターにインストールする必要があります。
この機能を有効にするには、kube-controller-managerとkubeletで<code>CSIMigrationPortworx=true</code>を設定します。</p><h2 id=using-subpath>subPathの使用</h2><p>1つのPodで複数の用途に使用するために1つのボリュームを共有すると便利な場合があります。
<code>volumeMounts.subPath</code>プロパティは、ルートではなく、参照されるボリューム内のサブパスを指定します。</p><p>次の例は、単一の共有ボリュームを使用してLAMPスタック(Linux Apache MySQL PHP)でPodを構成する方法を示しています。
このサンプルの<code>subPath</code>構成は、プロダクションでの使用にはお勧めしません。</p><p>PHPアプリケーションのコードとアセットはボリュームの<code>html</code>フォルダーにマップされ、MySQLデータベースはボリュームの<code>mysql</code>フォルダーに保存されます。例えば:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-lamp-site<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;rootpasswd&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>php:7.0-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/www/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>my-lamp-site-data<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=using-subpath-expanded-environment>拡張された環境変数でのsubPathの使用</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code></div><p><code>subPathExpr</code>フィールドを使用して、downwart API環境変数から<code>subPath</code>ディレクトリ名を作成します。
<code>subPath</code>プロパティと<code>subPathExpr</code>プロパティは相互に排他的です。</p><p>この例では、<code>Pod</code>が<code>subPathExpr</code>を使用して、<code>hostPath</code>ボリューム<code>/var/log/pods</code>内に<code>pod1</code>というディレクトリを作成します。
<code>hostPath</code>ボリュームは<code>downwardAPI</code>から<code>Pod</code>名を受け取ります。
ホストディレクトリ<code>/var/log/pods/pod1</code>は、コンテナ内の<code>/logs</code>にマウントされます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>POD_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while [ true ]; do echo &#39;Hello&#39;; sleep 10; done | tee -a /logs/hello.txt&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/logs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># The variable expansion uses round brackets (not curly brackets).</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>subPathExpr</span>:<span style=color:#bbb> </span>$(POD_NAME)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/pods<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=リソース>リソース</h2><p><code>emptyDir</code>ボリュームの記憶媒体(DiskやSSDなど)は、kubeletのルートディレクトリ(通常は<code>/var/lib/kubelet</code>)を保持するファイルシステムの媒体によって決定されます。
<code>emptyDir</code>または<code>hostPath</code>ボリュームが消費する容量に制限はなく、コンテナ間またはPod間で隔離されることもありません。</p><p>リソース仕様を使用したスペースの要求については、<a href=/ja/docs/concepts/configuration/manage-resources-containers/>リソースの管理方法</a>を参照してください。</p><h2 id=ツリー外のボリュームプラグイン>ツリー外のボリュームプラグイン</h2><p>ツリー外ボリュームプラグインには<a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label='Container Storage Interface'>Container Storage Interface</a>(CSI)、およびFlexVolume(非推奨)があります。
これらのプラグインによりストレージベンダーは、プラグインのソースコードをKubernetesリポジトリに追加することなく、カスタムストレージプラグインを作成することができます。</p><p>以前は、すべてのボリュームプラグインが「ツリー内」にありました。
「ツリー内」のプラグインは、Kubernetesのコアバイナリとともにビルド、リンク、コンパイルされ、出荷されていました。
つまり、Kubernetesに新しいストレージシステム(ボリュームプラグイン)を追加するには、Kubernetesのコアコードリポジトリにコードをチェックインする必要があったのです。</p><p>CSIとFlexVolumeはどちらも、ボリュームプラグインをKubernetesコードベースとは独立して開発し、拡張機能としてKubernetesクラスターにデプロイ(インストール)することを可能にします。</p><p>ツリー外のボリュームプラグインの作成を検討しているストレージベンダーについては、<a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md>ボリュームプラグインのFAQ</a>を参照してください。</p><h3 id=csi>csi</h3><p><a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>Container Storage Interface</a>(CSI)は、コンテナオーケストレーションシステム(Kubernetesなど)の標準インターフェイスを定義して、任意のストレージシステムをコンテナワークロードに公開します。</p><p>詳細については<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md>CSI design proposal</a>を参照してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> CSI仕様バージョン0.2および0.3のサポートは、Kubernetes v1.13で非推奨になり、将来のリリースで削除される予定です。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> CSIドライバーは、すべてのKubernetesリリース間で互換性があるとは限りません。各Kubernetesリリースでサポートされているデプロイ手順と互換性マトリックスについては、特定のCSIドライバーのドキュメントを確認してください。</div><p>CSI互換のボリュームドライバーがKubernetesクラスター上に展開されると、ユーザーは<code>csi</code>ボリュームタイプを使用して、CSIドライバーによって公開されたボリュームをアタッチまたはマウントすることができます。</p><p><code>csi</code>ボリュームはPodで3つの異なる方法によって使用することができます。</p><ul><li><a href=#persistentvolumeclaim>PersistentVolumeClaim</a>の参照を通して</li><li><a href=/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes>一般的なエフェメラルボリューム</a>(alpha機能)で</li><li>ドライバーがそれをサポートしている場合は、<a href=/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>CSIエフェメラルボリューム</a>(beta機能)を使って</li></ul><p>ストレージ管理者は、CSI永続ボリュームを構成するために次のフィールドを使用できます。</p><ul><li><code>driver</code>: 使用するボリュームドライバーの名前を指定する文字列。
この値は<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#getplugininfo>CSI spec</a>で定義されたCSIドライバーが<code>GetPluginInfoResponse</code>で返す値に対応していなければなりません。
これはKubernetesが呼び出すCSIドライバーを識別するために使用され、CSIドライバーコンポーネントがCSIドライバーに属するPVオブジェクトを識別するために使用されます。</li><li><code>volumeHandle</code>: ボリュームを一意に識別する文字列。この値は、<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>CSI spec</a>で定義されたCSIドライバーが<code>CreateVolumeResponse</code>の<code>volume.id</code>フィールドに返す値に対応していなければなりません。この値はCSIボリュームドライバーのすべての呼び出しで、ボリュームを参照する際に<code>volume_id</code>として渡されます。</li><li><code>readOnly</code>: ボリュームを読み取り専用として「ControllerPublished」(添付)するかどうかを示すオプションのブール値。デフォルトはfalseです。この値は、<code>ControllerPublishVolumeRequest</code>の<code>readonly</code>フィールドを介してCSIドライバーに渡されます。</li><li><code>fsType</code>: PVの<code>VolumeMode</code>が<code>Filesystem</code>の場合、このフィールドを使用して、ボリュームのマウントに使用する必要のあるファイルシステムを指定できます。ボリュームがフォーマットされておらず、フォーマットがサポートされている場合、この値はボリュームのフォーマットに使用されます。この値は、<code>ControllerPublishVolumeRequest</code>、<code>NodeStageVolumeRequest</code>、および<code>NodePublishVolumeRequest</code>の<code>VolumeCapability</code>フィールドを介してCSIドライバーに渡されます。</li><li><code>volumeAttributes</code>: ボリュームの静的プロパティを指定する、文字列から文字列へのマップ。このマップは、<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>CSI spec</a>で定義されているように、CSIドライバーが<code>CreateVolumeResponse</code>の<code>volume.attributes</code>フィールドで返すマップと一致しなければなりません。このマップは<code>ControllerPublishVolumeRequest</code>,<code>NodeStageVolumeRequest</code>,<code>NodePublishVolumeRequest</code>の<code>volume_context</code>フィールドを介してCSIドライバーに渡されます。</li><li><code>controllerPublishSecretRef</code>: CSI<code>ControllerPublishVolume</code>および<code>ControllerUnpublishVolume</code>呼び出しを完了するためにCSIドライバーに渡す機密情報を含むsecretオブジェクトへの参照。このフィールドはオプションで、secretが必要ない場合は空にすることができます。secretに複数のsecretが含まれている場合は、すべてのsecretが渡されます。</li><li><code>nodeStageSecretRef</code>: CSI<code>NodeStageVolume</code>呼び出しを完了するために、CSIドライバーに渡す機密情報を含むsecretオブジェクトへの参照。このフィールドはオプションで、secretが必要ない場合は空にすることができます。secretに複数のsecretが含まれている場合、すべてのsecretが渡されます。</li><li><code>nodePublishSecretRef</code>: CSI<code>NodePublishVolume</code>呼び出しを完了するために、CSIドライバーに渡す機密情報を含むsecretオブジェクトへの参照。このフィールドはオプションで、secretが必要ない場合は空にすることができます。secretオブジェクトが複数のsecretを含んでいる場合、すべてのsecretが渡されます。</li></ul><h4 id=csi-rawブロックボリュームのサポート>CSI rawブロックボリュームのサポート</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>外部のCSIドライバーを使用するベンダーは、Kubernetesワークロードでrawブロックボリュームサポートを実装できます。</p><p>CSI固有の変更を行うことなく、通常どおり、<a href=/docs/concepts/storage/persistent-volumes/#raw-block-volume-support>rawブロックボリュームをサポートするPersistentVolume/PersistentVolumeClaim</a>を設定できます。</p><h4 id=csiエフェメラルボリューム>CSIエフェメラルボリューム</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code></div><p>Pod仕様内でCSIボリュームを直接構成できます。この方法で指定されたボリュームは一時的なものであり、Podを再起動しても持続しません。詳細については<a href=/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>エフェメラルボリューム</a>を参照してください。</p><p>CSIドライバーの開発方法の詳細については<a href=https://kubernetes-csi.github.io/docs/>kubernetes-csiドキュメント</a>を参照してください。</p><h4 id=ツリー内プラグインからcsiドライバーへの移行>ツリー内プラグインからCSIドライバーへの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p><code>CSIMigration</code>機能を有効にすると、既存のツリー内プラグインに対する操作が、対応するCSIプラグイン(インストールおよび構成されていることが期待されます)に転送されます。
その結果、オペレーターは、ツリー内プラグインに取って代わるCSIドライバーに移行するときに、既存のストレージクラス、PersistentVolume、またはPersistentVolumeClaim(ツリー内プラグインを参照)の構成を変更する必要がありません。</p><p>サポートされている操作と機能には、プロビジョニング/削除、アタッチ/デタッチ、マウント/アンマウント、およびボリュームのサイズ変更が含まれます。</p><p><code>CSIMigration</code>をサポートし、対応するCSIドライバーが実装されているツリー内プラグインは、<a href=%EF%BC%83volume-types>ボリュームのタイプ</a>にリストされています。</p><h3 id=flexvolume>flexVolume</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [deprecated]</code></div><p>FlexVolumeは、ストレージドライバーとのインターフェースにexecベースのモデルを使用するツリー外プラグインインターフェースです。FlexVolumeドライバーのバイナリは、各ノード、場合によってはコントロールプレーンノードにも、あらかじめ定義されたボリュームプラグインパスにインストールする必要があります。</p><p>Podは<code>flexVolume</code>ツリー内ボリュームプラグインを通してFlexVolumeドライバーと対話します。</p><p>詳細については<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md#readme>FlexVolumeのREADME</a>を参照してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>FlexVolumeは非推奨です。ツリー外のCSIドライバーを使用することは、外部ストレージをKubernetesと統合するための推奨される方法です。</p><p>FlexVolumeドライバーのメンテナーは、CSIドライバーを実装し、FlexVolumeドライバーのユーザーをCSIに移行するのを支援する必要があります。FlexVolumeのユーザーは、同等のCSIドライバーを使用するようにワークロードを移動する必要があります。</p></div><h2 id=マウントの伝播>マウントの伝播</h2><p>マウントの伝播により、コンテナによってマウントされたボリュームを、同じPod内の他のコンテナ、または同じノード上の他のPodに共有できます。</p><p>ボリュームのマウント伝播は、<code>Container.volumeMounts</code>の<code>mountPropagation</code>フィールドによって制御されます。その値は次のとおりです。</p><ul><li><p><code>None</code> - このボリュームマウントは、ホストによってこのボリュームまたはそのサブディレクトリにマウントされる後続のマウントを受け取りません。同様に、コンテナによって作成されたマウントはホストに表示されません。これがデフォルトのモードです。</p><p>このモードは<a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>Linuxカーネルドキュメント</a>で説明されている<code>private</code>マウント伝播と同じです。</p></li><li><p><code>HostToContainer</code> - このボリュームマウントは、このボリュームまたはそのサブディレクトリのいずれかにマウントされる後続のすべてのマウントを受け取ります。</p><p>つまりホストがボリュームマウント内に何かをマウントすると、コンテナはそこにマウントされていることを確認します。</p><p>同様に同じボリュームに対して<code>Bidirectional</code>マウント伝搬を持つPodが何かをマウントすると、<code>HostToContainer</code>マウント伝搬を持つコンテナはそれを見ることができます。</p><p>このモードは<a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>Linuxカーネルドキュメント</a>で説明されている<code>rslave</code>マウント伝播と同じです。</p></li><li><p><code>Bidirectional</code> - このボリュームマウントは、<code>HostToContainer</code>マウントと同じように動作します。さらに、コンテナによって作成されたすべてのボリュームマウントは、ホストと、同じボリュームを使用するすべてのPodのすべてのコンテナに伝播されます。</p><p>このモードの一般的な使用例は、FlexVolumeまたはCSIドライバーを備えたPod、または<code>hostPath</code>ボリュームを使用してホストに何かをマウントする必要があるPodです。</p><p>このモードは<a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>Linuxカーネルドキュメント</a>で説明されている<code>rshared</code>マウント伝播と同じです。</p><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> <code>Bidirectional</code>マウント伝搬は危険です。ホストオペレーティングシステムにダメージを与える可能性があるため、特権的なコンテナでのみ許可されています。
Linuxカーネルの動作に精通していることが強く推奨されます。
また、Pod内のコンテナによって作成されたボリュームマウントは、終了時にコンテナによって破棄(アンマウント)される必要があります。</div></li></ul><h3 id=構成>構成</h3><p>一部のデプロイメント(CoreOS、RedHat/Centos、Ubuntu)でマウント伝播が正しく機能する前に、以下に示すように、Dockerでマウント共有を正しく構成する必要があります。</p><p>Dockerの<code>systemd</code>サービスファイルを編集します。以下のように<code>MountFlags</code>を設定します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>MountFlags</span><span style=color:#666>=</span>shared
</span></span></code></pre></div><p>または、<code>MountFlags=slave</code>があれば削除してください。その後、Dockerデーモンを再起動します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart docker
</span></span></code></pre></div><h2 id=次の項目>次の項目</h2><p><a href=/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>永続ボリュームを使用してWordPressとMySQLをデプロイする例</a>に従ってください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ffd12528a12882b282e1bd19e29f9e75>6.2 - 永続ボリューム</h1><p>このドキュメントではKubernetesの <em>PersistentVolume</em> について説明します。<a href=/docs/concepts/storage/volumes/>ボリューム</a>を一読することをおすすめします。</p><h2 id=概要>概要</h2><p>ストレージを管理することはインスタンスを管理することとは全くの別物です。PersistentVolumeサブシステムは、ストレージが何から提供されているか、どのように消費されているかをユーザーと管理者から抽象化するAPIを提供します。これを実現するためのPersistentVolumeとPersistentVolumeClaimという2つの新しいAPIリソースを紹介します。</p><p><em>PersistentVolume</em> (PV)は<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>を使って管理者もしくは動的にプロビジョニングされるクラスターのストレージの一部です。これはNodeと同じようにクラスターリソースの一部です。PVはVolumeのようなボリュームプラグインですが、PVを使う個別のPodとは独立したライフサイクルを持っています。このAPIオブジェクトはNFS、iSCSIやクラウドプロバイダー固有のストレージシステムの実装の詳細を捕捉します。</p><p><em>PersistentVolumeClaim</em> (PVC)はユーザーによって要求されるストレージです。これはPodと似ています。PodはNodeリソースを消費し、PVCはPVリソースを消費します。Podは特定レベルのCPUとメモリーリソースを要求することができます。クレームは特定のサイズやアクセスモード(例えば、ReadWriteOnce、ReadOnlyMany、ReadWriteManyにマウントできます。詳しくは<a href=#access-modes>アクセスモード</a>を参照してください)を要求することができます。</p><p>PersistentVolumeClaimはユーザーに抽象化されたストレージリソースの消費を許可する一方、ユーザーは色々な問題に対処するためにパフォーマンスといった様々なプロパティを持ったPersistentVolumeを必要とすることは一般的なことです。クラスター管理者はユーザーに様々なボリュームがどのように実装されているかを表に出すことなく、サイズやアクセスモードだけではない色々な点で異なった、様々なPersistentVolumeを提供できる必要があります。これらのニーズに応えるために <em>StorageClass</em> リソースがあります。</p><p><a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/>実例を含む詳細なチュートリアル</a>を参照して下さい。</p><h2 id=ボリュームと要求のライフサイクル>ボリュームと要求のライフサイクル</h2><p>PVはクラスター内のリソースです。PVCはこれらのリソースの要求でありまた、クレームのチェックとしても機能します。PVとPVCの相互作用はこのライフサイクルに従います。</p><h3 id=プロビジョニング>プロビジョニング</h3><p>PVは静的か動的どちらかでプロビジョニングされます。</p><h4 id=静的>静的</h4><p>クラスター管理者は多数のPVを作成します。それらはクラスターのユーザーが使うことのできる実際のストレージの詳細を保持します。それらはKubernetes APIに存在し、利用できます。</p><h4 id=動的>動的</h4><p>ユーザーのPersistentVolumeClaimが管理者の作成したいずれの静的PVにも一致しない場合、クラスターはPVC用にボリュームを動的にプロビジョニングしようとする場合があります。
このプロビジョニングはStorageClassに基づいています。PVCは<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>の要求が必要であり、管理者は動的プロビジョニングを行うためにストレージクラスの作成・設定が必要です。ストレージクラスを""にしたストレージ要求は、自身の動的プロビジョニングを事実上無効にします。</p><p>ストレージクラスに基づいたストレージの動的プロビジョニングを有効化するには、クラスター管理者が<code>DefaultStorageClass</code><a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass>アドミッションコントローラー</a>をAPIサーバーで有効化する必要があります。
これは例えば、<code>DefaultStorageClass</code>がAPIサーバーコンポーネントの<code>--enable-admission-plugins</code>フラグのコンマ区切りの順序付きリストの中に含まれているかで確認できます。
APIサーバーのコマンドラインフラグの詳細については<a href=/docs/admin/kube-apiserver/>kube-apiserver</a>のドキュメントを参照してください。</p><h3 id=バインディング>バインディング</h3><p>ユーザは、特定のサイズのストレージとアクセスモードを指定した上でPersistentVolumeClaimを作成します（動的プロビジョニングの場合は、すでに作られています）。マスター内のコントロールループは、新しく作られるPVCをウォッチして、それにマッチするPVが見つかったときに、それらを紐付けます。PVが新しいPVC用に動的プロビジョニングされた場合、コントロールループは常にPVをそのPVCに紐付けます。そうでない場合、ユーザーは常に少なくとも要求したサイズ以上のボリュームを取得しますが、ボリュームは要求されたサイズを超えている可能性があります。一度紐付けされると、どのように紐付けられたかに関係なくPersistentVolumeClaimの紐付けは排他的（決められた特定のPVとしか結びつかない状態）になります。PVCからPVへの紐付けは、PersistentVolumeとPersistentVolumeClaim間の双方向の紐付けであるClaimRefを使用した1対1のマッピングになっています。</p><p>一致するボリュームが存在しない場合、クレームはいつまでも紐付けされないままになります。一致するボリュームが利用可能になると、クレームがバインドされます。たとえば、50GiのPVがいくつもプロビジョニングされているクラスターだとしても、100Giを要求するPVCとは一致しません。100GiのPVがクラスターに追加されると、PVCを紐付けできます。</p><h3 id=使用>使用</h3><p>Podは要求をボリュームとして使用します。クラスターは、要求を検査して紐付けられたボリュームを見つけそのボリュームをPodにマウントします。複数のアクセスモードをサポートするボリュームの場合、ユーザーはPodのボリュームとしてクレームを使う時にどのモードを希望するかを指定します。</p><p>ユーザーがクレームを取得し、そのクレームがバインドされると、バインドされたPVは必要な限りそのユーザーに属します。ユーザーはPodをスケジュールし、Podのvolumesブロックに<code>persistentVolumeClaim</code>を含めることで、バインドされたクレームのPVにアクセスします。
<a href=#claims-as-volumes>書式の詳細はこちらを確認して下さい。</a></p><h3 id=使用中のストレージオブジェクトの保護>使用中のストレージオブジェクトの保護</h3><p>使用中のストレージオブジェクト保護機能の目的はデータ損失を防ぐために、Podによって実際に使用されている永続ボリュームクレーム(PVC)と、PVCにバインドされている永続ボリューム(PV)がシステムから削除されないようにすることです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> PVCを使用しているPodオブジェクトが存在する場合、PVCはPodによって実際に使用されています。</div><p>ユーザーがPodによって実際に使用されているPVCを削除しても、そのPVCはすぐには削除されません。PVCの削除は、PVCがPodで使用されなくなるまで延期されます。また、管理者がPVCに紐付けられているPVを削除しても、PVはすぐには削除されません。PVがPVCに紐付けられなくなるまで、PVの削除は延期されます。</p><p>PVCの削除が保護されているかは、PVCのステータスが<code>Terminating</code>になっていて、そして<code>Finalizers</code>のリストに<code>kubernetes.io/pvc-protection</code>が含まれているかで確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pvc hostpath
</span></span><span style=display:flex><span>Name:          hostpath
</span></span><span style=display:flex><span>Namespace:     default
</span></span><span style=display:flex><span>StorageClass:  example-hostpath
</span></span><span style=display:flex><span>Status:        Terminating
</span></span><span style=display:flex><span>Volume:
</span></span><span style=display:flex><span>Labels:        &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:   volume.beta.kubernetes.io/storage-class<span style=color:#666>=</span>example-hostpath
</span></span><span style=display:flex><span>               volume.beta.kubernetes.io/storage-provisioner<span style=color:#666>=</span>example.com/hostpath
</span></span><span style=display:flex><span>Finalizers:    <span style=color:#666>[</span>kubernetes.io/pvc-protection<span style=color:#666>]</span>
</span></span></code></pre></div><p>同様にPVの削除が保護されているかは、PVのステータスが<code>Terminating</code>になっていて、そして<code>Finalizers</code>のリストに<code>kubernetes.io/pv-protection</code>が含まれているかで確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pv task-pv-volume
</span></span><span style=display:flex><span>Name:            task-pv-volume
</span></span><span style=display:flex><span>Labels:          <span style=color:#b8860b>type</span><span style=color:#666>=</span><span style=color:#a2f>local</span>
</span></span><span style=display:flex><span>Annotations:     &lt;none&gt;
</span></span><span style=display:flex><span>Finalizers:      <span style=color:#666>[</span>kubernetes.io/pv-protection<span style=color:#666>]</span>
</span></span><span style=display:flex><span>StorageClass:    standard
</span></span><span style=display:flex><span>Status:          Terminating
</span></span><span style=display:flex><span>Claim:
</span></span><span style=display:flex><span>Reclaim Policy:  Delete
</span></span><span style=display:flex><span>Access Modes:    RWO
</span></span><span style=display:flex><span>Capacity:        1Gi
</span></span><span style=display:flex><span>Message:
</span></span><span style=display:flex><span>Source:
</span></span><span style=display:flex><span>    Type:          HostPath <span style=color:#666>(</span>bare host directory volume<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    Path:          /tmp/data
</span></span><span style=display:flex><span>    HostPathType:
</span></span><span style=display:flex><span>Events:            &lt;none&gt;
</span></span></code></pre></div><h3 id=再クレーム>再クレーム</h3><p>ユーザーは、ボリュームの使用が完了したら、リソースの再クレームを許可するAPIからPVCオブジェクトを削除できます。PersistentVolumeの再クレームポリシーはそのクレームが解放された後のボリュームの処理をクラスターに指示します。現在、ボリュームは保持、リサイクル、または削除できます。</p><h4 id=保持>保持</h4><p><code>Retain</code>という再クレームポリシーはリソースを手動で再クレームすることができます。PersistentVolumeClaimが削除される時、PersistentVolumeは依然として存在はしますが、ボリュームは解放済みです。ただし、以前のクレームデータはボリューム上に残っているため、別のクレームにはまだ使用できません。管理者は次の手順でボリュームを手動で再クレームできます。</p><ol><li>PersistentVolumeを削除します。PVが削除された後も、外部インフラストラクチャー(AWS EBS、GCE PD、Azure Disk、Cinderボリュームなど)に関連付けられたストレージアセットは依然として残ります。</li><li>ストレージアセットに関連するのデータを手動で適切にクリーンアップします。</li><li>関連するストレージアセットを手動で削除するか、同じストレージアセットを再利用したい場合、新しいストレージアセット定義と共にPersistentVolumeを作成します。</li></ol><h4 id=delete>削除</h4><p><code>Delete</code>再クレームポリシーをサポートするボリュームプラグインの場合、削除するとPersistentVolumeオブジェクトがKubernetesから削除されるだけでなく、AWS EBS、GCE PD、Azure Disk、Cinderボリュームなどの外部インフラストラクチャーの関連ストレージアセットも削除されます。動的にプロビジョニングされたボリュームは、<a href=#reclaim-policy>StorageClassの再クレームポリシー</a>を継承します。これはデフォルトで削除です。管理者は、ユーザーの需要に応じてStorageClassを構成する必要があります。そうでない場合、PVは作成後に編集またはパッチを適用する必要があります。<a href=/docs/tasks/administer-cluster/change-pv-reclaim-policy/>PersistentVolumeの再クレームポリシーの変更</a>を参照してください。</p><h4 id=リサイクル>リサイクル</h4><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> <code>Recycle</code>再クレームポリシーは非推奨になりました。代わりに、動的プロビジョニングを使用することをおすすめします。</div><p>基盤となるボリュームプラグインでサポートされている場合、<code>Recycle</code>再クレームポリシーはボリュームに対して基本的な削除(<code>rm -rf /thevolume/*</code>)を実行し、新しいクレームに対して再び利用できるようにします。</p><p>管理者は<a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>reference</a>で説明するように、Kubernetesコントローラーマネージャーのコマンドライン引数を使用して、カスタムリサイクラーPodテンプレートを構成できます。カスタムリサイクラーPodテンプレートには、次の例に示すように、<code>volumes</code>仕様が含まれている必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/any/path/it/will/be/replaced<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/busybox&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;test -e /scrub &amp;&amp; rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  &amp;&amp; test -z \&#34;$(ls -A /scrub)\&#34; || exit 1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/scrub<span style=color:#bbb>
</span></span></span></code></pre></div><p>ただし、カスタムリサイクラーPodテンプレートの<code>volumes</code>パート内で指定された特定のパスは、リサイクルされるボリュームの特定のパスに置き換えられます。</p><h3 id=永続ボリュームの予約>永続ボリュームの予約</h3><p>コントロールプレーンは、永続ボリュームクレームをクラスター内の一致する永続ボリュームに<a href=#%E3%83%90%E3%82%A4%E3%83%B3%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0>バインド</a>できます。
ただし、永続ボリュームクレームを特定の永続ボリュームにバインドする場合、それらを事前にバインドする必要があります。</p><p>永続ボリュームクレームで永続ボリュームを指定することにより、その特定の永続ボリュームと永続ボリュームクレームの間のバインディングを宣言します。
永続ボリュームが存在し、その<code>claimRef</code>フィールドで永続ボリュームクレームを予約していない場合に永続ボリュームと永続ボリュームクレームがバインドされます。</p><p>バインディングは、ノードアフィニティを含むいくつかのボリュームの一致基準に関係なく発生します。
コントロールプレーンは、依然として<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>、アクセスモード、および要求されたストレージサイズが有効であることをチェックします。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 空の文字列を明示的に指定する必要があります。そうしないとデフォルトのストレージクラスが設定されてしまいます。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>この方法は、永続ボリュームへのバインド特権を保証するものではありません。
他の永続ボリュームクレームが指定した永続ボリュームを使用できる場合、最初にそのストレージボリュームを予約する必要があります。
永続ボリュームの<code>claimRef</code>フィールドに関連する永続ボリュームクレームを指定して、他の永続ボリュームクレームがその永続ボリュームにバインドできないようにしてください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>claimRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>これは、既存の永続ボリュームを再利用する場合など、<code>claimPolicy</code>が<code>Retain</code>に設定されている永続ボリュームを使用する場合に役立ちます。</p><h3 id=永続ボリュームクレームの拡大>永続ボリュームクレームの拡大</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>PersistentVolumeClaim(PVC)の拡大はデフォルトで有効です。次のボリュームの種類で拡大できます。</p><ul><li>gcePersistentDisk</li><li>awsElasticBlockStore</li><li>Cinder</li><li>glusterfs</li><li>rbd</li><li>Azure File</li><li>Azure Disk</li><li>Portworx</li><li>FlexVolumes</li><li>CSI</li></ul><p>そのストレージクラスの<code>allowVolumeExpansion</code>フィールドがtrueとなっている場合のみ、PVCを拡大できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gluster-vol-default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://192.168.10.100:8080&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>PVCに対してさらに大きなボリュームを要求するには、PVCオブジェクトを編集してより大きなサイズを指定します。これによりPersistentVolumeを受け持つ基盤にボリュームの拡大がトリガーされます。クレームを満たすため新しくPersistentVolumeが作成されることはありません。代わりに既存のボリュームがリサイズされます。</p><h4 id=csiボリュームの拡張>CSIボリュームの拡張</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [stable]</code></div><p>CSIボリュームの拡張のサポートはデフォルトで有効になっていますが、ボリューム拡張をサポートするにはボリューム拡張を利用できるCSIドライバーも必要です。詳細については、それぞれのCSIドライバーのドキュメントを参照してください。</p><h4 id=ファイルシステムを含むボリュームのリサイズ>ファイルシステムを含むボリュームのリサイズ</h4><p>ファイルシステムがXFS、Ext3、またはExt4の場合にのみ、ファイルシステムを含むボリュームのサイズを変更できます。</p><p>ボリュームにファイルシステムが含まれる場合、新しいPodが<code>PersistentVolumeClaim</code>でReadWriteモードを使用している場合にのみ、ファイルシステムのサイズが変更されます。ファイルシステムの拡張は、Podの起動時、もしくはPodの実行時で基盤となるファイルシステムがオンラインの拡張をサポートする場合に行われます。</p><p>FlexVolumesでは、ドライバの<code>RequiresFSResize</code>機能がtrueに設定されている場合、サイズを変更できます。
FlexVolumeは、Podの再起動時にサイズ変更できます。</p><h4 id=使用中の永続ボリュームクレームのリサイズ>使用中の永続ボリュームクレームのリサイズ</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用中のPVCの拡張は、Kubernetes 1.15以降のベータ版と、1.11以降のアルファ版として利用可能です。<code>ExpandInUsePersistentVolume</code>機能を有効化する必要があります。これはベータ機能のため多くのクラスターで自動的に行われます。詳細については、<a href=/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>のドキュメントを参照してください。</div><p>この場合、既存のPVCを使用しているPodまたはDeploymentを削除して再作成する必要はありません。使用中のPVCは、ファイルシステムが拡張されるとすぐにPodで自動的に使用可能になります。この機能は、PodまたはDeploymentで使用されていないPVCには影響しません。拡張を完了する前に、PVCを使用するPodを作成する必要があります。</p><p>他のボリュームタイプと同様、FlexVolumeボリュームは、Podによって使用されている最中でも拡張できます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> FlexVolumeのリサイズは、基盤となるドライバーがリサイズをサポートしている場合のみ可能です。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> EBSの拡張は時間がかかる操作です。また変更は、ボリュームごとに6時間に1回までというクォータもあります。</div><h4 id=ボリューム拡張時の障害からの復旧>ボリューム拡張時の障害からの復旧</h4><p>基盤ストレージの拡張に失敗した際には、クラスターの管理者はPersistent Volume Claim (PVC)の状態を手動で復旧し、リサイズ要求をキャンセルします。それをしない限り、リサイズ要求は管理者の介入なしにコントローラーによって継続的に再試行されます。</p><ol><li>PersistentVolumeClaim(PVC)にバインドされているPersistentVolume(PV)を<code>Retain</code>再クレームポリシーとしてマークします。</li><li>PVCを削除します。PVは<code>Retain</code>再クレームポリシーを持っているため、PVCを再び作成したときにいかなるデータも失うことはありません。</li><li><code>claimRef</code>エントリーをPVスペックから削除して、新しいPVCがそれにバインドできるようにします。これによりPVは<code>Available</code>になります。</li><li>PVより小さいサイズでPVCを再作成し、PVCの<code>volumeName</code>フィールドをPVの名前に設定します。これにより新しいPVCを既存のPVにバインドします。</li><li>PVを再クレームポリシーを復旧することを忘れずに行ってください。</li></ol><h2 id=永続ボリュームの種類>永続ボリュームの種類</h2><p>PersistentVolumeの種類はプラグインとして実装されます。Kubernetesは現在次のプラグインに対応しています。</p><ul><li><a href=/docs/concepts/storage/volumes/#awselasticblockstore><code>awsElasticBlockStore</code></a> - AWS Elastic Block Store (EBS)</li><li><a href=/docs/concepts/storage/volumes/#azuredisk><code>azureDisk</code></a> - Azure Disk</li><li><a href=/docs/concepts/storage/volumes/#azurefile><code>azureFile</code></a> - Azure File</li><li><a href=/docs/concepts/storage/volumes/#cephfs><code>cephfs</code></a> - CephFS volume</li><li><a href=/docs/concepts/storage/volumes/#cinder><code>cinder</code></a> - Cinder (OpenStack block storage)
(<strong>非推奨</strong>)</li><li><a href=/docs/concepts/storage/volumes/#csi><code>csi</code></a> - Container Storage Interface (CSI)</li><li><a href=/docs/concepts/storage/volumes/#fc><code>fc</code></a> - Fibre Channel (FC) storage</li><li><a href=/docs/concepts/storage/volumes/#flexVolume><code>flexVolume</code></a> - FlexVolume</li><li><a href=/docs/concepts/storage/volumes/#flocker><code>flocker</code></a> - Flocker storage</li><li><a href=/docs/concepts/storage/volumes/#gcepersistentdisk><code>gcePersistentDisk</code></a> - GCE Persistent Disk</li><li><a href=/docs/concepts/storage/volumes/#glusterfs><code>glusterfs</code></a> - Glusterfs volume</li><li><a href=/docs/concepts/storage/volumes/#hostpath><code>hostPath</code></a> - HostPath volume
(テスト用の単一ノードのみ。マルチノードクラスターでは動作しません。代わりに<code>local</code>ボリュームを利用することを検討してください。)</li><li><a href=/docs/concepts/storage/volumes/#iscsi><code>iscsi</code></a> - iSCSI (SCSI over IP) storage</li><li><a href=/docs/concepts/storage/volumes/#local><code>local</code></a> - ノードにマウントされたローカルストレージデバイス</li><li><a href=/docs/concepts/storage/volumes/#nfs><code>nfs</code></a> - Network File System (NFS) storage</li><li><code>photonPersistentDisk</code> - Photon controller persistent disk
(対応するクラウドプロバイダーが削除されたため、このボリュームタイプは機能しなくなりました。)</li><li><a href=/docs/concepts/storage/volumes/#portworxvolume><code>portworxVolume</code></a> - Portworx volume</li><li><a href=/docs/concepts/storage/volumes/#quobyte><code>quobyte</code></a> - Quobyte volume</li><li><a href=/docs/concepts/storage/volumes/#rbd><code>rbd</code></a> - Rados Block Device (RBD) volume</li><li><a href=/docs/concepts/storage/volumes/#scaleio><code>scaleIO</code></a> - ScaleIO volume
(<strong>非推奨</strong>)</li><li><a href=/docs/concepts/storage/volumes/#storageos><code>storageos</code></a> - StorageOS volume</li><li><a href=/docs/concepts/storage/volumes/#vspherevolume><code>vsphereVolume</code></a> - vSphere VMDK volume</li></ul><h2 id=永続ボリューム>永続ボリューム</h2><p>各PVには、仕様とボリュームのステータスが含まれているspecとstatusが含まれています。
PersistentVolumeオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv0003<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Recycle<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- hard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- nfsvers=4.1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nfs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/tmp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.2</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> クラスター内でPersistentVolumeを使用するには、ボリュームタイプに関連するヘルパープログラムが必要な場合があります。
この例では、PersistentVolumeはNFSタイプで、NFSファイルシステムのマウントをサポートするためにヘルパープログラム<code>/sbin/mount.nfs</code>が必要になります。</div><h3 id=容量>容量</h3><p>通常、PVには特定のストレージ容量があります。これはPVの<code>capacity</code>属性を使用して設定されます。容量によって期待される単位を理解するためには、Kubernetesの<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>リソースモデル</a>を参照してください。</p><p>現在、設定または要求できるのはストレージサイズのみです。将来の属性には、IOPS、スループットなどが含まれます。</p><h3 id=ボリュームモード>ボリュームモード</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>KubernetesはPersistentVolumesの2つの<code>volumeModes</code>をサポートしています: <code>Filesystem</code>と<code>Block</code>です。<br><code>volumeMode</code>は任意のAPIパラメーターです。<br><code>Filesystem</code>は<code>volumeMode</code>パラメーターが省略されたときに使用されるデフォルトのモードです。</p><p><code>volumeMode: Filesystem</code>であるボリュームはPodに<em>マウント</em>されてディレクトリになります。 ボリュームがブロックデバイスでデバイスが空の時、Kubernetesは初めてそれにマウントされる前にデバイスのファイルシステムを作成します。</p><p><code>volumeMode</code>の値を<code>Block</code>に設定してボリュームをRAWブロックデバイスとして使用します。<br>このようなボリュームは、ファイルシステムを持たないブロックデバイスとしてPodに提示されます。<br>このモードは、Podとボリュームの間のファイルシステムレイヤなしにボリュームにアクセスする可能な限り最速の方法をPodに提供するのに便利です。一方で、Pod上で実行しているアプリケーションはRAWブロックデバイスの扱い方を知っていなければなりません。<br>Pod内で<code>volumeMode: Block</code>とともにボリュームを使用する例としては、<a href=#raw-block-volume-support>Raw Block Volume Support</a>を参照してください。</p><h3 id=アクセスモード>アクセスモード</h3><p>PersistentVolumeは、リソースプロバイダーがサポートする方法でホストにマウントできます。次の表に示すように、プロバイダーにはさまざまな機能があり、各PVのアクセスモードは、その特定のボリュームでサポートされる特定のモードに設定されます。たとえば、NFSは複数の読み取り/書き込みクライアントをサポートできますが、特定のNFSのPVはサーバー上で読み取り専用としてエクスポートされる場合があります。各PVは、その特定のPVの機能を記述する独自のアクセスモードのセットを取得します。</p><p>アクセスモードは次の通りです。</p><dl><dt><code>ReadWriteOnce</code></dt><dd>ボリュームは単一のNodeで読み取り/書き込みとしてマウントできます</dd><dt><code>ReadOnlyMany</code></dt><dd>ボリュームは多数のNodeで読み取り専用としてマウントできます</dd><dt><code>ReadWriteMany</code></dt><dd>ボリュームは多数のNodeで読み取り/書き込みとしてマウントできます</dd><dt><code>ReadWriteOncePod</code></dt><dd>ボリュームは、単一のPodで読み取り/書き込みとしてマウントできます。クラスタ全体で1つのPodのみがそのPVCの読み取りまたは書き込みを行えるようにする場合は、ReadWriteOncePodアクセスモードを使用します。これは、CSIボリュームとKubernetesバージョン1.22以降でのみサポートされます。</dd></dl><p>これについてはブログ<a href=/blog/2021/09/13/read-write-once-pod-access-mode-alpha/>Introducing Single Pod Access Mode for PersistentVolumes</a>に詳細が記載されています。</p><p>CLIではアクセスモードは次のように略されます。</p><ul><li>RWO - ReadWriteOnce</li><li>ROX - ReadOnlyMany</li><li>RWX - ReadWriteMany</li></ul><blockquote><p><strong>Important!</strong> ボリュームは、多数のモードをサポートしていても、一度に1つのアクセスモードでしかマウントできません。たとえば、GCEPersistentDiskは、単一NodeではReadWriteOnceとして、または多数のNodeではReadOnlyManyとしてマウントできますが、同時にマウントすることはできません。</p></blockquote><table><thead><tr><th style=text-align:left>ボリュームプラグイン</th><th style=text-align:center>ReadWriteOnce</th><th style=text-align:center>ReadOnlyMany</th><th style=text-align:center>ReadWriteMany</th></tr></thead><tbody><tr><td style=text-align:left>AWSElasticBlockStore</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>AzureFile</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>AzureDisk</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>CephFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>Cinder</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>CSI</td><td style=text-align:center>ドライバーに依存</td><td style=text-align:center>ドライバーに依存</td><td style=text-align:center>ドライバーに依存</td></tr><tr><td style=text-align:left>FC</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>FlexVolume</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>ドライバーに依存</td></tr><tr><td style=text-align:left>Flocker</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>GCEPersistentDisk</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Glusterfs</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>HostPath</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>iSCSI</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Quobyte</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>NFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>RBD</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>VsphereVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>- (Podが連結されている場合のみ)</td></tr><tr><td style=text-align:left>PortworxVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>ScaleIO</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>StorageOS</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr></tbody></table><h3 id=class>Class</h3><p>PVはクラスを持つことができます。これは<code>storageClassName</code>属性を<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>の名前に設定することで指定されます。特定のクラスのPVは、そのクラスを要求するPVCにのみバインドできます。<code>storageClassName</code>にクラスがないPVは、特定のクラスを要求しないPVCにのみバインドできます。</p><p>以前<code>volume.beta.kubernetes.io/storage-class</code>アノテーションは、<code>storageClassName</code>属性の代わりに使用されていました。このアノテーションはまだ機能しています。ただし、将来のKubernetesリリースでは完全に非推奨です。</p><h3 id=reclaim-policy>再クレームポリシー</h3><p>現在の再クレームポリシーは次のとおりです。</p><ul><li>保持 -- 手動再クレーム</li><li>リサイクル -- 基本的な削除 (<code>rm -rf /thevolume/*</code>)</li><li>削除 -- AWS EBS、GCE PD、Azure Disk、もしくはOpenStack Cinderボリュームに関連するストレージアセットを削除</li></ul><p>現在、NFSとHostPathのみがリサイクルをサポートしています。AWS EBS、GCE PD、Azure Disk、およびCinder volumeは削除をサポートしています。</p><h3 id=マウントオプション>マウントオプション</h3><p>Kubernetes管理者は永続ボリュームがNodeにマウントされるときの追加マウントオプションを指定できます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> すべての永続ボリュームタイプがすべてのマウントオプションをサポートするわけではありません。</div><p>次のボリュームタイプがマウントオプションをサポートしています。</p><ul><li>AWSElasticBlockStore</li><li>AzureDisk</li><li>AzureFile</li><li>CephFS</li><li>Cinder (OpenStackブロックストレージ)</li><li>GCEPersistentDisk</li><li>Glusterfs</li><li>NFS</li><li>Quobyte Volumes</li><li>RBD (Ceph Block Device)</li><li>StorageOS</li><li>VsphereVolume</li><li>iSCSI</li></ul><p>マウントオプションは検証されないため、不正だった場合マウントは失敗します。</p><p>以前<code>volume.beta.kubernetes.io/mount-options</code>アノテーションが<code>mountOptions</code>属性の代わりに使われていました。このアノテーションはまだ機能しています。ただし、将来のKubernetesリリースでは完全に非推奨です。</p><h3 id=ノードアフィニティ>ノードアフィニティ</h3><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ほとんどのボリュームタイプはこのフィールドを設定する必要がありません。<a href=/docs/concepts/storage/volumes/#awselasticblockstore>AWS EBS</a>、<a href=/docs/concepts/storage/volumes/#gcepersistentdisk>GCE PD</a>、もしくは<a href=/docs/concepts/storage/volumes/#azuredisk>Azure Disk</a>ボリュームブロックタイプの場合自動的に設定されます。<a href=/docs/concepts/storage/volumes/#local>local</a>ボリュームは明示的に設定する必要があります。</div><p>PVは<a href=/docs/reference/generated/kubernetes-api/v1.25/#volumenodeaffinity-v1-core>ノードアフィニティ</a>を指定して、このボリュームにアクセスできるNodeを制限する制約を定義できます。PVを使用するPodは、ノードアフィニティによって選択されたNodeにのみスケジュールされます。</p><h3 id=フェーズ>フェーズ</h3><p>ボリュームは次のフェーズのいずれかです。</p><ul><li>利用可能 -- まだクレームに紐付いていない自由なリソース</li><li>バウンド -- クレームに紐付いている</li><li>リリース済み -- クレームが削除されたが、クラスターにまだクレームされている</li><li>失敗 -- 自動再クレームに失敗</li></ul><p>CLIにはPVに紐付いているPVCの名前が表示されます。</p><h2 id=persistentvolumeclaims>永続ボリューム要求</h2><p>各PVCにはspecとステータスが含まれます。これは、仕様とクレームのステータスです。</p><p>PersistentVolumeClaimオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>8Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>release</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- {<span style=color:green;font-weight:700>key: environment, operator: In, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=アクセスモード-1>アクセスモード</h3><p>クレームは、特定のアクセスモードでストレージを要求するときにボリュームと同じ規則を使用します。</p><h3 id=ボリュームモード-1>ボリュームモード</h3><p>クレームは、ボリュームと同じ規則を使用して、ファイルシステムまたはブロックデバイスとしてのボリュームの消費を示します。</p><h3 id=リソース>リソース</h3><p>Podと同様に、クレームは特定の量のリソースを要求できます。この場合、要求はストレージ用です。同じ<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>リソースモデル</a>がボリュームとクレームの両方に適用されます。</p><h3 id=セレクター>セレクター</h3><p>クレームでは、<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルセレクター</a>を指定して、ボリュームセットをさらにフィルター処理できます。ラベルがセレクターに一致するボリュームのみがクレームにバインドできます。セレクターは2つのフィールドで構成できます。</p><ul><li><code>matchLabels</code> - ボリュームはこの値のラベルが必要です</li><li><code>matchExpressions</code> - キー、値のリスト、およびキーと値を関連付ける演算子を指定することによって作成された要件のリスト。有効な演算子は、In、NotIn、ExistsおよびDoesNotExistです。</li></ul><p><code>matchLabels</code>と<code>matchExpressions</code>の両方からのすべての要件はANDで結合されます。一致するには、すべてが一致する必要があります。</p><h3 id=クラス>クラス</h3><p>クレームは、<code>storageClassName</code>属性を使用して<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>の名前を指定することにより、特定のクラスを要求できます。PVCにバインドできるのは、PVCと同じ<code>storageClassName</code>を持つ、要求されたクラスのPVのみです。</p><p>PVCは必ずしもクラスをリクエストする必要はありません。<code>storageClassName</code>が<code>""</code>に設定されているPVCは、クラスのないPVを要求していると常に解釈されるため、クラスのないPVにのみバインドできます（アノテーションがないか、<code>""</code>に等しい1つのセット）。<code>storageClassName</code>のないPVCはまったく同じではなく、<a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code>アドミッションプラグイン</a>がオンになっているかどうかによって、クラスターによって異なる方法で処理されます。</p><ul><li>アドミッションプラグインがオンになっている場合、管理者はデフォルトの<code>StorageClass</code>を指定できます。<code>storageClassName</code>を持たないすべてのPVCは、そのデフォルトのPVにのみバインドできます。デフォルトの<code>StorageClass</code>の指定は、<code>StorageClass</code>オブジェクトで<code>storageclass.kubernetes.io/is-default-class</code>アノテーションを<code>true</code>に設定することにより行われます。管理者がデフォルトを指定しない場合、クラスターは、アドミッションプラグインがオフになっているかのようにPVC作成をレスポンスします。複数のデフォルトが指定されている場合、アドミッションプラグインはすべてのPVCの作成を禁止します。</li><li>アドミッションプラグインがオフになっている場合、デフォルトの<code>StorageClass</code>の概念はありません。<code>storageClassName</code>を持たないすべてのPVCは、クラスを持たないPVにのみバインドできます。この場合、storageClassNameを持たないPVCは、<code>storageClassName</code>が<code>""</code>に設定されているPVCと同じように扱われます。</li></ul><p>インストール方法によっては、インストール時にアドオンマネージャーによってデフォルトのストレージクラスがKubernetesクラスターにデプロイされる場合があります。</p><p>PVCが<code>selector</code>を要求することに加えて<code>StorageClass</code>を指定する場合、要件はANDで一緒に結合されます。要求されたクラスのPVと要求されたラベルのみがPVCにバインドされます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 現在、<code>selector</code>が空ではないPVCは、PVを動的にプロビジョニングできません。</div><p>以前は、<code>storageClassName</code>属性の代わりに<code>volume.beta.kubernetes.io/storage-class</code>アノテーションが使用されていました。このアノテーションはまだ機能しています。ただし、今後のKubernetesリリースではサポートされません。</p><h2 id=ボリュームとしてのクレーム>ボリュームとしてのクレーム</h2><p>Podは、クレームをボリュームとして使用してストレージにアクセスします。クレームは、そのクレームを使用するPodと同じ名前空間に存在する必要があります。クラスターは、Podの名前空間でクレームを見つけ、それを使用してクレームを支援しているPersistentVolumeを取得します。次に、ボリュームがホストとPodにマウントされます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfrontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/www/html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=名前空間に関する注意>名前空間に関する注意</h3><p>PersistentVolumeバインドは排他的であり、PersistentVolumeClaimは名前空間オブジェクトであるため、"多"モード(<code>ROX</code>、<code>RWX</code>)でクレームをマウントすることは1つの名前空間内でのみ可能です。</p><h2 id=rawブロックボリュームのサポート>Rawブロックボリュームのサポート</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>次のボリュームプラグインは、必要に応じて動的プロビジョニングを含むrawブロックボリュームをサポートします。</p><ul><li>AWSElasticBlockStore</li><li>AzureDisk</li><li>CSI</li><li>FC (Fibre Channel)</li><li>GCEPersistentDisk</li><li>iSCSI</li><li>Local volume</li><li>OpenStack Cinder</li><li>RBD (Ceph Block Device)</li><li>VsphereVolume</li></ul><h3 id=persistent-volume-using-a-raw-block-volume>Rawブロックボリュームを使用した永続ボリューム</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fc</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetWWNs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;50060e801049cfd1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lun</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=rawブロックボリュームを要求する永続ボリュームクレーム>Rawブロックボリュームを要求する永続ボリュームクレーム</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=コンテナにrawブロックデバイスパスを追加するpod仕様>コンテナにRawブロックデバイスパスを追加するPod仕様</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-block-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fc-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:26<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;tail -f /dev/null&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeDevices</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>devicePath</span>:<span style=color:#bbb> </span>/dev/xvda<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Podにrawブロックデバイスを追加する場合は、マウントパスの代わりにコンテナーでデバイスパスを指定します。</div><h3 id=ブロックボリュームのバインド>ブロックボリュームのバインド</h3><p>ユーザーがPersistentVolumeClaim specの<code>volumeMode</code>フィールドを使用してrawブロックボリュームの要求を示す場合、バインディングルールは、このモードをspecの一部として考慮しなかった以前のリリースとわずかに異なります。表にリストされているのは、ユーザーと管理者がrawブロックデバイスを要求するために指定可能な組み合わせの表です。この表は、ボリュームがバインドされるか、組み合わせが与えられないかを示します。静的にプロビジョニングされたボリュームのボリュームバインディングマトリクスはこちらです。</p><table><thead><tr><th>PVボリュームモード</th><th style=text-align:center>PVCボリュームモード</th><th style=text-align:right>結果</th></tr></thead><tbody><tr><td>未定義</td><td style=text-align:center>未定義</td><td style=text-align:right>バインド</td></tr><tr><td>未定義</td><td style=text-align:center>ブロック</td><td style=text-align:right>バインドなし</td></tr><tr><td>未定義</td><td style=text-align:center>ファイルシステム</td><td style=text-align:right>バインド</td></tr><tr><td>ブロック</td><td style=text-align:center>未定義</td><td style=text-align:right>バインドなし</td></tr><tr><td>ブロック</td><td style=text-align:center>ブロック</td><td style=text-align:right>バインド</td></tr><tr><td>ブロック</td><td style=text-align:center>ファイルシステム</td><td style=text-align:right>バインドなし</td></tr><tr><td>ファイルシステム</td><td style=text-align:center>ファイルシステム</td><td style=text-align:right>バインド</td></tr><tr><td>ファイルシステム</td><td style=text-align:center>ブロック</td><td style=text-align:right>バインドなし</td></tr><tr><td>ファイルシステム</td><td style=text-align:center>未定義</td><td style=text-align:right>バインド</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>備考:</strong> アルファリリースでは、静的にプロビジョニングされたボリュームのみがサポートされます。管理者は、rawブロックデバイスを使用する場合、これらの値を考慮するように注意する必要があります。</div><h2 id=ボリュームのスナップショットとスナップショットからのボリュームの復元のサポート>ボリュームのスナップショットとスナップショットからのボリュームの復元のサポート</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p>ボリュームスナップショット機能は、CSIボリュームプラグインのみをサポートするために追加されました。詳細については、<a href=/docs/concepts/storage/volume-snapshots/>ボリュームのスナップショット</a>を参照してください。</p><p>ボリュームスナップショットのデータソースからボリュームを復元する機能を有効にするには、apiserverおよびcontroller-managerで<code>VolumeSnapshotDataSource</code>フィーチャーゲートを有効にします。</p><h3 id=create-persistent-volume-claim-from-volume-snapshot>ボリュームスナップショットから永続ボリュームクレームを作成する</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>restore-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>csi-hostpath-sc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=ボリュームの複製>ボリュームの複製</h2><p><a href=/ja/docs/concepts/storage/volume-pvc-datasource/>ボリュームの複製</a>はCSIボリュームプラグインにのみ利用可能です。</p><p>PVCデータソースからのボリューム複製機能を有効にするには、apiserverおよびcontroller-managerで<code>VolumeSnapshotDataSource</code>フィーチャーゲートを有効にします。</p><h3 id=create-persistent-volume-claim-from-an-existing-pvc>既存のPVCからの永続ボリュームクレーム作成</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloned-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>my-csi-plugin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>existing-src-pvc-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=可搬性の高い設定の作成>可搬性の高い設定の作成</h2><p>もし幅広いクラスターで実行され、永続ボリュームが必要となる構成テンプレートやサンプルを作成している場合は、次のパターンを使用することをお勧めします。</p><ul><li><p>構成にPersistentVolumeClaimオブジェクトを含める(DeploymentやConfigMapと共に)</p></li><li><p>ユーザーが設定をインスタンス化する際にPersistentVolumeを作成する権限がない場合があるため、設定にPersistentVolumeオブジェクトを含めない。</p></li><li><p>テンプレートをインスタンス化する時にストレージクラス名を指定する選択肢をユーザーに与える</p><ul><li>ユーザーがストレージクラス名を指定する場合、persistentVolumeClaim.storageClassName フィールドにその値を入力する。これにより、クラスターが管理者によって有効にされたストレージクラスを持っている場合、PVCは正しいストレージクラスと一致する。</li><li>ユーザーがストレージクラス名を指定しない場合、<code>persistentVolumeClaim.storageClassName</code>フィールドはnilのままにする。これにより、PVはユーザーにクラスターのデフォルトストレージクラスで自動的にプロビジョニングされる。多くのクラスター環境ではデフォルトのストレージクラスがインストールされているが、管理者は独自のデフォルトストレージクラスを作成することができる。</li></ul></li><li><p>ツールがPVCを監視し、しばらくしてもバインドされないことをユーザーに表示する。これはクラスターが動的ストレージをサポートしない(この場合ユーザーは対応するPVを作成するべき)、もしくはクラスターがストレージシステムを持っていない(この場合ユーザーはPVCを必要とする設定をデプロイできない)可能性があることを示す。</p><h2 id=次の項目>次の項目</h2></li></ul><ul><li><a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume>Creating a Persistent Volume</a>について学ぶ</li><li><a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolumeclaim>Creating a Persistent Volume Claim</a>について学ぶ</li><li><a href=https://git.k8s.io/design-proposals-archive/storage/persistent-storage.md>Persistent Storage design document</a>を読む</li></ul><h3 id=リファレンス>リファレンス</h3><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolume-v1-core>PersistentVolume</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumespec-v1-core>PersistentVolumeSpec</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumeclaim-v1-core>PersistentVolumeClaim</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumeclaimspec-v1-core>PersistentVolumeClaimSpec</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2db414b26d4daec3ebed19dd837830c3>6.3 - 投影ボリューム</h1><p>このドキュメントでは、Kubernetesの<em>投影ボリューム</em>について説明します。<a href=/docs/concepts/storage/volumes/>ボリューム</a>に精通していることをお勧めします。</p><h2 id=概要>概要</h2><p>ボリュームは、いくつかの既存の<code>投影</code>ボリュームソースを同じディレクトリにマップします。</p><p>現在、次のタイプのボリュームソースを投影できます。</p><ul><li><a href=/docs/concepts/storage/volumes/#secret><code>secret</code></a></li><li><a href=/docs/concepts/storage/volumes/#downwardapi><code>downwardAPI</code></a></li><li><a href=/docs/concepts/storage/volumes/#configmap><code>configMap</code></a></li><li><code>serviceAccountToken</code></li></ul><p>すべてのソースは、Podと同じnamespaceにある必要があります。詳細は<a href=https://github.com/kubernetes/design-proposals-archive/blob/main/node/all-in-one-volume.md>all-in-one volume</a>デザインドキュメントを参照してください。</p><h3 id=example-configuration-secret-downwardapi-configmap>secret、downwardAPI、およびconfigMapを使用した構成例</h3><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/storage/projected-secret-downwardapi-configmap.yaml download=pods/storage/projected-secret-downwardapi-configmap.yaml><code>pods/storage/projected-secret-downwardapi-configmap.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-secret-downwardapi-configmap-yaml")' title="Copy pods/storage/projected-secret-downwardapi-configmap.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-secret-downwardapi-configmap-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>volume-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;labels&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.labels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;cpu_limit&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-config<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h3 id=example-configuration-secrets-nondefault-permission-mode>構成例:デフォルト以外のアクセス許可モードが設定されたsecret</h3><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/storage/projected-secrets-nondefault-permission-mode.yaml download=pods/storage/projected-secrets-nondefault-permission-mode.yaml><code>pods/storage/projected-secrets-nondefault-permission-mode.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-secrets-nondefault-permission-mode-yaml")' title="Copy pods/storage/projected-secrets-nondefault-permission-mode.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-secrets-nondefault-permission-mode-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>volume-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>511</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>各投影ボリュームソースは、specの<code>sources</code>にリストされています。パラメーターは、2つの例外を除いてほぼ同じです。</p><ul><li>secretについて、ConfigMapの命名と一致するように<code>secretName</code>フィールドが<code>name</code>に変更されました。</li><li><code>defaultMode</code>はprojectedレベルでのみ指定でき、各ボリュームソースには指定できません。ただし上に示したように、個々の投影ごとに<code>mode</code>を明示的に設定できます。</li></ul><p><code>TokenRequestProjection</code>機能が有効になっている場合、現在の<a href=/ja/docs/reference/access-authn-authz/authentication/#service-account-token>サービスアカウントトークン</a>を指定されたパスのPodに挿入できます。例えば:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/storage/projected-service-account-token.yaml download=pods/storage/projected-service-account-token.yaml><code>pods/storage/projected-service-account-token.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-service-account-token-yaml")' title="Copy pods/storage/projected-service-account-token.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-service-account-token-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sa-token-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>token-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/service-account&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>token-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>audience</span>:<span style=color:#bbb> </span>api<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>token<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>この例のPodには、挿入されたサービスアカウントトークンを含む投影ボリュームがあります。このトークンはPodのコンテナがKubernetes APIサーバーにアクセスするために使用できます。この<code>audience</code>フィールドにはトークンの受信対象者が含まれています。トークンの受信者は、トークンの<code>audience</code>フィールドで指定された識別子で自分自身であるかを識別します。そうでない場合はトークンを拒否します。このフィールドはオプションで、デフォルトではAPIサーバーの識別子が指定されます。</p><p><code>expirationSeconds</code>はサービスアカウントトークンが有効であると予想される期間です。
デフォルトは1時間で、最低でも10分(600秒)でなければなりません。
管理者は、APIサーバーに<code>--service-account-max-token-expiration</code>オプションを指定することで、その最大値を制限することも可能です。
<code>path</code>フィールドは、投影ボリュームのマウントポイントへの相対パスを指定します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 投影ボリュームソースを<a href=/docs/concepts/storage/volumes/#using-subpath><code>subPath</code></a>ボリュームマウントとして使用しているコンテナは、それらのボリュームソースの更新を受信しません。</div><h2 id=securitycontextの相互作用>SecurityContextの相互作用</h2><p>サービスアカウントの投影ボリューム拡張でのファイル権限処理の<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/2451-service-account-token-volumes#proposal>提案</a>により、正しい所有者権限が設定された投影ファイルが導入されました。</p><h3 id=linux>Linux</h3><p>投影ボリュームがあり、Podの<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context><code>SecurityContext</code></a>に<code>RunAsUser</code>が設定されているLinux Podでは、投影されたファイルには、コンテナユーザーの所有権を含む正しい所有権が設定されます。</p><h3 id=windows>Windows</h3><p>投影ボリュームを持ち、Podの<code>SecurityContext</code>で<code>RunAsUsername</code>を設定したWindows Podでは、Windowsのユーザーアカウント管理方法により所有権が強制されません。
Windowsは、ローカルユーザーとグループアカウントをセキュリティアカウントマネージャー(SAM)と呼ばれるデータベースファイルに保存し、管理します。
各コンテナはSAMデータベースの独自のインスタンスを維持し、コンテナの実行中はホストはそのインスタンスを見ることができません。
Windowsコンテナは、OSのユーザーモード部分をホストから分離して実行するように設計されており、そのため仮想SAMデータベースを維持することになります。
そのため、ホスト上で動作するkubeletには、仮想化されたコンテナアカウントのホストファイル所有権を動的に設定する機能がありません。
ホストマシン上のファイルをコンテナと共有する場合は、<code>C:\</code>以外の独自のボリュームマウントに配置することをお勧めします。</p><p>デフォルトでは、投影ボリュームファイルの例に示されているように、投影されたファイルには次の所有権があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>PS </span>C:\&gt; <span style=color:#a2f>Get-Acl</span> C:\var\run\secrets\kubernetes.io\serviceaccount\..2021_08_31_22_22_18.<span style=color:#666>318230061</span>\ca.crt | <span style=color:#a2f>Format-List</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Path   <span>:</span> Microsoft.PowerShell.Core\FileSystem::C:\var\run\secrets\kubernetes.io\serviceaccount\..2021_08_31_22_22_18.<span style=color:#666>318230061</span>\ca.crt
</span></span><span style=display:flex><span>Owner  <span>:</span> BUILTIN\Administrators
</span></span><span style=display:flex><span><span style=color:#a2f>Group </span> <span>:</span> NT AUTHORITY\SYSTEM
</span></span><span style=display:flex><span>Access <span>:</span> NT AUTHORITY\SYSTEM Allow  FullControl
</span></span><span style=display:flex><span>         BUILTIN\Administrators Allow  FullControl
</span></span><span style=display:flex><span>         BUILTIN\Users Allow  ReadAndExecute, Synchronize
</span></span><span style=display:flex><span>Audit  <span>:</span>
</span></span><span style=display:flex><span>Sddl   <span>:</span> O:BAG<span>:</span>SYD<span>:</span>AI(A;ID;FA;;;SY)(A;ID;FA;;;BA)(A;ID;0x1200a9;;;BU)
</span></span></code></pre></div><p>これは、<code>ContainerAdministrator</code>のようなすべての管理者ユーザーが読み取り、書き込み、および実行アクセス権を持ち、非管理者ユーザーが読み取りおよび実行アクセス権を持つことを意味します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>一般に、コンテナにホストへのアクセスを許可することは、潜在的なセキュリティの悪用への扉を開く可能性があるため、お勧めできません。</p><p>Windows Podの<code>SecurityContext</code>に<code>RunAsUser</code>を指定して作成すると、Podは<code>ContainerCreating</code>で永久に固まります。したがって、Windows PodでLinux専用の<code>RunAsUser</code>オプションを使用しないことをお勧めします。</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-707ca81a34eb1ca202f34692e9917d1e>6.4 - CSI Volume Cloning</h1><p>このドキュメントではKubernetesで既存のCSIボリュームの複製についてのコンセプトを説明します。このページを読む前にあらかじめ<a href=/docs/concepts/storage/volumes>ボリューム</a>についてよく理解していることが望ましいです。</p><h2 id=イントロダクション>イントロダクション</h2><p><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>のボリューム複製機能は、ユーザーが<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>の複製を作成することを示す<code>dataSource</code>フィールドで既存の<a class=glossary-tooltip title=コンテナ内でボリュームとしてマウントするためにPersistentVolume内で定義されたストレージリソースを要求します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PVC>PVC</a>を指定するためのサポートを追加します。</p><p>複製は既存のKubernetesボリュームの複製として定義され、標準のボリュームと同じように使用できます。唯一の違いは、プロビジョニング時に「新しい」空のボリュームを作成するのではなく、バックエンドデバイスが指定されたボリュームの正確な複製を作成することです。</p><p>複製の実装は、Kubernetes APIの観点からは新しいPVCの作成時に既存のPVCをdataSourceとして指定する機能を追加するだけです。ソースPVCはバインドされており、使用可能でなければなりません(使用中ではありません)。</p><p>この機能を使用する場合、ユーザーは次のことに注意する必要があります:</p><ul><li>複製のサポート(<code>VolumePVCDataSource</code>)はCSIドライバーのみです。</li><li>複製のサポートは動的プロビジョニングのみです。</li><li>CSIドライバーはボリューム複製機能を実装している場合としていない場合があります。</li><li>PVCは複製先のPVCと同じ名前空間に存在する場合にのみ複製できます(複製元と複製先は同じ名前空間になければなりません)。</li><li>複製は同じストレージクラス内でのみサポートされます。<ul><li>宛先ボリュームは、ソースと同じストレージクラスである必要があります。</li><li>デフォルトのストレージクラスを使用でき、仕様ではstorageClassNameを省略できます。</li></ul></li><li>複製は同じVolumeMode設定を使用する2つのボリューム間でのみ実行できます(ブロックモードのボリュームを要求する場合、ソースもブロックモードである必要があります)。</li></ul><h2 id=プロビジョニング>プロビジョニング</h2><p>複製は同じ名前空間内の既存のPVCを参照するdataSourceを追加すること以外は他のPVCと同様にプロビジョニングされます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>clone-of-pvc-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>myns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>cloning<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pvc-1<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>spec.resources.requests.storage</code>に容量の値を指定する必要があります。指定する値は、ソースボリュームの容量と同じかそれ以上である必要があります。</div><p>このyamlの作成結果は指定された複製元である<code>pvc-1</code>と全く同じデータを持つ<code>clone-of-pvc-1</code>という名前の新しいPVCです。</p><h2 id=使い方>使い方</h2><p>新しいPVCが使用可能になると、複製されたPVCは他のPVCと同じように利用されます。またこの時点で新しく作成されたPVCは独立したオブジェクトであることが期待されます。元のdataSource PVCを考慮せず個別に利用、複製、スナップショット、削除できます。これはまた複製元が新しく作成された複製にリンクされておらず、新しく作成された複製に影響を与えずに変更または削除できることを意味します。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4d00116c86dade62bdd5be7dc2afa1ca>6.5 - VolumeSnapshotClass</h1><p>このドキュメントでは、Kubernetesにおける<code>VolumeSnapshotClass</code>のコンセプトについて説明します。<br>関連する項目として、<a href=/docs/concepts/storage/volume-snapshots/>Volumeのスナップショット</a>と<a href=/docs/concepts/storage/storage-classes>ストレージクラス</a>も参照してください。</p><h2 id=イントロダクション>イントロダクション</h2><p><code>StorageClass</code>はVolumeをプロビジョンするときに、ストレージの"クラス"に関する情報を記述する方法を提供します。それと同様に、<code>VolumeSnapshotClass</code>ではVolumeSnapshotをプロビジョンするときに、ストレージの"クラス"に関する情報を記述する方法を提供します。</p><h2 id=volumesnapshotclass-リソース>VolumeSnapshotClass リソース</h2><p>各<code>VolumeSnapshotClass</code>は<code>driver</code>、<code>deletionPolicy</code>と<code>parameters</code>フィールドを含み、それらは、そのクラスに属する<code>VolumeSnapshot</code>が動的にプロビジョンされるときに使われます。</p><p><code>VolumeSnapshotClass</code>オブジェクトの名前は重要であり、それはユーザーがどのように特定のクラスをリクエストできるかを示したものです。管理者は初めて<code>VolumeSnapshotClass</code>オブジェクトを作成するときに、その名前と他のパラメーターをセットし、そのオブジェクトは一度作成されるとそのあと更新することができません。</p><p>管理者は、バインド対象のクラスを1つもリクエストしないようなVolumeSnapshotのために、デフォルトの<code>VolumeSnapshotClass</code>を指定することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=driver>Driver</h3><p>VolumeSnapshotClassは、VolumeSnapshotをプロビジョンするときに何のCSIボリュームプラグインを使うか決定するための<code>driver</code>フィールドを持っています。このフィールドは必須となります。</p><h3 id=deletionpolicy>DeletionPolicy</h3><p>VolumeSnapshotClassにはdeletionPolicyがあります。これにより、バインドされている <code>VolumeSnapshot</code>オブジェクトが削除されるときに、<code>VolumeSnapshotContent</code>がどうなるかを設定することができます。VolumeSnapshotのdeletionPolicyは、<code>Retain</code>または<code>Delete</code>のいずれかです。このフィールドは指定しなければなりません。</p><p>deletionPolicyが<code>Delete</code>の場合、元となるストレージスナップショットは <code>VolumeSnapshotContent</code>オブジェクトとともに削除されます。deletionPolicyが<code>Retain</code>の場合、元となるスナップショットと<code>VolumeSnapshotContent</code>の両方が残ります。</p><h2 id=parameters>Parameters</h2><p>VolumeSnapshotClassは、そのクラスに属するVolumeSnapshotを指定するパラメータを持っています。
<code>driver</code>に応じて様々なパラメータを使用できます。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-018f0a7fc6e2f6d16da37702fc39b4f3>6.6 - ボリュームの動的プロビジョニング(Dynamic Volume Provisioning)</h1><p>ボリュームの動的プロビジョニングにより、ストレージ用のボリュームをオンデマンドに作成することができます。
動的プロビジョニングなしでは、クラスター管理者はクラウドプロバイダーまたはストレージプロバイダーに対して新規のストレージ用のボリュームと<a href=/ja/docs/concepts/storage/persistent-volumes/><code>PersistentVolume</code>オブジェクト</a>を作成するように手動で指示しなければなりません。動的プロビジョニングの機能によって、クラスター管理者がストレージを事前にプロビジョンする必要がなくなります。その代わりに、ユーザーによってリクエストされたときに自動でストレージをプロビジョンします。</p><h2 id=バックグラウンド>バックグラウンド</h2><p>ボリュームの動的プロビジョニングの実装は<code>storage.k8s.io</code>というAPIグループ内の<code>StorageClass</code>というAPIオブジェクトに基づいています。クラスター管理者は<code>StorageClass</code>オブジェクトを必要に応じていくつでも定義でき、各オブジェクトはボリュームをプロビジョンする<em>Volumeプラグイン</em> (別名<em>プロビジョナー</em>)と、プロビジョンされるときにプロビジョナーに渡されるパラメータを指定します。
クラスター管理者はクラスター内で複数の種類のストレージ(同一または異なるストレージシステム)を定義し、さらには公開でき、それらのストレージはパラメータのカスタムセットを持ちます。この仕組みにおいて、エンドユーザーはストレージがどのようにプロビジョンされるか心配する必要がなく、それでいて複数のストレージオプションから選択できることを保証します。</p><p>StorageClassに関するさらなる情報は<a href=/docs/concepts/storage/storage-classes/>Storage Class</a>を参照ください。</p><h2 id=動的プロビジョニングを有効にする>動的プロビジョニングを有効にする</h2><p>動的プロビジョニングを有効にするために、クラスター管理者はユーザーのために1つまたはそれ以上のStorageClassを事前に作成する必要があります。StorageClassオブジェクトは、動的プロビジョニングが実行されるときに、どのプロビジョナーが使用されるべきか、またどのようなパラメーターをプロビジョナーに渡すべきか定義します。StorageClassオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><p>下記のマニフェストでは標準的な永続化ディスクをプロビジョンする"slow"というStorageClassを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></span></span></code></pre></div><p>下記のマニフェストではSSDを使った永続化ディスクをプロビジョンする"fast"というStorageClassを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-ssd<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=動的プロビジョニングの使用>動的プロビジョニングの使用</h2><p>ユーザーは<code>PersistentVolumeClaim</code>リソース内でStorageClassを含むことで、動的にプロビジョンされたStorageをリクエストできます。Kubernetes v1.6以前では、この機能は<code>volume.beta.kubernetes.io/storage-class</code>アノテーションを介して使うことができました。しかしこのアノテーションではv1.6から廃止になりました。その代わりユーザーは現在では<code>PersistentVolumeClaim</code>オブジェクトの<code>storageClassName</code>を使う必要があります。このフィールドの値は、管理者によって設定された<code>StorageClass</code>の名前と一致しなければなりません(<a href=#enabling-dynamic-provisioning>下記</a>のセクションも参照ください)。</p><p>"fast"というStorageClassを選択するために、例としてユーザーは下記のPersistentVolumeClaimを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>claim1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>30Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>このリソースによってSSDのような永続化ディスクが自動的にプロビジョンされます。このリソースが削除された時、そのボリュームは削除されます。</p><h2 id=デフォルトの挙動>デフォルトの挙動</h2><p>動的プロビジョニングは、もしStorageClassが1つも指定されていないときに全てのPersistentVolumeClaimが動的にプロビジョンされるようにクラスター上で有効にできます。クラスター管理者は、下記を行うことによりこのふるまいを有効にできます。</p><ul><li>1つの<code>StorageClass</code>オブジェクトを<em>default</em> としてマーキングする</li><li>API Server上で<a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code>管理コントローラー</a>を有効にする。</li></ul><p>管理者は<code>StorageClass</code>に対して<code>storageclass.kubernetes.io/is-default-class</code>アノテーションをつけることで、デフォルトのStorageClassとしてマーキングできます。
デフォルトの<code>StorageClass</code>がクラスター内で存在し、かつユーザーが<code>PersistentVolumeClaim</code>リソースで<code>storageClassName</code>を指定しなかった場合、<code>DefaultStorageClass</code>という管理コントローラーは<code>storageClassName</code>フィールドの値をデフォルトのStorageClassを指し示すように自動で追加します。</p><p>注意点として、クラスター上では最大1つしか<em>デフォルト</em> のStorageClassが指定できず、<code>storageClassName</code>を明示的に指定しない<code>PersistentVolumeClaim</code>は作成することもできません。</p><h2 id=トポロジーに関する注意>トポロジーに関する注意</h2><p><a href=/docs/setup/multiple-zones>マルチゾーン</a>クラスター内では、Podは単一のリージョン内のゾーンをまたいでしか稼働できません。シングルゾーンのStorageバックエンドはPodがスケジュールされるゾーン内でプロビジョンされる必要があります。これは<a href=/docs/concepts/storage/storage-classes/#volume-binding-mode>Volume割り当てモード</a>を設定することにより可能となります。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-00cd24f4570b7acaac75c2551c948bc7>6.7 - ストレージ容量</h1><p>ストレージ容量は、Podが実行されるノードごとに制限があったり、大きさが異なる可能性があります。たとえば、NASがすべてのノードからはアクセスできなかったり、初めからストレージがノードローカルでしか利用できない可能性があります。</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [alpha]</code></div><p>このページでは、Kubernetesがストレージ容量を追跡し続ける方法と、スケジューラーがその情報を利用して、残りの未作成のボリュームのために十分なストレージ容量へアクセスできるノード上にどのようにPodをスケジューリングするかについて説明します。もしストレージ容量の追跡がなければ、スケジューラーは、ボリュームをプロビジョニングするために十分な容量のないノードを選択してしまい、スケジューリングの再試行が複数回行われてしまう恐れがあります。</p><p>ストレージ容量の追跡は、<a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label='Container Storage Interface'>Container Storage Interface</a>(CSI)向けにサポートされており、CSIドライバーのインストール時に<a href=#enabling-storage-capacity-tracking>有効にする必要があります</a>。</p><h2 id=api>API</h2><p>この機能には、以下の2つのAPI拡張があります。</p><ul><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#csistoragecapacity-v1alpha1-storage-k8s-io>CSIStorageCapacity</a>オブジェクト: このオブジェクトは、CSIドライバーがインストールされた名前空間に生成されます。各オブジェクトには1つのストレージクラスに対する容量の情報が含まれ、そのストレージに対してどのノードがアクセス権を持つかが定められています。</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#csidriverspec-v1-storage-k8s-io><code>CSIDriverSpec.StorageCapacity</code>フィールド</a>: <code>true</code>に設定すると、Kubernetesのスケジューラーが、CSIドライバーを使用するボリュームに対してストレージ容量を考慮するようになります。</p></li></ul><h2 id=スケジューリング>スケジューリング</h2><p>ストレージ容量の情報がKubernetesのスケジューラーで利用されるのは、以下のすべての条件を満たす場合です。</p><ul><li><code>CSIStorageCapacity</code>フィーチャーゲートがtrueである</li><li>Podがまだ作成されていないボリュームを使用する時</li><li>そのボリュームが、CSIドライバーを参照し、<a href=/docs/concepts/storage/storage-classes/#volume-binding-mode>volume binding mode</a>に<code>WaitForFirstConsumer</code>を使う<a class=glossary-tooltip title=StorageClassは管理者が利用可能なさまざまなストレージタイプを記述する方法を提供します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/storage-classes target=_blank aria-label=StorageClass>StorageClass</a>を使用している</li><li>ドライバーに対する<code>CSIDriver</code>オブジェクトの<code>StorageCapacity</code>がtrueに設定されている</li></ul><p>その場合、スケジューラーはPodに対して、十分なストレージ容量が利用できるノードだけを考慮するようになります。このチェックは非常に単純で、ボリュームのサイズと、<code>CSIStorageCapacity</code>オブジェクトに一覧された容量を、ノードを含むトポロジーで比較するだけです。</p><p>volume binding modeが<code>Immediate</code>のボリュームの場合、ストレージドライバーはボリュームを使用するPodとは関係なく、ボリュームを作成する場所を決定します。次に、スケジューラーはボリュームが作成された後、Podをボリュームが利用できるノードにスケジューリングします。</p><p><a href=/docs/concepts/storage/volumes/#csi>CSI ephemeral volumes</a>の場合、スケジューリングは常にストレージ容量を考慮せずに行われます。このような動作になっているのは、このボリュームタイプはノードローカルな特別なCSIドライバーでのみ使用され、そこでは特に大きなリソースが必要になることはない、という想定に基づいています。</p><h2 id=再スケジューリング>再スケジューリング</h2><p><code>WaitForFirstConsumer</code>ボリュームがあるPodに対してノードが選択された場合は、その決定はまだ一時的なものです。次のステップで、CSIストレージドライバーに対して、選択されたノード上でボリュームが利用可能になることが予定されているというヒントを使用してボリュームの作成を要求します。</p><p>Kubernetesは古い容量の情報をもとにノードを選択する場合があるため、実際にはボリュームが作成できないという可能性が存在します。その場合、ノードの選択がリセットされ、KubernetesスケジューラーはPodに割り当てるノードを再び探します。</p><h2 id=制限>制限</h2><p>ストレージ容量を追跡することで、1回目の試行でスケジューリングが成功する可能性が高くなります。しかし、スケジューラーは潜在的に古い情報に基づいて決定を行う可能性があるため、成功を保証することはできません。通常、ストレージ容量の情報が存在しないスケジューリングと同様のリトライの仕組みによって、スケジューリングの失敗に対処します。</p><p>スケジューリングが永続的に失敗する状況の1つは、Podが複数のボリュームを使用する場合で、あるトポロジーのセグメントで1つのボリュームがすでに作成された後、もう1つのボリュームのために十分な容量が残っていないような場合です。この状況から回復するには、たとえば、容量を増加させたり、すでに作成されたボリュームを削除するなどの手動での対応が必要です。この問題に自動的に対処するためには、まだ<a href=https://github.com/kubernetes/enhancements/pull/1703>追加の作業</a>が必要となっています。</p><h2 id=enabling-storage-capacity-tracking>ストレージ容量の追跡を有効にする</h2><p>ストレージ容量の追跡は<em>アルファ機能</em>であり、<code>CSIStorageCapacity</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>と<code>storage.k8s.io/v1alpha1</code> <a class=glossary-tooltip title='A set of related paths in the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label='API group'>API group</a>を有効にした場合にのみ、有効化されます。詳細については、<code>--feature-gates</code>および<code>--runtime-config</code> <a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserverパラメータ</a>を参照してください。</p><p>Kubernetesクラスターがこの機能をサポートしているか簡単に確認するには、以下のコマンドを実行して、CSIStorageCapacityオブジェクトを一覧表示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csistoragecapacities --all-namespaces
</span></span></code></pre></div><p>クラスターがCSIStorageCapacityをサポートしていれば、CSIStorageCapacityのリストが表示されるか、次のメッセージが表示されます。</p><pre tabindex=0><code>No resources found
</code></pre><p>もしサポートされていなければ、代わりに次のエラーが表示されます。</p><pre tabindex=0><code>error: the server doesn&#39;t have a resource type &#34;csistoragecapacities&#34;
</code></pre><p>クラスター内で機能を有効化することに加えて、CSIドライバーもこの機能をサポートしている必要があります。詳細については、各ドライバーのドキュメントを参照してください。</p><h2 id=次の項目>次の項目</h2><ul><li>設計に関するさらなる情報について知るために、<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1472-storage-capacity-tracking/README.md>Storage Capacity Constraints for Pod Scheduling KEP</a>を読む。</li><li>この機能の今後の開発に関する情報について知るために、<a href=https://github.com/kubernetes/enhancements/issues/1472>enhancement tracking issue #1472</a>を参照する。</li><li><a href=/ja/docs/concepts/scheduling-eviction/kube-scheduler/>Kubernetesのスケジューラー</a>についてもっと学ぶ。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4f40cb95a671e51b4f0156a409d95c6d>6.8 - ボリュームヘルスモニタリング</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code></div><p><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>ボリュームヘルスモニタリングにより、CSIドライバーは、基盤となるストレージシステムから異常なボリューム状態を検出し、それらを<a class=glossary-tooltip title=コンテナ内でボリュームとしてマウントするためにPersistentVolume内で定義されたストレージリソースを要求します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PVC>PVC</a>または<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>のイベントとして報告できます。</p><h2 id=ボリュームヘルスモニタリング>ボリュームヘルスモニタリング</h2><p>Kubernetes <em>volume health monitoring</em> は、KubernetesがContainerStorageInterface(CSI)を実装する方法の一部です。ボリュームヘルスモニタリング機能は、外部のヘルスモニターコントローラーと<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>の2つのコンポーネントで実装されます。</p><p>CSIドライバーがコントローラー側からのボリュームヘルスモニタリング機能をサポートしている場合、CSIボリュームで異常なボリューム状態が検出されると、関連する<a class=glossary-tooltip title=コンテナ内でボリュームとしてマウントするためにPersistentVolume内で定義されたストレージリソースを要求します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PersistentVolumeClaim>PersistentVolumeClaim</a>(PVC)でイベントが報告されます。</p><p>外部ヘルスモニター<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>も、ノード障害イベントを監視します。<code>enable-node-watcher</code>フラグをtrueに設定することで、ノード障害の監視を有効にできます。外部ヘルスモニターがノード障害イベントを検出すると、コントローラーは、このPVCを使用するポッドが障害ノード上にあることを示すために、PVCでイベントが報告されることを報告します。</p><p>CSIドライバーがノード側からのボリュームヘルスモニタリング機能をサポートしている場合、CSIボリュームで異常なボリューム状態が検出されると、PVCを使用するすべてのPodでイベントが報告されます。さらに、ボリュームヘルス情報はKubelet VolumeStatsメトリクスとして公開されます。新しいメトリックkubelet_volume_stats_health_status_abnormalが追加されました。このメトリックには<code>namespace</code>と<code>persistentvolumeclaim</code>の2つのラベルが含まれます。カウントは1または0です。1はボリュームが異常であることを示し、0はボリュームが正常であることを示します。詳細については、<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1432-volume-health-monitor#kubelet-metrics-changes>KEP</a>を確認してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ノード側からこの機能を使用するには、<code>CSIVolumeHealth</code><a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>を有効にする必要があります。</div><h2 id=次の項目>次の項目</h2><p><a href=https://kubernetes-csi.github.io/docs/drivers.html>CSIドライバーのドキュメント</a>を参照して、この機能を実装しているCSIドライバーを確認してください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b2e4b16ac37988c678a3312a4a6639f8>6.9 - ノード固有のボリューム制限</h1><p>このページでは、さまざまなクラウドプロバイダーのノードに接続できるボリュームの最大数について説明します。</p><p>通常、Google、Amazon、Microsoftなどのクラウドプロバイダーには、ノードに接続できるボリュームの数に制限があります。Kubernetesがこれらの制限を尊重することが重要です。
そうしないと、ノードでスケジュールされたPodが、ボリュームが接続されるのを待ってスタックする可能性があります。</p><h2 id=kubernetesのデフォルトの制限>Kubernetesのデフォルトの制限</h2><p>Kubernetesスケジューラーには、ノードに接続できるボリュームの数にデフォルトの制限があります。</p><table><tr><th>クラウドサービス</th><th>ノード当たりの最大ボリューム</th></tr><tr><td><a href=https://aws.amazon.com/ebs/>Amazon Elastic Block Store (EBS)</a></td><td>39</td></tr><tr><td><a href=https://cloud.google.com/persistent-disk/>Google Persistent Disk</a></td><td>16</td></tr><tr><td><a href=https://azure.microsoft.com/en-us/services/storage/main-disks/>Microsoft Azure Disk Storage</a></td><td>16</td></tr></table><h2 id=カスタム制限>カスタム制限</h2><p>これらの制限を変更するには、<code>KUBE_MAX_PD_VOLS</code>環境変数の値を設定し、スケジューラーを開始します。CSIドライバーの手順は異なる場合があります。制限をカスタマイズする方法については、CSIドライバーのドキュメントを参照してください。</p><p>デフォルトの制限よりも高い制限を設定する場合は注意してください。クラウドプロバイダーのドキュメントを参照して、設定した制限をノードが実際にサポートしていることを確認してください。</p><p>制限はクラスター全体に適用されるため、すべてのノードに影響します。</p><h2 id=動的ボリューム制限>動的ボリューム制限</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code></div><p>動的ボリューム制限は、次のボリュームタイプでサポートされています。</p><ul><li>Amazon EBS</li><li>Google Persistent Disk</li><li>Azure Disk</li><li>CSI</li></ul><p>ツリー内のボリュームプラグインによって管理されるボリュームの場合、Kubernetesはノードタイプを自動的に決定し、ノードに適切なボリュームの最大数を適用します。例えば:</p><ul><li><p><a href=https://cloud.google.com/compute/>Google Compute Engine</a>上では<a href=https://cloud.google.com/compute/docs/disks/#pdnumberlimits>ノードタイプ</a>に応じて、最大127個のボリュームをノードに接続できます。</p></li><li><p>M5、C5、R5、T3、およびZ1DインスタンスタイプのAmazon EBSディスクの場合、Kubernetesは25ボリュームのみをノードにアタッチできます。<a href=https://aws.amazon.com/ec2/>Amazon Elastic Compute Cloud (EC2)</a>の他のインスタンスタイプの場合、Kubernetesでは39個のボリュームをノードに接続できます。</p></li><li><p>Azureでは、ノードの種類に応じて、最大64個のディスクをノードに接続できます。詳細については、<a href=https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes>Azureの仮想マシンのサイズ</a>を参照してください。</p></li><li><p>CSIストレージドライバーが(<code>NodeGetInfo</code>を使用して)ノードの最大ボリューム数をアドバタイズする場合、<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>はその制限を尊重します。詳細については、<a href=https://github.com/ontainer-storage-interface/spec/blob/master/spec.md#nodegetinfo>CSIの仕様</a>を参照してください。</p></li><li><p>CSIドライバーに移行されたツリー内プラグインによって管理されるボリュームの場合、ボリュームの最大数はCSIドライバーによって報告される数になります。</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-275bea454e1cf4c5adeca4058b5af988>7 - 設定</h1></div><div class=td-content><h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>7.1 - 設定のベストプラクティス</h1><p>このドキュメントでは、ユーザーガイド、入門マニュアル、および例を通して紹介されている設定のベストプラクティスを中心に説明します。</p><p>このドキュメントは生ものです。このリストには載っていないが他の人に役立つかもしれない何かについて考えている場合、IssueまたはPRを遠慮なく作成してください。</p><h2 id=一般的な設定のtips>一般的な設定のTips</h2><ul><li><p>構成を定義する際には、最新の安定したAPIバージョンを指定してください。</p></li><li><p>設定ファイルは、クラスターに反映される前にバージョン管理システムに保存されるべきです。これによって、必要に応じて設定変更を迅速にロールバックできます。また、クラスターの再作成や復元時にも役立ちます。</p></li><li><p>JSONではなくYAMLを使って設定ファイルを書いてください。これらのフォーマットはほとんどすべてのシナリオで互換的に使用できますが、YAMLはよりユーザーフレンドリーになる傾向があります。</p></li><li><p>意味がある場合は常に、関連オブジェクトを単一ファイルにグループ化します。多くの場合、1つのファイルの方が管理が簡単です。例として<a href=https://github.com/kubernetes/examples/tree/master/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a>ファイルを参照してください。</p></li><li><p>多くの<code>kubectl</code>コマンドがディレクトリに対しても呼び出せることも覚えておきましょう。たとえば、設定ファイルのディレクトリで <code>kubectl apply</code>を呼び出すことができます。</p></li><li><p>不必要にデフォルト値を指定しないでください。シンプルかつ最小限の設定のほうがエラーが発生しにくくなります。</p></li><li><p>よりよいイントロスペクションのために、オブジェクトの説明をアノテーションに入れましょう。</p></li></ul><h2 id=naked-pods-vs-replicasets-deployments-and-jobs>"真っ裸"のPod に対する ReplicaSet、Deployment、およびJob</h2><ul><li><p>可能な限り、"真っ裸"のPod(<a href=/ja/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>や<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>にバインドされていないPod)は使わないでください。Nodeに障害が発生した場合、これらのPodは再スケジュールされません。</p><p>明示的に<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>restartPolicy: Never</code></a>を使いたいシーンを除いて、DeploymentはPodを直接作成するよりもほとんど常に望ましい方法です。Deploymentには、希望する数のPodが常に使用可能であることを確認するためにReplicaSetを作成したり、Podを置き換えるための戦略(RollingUpdateなど)を指定したりできます。<a href=/docs/concepts/workloads/controllers/job/>Job</a>のほうが適切な場合もあるかもしれません。</p></li></ul><h2 id=service>Service</h2><ul><li><p>対応するバックエンドワークロード（DeploymentまたはReplicaSet）の前、およびそれにアクセスする必要があるワークロードの前に<a href=/ja/docs/concepts/services-networking/service/>Service</a>を作成します。Kubernetesがコンテナを起動すると、コンテナ起動時に実行されていたすべてのServiceを指す環境変数が提供されます。たとえば、fooという名前のServiceが存在する場合、すべてのコンテナは初期環境で次の変数を取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;the host the Service is running on&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;the port the Service is running on&gt;
</span></span></code></pre></div><p><em>これは順序付けの必要性を意味します</em> - <code>Pod</code>がアクセスしたい<code>Service</code>は<code>Pod</code>自身の前に作らなければならず、そうしないと環境変数は注入されません。DNSにはこの制限はありません。</p></li><li><p>（強くお勧めしますが）<a href=/ja/docs/concepts/cluster-administration/addons/>クラスターアドオン</a>の1つの選択肢はDNSサーバーです。DNSサーバーは、新しい<code>Service</code>についてKubernetes APIを監視し、それぞれに対して一連のDNSレコードを作成します。クラスタ全体でDNSが有効になっている場合は、すべての<code>Pod</code>が自動的に<code>Services</code>の名前解決を行えるはずです。</p></li><li><p>どうしても必要な場合以外は、Podに<code>hostPort</code>を指定しないでください。Podを<code>hostPort</code>にバインドすると、Podがスケジュールできる場所の数を制限します、それぞれの&lt;<code>hostIP</code>、 <code>hostPort</code>、<code>protocol</code>>の組み合わせはユニークでなければならないからです。<code>hostIP</code>と<code>protocol</code>を明示的に指定しないと、Kubernetesはデフォルトの<code>hostIP</code>として<code>0.0.0.0</code>を、デフォルトの <code>protocol</code>として<code>TCP</code>を使います。</p><p>デバッグ目的でのみポートにアクセスする必要がある場合は、<a href=/docs/tasks/access-application-cluster/access-cluster/#manually-constructing-apiserver-proxy-urls>apiserver proxy</a>または<a href=/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>を使用できます。</p><p>ノード上でPodのポートを明示的に公開する必要がある場合は、hostPortに頼る前に<a href=/ja/docs/concepts/services-networking/service/#nodeport>NodePort</a>の使用を検討してください。</p></li><li><p><code>hostPort</code>の理由と同じくして、<code>hostNetwork</code>の使用はできるだけ避けてください。</p></li><li><p><code>kube-proxy</code>のロードバランシングが不要な場合は、<a href=/ja/docs/concepts/services-networking/service/#headless-service>headless Service</a>（<code>ClusterIP</code>が<code>None</code>）を使用してServiceを簡単に検出できます。</p></li></ul><h2 id=ラベルの使用>ラベルの使用</h2><ul><li><code>{ app: myapp, tier: frontend, phase: test, deployment: v3 }</code>のように、アプリケーションまたはデプロイメントの <strong>セマンティック属性</strong> を識別する<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>を定義して使いましょう。これらのラベルを使用して、他のリソースに適切なPodを選択できます。例えば、すべての<code>tier：frontend</code>を持つPodを選択するServiceや、<code>app：myapp</code>に属するすべての<code>phase：test</code>コンポーネント、などです。このアプローチの例を知るには、<a href=https://github.com/kubernetes/examples/tree/master/guestbook/>ゲストブック</a>アプリも合わせてご覧ください。</li></ul><p>セレクターからリリース固有のラベルを省略することで、Serviceを複数のDeploymentにまたがるように作成できます。 <a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>により、ダウンタイムなしで実行中のサービスを簡単に更新できます。</p><p>オブジェクトの望ましい状態はDeploymentによって記述され、その仕様への変更が <em>適用</em> されると、Deploymentコントローラは制御された速度で実際の状態を望ましい状態に変更します。</p><ul><li>デバッグ用にラベルを操作できます。Kubernetesコントローラー（ReplicaSetなど）とServiceはセレクターラベルを使用してPodとマッチするため、Podから関連ラベルを削除すると、コントローラーによって考慮されたり、Serviceによってトラフィックを処理されたりすることがなくなります。既存のPodのラベルを削除すると、そのコントローラーはその代わりに新しいPodを作成します。これは、「隔離」環境で以前の「ライブ」Podをデバッグするのに便利な方法です。対話的にラベルを削除または追加するには、<a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>を使います。</li></ul><h2 id=コンテナイメージ>コンテナイメージ</h2><p><a href=/ja/docs/concepts/containers/images/#updating-images>imagePullPolicy</a>とイメージのタグは、<a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>が特定のイメージをpullしようとしたときに作用します。</p><ul><li><p><code>imagePullPolicy: IfNotPresent</code>: ローカルでイメージが見つからない場合にのみイメージをpullします。</p></li><li><p><code>imagePullPolicy: Always</code>: kubeletがコンテナを起動する度に、kubeletはコンテナイメージレジストリに問い合わせて、イメージのダイジェストの名前解決を行います。もし、kubeletが同じダイジェストのコンテナイメージをローカルにキャッシュしていたら、kubeletはそのキャッシュされたイメージを利用します。そうでなければ、kubeletは解決されたダイジェストのイメージをダウンロードし、そのイメージを利用してコンテナを起動します。</p></li><li><p><code>imagePullPolicy</code> のタグが省略されていて、利用してるイメージのタグが<code>:latest</code>の場合や省略されている場合、<code>Always</code>が適用されます。</p></li><li><p><code>imagePullPolicy</code> のタグが省略されていて、利用してるイメージのタグはあるが<code>:latest</code>でない場合、<code>IfNotPresent</code>が適用されます。</p></li><li><p><code>imagePullPolicy: Never</code>: 常にローカルでイメージを探そうとします。ない場合にもイメージはpullしません。</p></li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong> コンテナが常に同じバージョンのイメージを使用するようにするためには、そのコンテナイメージの<a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>ダイジェスト</a>を指定することができます。<code>&lt;image-name>:&lt;tag></code>を<code>&lt;image-name>@&lt;digest></code>で置き換えます(例:<code>image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>)。このダイジェストはイメージの特定のバージョンを一意に識別するため、ダイジェスト値を変更しない限り、Kubernetesによって更新されることはありません。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> どのバージョンのイメージが実行されているのかを追跡するのが難しく、適切にロールバックするのが難しいため、本番環境でコンテナをデプロイするときは <code>：latest</code>タグを使用しないでください。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ベースイメージのプロバイダーのキャッシュセマンティクスにより、<code>imagePullPolicy：Always</code>もより効率的になります。たとえば、Dockerでは、イメージがすでに存在する場合すべてのイメージレイヤーがキャッシュされ、イメージのダウンロードが不要であるため、pullが高速になります。</div><h2 id=kubectlの使い方>kubectlの使い方</h2><ul><li><p><code>kubectl apply -f &lt;directory></code>を使いましょう。これを使うと、ディレクトリ内のすべての<code>.yaml</code>、<code>.yml</code>、および<code>.json</code>ファイルが<code>apply</code>に渡されます。</p></li><li><p><code>get</code>や<code>delete</code>を行う際は、特定のオブジェクト名を指定するのではなくラベルセレクターを使いましょう。<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルセレクター</a>と<a href=/ja/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>ラベルの効果的な使い方</a>のセクションを参照してください。</p></li><li><p>単一コンテナのDeploymentやServiceを素早く作成するなら、<code>kubectl create deployment</code>や<code>kubectl expose</code>を使いましょう。一例として、<a href=/ja/docs/tasks/access-application-cluster/service-access-application-cluster/>Serviceを利用したクラスター内のアプリケーションへのアクセス</a>を参照してください。</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6b5ccadd699df0904e8e9917c5450c4b>7.2 - ConfigMap</h1><p><p>ConfigMapは、 機密性のないデータをキーと値のペアで保存するために使用されるAPIオブジェクトです。<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>は、環境変数、コマンドライン引数、または<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>内の設定ファイルとしてConfigMapを使用できます。</p></p><p>ConfigMapを使用すると、環境固有の設定を<a class=glossary-tooltip title=アプリケーションの実行に必要なソフトウェアのセットを持つ、保存されたコンテナの実体です。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-image' target=_blank aria-label=コンテナイメージ>コンテナイメージ</a>から分離できるため、アプリケーションを簡単に移植できるようになります。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> ConfigMapは機密性や暗号化を提供しません。保存したいデータが機密情報である場合は、ConfigMapの代わりに<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>を使用するか、追加の(サードパーティー)ツールを使用してデータが非公開になるようにしてください。</div><h2 id=動機>動機</h2><p>アプリケーションのコードとは別に設定データを設定するには、ConfigMapを使用します。</p><p>たとえば、アプリケーションを開発していて、(開発用時には)自分のコンピューター上と、(実際のトラフィックをハンドルするときは)クラウド上とで実行することを想像してみてください。あなたは、<code>DATABASE_HOST</code>という名前の環境変数を使用するコードを書きます。ローカルでは、この変数を<code>localhost</code>に設定します。クラウド上では、データベースコンポーネントをクラスター内に公開するKubernetesの<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を指すように設定します。</p><p>こうすることで、必要であればクラウド上で実行しているコンテナイメージを取得することで、ローカルでも完全に同じコードを使ってデバッグができるようになります。</p><p>ConfigMapは、大量のデータを保持するようには設計されていません。ConfigMapに保存されるデータは1MiBを超えることはできません。この制限を超える設定を保存する必要がある場合は、ボリュームのマウントを検討するか、別のデータベースまたはファイルサービスを使用することを検討してください。</p><h2 id=configmapオブジェクト>ConfigMapオブジェクト</h2><p>ConfigMapは、他のオブジェクトが使うための設定を保存できるAPI<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/>オブジェクト</a>です。ほとんどのKubernetesオブジェクトに<code>spec</code>セクションがあるのとは違い、ConfigMapには<code>data</code>および<code>binaryData</code>フィールドがあります。これらのフィールドは、キーとバリューのペアを値として受け入れます。<code>data</code>フィールドと<code>binaryData</code>フィールドはどちらもオプションです。<code>data</code>フィールドはUTF-8バイトシーケンスを含むように設計されていますが、<code>binaryData</code>フィールドはバイナリデータを含むように設計されています。</p><p>ConfigMapの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSのサブドメイン名</a>でなければなりません。</p><p><code>data</code>または<code>binaryData</code>フィールドの各キーは、英数字、<code>-</code>、<code>_</code>、または<code>.</code>で構成されている必要があります。<code>data</code>に格納されているキーは、<code>binaryData</code>フィールドのキーと重複することはできません。</p><p>v1.19以降、ConfigMapの定義に<code>immutable</code>フィールドを追加して、<a href=#configmap-immutable>イミュータブルなConfigMap</a>を作成できます。</p><h2 id=configmapとpod>ConfigMapとPod</h2><p>ConfigMapを参照して、ConfigMap内のデータを元にしてPod内のコンテナの設定をするPodの<code>spec</code>を書くことができます。このとき、PodとConfigMapは同じ<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=名前空間>名前空間</a>内に存在する必要があります。</p><p>以下に、ConfigMapの例を示します。単一の値を持つキーと、Configuration形式のデータ片のような値を持つキーがあります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># プロパティーに似たキー。各キーは単純な値にマッピングされている</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>player_initial_lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui_properties_file_name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ファイルに似たキー</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemy.types=aliens,monsters
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    player.maximum-lives=5</span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user-interface.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.good=purple
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    allow.textmode=true</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>ConfigMapを利用してPod内のコンテナを設定する方法には、次の4種類があります。</p><ol><li>コンテナ内のコマンドと引数</li><li>環境変数をコンテナに渡す</li><li>読み取り専用のボリューム内にファイルを追加し、アプリケーションがそのファイルを読み取る</li><li>Kubernetes APIを使用してConfigMapを読み込むコードを書き、そのコードをPod内で実行する</li></ol><p>これらのさまざまな方法は、利用するデータをモデル化するのに役立ちます。最初の3つの方法では、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>がPodのコンテナを起動する時にConfigMapのデータを使用します。</p><p>4番目の方法では、ConfigMapとそのデータを読み込むためのコードを自分自身で書く必要があります。しかし、Kubernetes APIを直接使用するため、アプリケーションはConfigMapがいつ変更されても更新イベントを受信でき、変更が発生したときにすぐに反応できます。この手法では、Kubernetes APIに直接アクセスすることで、別の名前空間にあるConfigMapにもアクセスできます。</p><p>以下に、Podを設定するために<code>game-demo</code>から値を使用するPodの例を示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-demo-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>alpine<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;3600&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 環境変数を定義します。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PLAYER_INITIAL_LIVES<span style=color:#bbb> </span><span style=color:#080;font-style:italic># ここではConfigMap内のキーの名前とは違い</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                                     </span><span style=color:#080;font-style:italic># 大文字が使われていることに着目してください。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo          <span style=color:#bbb> </span><span style=color:#080;font-style:italic># この値を取得するConfigMap。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>player_initial_lives<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 取得するキー。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>UI_PROPERTIES_FILE_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ui_properties_file_name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/config&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Podレベルでボリュームを設定し、Pod内のコンテナにマウントします。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># マウントしたいConfigMapの名前を指定します。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ファイルとして作成するConfigMapのキーの配列</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>ConfigMapは1行のプロパティの値と複数行のファイルに似た形式の値を区別しません。問題となるのは、Podや他のオブジェクトによる値の使用方法です。</p><p>この例では、ボリュームを定義して、<code>demo</code>コンテナの内部で<code>/config</code>にマウントしています。これにより、ConfigMap内には4つのキーがあるにもかかわらず、2つのファイル<code>/config/game.properties</code>および<code>/config/user-interface.properties</code>だけが作成されます。</p><p>これは、Podの定義が<code>volumes</code>セクションで<code>items</code>という配列を指定しているためです。もし<code>items</code>の配列を完全に省略すれば、ConfigMap内の各キーがキーと同じ名前のファイルになり、4つのファイルが作成されます。</p><h2 id=configmapを使う>ConfigMapを使う</h2><p>ConfigMapは、データボリュームとしてマウントできます。ConfigMapは、Podへ直接公開せずにシステムの他の部品として使うこともできます。たとえば、ConfigMapには、システムの他の一部が設定のために使用するデータを保存できます。</p><p>ConfigMapの最も一般的な使い方では、同じ名前空間にあるPod内で実行されているコンテナに設定を構成します。ConfigMapを独立して使用することもできます。</p><p>たとえば、ConfigMapに基づいて動作を調整する<a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=アドオン>アドオン</a>や<a class=glossary-tooltip title='A specialized controller used to manage a custom resource' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=オペレーター>オペレーター</a>を見かけることがあるかもしれません。</p><h3 id=configmapをpodからファイルとして使う>ConfigMapをPodからファイルとして使う</h3><p>ConfigMapをPod内のボリュームで使用するには、次のようにします。</p><ol><li>ConfigMapを作成するか、既存のConfigMapを使用します。複数のPodから同じConfigMapを参照することもできます。</li><li>Podの定義を修正して、<code>.spec.volumes[]</code>以下にボリュームを追加します。ボリュームに任意の名前を付け、<code>.spec.volumes[].configMap.name</code>フィールドにConfigMapオブジェクトへの参照を設定します。</li><li>ConfigMapが必要な各コンテナに<code>.spec.containers[].volumeMounts[]</code>を追加します。<code>.spec.containers[].volumeMounts[].readOnly = true</code>を指定して、<code>.spec.containers[].volumeMounts[].mountPath</code>には、ConfigMapのデータを表示したい未使用のディレクトリ名を指定します。</li><li>イメージまたはコマンドラインを修正して、プログラムがそのディレクトリ内のファイルを読み込むように設定します。ConfigMapの<code>data</code>マップ内の各キーが、<code>mountPath</code>以下のファイル名になります。</li></ol><p>以下は、ボリューム内にConfigMapをマウントするPodの例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></span></span></code></pre></div><p>使用したいそれぞれのConfigMapごとに、<code>.spec.volumes</code>内で参照する必要があります。</p><p>Pod内に複数のコンテナが存在する場合、各コンテナにそれぞれ別の<code>volumeMounts</code>のブロックが必要ですが、<code>.spec.volumes</code>はConfigMapごとに1つしか必要ありません。</p><h4 id=マウントしたconfigmapの自動的な更新>マウントしたConfigMapの自動的な更新</h4><p>ボリューム内で現在使用中のConfigMapが更新されると、射影されたキーも最終的に(eventually)更新されます。kubeletは定期的な同期のたびにマウントされたConfigMapが新しいかどうか確認します。しかし、kubeletが現在のConfigMapの値を取得するときにはローカルキャッシュを使用します。キャッシュの種類は、<a href=https://github.com/kubernetes/kubernetes/blob/main/staging/src/k8s.io/kubelet/config/v1beta1/types.go>KubeletConfiguration構造体</a>の中の<code>ConfigMapAndSecretChangeDetectionStrategy</code>フィールドで設定可能です。ConfigMapは、監視(デフォルト)、ttlベース、またはすべてのリクエストを直接APIサーバーへ単純にリダイレクトする方法のいずれかによって伝搬されます。その結果、ConfigMapが更新された瞬間から、新しいキーがPodに射影されるまでの遅延の合計は、最長でkubeletの同期期間+キャッシュの伝搬遅延になります。ここで、キャッシュの伝搬遅延は選択したキャッシュの種類に依存します(監視の伝搬遅延、キャッシュのttl、または0に等しくなります)。</p><p>環境変数として使用されるConfigMapは自動的に更新されないため、ポッドを再起動する必要があります。</p><h2 id=configmap-immutable>イミュータブルなConfigMap</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p>Kubernetesのベータ版の機能である <em>イミュータブルなSecretおよびConfigMap</em> は、個別のSecretやConfigMapをイミュータブルに設定するオプションを提供します。ConfigMapを広範に使用している(少なくとも数万のConfigMapがPodにマウントされている)クラスターでは、データの変更を防ぐことにより、以下のような利点が得られます。</p><ul><li>アプリケーションの停止を引き起こす可能性のある予想外の(または望まない)変更を防ぐことができる</li><li>ConfigMapをイミュータブルにマークして監視を停止することにより、kube-apiserverへの負荷を大幅に削減し、クラスターの性能が向上する</li></ul><p>この機能は、<code>ImmutableEmphemeralVolumes</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>によって管理されます。<code>immutable</code>フィールドを<code>true</code>に設定することで、イミュータブルなConfigMapを作成できます。次に例を示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>一度ConfigMapがイミュータブルに設定されると、この変更を元に戻したり、<code>data</code>または<code>binaryData</code>フィールドのコンテンツを変更することは<em>できません</em>。ConfigMapの削除と再作成のみ可能です。既存のPodは削除されたConfigMapのマウントポイントを保持するため、こうしたPodは再作成することをおすすめします。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/configuration/secret/>Secret</a>について読む。</li><li><a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>Podを構成してConfigMapを使用する</a>を読む。</li><li>コードを設定から分離する動機を理解するために<a href=https://12factor.net/ja/>The Twelve-Factor App</a>を読む。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e511ed821ada65d0053341dbd8ad2bb5>7.3 - Secret</h1><p>Secretとは、パスワードやトークン、キーなどの少量の機密データを含むオブジェクトのことです。
このような情報は、Secretを用いないと<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>の定義や<a class=glossary-tooltip title=アプリケーションの実行に必要なソフトウェアのセットを持つ、保存されたコンテナの実体です。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-image' target=_blank aria-label=コンテナイメージ>コンテナイメージ</a>に直接記載することになってしまうかもしれません。
Secretを使用すれば、アプリケーションコードに機密データを含める必要がなくなります。</p><p>なぜなら、Secretは、それを使用するPodとは独立して作成することができ、
Podの作成、閲覧、編集といったワークフローの中でSecret(およびそのデータ)が漏洩する危険性が低くなるためです。
また、Kubernetesやクラスター内で動作するアプリケーションは、不揮発性ストレージに機密データを書き込まないようにするなど、Secretで追加の予防措置を取ることができます。</p><p>Secretsは、<a class=glossary-tooltip title=機密性のないデータをキーと値のペアで保存するために使用されるAPIオブジェクトです。環境変数、コマンドライン引数、またはボリューム内の設定ファイルとして使用できます。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/configmap/ target=_blank aria-label=ConfigMaps>ConfigMaps</a>に似ていますが、機密データを保持するために用います。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong><p>KubernetesのSecretは、デフォルトでは、APIサーバーの基礎となるデータストア(etcd)に暗号化されずに保存されます。APIにアクセスできる人は誰でもSecretを取得または変更でき、etcdにアクセスできる人も同様です。
さらに、名前空間でPodを作成する権限を持つ人は、そのアクセスを使用して、その名前空間のあらゆるSecretを読むことができます。これには、Deploymentを作成する能力などの間接的なアクセスも含まれます。</p><p>Secretsを安全に使用するには、以下の手順を推奨します。</p><ol><li>Secretsを<a href=/docs/tasks/administer-cluster/encrypt-data/>安全に暗号化する</a></li><li>Secretsのデータの読み取りを制限する<a href=/docs/reference/access-authn-authz/authorization/>RBACルール</a>の有効化または設定</li><li>適切な場合には、RBACなどのメカニズムを使用して、どの原則が新しいSecretの作成や既存のSecretの置き換えを許可されるかを制限します。</li></ol></div><h2 id=secretの概要>Secretの概要</h2><p>Secretを使うには、PodはSecretを参照することが必要です。
PodがSecretを使う方法は3種類あります。</p><ul><li><a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>内の<a href=#using-secrets-as-files-from-a-pod>ファイル</a>として、Podの単一または複数のコンテナにマウントする</li><li><a href=#using-secrets-as-environment-variables>コンテナの環境変数</a>として利用する</li><li>Podを生成するために<a href=#using-imagepullsecrets>kubeletがイメージをpullする</a>ときに使用する</li></ul><p>KubernetesのコントロールプレーンでもSecretsは使われています。例えば、<a href=#bootstrap-token-secrets>bootstrap token Secrets</a>は、ノード登録を自動化するための仕組みです。</p><p>Secretオブジェクトの名称は正当な<a href=/ja/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。
シークレットの構成ファイルを作成するときに、<code>data</code>および/または<code>stringData</code>フィールドを指定できます。<code>data</code>フィールドと<code>stringData</code>フィールドはオプションです。
<code>data</code>フィールドのすべてのキーの値は、base64でエンコードされた文字列である必要があります。
base64文字列への変換が望ましくない場合は、代わりに<code>stringData</code>フィールドを指定することを選択できます。これは任意の文字列を値として受け入れます。</p><p><code>data</code>と<code>stringData</code>のキーは、英数字、<code>-</code>、<code>_</code>、または<code>.</code>で構成されている必要があります。
<code>stringData</code>フィールドのすべてのキーと値のペアは、内部で<code>data</code>フィールドにマージされます。
キーが<code>data</code>フィールドと<code>stringData</code>フィールドの両方に表示される場合、<code>stringData</code>フィールドで指定された値が優先されます。</p><h2 id=secret-types>Secretの種類</h2><p>Secretを作成するときは、<a href=/docs/reference/generated/kubernetes-api/v1.25/#secret-v1-core><code>Secret</code></a>の<code>type</code>フィールド、または特定の同等の<code>kubectl</code>コマンドラインフラグ（使用可能な場合）を使用して、その型を指定できます。
Secret型は、Secret dataのプログラムによる処理を容易にするために使用されます。</p><p>Kubernetesは、いくつかの一般的な使用シナリオに対応するいくつかの組み込み型を提供します。
これらの型は、実行される検証とKubernetesが課す制約の点で異なります。</p><table><thead><tr><th>Builtin Type</th><th>Usage</th></tr></thead><tbody><tr><td><code>Opaque</code></td><td>arbitrary user-defined data</td></tr><tr><td><code>kubernetes.io/service-account-token</code></td><td>service account token</td></tr><tr><td><code>kubernetes.io/dockercfg</code></td><td>serialized <code>~/.dockercfg</code> file</td></tr><tr><td><code>kubernetes.io/dockerconfigjson</code></td><td>serialized <code>~/.docker/config.json</code> file</td></tr><tr><td><code>kubernetes.io/basic-auth</code></td><td>credentials for basic authentication</td></tr><tr><td><code>kubernetes.io/ssh-auth</code></td><td>credentials for SSH authentication</td></tr><tr><td><code>kubernetes.io/tls</code></td><td>data for a TLS client or server</td></tr><tr><td><code>bootstrap.kubernetes.io/token</code></td><td>bootstrap token data</td></tr></tbody></table><p>Secretオブジェクトの<code>type</code>値として空でない文字列を割り当てることにより、独自のSecret型を定義して使用できます。空の文字列は<code>Opaque</code>型として扱われます。Kubernetesは型名に制約を課しません。ただし、組み込み型の1つを使用している場合は、その型に定義されているすべての要件を満たす必要があります。</p><h3 id=opaque-secrets>Opaque secrets</h3><p><code>Opaque</code>は、Secret構成ファイルから省略された場合のデフォルトのSecret型です。
<code>kubectl</code>を使用してSecretを作成する場合、<code>generic</code>サブコマンドを使用して<code>Opaque</code>Secret型を示します。 たとえば、次のコマンドは、<code>Opaque</code>型の空のSecretを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic empty-secret
</span></span><span style=display:flex><span>kubectl get secret empty-secret
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6s
</code></pre><p><code>DATA</code>列には、Secretに保存されているデータ項目の数が表示されます。
この場合、<code>0</code>は空のSecretを作成したことを意味します。</p><h3 id=service-account-token-secrets>Service account token Secrets</h3><p><code>kubernetes.io/service-account-token</code>型のSecretは、サービスアカウントを識別するトークンを格納するために使用されます。 このSecret型を使用する場合は、<code>kubernetes.io/service-account.name</code>アノテーションが既存のサービスアカウント名に設定されていることを確認する必要があります。Kubernetesコントローラーは、<code>kubernetes.io/service-account.uid</code>アノテーションや実際のトークンコンテンツに設定された<code>data</code>フィールドの<code>token</code>キーなど、他のいくつかのフィールドに入力します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-sa-sample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-account.name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sa-name&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># You can include additional key value pairs as you do with Opaque Secrets</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb> </span>YmFyCg==<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>Pod</code>を作成すると、Kubernetesはservice account Secretを自動的に作成し、このSecretを使用するようにPodを自動的に変更します。service account token Secretには、APIにアクセスするための資格情報が含まれています。</p><p>API証明の自動作成と使用は、必要に応じて無効にするか、上書きすることができます。 ただし、API Serverに安全にアクセスするだけの場合は、これが推奨されるワークフローです。</p><p>ServiceAccountの動作の詳細については、<a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>のドキュメントを参照してください。
PodからServiceAccountを参照する方法については、<a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core><code>Pod</code></a>の<code>automountServiceAccountToken</code>フィールドと<code>serviceAccountName</code>フィールドを確認することもできます。</p><h3 id=docker-config-secrets>Docker config Secrets</h3><p>次の<code>type</code>値のいずれかを使用して、イメージのDockerレジストリにアクセスするための資格情報を格納するSecretを作成できます。</p><ul><li><code>kubernetes.io/dockercfg</code></li><li><code>kubernetes.io/dockerconfigjson</code></li></ul><p><code>kubernetes.io/dockercfg</code>型は、Dockerコマンドラインを構成するためのレガシー形式であるシリアル化された<code>~/.dockercfg</code>を保存するために予約されています。
このSecret型を使用する場合は、Secretの<code>data</code>フィールドに<code>.dockercfg</code>キーが含まれていることを確認する必要があります。このキーの値は、base64形式でエンコードされた<code>~/.dockercfg</code>ファイルの内容です。</p><p><code>kubernetes.io/dockerconfigjson</code>型は、<code>~/.dockercfg</code>の新しいフォーマットである<code>~/.docker/config.json</code>ファイルと同じフォーマットルールに従うシリアル化されたJSONを保存するために設計されています。
このSecret型を使用する場合、Secretオブジェクトの<code>data</code>フィールドには<code>.dockerconfigjson</code>キーが含まれている必要があります。このキーでは、<code>~/.docker/config.json</code>ファイルのコンテンツがbase64でエンコードされた文字列として提供されます。</p><p>以下は、<code>kubernetes.io/dockercfg</code>型のSecretの例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dockercfg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockercfg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockercfg</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span><span style=color:#b44>&#34;&lt;base64 encoded ~/.dockercfg file&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> base64エンコーディングを実行したくない場合は、代わりに<code>stringData</code>フィールドを使用することを選択できます。</div><p>マニフェストを使用してこれらの型のSecretを作成すると、APIserverは期待されるキーが<code>data</code>フィールドに存在するかどうかを確認し、提供された値を有効なJSONとして解析できるかどうかを確認します。APIサーバーは、JSONが実際にDocker configファイルであるかどうかを検証しません。</p><p>Docker configファイルがない場合、または<code>kubectl</code>を使用してDockerレジストリSecretを作成する場合は、次の操作を実行できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry secret-tiger-docker <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-username<span style=color:#666>=</span>tiger <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-password<span style=color:#666>=</span>pass113 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-email<span style=color:#666>=</span>tiger@acme.com <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-server<span style=color:#666>=</span>my-registry.example:5000
</span></span></code></pre></div><p>このコマンドは、<code>kubernetes.io/dockerconfigjson</code>型のSecretを作成します。
<code>data</code>フィールドから<code>.dockerconfigjson</code>コンテンツをダンプすると、その場で作成された有効なDocker configである次のJSONコンテンツを取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;data&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;.dockerconfigjson&#34;</span>: <span style=color:#b44>&#34;eyJhdXRocyI6eyJteS1yZWdpc3RyeTo1MDAwIjp7InVzZXJuYW1lIjoidGlnZXIiLCJwYXNzd29yZCI6InBhc3MxMTMiLCJlbWFpbCI6InRpZ2VyQGFjbWUuY29tIiwiYXV0aCI6ImRHbG5aWEk2Y0dGemN6RXhNdz09In19fQ==&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Secret&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>: <span style=color:#b44>&#34;2021-07-01T07:30:59Z&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;secret-tiger-docker&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>: <span style=color:#b44>&#34;566718&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;e15c1d7b-9071-4100-8681-f3a7a2ce89ca&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;kubernetes.io/dockerconfigjson&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=basic-authentication-secret>Basic authentication Secret</h3><p><code>kubernetes.io/basic-auth</code>型は、Basic認証に必要な認証を保存するために提供されています。このSecret型を使用する場合、Secretの<code>data</code>フィールドには次の2つのキーが含まれている必要があります。</p><ul><li><code>username</code>: 認証のためのユーザー名</li><li><code>password</code>: 認証のためのパスワードかトークン</li></ul><p>上記の2つのキーの両方の値は、base64でエンコードされた文字列です。もちろん、Secretの作成に<code>stringData</code>を使用してクリアテキストコンテンツを提供することもできます。</p><p>次のYAMLは、Basic authentication Secretの設定例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-basic-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/basic-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>admin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>t0p-Secret<span style=color:#bbb>
</span></span></span></code></pre></div><p>Basic認証Secret型は、ユーザーの便宜のためにのみ提供されています。Basic認証に使用される資格情報の<code>Opaque</code>を作成できます。
ただし、組み込みのSecret型を使用すると、認証の形式を統一するのに役立ち、APIserverは必要なキーがSecret configurationで提供されているかどうかを確認します。</p><h3 id=ssh-authentication-secrets>SSH authentication secrets</h3><p>組み込みのタイプ<code>kubernetes.io/ssh-auth</code>は、SSH認証で使用されるデータを保存するために提供されています。このSecret型を使用する場合、使用するSSH認証として<code>data</code>（または<code>stringData</code>）フィールドに<code>ssh-privatekey</code>キーと値のペアを指定する必要があります。</p><p>次のYAMLはSSH authentication Secretの設定例です：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-ssh-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/ssh-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># the data is abbreviated in this example</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ssh-privatekey</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>     </span><span style=color:#bbb>     </span>MIIEpQIBAAKCAQEAulqb/Y ...<span style=color:#bbb>
</span></span></span></code></pre></div><p>SSH authentication Secret型は、ユーザーの便宜のためにのみ提供されています。
SSH認証に使用される資格情報の<code>Opaque</code>を作成できます。
ただし、組み込みのSecret型を使用すると、認証の形式を統一するのに役立ち、APIserverは必要なキーがSecret configurationで提供されているかどうかを確認します。</p><h3 id=tls-secrets>TLS secrets</h3><p>Kubernetesは、TLSに通常使用される証明書とそれに関連付けられたキーを保存するための組み込みのSecret型<code>kubernetes.io/tls</code>を提供します。このデータは、主にIngressリソースのTLS terminationで使用されますが、他のリソースで使用されることも、ワークロードによって直接使用されることもあります。
このSecret型を使用する場合、APIサーバーは各キーの値を実際には検証しませんが、<code>tls.key</code>および<code>tls.crt</code>キーをSecret configurationの<code>data</code>（または<code>stringData</code>）フィールドに指定する必要があります。</p><p>次のYAMLはTLS Secretの設定例です：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># the data is abbreviated in this example</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIC2DCCAcCgAwIBAgIBATANBgkqh ...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...<span style=color:#bbb>
</span></span></span></code></pre></div><p>TLS Secret型は、ユーザーの便宜のために提供されています。 TLSサーバーやクライアントに使用される資格情報の<code>Opaque</code>を作成できます。ただし、組み込みのSecret型を使用すると、プロジェクトでSecret形式の一貫性を確保できます。APIserverは、必要なキーがSecret configurationで提供されているかどうかを確認します。</p><p><code>kubectl</code>を使用してTLS Secretを作成する場合、次の例に示すように<code>tls</code>サブコマンドを使用できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls my-tls-secret <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --cert<span style=color:#666>=</span>path/to/cert/file <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --key<span style=color:#666>=</span>path/to/key/file
</span></span></code></pre></div><p>公開鍵と秘密鍵のペアは、事前に存在している必要があります。<code>--cert</code>の公開鍵証明書は.PEMエンコード（Base64エンコードDER形式）であり、<code>--key</code>の指定された秘密鍵と一致する必要があります。
秘密鍵は、一般にPEM秘密鍵形式と呼ばれる暗号化されていない形式である必要があります。どちらの場合も、PEMの最初と最後の行（たとえば、<code>-------- BEGIN CERTIFICATE -----</code>と<code>------- END CERTIFICATE ----</code>）は含まれて<em>いません</em>。</p><h3 id=bootstrap-token-secrets>Bootstrap token Secrets</h3><p>Bootstrap token Secretは、Secretの<code>type</code>を<code>bootstrap.kubernetes.io/token</code>に明示的に指定することで作成できます。このタイプのSecretは、ノードのブートストラッププロセス中に使用されるトークン用に設計されています。よく知られているConfigMapに署名するために使用されるトークンを格納します。</p><p>Bootstrap token Secretは通常、<code>kube-system</code>namespaceで作成され<code>bootstrap-token-&lt;token-id></code>の形式で名前が付けられます。ここで<code>&lt;token-id></code>はトークンIDの6文字の文字列です。</p><p>Kubernetesマニフェストとして、Bootstrap token Secretは次のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>c3lzdGVtOmJvb3RzdHJhcHBlcnM6a3ViZWFkbTpkZWZhdWx0LW5vZGUtdG9rZW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>MjAyMC0wOS0xM1QwNDozOToxMFo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>NWVtaXRq<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>a3E0Z2lodnN6emduMXAwcg==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></span></span></code></pre></div><p>Bootstrap type Secretには、<code>data</code>で指定された次のキーがあります。</p><ul><li><code>token_id</code>：トークン識別子としてのランダムな6文字の文字列。必須。</li><li><code>token-secret</code>：実際のtoken secretとしてのランダムな16文字の文字列。必須。</li><li><code>description</code>：トークンの使用目的を説明する人間が読める文字列。オプション。</li><li><code>expiration</code>：トークンの有効期限を指定するRFC3339を使用した絶対UTC時間。オプション。</li><li><code>usage-bootstrap-&lt;usage></code>：Bootstrap tokenの追加の使用法を示すブールフラグ。</li><li><code>auth-extra-groups</code>：<code>system：bootstrappers</code>グループに加えて認証されるグループ名のコンマ区切りのリスト。</li></ul><p>上記のYAMLは、値がすべてbase64でエンコードされた文字列であるため、分かりづらく見えるかもしれません。実際には、次のYAMLを使用して同一のSecretを作成できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Note how the Secret is named</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># A bootstrap token Secret usually resides in the kube-system namespace</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;system:bootstrappers:kubeadm:default-node-token&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-09-13T04:39:10Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># This token ID is used in the name</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5emitj&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kq4gihvszzgn1p0r&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># This token can be used for authentication</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># and it can be used for signing</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=secretの作成>Secretの作成</h2><p>Secretを作成するには、いくつかのオプションがあります。</p><ul><li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-kubectl/>create Secret using <code>kubectl</code> command</a></li><li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-config-file/>create Secret from config file</a></li><li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-kustomize/>create Secret using kustomize</a></li></ul><h2 id=secretの編集>Secretの編集</h2><p>既存のSecretは次のコマンドで編集することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit secrets mysecret
</span></span></code></pre></div><p>デフォルトに設定されたエディターが開かれ、<code>data</code>フィールドのBase64でエンコードされたSecretの値を編集することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># Please edit the object below. Lines beginning with a &#39;#&#39; will be ignored,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># and an empty file will abort the edit. If an error occurs while saving this file will be</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># reopened with the relevant failures.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>{<span style=color:#bbb> </span>... }<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-01-22T18:41:56Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;164619&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>cfee02d6-c137-11e5-8d73-42010af00002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=secretの使用>Secretの使用</h2><p>Podの中のコンテナがSecretを使うために、データボリュームとしてマウントしたり、<a class=glossary-tooltip title='Container environment variables are name=value pairs that provide useful information into containers running in a Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment/ target=_blank aria-label=環境変数>環境変数</a>として値を参照できるようにできます。
Secretは直接Podが参照できるようにはされず、システムの別の部分に使われることもあります。
例えば、Secretはあなたに代わってシステムの他の部分が外部のシステムとやりとりするために使う機密情報を保持することもあります。</p><h3 id=secretをファイルとしてpodから利用する>SecretをファイルとしてPodから利用する</h3><p>PodのボリュームとしてSecretを使うには、</p><ol><li>Secretを作成するか既存のものを使用します。複数のPodが同一のSecretを参照することができます。</li><li>ボリュームを追加するため、Podの定義の<code>.spec.volumes[]</code>以下を書き換えます。ボリュームに命名し、<code>.spec.volumes[].secret.secretName</code>フィールドはSecretオブジェクトの名称と同一にします。</li><li>Secretを必要とするそれぞれのコンテナに<code>.spec.containers[].volumeMounts[]</code>を追加します。<code>.spec.containers[].volumeMounts[].readOnly = true</code>を指定して<code>.spec.containers[].volumeMounts[].mountPath</code>をSecretをマウントする未使用のディレクトリ名にします。</li><li>イメージやコマンドラインを変更し、プログラムがそのディレクトリを参照するようにします。連想配列<code>data</code>のキーは<code>mountPath</code>以下のファイル名になります。</li></ol><p>これはSecretをボリュームとしてマウントするPodの例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span></code></pre></div><p>使用したいSecretはそれぞれ<code>.spec.volumes</code>の中で参照されている必要があります。</p><p>Podに複数のコンテナがある場合、それぞれのコンテナが<code>volumeMounts</code>ブロックを必要としますが、<code>.spec.volumes</code>はSecret1つあたり1つで十分です。</p><p>多くのファイルを一つのSecretにまとめることも、多くのSecretを使うことも、便利な方を採ることができます。</p><h4 id=secretのキーの特定のパスへの割り当て>Secretのキーの特定のパスへの割り当て</h4><p>Secretのキーが割り当てられるパスを制御することができます。
それぞれのキーがターゲットとするパスは<code>.spec.volumes[].secret.items</code>フィールドによって指定できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span></code></pre></div><p>次のような挙動をします。</p><ul><li><code>username</code>は<code>/etc/foo/username</code>の代わりに<code>/etc/foo/my-group/my-username</code>の元に格納されます。</li><li><code>password</code>は現れません。</li></ul><p><code>.spec.volumes[].secret.items</code>が使われるときは、<code>items</code>の中で指定されたキーのみが現れます。
Secretの中の全てのキーを使用したい場合は、<code>items</code>フィールドに全て列挙する必要があります。
列挙されたキーは対応するSecretに存在する必要があり、そうでなければボリュームは生成されません。</p><h4 id=secretファイルのパーミッション>Secretファイルのパーミッション</h4><p>単一のSecretキーに対して、ファイルアクセスパーミッションビットを指定することができます。
パーミッションを指定しない場合、デフォルトで<code>0644</code>が使われます。
Secretボリューム全体のデフォルトモードを指定し、必要に応じてキー単位で上書きすることもできます。</p><p>例えば、次のようにしてデフォルトモードを指定できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>0400</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Secretは<code>/etc/foo</code>にマウントされ、Secretボリュームが生成する全てのファイルはパーミッション<code>0400</code>に設定されます。</p><p>JSONの仕様は8進数の記述に対応していないため、パーミッション0400を示す値として256を使用することに注意が必要です。
Podの定義にJSONではなくYAMLを使う場合は、パーミッションを指定するためにより自然な8進表記を使うことができます。</p><p><code>kubectl exec</code>を使ってPodに入るときは、期待したファイルモードを知るためにシンボリックリンクを辿る必要があることに注意してください。</p><p>例として、PodのSecretのファイルモードを確認します。</p><pre tabindex=0><code>kubectl exec mypod -it sh

cd /etc/foo
ls -l
</code></pre><p>出力は次のようになります。</p><pre tabindex=0><code>total 0
lrwxrwxrwx 1 root root 15 May 18 00:18 password -&gt; ..data/password
lrwxrwxrwx 1 root root 15 May 18 00:18 username -&gt; ..data/username
</code></pre><p>正しいファイルモードを知るためにシンボリックリンクを辿ります。</p><pre tabindex=0><code>cd /etc/foo/..data
ls -l
</code></pre><p>出力は次のようになります。</p><pre tabindex=0><code>total 8
-r-------- 1 root root 12 May 18 00:18 password
-r-------- 1 root root  5 May 18 00:18 username
</code></pre><p>前の例のようにマッピングを使い、ファイルごとに異なるパーミッションを指定することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>0777</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>この例では、ファイル<code>/etc/foo/my-group/my-username</code>のパーミッションは<code>0777</code>になります。
JSONを使う場合は、JSONの制約により10進表記の<code>511</code>と記述する必要があります。</p><p>後で参照する場合、このパーミッションの値は10進表記で表示されることがあることに注意してください。</p><h4 id=secretの値のボリュームによる利用>Secretの値のボリュームによる利用</h4><p>Secretのボリュームがマウントされたコンテナからは、Secretのキーはファイル名として、Secretの値はBase64デコードされ、それらのファイルに格納されます。
上記の例のコンテナの中でコマンドを実行した結果を示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls /etc/foo/
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>username
password
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/username
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/password
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><p>コンテナ内のプログラムはファイルからSecretの内容を読み取る責務を持ちます。</p><h4 id=マウントされたsecretの自動更新>マウントされたSecretの自動更新</h4><p>ボリュームとして使用されているSecretが更新されると、やがて割り当てられたキーも同様に更新されます。
kubeletは定期的な同期のたびにマウントされたSecretが新しいかどうかを確認します。
しかしながら、kubeletはSecretの現在の値の取得にローカルキャッシュを使用します。
このキャッシュは<a href=https://github.com/kubernetes/kubernetes/blob/main/staging/src/k8s.io/kubelet/config/v1beta1/types.go>KubeletConfiguration struct</a>内の<code>ConfigMapAndSecretChangeDetectionStrategy</code>フィールドによって設定可能です。
Secretはwatch（デフォルト）、TTLベース、単に全てのリクエストをAPIサーバーへリダイレクトすることのいずれかによって伝搬します。
結果として、Secretが更新された時点からPodに新しいキーが反映されるまでの遅延時間の合計は、kubeletの同期間隔 + キャッシュの伝搬遅延となります。
キャッシュの遅延は、キャッシュの種別により、それぞれwatchの伝搬遅延、キャッシュのTTL、0になります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Secretを<a href=/docs/concepts/storage/volumes#using-subpath>subPath</a>を指定してボリュームにマウントしているコンテナには、Secretの更新が反映されません。</div><h3 id=using-secrets-as-environment-variables>Secretを環境変数として使用する</h3><p>SecretをPodの<a class=glossary-tooltip title='Container environment variables are name=value pairs that provide useful information into containers running in a Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment/ target=_blank aria-label=環境変数>環境変数</a>として使用するには、</p><ol><li>Secretを作成するか既存のものを使います。複数のPodが同一のSecretを参照することができます。</li><li>Podの定義を変更し、Secretを使用したいコンテナごとにSecretのキーと割り当てたい環境変数を指定します。Secretキーを利用する環境変数は<code>env[].valueFrom.secretKeyRef</code>にSecretの名前とキーを指定すべきです。</li><li>イメージまたはコマンドライン（もしくはその両方）を変更し、プログラムが指定した環境変数を参照するようにします。</li></ol><p>Secretを環境変数で参照するPodの例を示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-env-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mycontainer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=環境変数からのsecretの値の利用>環境変数からのSecretの値の利用</h4><p>Secretを環境変数として利用するコンテナの内部では、Secretのキーは一般の環境変数名として現れ、値はBase64デコードされた状態で保持されます。</p><p>上記の例のコンテナの内部でコマンドを実行した結果の例を示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_USERNAME</span>
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_PASSWORD</span>
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><h2 id=secret-immutable>Immutable Secrets</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p>Kubernetesベータ機能<em>ImmutableSecrets and ConfigMaps</em>は、個々のSecretsとConfigMapsをimutableとして設定するオプションを提供します。Secret（少なくとも数万の、SecretからPodへの一意のマウント）を広範囲に使用するクラスターの場合、データの変更を防ぐことには次の利点があります。</p><ul><li>アプリケーションの停止を引き起こす可能性のある偶発的な（または不要な）更新からユーザーを保護します</li><li>imutableとしてマークされたSecretのウォッチを閉じることで、kube-apiserverの負荷を大幅に削減することができ、クラスターのパフォーマンスを向上させます。</li></ul><p>この機能は、<code>ImmutableEphemeralVolumes</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>によって制御されます。これは、v1.19以降デフォルトで有効になっています。<code>immutable</code>フィールドを<code>true</code>に設定することで、imutableのSecretを作成できます。例えば、</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> SecretまたはConfigMapがimutableとしてマークされると、この変更を元に戻したり、<code>data</code>フィールドの内容を変更したりすることは<em>できません</em>。Secretを削除して再作成することしかできません。
既存のPodは、削除されたSecretへのマウントポイントを維持します。これらのPodを再作成することをお勧めします。</div><h3 id=using-imagepullsecrets>imagePullSecretsを使用する</h3><p><code>imagePullSecrets</code>フィールドは同一のネームスペース内のSecretの参照のリストです。
kubeletにDockerやその他のイメージレジストリのパスワードを渡すために、<code>imagePullSecrets</code>にそれを含むSecretを指定することができます。
kubeletはこの情報をPodのためにプライベートイメージをpullするために使います。
<code>imagePullSecrets</code>の詳細は<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec API</a>を参照してください。</p><h4 id=imagepullsecretを手動で指定する>imagePullSecretを手動で指定する</h4><p><code>ImagePullSecrets</code>の指定の方法は<a href=/ja/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>コンテナイメージのドキュメント</a>に記載されています。</p><h3 id=imagepullsecretsが自動的にアタッチされるようにする>imagePullSecretsが自動的にアタッチされるようにする</h3><p><code>imagePullSecrets</code>を手動で作成し、サービスアカウントから参照することができます。
サービスアカウントが指定されるまたはデフォルトでサービスアカウントが設定されたPodは、サービスアカウントが持つ<code>imagePullSecrets</code>フィールドを得ます。
詳細な手順の説明は<a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>サービスアカウントへのImagePullSecretsの追加</a>を参照してください。</p><h3 id=手動で作成されたsecretの自動的なマウント>手動で作成されたSecretの自動的なマウント</h3><p>手動で作成されたSecret（例えばGitHubアカウントへのアクセスに使うトークンを含む）はサービスアカウントを基に自動的にアタッチすることができます。
詳細な説明は<a href=/docs/tasks/inject-data-application/podpreset/>PodPresetを使ったPodへの情報の注入</a>を参照してください。</p><h2 id=詳細>詳細</h2><h3 id=制限事項>制限事項</h3><p>Secretボリュームは指定されたオブジェクト参照が実際に存在するSecretオブジェクトを指していることを保証するため検証されます。
そのため、Secretはそれを必要とするPodよりも先に作成する必要があります。</p><p>Secretリソースは<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>に属します。
Secretは同一のnamespaceに属するPodからのみ参照することができます。</p><p>各Secretは1MiBの容量制限があります。
これはAPIサーバーやkubeletのメモリーを枯渇するような非常に大きなSecretを作成することを避けるためです。
しかしながら、小さなSecretを多数作成することも同様にメモリーを枯渇させます。
Secretに起因するメモリー使用量をより網羅的に制限することは、将来計画されています。</p><p>kubeletがPodに対してSecretを使用するとき、APIサーバーから取得されたSecretのみをサポートします。
これには<code>kubectl</code>を利用して、またはレプリケーションコントローラーによって間接的に作成されたPodが含まれます。
kubeletの<code>--manifest-url</code>フラグ、<code>--config</code>フラグ、またはREST APIにより生成されたPodは含まれません
（これらはPodを生成するための一般的な方法ではありません）。</p><p>環境変数として使われるSecretは任意と指定されていない限り、それを使用するPodよりも先に作成される必要があります。
存在しないSecretへの参照はPodの起動を妨げます。</p><p>Secretに存在しないキーへの参照（<code>secretKeyRef</code>フィールド）はPodの起動を妨げます。</p><p>Secretを<code>envFrom</code>フィールドによって環境変数へ設定する場合、環境変数の名称として不適切なキーは飛ばされます。
Podは起動することを認められます。
このとき、reasonが<code>InvalidVariableNames</code>であるイベントが発生し、メッセージに飛ばされたキーのリストが含まれます。
この例では、Podは2つの不適切なキー<code>1badkey</code>と<code>2alsobad</code>を含むdefault/mysecretを参照しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names.
</code></pre><h3 id=secretとpodの相互作用>SecretとPodの相互作用</h3><p>Kubernetes APIがコールされてPodが生成されるとき、参照するSecretの存在は確認されません。
Podがスケジューリングされると、kubeletはSecretの値を取得しようとします。
Secretが存在しない、または一時的にAPIサーバーへの接続が途絶えたことにより取得できない場合、kubeletは定期的にリトライします。
kubeletはPodがまだ起動できない理由に関するイベントを報告します。
Secretが取得されると、kubeletはそのボリュームを作成しマウントします。
Podのボリュームが全てマウントされるまでは、Podのコンテナは起動することはありません。</p><h2 id=ユースケース>ユースケース</h2><h3 id=ユースケース-コンテナの環境変数として>ユースケース: コンテナの環境変数として</h3><p>Secretの作成</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>USER_NAME</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>PASSWORD</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f mysecret.yaml
</span></span></code></pre></div><p><code>envFrom</code>を使ってSecretの全てのデータをコンテナの環境変数として定義します。
SecretのキーはPod内の環境変数の名称になります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=ユースケース-ssh鍵を持つpod>ユースケース: SSH鍵を持つPod</h3><p>SSH鍵を含むSecretを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic ssh-key-secret --from-file<span style=color:#666>=</span>ssh-privatekey<span style=color:#666>=</span>/path/to/.ssh/id_rsa --from-file<span style=color:#666>=</span>ssh-publickey<span style=color:#666>=</span>/path/to/.ssh/id_rsa.pub
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>secret &#34;ssh-key-secret&#34; created
</code></pre><p>SSH鍵を含む<code>secretGenerator</code>フィールドを持つ<code>kustomization.yaml</code>を作成することもできます。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> 自身のSSH鍵を送る前に慎重に検討してください。クラスターの他のユーザーがSecretにアクセスできる可能性があります。
Kubernetesクラスターを共有しているユーザー全員がアクセスできるようにサービスアカウントを使用し、ユーザーが安全でない状態になったらアカウントを無効化することができます。</div><p>SSH鍵のSecretを参照し、ボリュームとして使用するPodを作成することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>ssh-key-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ssh-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mySshImage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>コンテナのコマンドを実行するときは、下記のパスにて鍵が利用可能です。</p><pre tabindex=0><code>/etc/secret-volume/ssh-publickey
/etc/secret-volume/ssh-privatekey
</code></pre><p>コンテナーはSecretのデータをSSH接続を確立するために使用することができます。</p><h3 id=ユースケース-本番-テスト用の認証情報を持つpod>ユースケース: 本番、テスト用の認証情報を持つPod</h3><p>あるPodは本番の認証情報のSecretを使用し、別のPodはテスト環境の認証情報のSecretを使用する例を示します。</p><p><code>secretGenerator</code>フィールドを持つ<code>kustomization.yaml</code>を作成するか、<code>kubectl create secret</code>を実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic prod-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>produser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>Y4nys7f11
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>secret &#34;prod-db-secret&#34; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic test-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>testuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>iluvtests
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>secret &#34;test-db-secret&#34; created
</code></pre><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p><code>$</code>、<code>\</code>、<code>*</code>、<code>=</code>、<code>!</code>のような特殊文字は<a href=https://ja.wikipedia.org/wiki/%E3%82%B7%E3%82%A7%E3%83%AB>シェル</a>に解釈されるので、エスケープする必要があります。
ほとんどのシェルではパスワードをエスケープする最も簡単な方法はシングルクォート(<code>'</code>)で囲むことです。
例えば、実際のパスワードが<code>S!B\*d$zDsb=</code>だとすると、実行すべきコマンドは下記のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic dev-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</span></span></code></pre></div><p><code>--from-file</code>によってファイルを指定する場合は、そのパスワードに含まれる特殊文字をエスケープする必要はありません。</p></div><p>Podを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: List
</span></span></span><span style=display:flex><span><span style=color:#b44>items:
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: prod-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: prod-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: prod-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: test-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: test-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: test-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>同じkustomization.yamlにPodを追記します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>下記のコマンドを実行して、APIサーバーにこれらのオブジェクト群を適用します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><p>両方のコンテナはそれぞれのファイルシステムに下記に示すファイルを持ちます。ファイルの値はそれぞれのコンテナの環境ごとに異なります。</p><pre tabindex=0><code>/etc/secret-volume/username
/etc/secret-volume/password
</code></pre><p>2つのPodの仕様の差分は1つのフィールドのみである点に留意してください。
これは共通のPodテンプレートから異なる能力を持つPodを作成することを容易にします。</p><p>2つのサービスアカウントを使用すると、ベースのPod仕様をさらに単純にすることができます。</p><ol><li><code>prod-user</code>と<code>prod-db-secret</code></li><li><code>test-user</code>と<code>test-db-secret</code></li></ol><p>簡略化されたPod仕様は次のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myClientImage<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=ユースケース-secretボリューム内のdotfile>ユースケース: Secretボリューム内のdotfile</h3><p>キーをドットから始めることで、データを「隠す」ことができます。
このキーはdotfileまたは「隠し」ファイルを示します。例えば、次のSecretは<code>secret-volume</code>ボリュームにマウントされます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.secret-file</span>:<span style=color:#bbb> </span>dmFsdWUtMg0KDQo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dotfiles-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-l&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>このボリュームは<code>.secret-file</code>という単一のファイルを含み、<code>dotfile-test-container</code>はこのファイルを<code>/etc/secret-volume/.secret-file</code>のパスに持ちます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ドットから始まるファイルは<code>ls -l</code>の出力では隠されるため、ディレクトリの内容を参照するときには<code>ls -la</code>を使わなければなりません。</div><h3 id=ユースケース-podの中の単一コンテナのみが参照できるsecret>ユースケース: Podの中の単一コンテナのみが参照できるSecret</h3><p>HTTPリクエストを扱い、複雑なビジネスロジックを処理し、メッセージにHMACによる認証コードを付与する必要のあるプログラムを考えます。
複雑なアプリケーションロジックを持つため、サーバーにリモートのファイルを読み出せる未知の脆弱性がある可能性があり、この脆弱性は攻撃者に秘密鍵を晒してしまいます。</p><p>このプログラムは2つのコンテナに含まれる2つのプロセスへと分割することができます。
フロントエンドのコンテナはユーザーとのやりとりやビジネスロジックを扱い、秘密鍵を参照することはできません。
署名コンテナは秘密鍵を参照することができて、単にフロントエンドからの署名リクエストに応答します。例えば、localhostの通信によって行います。</p><p>この分割する手法によって、攻撃者はアプリケーションサーバーを騙して任意の処理を実行させる必要があるため、ファイルの内容を読み出すより困難になります。</p><h2 id=ベストプラクティス>ベストプラクティス</h2><h3 id=secret-apiを使用するクライアント>Secret APIを使用するクライアント</h3><p>Secret APIとやりとりするアプリケーションをデプロイするときには、<a href=/ja/docs/reference/access-authn-authz/rbac/>RBAC</a>のような<a href=/docs/reference/access-authn-authz/authorization/>認可ポリシー</a>を使用して、アクセスを制限すべきです。
Secretは様々な種類の重要な値を保持することが多く、サービスアカウントのトークンのようにKubernetes内部や、外部のシステムで昇格できるものも多くあります。個々のアプリケーションが、Secretの能力について推論することができたとしても、同じネームスペースの別のアプリケーションがその推定を覆すこともあります。</p><p>これらの理由により、ネームスペース内のSecretに対する<code>watch</code>や<code>list</code>リクエストはかなり強力な能力であり、避けるべきです。Secretのリストを取得することはクライアントにネームスペース内の全てのSecretの値を調べさせることを認めるからです。クラスター内の全てのSecretに対する<code>watch</code>、<code>list</code>権限は最も特権的な、システムレベルのコンポーネントに限って認めるべきです。</p><p>Secret APIへのアクセスが必要なアプリケーションは、必要なSecretに対する<code>get</code>リクエストを発行すべきです。管理者は全てのSecretに対するアクセスは制限しつつ、アプリケーションが必要とする<a href=/docs/reference/access-authn-authz/rbac/#referring-to-resources>個々のインスタンスに対するアクセス許可</a>を与えることができます。</p><p><code>get</code>リクエストの繰り返しに対するパフォーマンスを向上するために、クライアントはSecretを参照するリソースを設計し、それを<code>watch</code>して、参照が変更されたときにSecretを再度リクエストすることができます。加えて、個々のリソースを<code>watch</code>することのできる<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/bulk_watch.md>"bulk watch" API</a>が提案されており、将来のKubernetesリリースにて利用可能になる可能性があります。</p><h2 id=セキュリティ特性>セキュリティ特性</h2><h3 id=保護>保護</h3><p>Secretはそれを使用するPodとは独立に作成されるので、Podを作ったり、参照したり、編集したりするワークフローにおいてSecretが晒されるリスクは軽減されています。
システムは、可能であればSecretの内容をディスクに書き込まないような、Secretについて追加の考慮も行っています。</p><p>Secretはノード上のPodが必要とした場合のみ送られます。
kubeletはSecretがディスクストレージに書き込まれないよう、<code>tmpfs</code>に保存します。
Secretを必要とするPodが削除されると、kubeletはSecretのローカルコピーも同様に削除します。</p><p>同一のノードにいくつかのPodに対する複数のSecretが存在することもあります。
しかし、コンテナから参照できるのはPodが要求したSecretのみです。
そのため、あるPodが他のPodのためのSecretにアクセスすることはできません。</p><p>Podに複数のコンテナが含まれることもあります。しかし、Podの各コンテナはコンテナ内からSecretを参照するために<code>volumeMounts</code>によってSecretボリュームを要求する必要があります。
これは<a href=#use-case-secret-visible-to-one-container-in-a-pod>Podレベルでのセキュリティ分離</a>を実装するのに便利です。</p><p>ほとんどのKubernetesディストリビューションにおいては、ユーザーとAPIサーバー間やAPIサーバーからkubelet間の通信はSSL/TLSで保護されています。
そのような経路で伝送される場合、Secretは保護されています。</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.13 [beta]</code></div><p><a href=/docs/tasks/administer-cluster/encrypt-data/>保存データの暗号化</a>を有効にして、Secretが<a class=glossary-tooltip title=一貫性、高可用性を持ったキーバリューストアで、Kubernetesの全てのクラスター情報の保存場所として利用されています。 data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>に平文で保存されないようにすることができます。</p><h3 id=リスク>リスク</h3><ul><li>APIサーバーでは、機密情報は<a class=glossary-tooltip title=一貫性、高可用性を持ったキーバリューストアで、Kubernetesの全てのクラスター情報の保存場所として利用されています。 data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>に保存されます。
そのため、<ul><li>管理者はクラスターデータの保存データの暗号化を有効にすべきです（v1.13以降が必要）。</li><li>管理者はetcdへのアクセスを管理ユーザに限定すべきです。</li><li>管理者はetcdで使用していたディスクを使用しなくなったときにはそれをワイプするか完全消去したくなるでしょう。</li><li>クラスターの中でetcdが動いている場合、管理者はetcdのピアツーピア通信がSSL/TLSを利用していることを確認すべきです。</li></ul></li><li>Secretをマニフェストファイル（JSONまたはYAML）を介して設定する場合、それはBase64エンコードされた機密情報を含んでいるので、ファイルを共有したりソースリポジトリに入れることは秘密が侵害されることを意味します。Base64エンコーディングは暗号化手段では <em>なく</em> 、平文と同様であると判断すべきです。</li><li>アプリケーションはボリュームからSecretの値を読み取った後も、その値を保護する必要があります。例えば意図せずログに出力する、信用できない相手に送信するようなことがないようにです。</li><li>Secretを利用するPodを作成できるユーザーはSecretの値を見ることができます。たとえAPIサーバーのポリシーがユーザーにSecretの読み取りを許可していなくても、ユーザーはSecretを晒すPodを実行することができます。</li><li>現在、任意のノードでルート権限を持つ人は誰でも、kubeletに偽装することで <em>任意の</em> SecretをAPIサーバーから読み取ることができます。
単一のノードのルート権限を不正に取得された場合の影響を抑えるため、実際に必要としているノードに対してのみSecretを送る機能が計画されています。</li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/tasks/configmap-secret/managing-secret-using-kubectl/><code>kubectl</code>を使用してSecretを管理する</a>方法を学ぶ</li><li><a href=/docs/tasks/configmap-secret/managing-secret-using-config-file/>config fileを使用してSecretを管理する</a>方法を学ぶ</li><li><a href=/docs/tasks/configmap-secret/managing-secret-using-kustomize/>kustomizeを使用してSecretを管理する</a>方法を学ぶ</li><li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/>SecretのAPIリファレンス</a>を読む</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-436057b96151ecb8a4a9a9f456b5d0fc>7.4 - コンテナのリソース管理</h1><p><a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>を指定する際に、<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>が必要とする各リソースの量をオプションで指定することができます。
指定する最も一般的なリソースはCPUとメモリ(RAM)ですが、他にもあります。</p><p>Pod内のコンテナのリソース<em>要求</em>を指定すると、スケジューラはこの情報を使用して、どのNodeにPodを配置するかを決定します。コンテナに<em>制限</em>ソースを指定すると、kubeletはその制限を適用し、実行中のコンテナが設定した制限を超えてリソースを使用することができないようにします。また、kubeletは、少なくともそのシステムリソースのうち、<em>要求</em>の量を、そのコンテナが使用するために特別に確保します。</p><h2 id=requests-and-limits>要求と制限</h2><p>Podが動作しているNodeに利用可能なリソースが十分にある場合、そのリソースの<code>要求</code>が指定するよりも多くのリソースをコンテナが使用することが許可されます
ただし、コンテナはそのリソースの<code>制限</code>を超えて使用することはできません。</p><p>たとえば、コンテナに256MiBの<code>メモリー</code>要求を設定し、そのコンテナが8GiBのメモリーを持つNodeにスケジュールされたPod内に存在し、他のPodが存在しない場合、コンテナはより多くのRAMを使用しようとする可能性があります。</p><p>そのコンテナに4GiBの<code>メモリー</code>制限を設定すると、kubelet(および<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>) が制限を適用します。ランタイムは、コンテナーが設定済みのリソース制限を超えて使用するのを防ぎます。例えば、コンテナ内のプロセスが、許容量を超えるメモリを消費しようとすると、システムカーネルは、メモリ不足(OOM)エラーで、割り当てを試みたプロセスを終了します。</p><p>制限は、違反が検出されるとシステムが介入するように事後的に、またはコンテナーが制限を超えないようにシステムが防ぐように強制的に、実装できます。
異なるランタイムは、同じ制限を実装するために異なる方法をとることができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> コンテナが自身のメモリー制限を指定しているが、メモリー要求を指定していない場合、Kubernetesは制限に一致するメモリー要求を自動的に割り当てます。同様に、コンテナが自身のCPU制限を指定しているが、CPU要求を指定していない場合、Kubernetesは制限に一致するCPU要求を自動的に割り当てます。</div><h2 id=resource-types>リソースタイプ</h2><p><em>CPU</em>と<em>メモリー</em>はいずれも<em>リソースタイプ</em>です。リソースタイプには基本単位があります。
CPUは計算処理を表し、<a href=#meaning-of-cpu>Kubernetes CPUs</a>の単位で指定されます。
メモリはバイト単位で指定されます。
Kubernetes v1.14以降を使用している場合は、<em>huge page</em>リソースを指定することができます。
Huge PageはLinux固有の機能であり、Nodeのカーネルはデフォルトのページサイズよりもはるかに大きいメモリブロックを割り当てます。</p><p>たとえば、デフォルトのページサイズが4KiBのシステムでは、<code>hugepages-2Mi: 80Mi</code>という制限を指定できます。
コンテナが40を超える2MiBの巨大ページ(合計80 MiB)を割り当てようとすると、その割り当ては失敗します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>hugepages-*</code>リソースをオーバーコミットすることはできません。
これは<code>memory</code>や<code>cpu</code>リソースとは異なります。</div><p>CPUとメモリーは、まとめて<em>コンピュートリソース</em>または単に<em>リソース</em>と呼ばれます。
コンピューティングリソースは、要求され、割り当てられ、消費され得る測定可能な量です。
それらは<a href=/ja/docs/concepts/overview/kubernetes-api/>API resources</a>とは異なります。
Podや<a href=/ja/docs/concepts/services-networking/service/>Services</a>などのAPIリソースは、Kubernetes APIサーバーを介して読み取りおよび変更できるオブジェクトです。</p><h2 id=resource-requests-and-limits-of-pod-and-container>Podとコンテナのリソース要求と制限</h2><p>Podの各コンテナは、次の1つ以上を指定できます。</p><ul><li><code>spec.containers[].resources.limits.cpu</code></li><li><code>spec.containers[].resources.limits.memory</code></li><li><code>spec.containers[].resources.limits.hugepages-&lt;size></code></li><li><code>spec.containers[].resources.requests.cpu</code></li><li><code>spec.containers[].resources.requests.memory</code></li><li><code>spec.containers[].resources.requests.hugepages-&lt;size></code></li></ul><p>要求と制限はそれぞれのコンテナでのみ指定できますが、このPodリソースの要求と制限の関係性について理解すると便利です。
特定のリソースタイプの<em>Podリソース要求/制限</em>は、Pod内の各コンテナに対するそのタイプのリソース要求/制限の合計です。</p><h2 id=resource-units-in-kubernetes>Kubernetesにおけるリソースの単位</h2><h3 id=meaning-of-cpu>CPUの意味</h3><p>CPUリソースの制限と要求は、<em>cpu</em>単位で測定されます。
Kuberenetesにおける1つのCPUは、クラウドプロバイダーの<strong>1 vCPU/コア</strong>およびベアメタルのインテルプロセッサーの<strong>1 ハイパースレッド</strong>に相当します。</p><p>要求を少数で指定することもできます。
<code>spec.containers[].resources.requests.cpu</code>が<code>0.5</code>のコンテナは、1CPUを要求するコンテナの半分のCPUが保証されます。
<code>0.1</code>という表現は<code>100m</code>という表現と同等であり、<code>100ミリCPU</code>と読み替えることができます。
<code>100ミリコア</code>という表現も、同じことを意味しています。
<code>0.1</code>のような小数点のある要求はAPIによって<code>100m</code>に変換され、<code>1m</code>より細かい精度は許可されません。
このため、<code>100m</code>の形式が推奨されます。</p><p>CPUは常に相対量としてではなく、絶対量として要求されます。
0.1は、シングルコア、デュアルコア、あるいは48コアマシンのどのCPUに対してでも、同一の量を要求します。</p><h3 id=meaning-of-memory>メモリーの意味</h3><p><code>メモリー</code>の制限と要求はバイト単位で測定されます。
E、P、T、G、M、Kのいずれかのサフィックスを使用して、メモリーを整数または固定小数点数として表すことができます。
また、Ei、Pi、Ti、Gi、Mi、Kiのような2の累乗の値を使用することもできます。
たとえば、以下はほぼ同じ値を表しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>128974848, 129e6, 129M, 123Mi
</span></span></code></pre></div><p>例を見てみましょう。
次のPodには2つのコンテナがあります。
各コンテナには、0.25cpuおよび64MiB(2<sup>26</sup>バイト)のメモリー要求と、0.5cpuおよび128MiBのメモリー制限があります
Podには0.5cpuと128MiBのメモリー要求があり、1cpuと256MiBのメモリ制限があると言えます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=how-pods-with-resource-requests-are-scheduled>リソース要求を含むPodがどのようにスケジュールされるか</h2><p>Podを作成すると、KubernetesスケジューラーはPodを実行するNodeを選択します。
各Nodeには、リソースタイプごとに最大容量があります。それは、Podに提供できるCPUとメモリの量です。
スケジューラーは、リソースタイプごとに、スケジュールされたコンテナのリソース要求の合計がNodeの容量より少ないことを確認します。
Node上の実際のメモリーまたはCPUリソースの使用率は非常に低いですが、容量チェックが失敗した場合、スケジューラーはNodeにPodを配置しないことに注意してください。
これにより、例えば日々のリソース要求のピーク時など、リソース利用が増加したときに、Nodeのリソース不足から保護されます。</p><h2 id=how-pods-with-resource-limits-are-run>リソース制限のあるPodがどのように実行されるか</h2><p>kubeletがPodのコンテナを開始すると、CPUとメモリーの制限がコンテナランタイムに渡されます。</p><p>Dockerを使用する場合:</p><ul><li><p><code>spec.containers[].resources.requests.cpu</code>は、潜在的に小数であるコア値に変換され、1024倍されます。
<code>docker run</code>コマンドの<a href=https://docs.docker.com/engine/reference/run/#cpu-share-constraint><code>--cpu-shares</code></a>フラグの値は、この数値と2のいずれか大きい方が用いられます。</p></li><li><p><code>spec.containers[].resources.limits.cpu</code>はミリコアの値に変換され、100倍されます。
結果の値は、コンテナが100ミリ秒ごとに使用できるCPU時間の合計です。
コンテナは、この間隔の間、CPU時間の占有率を超えて使用することはできません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> デフォルトのクォータ期間は100ミリ秒です。
CPUクォータの最小分解能は1ミリ秒です。</div></li><li><p><code>spec.containers[].resources.limits.memory</code>は整数に変換され、<code>docker run</code>コマンドの<a href=https://docs.docker.com/engine/reference/run/#/user-memory-constraints><code>--memory</code></a>フラグの値として使用されます。</p></li></ul><p>コンテナがメモリー制限を超過すると、終了する場合があります。
コンテナが再起動可能である場合、kubeletは他のタイプのランタイム障害と同様にコンテナを再起動します。</p><p>コンテナがメモリー要求を超過すると、Nodeのメモリーが不足するたびにそのPodが排出される可能性があります。</p><p>コンテナは、長時間にわたってCPU制限を超えることが許可される場合と許可されない場合があります。
ただし、CPUの使用量が多すぎるために、コンテナが強制終了されることはありません。</p><p>コンテナをスケジュールできないか、リソース制限が原因で強制終了されているかどうかを確認するには、<a href=#troubleshooting>トラブルシューティング</a>のセクションを参照してください。</p><h3 id=monitoring-compute-memory-resource-usage>コンピュートリソースとメモリーリソースの使用量を監視する</h3><p>Podのリソース使用量は、Podのステータスの一部として報告されます。</p><p>オプションの<a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>監視ツール</a>がクラスターにおいて利用可能な場合、Podのリソース使用量は<a href=/docs/tasks/debug-application-cluster/resource-metrics-pipeline/#the-metrics-api>メトリクスAPI</a>から直接、もしくは監視ツールから取得できます。</p><h2 id=local-ephemeral-storage>ローカルのエフェメラルストレージ</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code></div><p>Nodeには、ローカルに接続された書き込み可能なデバイス、または場合によってはRAMによってサポートされるローカルのエフェメラルストレージがあります。
"エフェメラル"とは、耐久性について長期的な保証がないことを意味します。</p><p>Podは、スクラッチ領域、キャッシュ、ログ用にエフェメラルなローカルストレージを使用しています。
kubeletは、ローカルのエフェメラルストレージを使用して、Podにスクラッチ領域を提供し、<a href=https://kubernetes.io/docs/concepts/storage/volumes/#emptydir><code>emptyDir</code></a> <a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>をコンテナにマウントできます。</p><p>また、kubeletはこの種類のストレージを使用して、<a href=/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>Nodeレベルのコンテナログ</a>、コンテナイメージ、実行中のコンテナの書き込み可能なレイヤーを保持します。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> Nodeに障害が発生すると、そのエフェメラルストレージ内のデータが失われる可能性があります。
アプリケーションは、ローカルのエフェメラルストレージにパフォーマンスのサービス品質保証(ディスクのIOPSなど)を期待することはできません。</div><p>ベータ版の機能として、Kubernetesでは、Podが消費するローカルのエフェメラルストレージの量を追跡、予約、制限することができます。</p><h3 id=configurations-for-local-ephemeral-storage>ローカルエフェメラルストレージの設定</h3><p>Kubernetesは、Node上のローカルエフェメラルストレージを構成する2つの方法をサポートしています。<ul class="nav nav-tabs" id=local-storage-configurations role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#local-storage-configurations-0 role=tab aria-controls=local-storage-configurations-0 aria-selected=true>シングルファイルシステム</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#local-storage-configurations-1 role=tab aria-controls=local-storage-configurations-1>2ファイルシステム</a></li></ul><div class=tab-content id=local-storage-configurations><div id=local-storage-configurations-0 class="tab-pane show active" role=tabpanel aria-labelledby=local-storage-configurations-0><p><p>この構成では、さまざまな種類のローカルのエフェメラルデータ(<code>emptyDir</code>ボリュームや、書き込み可能なレイヤー、コンテナイメージ、ログなど)をすべて1つのファイルシステムに配置します。
kubeletを構成する最も効果的な方法は、このファイルシステムをKubernetes(kubelet)データ専用にすることです。</p><p>kubeletは<a href=/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>Nodeレベルのコンテナログ</a>も書き込み、これらをエフェメラルなローカルストレージと同様に扱います。</p><p>kubeletは、設定されたログディレクトリ(デフォルトでは<code>/var/log</code>)内のファイルにログを書き出し、ローカルに保存された他のデータのベースディレクトリ(デフォルトでは<code>/var/lib/kubelet</code>)を持ちます。</p><p>通常、<code>/var/lib/kubelet</code>と<code>/var/log</code>はどちらもシステムルートファイルシステムにあり、kubeletはそのレイアウトを考慮して設計されています。</p><p>Nodeには、Kubernetesに使用されていない他のファイルシステムを好きなだけ持つことができます。</p></div><div id=local-storage-configurations-1 class=tab-pane role=tabpanel aria-labelledby=local-storage-configurations-1><p><p>Node上にファイルシステムがありますが、このファイルシステムは、ログや<code>emptyDir</code>ボリュームなど、実行中のPodの一時的なデータに使用されます。
このファイルシステムは、例えばKubernetesに関連しないシステムログなどの他のデータに使用することができ、ルートファイルシステムとすることさえ可能です。</p><p>また、kubeletは<a href=/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>ノードレベルのコンテナログ</a>を最初のファイルシステムに書き込み、これらをエフェメラルなローカルストレージと同様に扱います。</p><p>また、別の論理ストレージデバイスでバックアップされた別のファイルシステムを使用することもできます。
この設定では、コンテナイメージレイヤーと書き込み可能なレイヤーを配置するようにkubeletに指示するディレクトリは、この2番目のファイルシステム上にあります。</p><p>最初のファイルシステムは、コンテナイメージレイヤーや書き込み可能なレイヤーを保持していません。</p><p>Nodeには、Kubernetesに使用されていない他のファイルシステムを好きなだけ持つことができます。</p></div></div></p><p>kubeletは、ローカルストレージの使用量を測定できます。
これは、以下の条件で提供されます。</p><ul><li><code>LocalStorageCapacityIsolation</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>が有効になっています。(デフォルトでオンになっています。)</li><li>そして、ローカルのエフェメラルストレージ用にサポートされている構成の1つを使用してNodeをセットアップします。</li></ul><p>別の構成を使用している場合、kubeletはローカルのエフェメラルストレージにリソース制限を適用しません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> kubeletは、<code>tmpfs</code>のemptyDirボリュームをローカルのエフェメラルストレージとしてではなく、コンテナメモリーとして追跡します。</div><h3 id=setting-requests-and-limits-for-local-ephemeral-storage>ローカルのエフェメラルストレージの要求と制限設定</h3><p>ローカルのエフェメラルストレージを管理するためには <em>ephemeral-storage</em> パラメーターを利用することができます。
Podの各コンテナは、次の1つ以上を指定できます。</p><ul><li><code>spec.containers[].resources.limits.ephemeral-storage</code></li><li><code>spec.containers[].resources.requests.ephemeral-storage</code></li></ul><p><code>ephemeral-storage</code>の制限と要求はバイト単位で記します。
ストレージは、次のいずれかの接尾辞を使用して、通常の整数または固定小数点数として表すことができます。
E、P、T、G、M、K。Ei、Pi、Ti、Gi、Mi、Kiの2のべき乗を使用することもできます。
たとえば、以下はほぼ同じ値を表しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>128974848, 129e6, 129M, 123Mi
</span></span></code></pre></div><p>次の例では、Podに2つのコンテナがあります。
各コンテナには、2GiBのローカルのエフェメラルストレージ要求があります。
各コンテナには、4GiBのローカルのエフェメラルストレージ制限があります。
したがって、Podには4GiBのローカルのエフェメラルストレージの要求と、8GiBのローカルのエフェメラルストレージ制限があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=how-pods-with-ephemeral-storage-requests-are-scheduled>エフェメラルストレージを要求するPodのスケジュール方法</h3><p>Podを作成すると、KubernetesスケジューラーはPodを実行するNodeを選択します。
各Nodeには、Podに提供できるローカルのエフェメラルストレージの上限があります。
詳細については、<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>Node割り当て可能</a>を参照してください。</p><p>スケジューラーは、スケジュールされたコンテナのリソース要求の合計がNodeの容量より少なくなるようにします。</p><h3 id=resource-emphemeralstorage-consumption>エフェメラルストレージの消費管理</h3><p>kubeletがローカルのエフェメラルストレージをリソースとして管理している場合、kubeletはストレージの使用量を測定します</p><ul><li><em>tmpfs</em><code>emptyDir</code>ボリュームを除く<code>emptyDir</code>ボリューム</li><li>Nodeレベルのログを保持するディレクトリ</li><li>書き込み可能なコンテナレイヤー</li></ul><p>Podが許可するよりも多くのエフェメラルストレージを使用している場合、kubeletはPodの排出をトリガーするシグナルを設定します。</p><p>コンテナレベルの分離の場合、コンテナの書き込み可能なレイヤーとログ使用量がストレージの制限を超えると、kubeletはPodに排出のマークを付けます。</p><p>Podレベルの分離の場合、kubeletはPod内のコンテナの制限を合計し、Podの全体的なストレージ制限を計算します。
このケースでは、すべてのコンテナからのローカルのエフェメラルストレージの使用量とPodの<code>emptyDir</code>ボリュームの合計がPod全体のストレージ制限を超過する場合、
kubeletはPodをまた排出対象としてマークします。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong><p>kubeletがローカルのエフェメラルストレージを測定していない場合、ローカルストレージの制限を超えるPodは、ローカルストレージのリソース制限に違反しても排出されません。</p><p>ただし、書き込み可能なコンテナレイヤー、Nodeレベルのログ、または<code>emptyDir</code>ボリュームのファイルシステムスペースが少なくなると、Nodeはローカルストレージが不足していると汚染<a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taints>taints</a>し、この汚染は、汚染を特に許容しないPodの排出をトリガーします。</p><p>ローカルのエフェメラルストレージについては、サポートされている<a href=%EF%BC%83configurations-for-local-ephemeral-storage>設定</a>をご覧ください。</p></div><p>kubeletはPodストレージの使用状況を測定するさまざまな方法をサポートしています</p><ul class="nav nav-tabs" id=resource-emphemeralstorage-measurement role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#resource-emphemeralstorage-measurement-0 role=tab aria-controls=resource-emphemeralstorage-measurement-0 aria-selected=true>定期スキャン</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#resource-emphemeralstorage-measurement-1 role=tab aria-controls=resource-emphemeralstorage-measurement-1>ファイルシステムプロジェクトクォータ</a></li></ul><div class=tab-content id=resource-emphemeralstorage-measurement><div id=resource-emphemeralstorage-measurement-0 class="tab-pane show active" role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-0><p><p>kubeletは、<code>emptyDir</code>ボリューム、コンテナログディレクトリ、書き込み可能なコンテナレイヤーをスキャンする定期的なスケジュールチェックを実行します。</p><p>スキャンは、使用されているスペースの量を測定します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>このモードでは、kubeletは削除されたファイルのために、開いているファイルディスクリプタを追跡しません。</p><p>あなた(またはコンテナ)が<code>emptyDir</code>ボリューム内にファイルを作成した後、何かがそのファイルを開き、そのファイルが開かれたままの状態でファイルを削除した場合、削除されたファイルのinodeはそのファイルを閉じるまで残りますが、kubeletはそのスペースを使用中として分類しません。</p></div></div><div id=resource-emphemeralstorage-measurement-1 class=tab-pane role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-1><p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [alpha]</code></div><p>プロジェクトクォータは、ファイルシステム上のストレージ使用量を管理するためのオペレーティングシステムレベルの機能です。
Kubernetesでは、プロジェクトクォータを有効にしてストレージの使用状況を監視することができます。
ノード上の<code>emptyDir</code>ボリュームをバックアップしているファイルシステムがプロジェクトクォータをサポートしていることを確認してください。
例えば、XFSやext4fsはプロジェクトクォータを提供しています。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> プロジェクトクォータはストレージの使用状況を監視しますが、制限を強制するものではありません。</div><p>Kubernetesでは、<code>1048576</code>から始まるプロジェクトIDを使用します。
使用するプロジェクトIDは<code>/etc/projects</code>と<code>/etc/projid</code>に登録されます。
この範囲のプロジェクトIDをシステム上で別の目的で使用する場合は、それらのプロジェクトIDを<code>/etc/projects</code>と<code>/etc/projid</code>に登録し、
Kubernetesが使用しないようにする必要があります。</p><p>クォータはディレクトリスキャンよりも高速で正確です。
ディレクトリがプロジェクトに割り当てられると、ディレクトリ配下に作成されたファイルはすべてそのプロジェクト内に作成され、カーネルはそのプロジェクト内のファイルによって使用されているブロックの数を追跡するだけです。
ファイルが作成されて削除されても、開いているファイルディスクリプタがあれば、スペースを消費し続けます。
クォータトラッキングはそのスペースを正確に記録しますが、ディレクトリスキャンは削除されたファイルが使用するストレージを見落としてしまいます。</p><p>プロジェクトクォータを使用する場合は、次のことを行う必要があります。</p><ul><li><p>kubelet設定で、<code>LocalocalStorpactionCapactionIsolationFSQuotaMonitoring=true</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gate/>フィーチャーゲート</a>を有効にします。</p></li><li><p>ルートファイルシステム(またはオプションのランタイムファイルシステム))がプロジェクトクォータを有効にしていることを確認してください。
すべてのXFSファイルシステムはプロジェクトクォータをサポートしています。
ext4ファイルシステムでは、ファイルシステムがマウントされていない間は、プロジェクトクォータ追跡機能を有効にする必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># ext4の場合、/dev/block-deviceがマウントされていません</span>
</span></span><span style=display:flex><span>sudo tune2fs -O project -Q prjquota /dev/block-device
</span></span></code></pre></div></li><li><p>ルートファイルシステム(またはオプションのランタイムファイルシステム)がプロジェクトクォータを有効にしてマウントされていることを確認してください。
XFSとext4fsの両方で、マウントオプションは<code>prjquota</code>という名前になっています。</p></li></ul></div></div><h2 id=extended-resources>拡張リソース</h2><p>拡張リソースは<code>kubernetes.io</code>ドメインの外で完全に修飾されたリソース名です。
これにより、クラスタオペレータはKubernetesに組み込まれていないリソースをアドバタイズし、ユーザはそれを利用することができるようになります。</p><p>拡張リソースを使用するためには、2つのステップが必要です。
第一に、クラスタオペレーターは拡張リソースをアドバタイズする必要があります。
第二に、ユーザーはPodで拡張リソースを要求する必要があります。</p><h3 id=managing-extended-resources>拡張リソースの管理</h3><h4 id=node-level-extended-resources>Nodeレベルの拡張リソース</h4><p>Nodeレベルの拡張リソースはNodeに関連付けられています。</p><h5 id=device-plugin-managed-resources>デバイスプラグイン管理のリソース</h5><p>各Nodeにデバイスプラグインで管理されているリソースをアドバタイズする方法については、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a>を参照してください。</p><h5 id=other-resources>その他のリソース</h5><p>新しいNodeレベルの拡張リソースをアドバタイズするには、クラスタオペレータはAPIサーバに<code>PATCH</code>HTTPリクエストを送信し、クラスタ内のNodeの<code>status.capacity</code>に利用可能な量を指定します。
この操作の後、ノードの<code>status.capacity</code>には新しいリソースが含まれます。
<code>status.allocatable</code>フィールドは、kubeletによって非同期的に新しいリソースで自動的に更新されます。
スケジューラはPodの適合性を評価する際にNodeの<code>status.allocatable</code>値を使用するため、Nodeの容量に新しいリソースを追加してから、そのNodeでリソースのスケジューリングを要求する最初のPodが現れるまでには、短い遅延が生じる可能性があることに注意してください。</p><p><strong>例:</strong></p><p>以下は、<code>curl</code>を使用して、Masterが<code>k8s-master</code>であるNode<code>k8s-node-1</code>で5つの<code>example.com/foo</code>リソースを示すHTTPリクエストを作成する方法を示す例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1foo&#34;, &#34;value&#34;: &#34;5&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>http://k8s-master:8080/api/v1/nodes/k8s-node-1/status
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 上記のリクエストでは、<code>~1</code>はパッチパス内の文字<code>/</code>のエンコーディングです。
JSON-Patchの操作パス値は、JSON-Pointerとして解釈されます。
詳細については、<a href=https://tools.ietf.org/html/rfc6901#section-3>IETF RFC 6901, section 3</a>を参照してください。</div><h4 id=cluster-level-extended-resources>クラスターレベルの拡張リソース</h4><p>クラスターレベルの拡張リソースはノードに関連付けられていません。
これらは通常、リソース消費とリソースクォータを処理するスケジューラー拡張機能によって管理されます。</p><p><a href=https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/scheduler/api/v1/types.go#L31>スケジューラーポリシー構成</a>では。スケジューラー拡張機能によって扱われる拡張リソースを指定できます。</p><p><strong>例:</strong></p><p>次のスケジューラーポリシーの構成は、クラスターレベルの拡張リソース"example.com/foo"がスケジューラー拡張機能によって処理されることを示しています。</p><ul><li>スケジューラーは、Podが"example.com/foo"を要求した場合にのみ、Podをスケジューラー拡張機能に送信します。</li><li><code>ignoredByScheduler</code>フィールドは、スケジューラがその<code>PodFitsResources</code>述語で"example.com/foo"リソースをチェックしないことを指定します。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;extenders&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;urlPrefix&#34;</span>:<span style=color:#b44>&#34;&lt;extender-endpoint&gt;&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;bindVerb&#34;</span>: <span style=color:#b44>&#34;bind&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;managedResources&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example.com/foo&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;ignoredByScheduler&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=consuming-extended-resources>拡張リソースの消費</h3><p>ユーザーは、CPUやメモリのようにPodのスペックで拡張されたリソースを消費できます。
利用可能な量以上のリソースが同時にPodに割り当てられないように、スケジューラーがリソースアカウンティングを行います。</p><p>APIサーバーは、拡張リソースの量を整数の値で制限します。
有効な数量の例は、<code>3</code>、<code>3000m</code>、<code>3Ki</code>です。
無効な数量の例は、<code>0.5</code>、<code>1500m</code>です。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 拡張リソースは不透明な整数リソースを置き換えます。
ユーザーは、予約済みの<code>kubernetes.io</code>以外のドメイン名プレフィックスを使用できます。</div><p>Podで拡張リソースを消費するには、コンテナ名の<code>spec.containers[].resources.limits</code>マップにキーとしてリソース名を含めます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 拡張リソースはオーバーコミットできないので、コンテナスペックに要求と制限の両方が存在する場合は等しくなければなりません。</div><p>Podは、CPU、メモリ、拡張リソースを含むすべてのリソース要求が満たされた場合にのみスケジュールされます。
リソース要求が満たされない限り、Podは<code>PENDING</code>状態のままです。</p><p><strong>例:</strong></p><p>下のPodはCPUを2つ、"example.com/foo"(拡張リソース)を1つ要求しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myimage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=troubleshooting>トラブルシューティング</h2><h3 id=my-pods-are-pending-with-event-message-failedscheduling>failedSchedulingイベントメッセージが表示され、Podが保留中になる</h3><p>スケジューラーがPodが収容されるNodeを見つけられない場合、場所が見つかるまでPodはスケジュールされないままになります。
スケジューラーがPodの場所を見つけられないたびに、次のようなイベントが生成されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod frontend | grep -A <span style=color:#666>3</span> Events
</span></span></code></pre></div><pre tabindex=0><code>Events:
  FirstSeen LastSeen   Count  From          Subobject   PathReason      Message
  36s   5s     6      {scheduler }              FailedScheduling  Failed for reason PodExceedsFreeCPU and possibly others
</code></pre><p>前述の例では、"frontend"という名前のPodは、Node上のCPUリソースが不足しているためにスケジューリングに失敗しています。
同様のエラーメッセージは、メモリー不足による失敗を示唆することもあります(PodExceedsFreeMemory)。
一般的に、このタイプのメッセージでPodが保留されている場合は、いくつか試すべきことがあります。</p><ul><li>クラスタにNodeを追加します。</li><li>不要なポッドを終了して、保留中のPodのためのスペースを空けます。</li><li>PodがすべてのNodeよりも大きくないことを確認してください。
例えば、すべてのNodeが<code>cpu: 1</code>の容量を持っている場合、<code>cpu: 1.1</code>を要求するPodは決してスケジューリングされません。</li></ul><p>Nodeの容量や割り当て量は<code>kubectl describe nodes</code>コマンドで調べることができる。
例えば、以下のようになる。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe nodes e2e-test-node-pool-4lw4
</span></span></code></pre></div><pre tabindex=0><code>Name:            e2e-test-node-pool-4lw4
[ ... lines removed for clarity ...]
Capacity:
 cpu:                               2
 memory:                            7679792Ki
 pods:                              110
Allocatable:
 cpu:                               1800m
 memory:                            7474992Ki
 pods:                              110
[ ... lines removed for clarity ...]
Non-terminated Pods:        (5 in total)
  Namespace    Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits
  ---------    ----                                  ------------  ----------  ---------------  -------------
  kube-system  fluentd-gcp-v1.38-28bv1               100m (5%)     0 (0%)      200Mi (2%)       200Mi (2%)
  kube-system  kube-dns-3297075139-61lj3             260m (13%)    0 (0%)      100Mi (1%)       170Mi (2%)
  kube-system  kube-proxy-e2e-test-...               100m (5%)     0 (0%)      0 (0%)           0 (0%)
  kube-system  monitoring-influxdb-grafana-v4-z1m12  200m (10%)    200m (10%)  600Mi (8%)       600Mi (8%)
  kube-system  node-problem-detector-v0.1-fj7m3      20m (1%)      200m (10%)  20Mi (0%)        100Mi (1%)
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests    CPU Limits    Memory Requests    Memory Limits
  ------------    ----------    ---------------    -------------
  680m (34%)      400m (20%)    920Mi (12%)        1070Mi (14%)
</code></pre><p>前述の出力では、Podが1120m以上のCPUや6.23Gi以上のメモリーを要求した場合、そのPodはNodeに収まらないことがわかります。</p><p><code>Pods</code>セクションを見れば、どのPodがNode上でスペースを占有しているかがわかります。</p><p>システムデーモンが利用可能なリソースの一部を使用しているため、Podに利用可能なリソースの量はNodeの容量よりも少なくなっています。
<code>allocatable</code>フィールド<a href=/docs/reference/generated/kubernetes-api/v1.25/#nodestatus-v1-core>NodeStatus</a>は、Podに利用可能なリソースの量を与えます。
詳細については、<a href=https://git.k8s.io/design-proposals-archive/node/node-allocatable.md>ノード割り当て可能なリソース</a>を参照してください。</p><p><a href=/docs/concepts/policy/resource-quotas/>リソースクォータ</a>機能は、消費できるリソースの総量を制限するように設定することができます。
名前空間と組み合わせて使用すると、1つのチームがすべてのリソースを占有するのを防ぐことができます。</p><h3 id=my-container-is-terminated>コンテナが終了した</h3><p>コンテナはリソース不足のため、終了する可能性があります。
コンテナがリソース制限に達したために強制終了されているかどうかを確認するには、対象のPodで<code>kubectl describe pod</code>を呼び出します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod simmemleak-hra99
</span></span></code></pre></div><pre tabindex=0><code>Name:                           simmemleak-hra99
Namespace:                      default
Image(s):                       saadali/simmemleak
Node:                           kubernetes-node-tf0f/10.240.216.66
Labels:                         name=simmemleak
Status:                         Running
Reason:
Message:
IP:                             10.244.2.75
Replication Controllers:        simmemleak (1/1 replicas created)
Containers:
  simmemleak:
    Image:  saadali/simmemleak
    Limits:
      cpu:                      100m
      memory:                   50Mi
    State:                      Running
      Started:                  Tue, 07 Jul 2015 12:54:41 -0700
    Last Termination State:     Terminated
      Exit Code:                1
      Started:                  Fri, 07 Jul 2015 12:54:30 -0700
      Finished:                 Fri, 07 Jul 2015 12:54:33 -0700
    Ready:                      False
    Restart Count:              5
Conditions:
  Type      Status
  Ready     False
Events:
  FirstSeen                         LastSeen                         Count  From                              SubobjectPath                       Reason      Message
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {scheduler }                                                          scheduled   Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   pulled      Pod container image &#34;k8s.gcr.io/pause:0.8.0&#34; already present on machine
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   created     Created with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   started     Started with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    spec.containers{simmemleak}         created     Created with docker id 87348f12526a
</code></pre><p>上記の例では、<code>Restart Count：5</code>はPodの<code>simmemleak</code>コンテナが終了して、5回再起動したことを示しています。</p><p><code>-o go-template=...</code>オプションを指定して、<code>kubectl get pod</code>を呼び出し、以前に終了したコンテナのステータスを取得できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range.status.containerStatuses}}{{&#34;Container Name: &#34;}}{{.name}}{{&#34;\r\nLastState: &#34;}}{{.lastState}}{{end}}&#39;</span>  simmemleak-hra99
</span></span></code></pre></div><pre tabindex=0><code>Container Name: simmemleak
LastState: map[terminated:map[exitCode:137 reason:OOM Killed startedAt:2015-07-07T20:58:43Z finishedAt:2015-07-07T20:58:43Z containerID:docker://0e4095bba1feccdfe7ef9fb6ebffe972b4b14285d5acdec6f0d3ae8a22fad8b2]]
</code></pre><p><code>reason：OOM Killed</code>が原因でコンテナが終了したことがわかります。<code>OOM</code>はメモリー不足を表します。</p><h2 id=次の項目>次の項目</h2><ul><li><p><a href=/ja/docs/tasks/configure-pod-container/assign-memory-resource/>コンテナとPodへのメモリーリソースの割り当て</a>ハンズオンを行う</p></li><li><p><a href=/ja/docs/tasks/configure-pod-container/assign-cpu-resource/>コンテナとPodへのCPUリソースの割り当て</a>ハンズオンを行う</p></li><li><p>要求と制限の違いの詳細については、<a href=https://git.k8s.io/design-proposals-archive/node/resource-qos.md>リソースQoS</a>を参照する</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>コンテナ</a>APIリファレンスを読む</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#resourcerequirements-v1-core>リソース要求</a>APIリファレンスを読む</p></li><li><p>XFSの<a href=http://xfs.org/docs/xfsdocs-xml-dev/XFS_User_Guide/tmp/en-US/html/xfs-quotas.html>プロジェクトクォータ</a>について読む</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>7.5 - kubeconfigファイルを使用してクラスターアクセスを組織する</h1><p>kubeconfigを使用すると、クラスターに、ユーザー、名前空間、認証の仕組みに関する情報を組織できます。<code>kubectl</code>コマンドラインツールはkubeconfigファイルを使用してクラスターを選択するために必要な情報を見つけ、クラスターのAPIサーバーと通信します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> クラスターへのアクセスを設定するために使われるファイルは<em>kubeconfigファイル</em>と呼ばれます。これは設定ファイルを指すために使われる一般的な方法です。<code>kubeconfig</code>という名前を持つファイルが存在するという意味ではありません。</div><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> 信頼できるソースからのkubeconfigファイルのみを使用してください。特別に細工されたkubeconfigファイルを使用すると、悪意のあるコードの実行やファイルの公開につながる可能性があります。
信頼できないkubeconfigファイルを使用しなければならない場合は、シェルスクリプトを使用するのと同じように、まず最初に慎重に検査してください。</div><p>デフォルトでは、<code>kubectl</code>は<code>$HOME/.kube</code>ディレクトリ内にある<code>config</code>という名前のファイルを探します。<code>KUBECONFIG</code>環境変数を設定するか、<a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a>フラグで指定することで、別のkubeconfigファイルを指定することもできます。</p><p>kubeconfigファイルの作成と指定に関するステップバイステップの手順を知りたいときは、<a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters>複数のクラスターへのアクセスを設定する</a>を参照してください。</p><h2 id=複数のクラスター-ユーザ-認証の仕組みのサポート>複数のクラスター、ユーザ、認証の仕組みのサポート</h2><p>複数のクラスターを持っていて、ユーザーやコンポーネントがさまざまな方法で認証を行う次のような状況を考えてみます。</p><ul><li>実行中のkubeletが証明書を使用して認証を行う可能性がある。</li><li>ユーザーがトークンを使用して認証を行う可能性がある。</li><li>管理者が個別のユーザに提供する複数の証明書を持っている可能性がある。</li></ul><p>kubeconfigファイルを使用すると、クラスター、ユーザー、名前空間を組織化することができます。また、contextを定義することで、複数のクラスターや名前空間を素早く簡単に切り替えられます。</p><h2 id=context>Context</h2><p>kubeconfigファイルの<em>context</em>要素は、アクセスパラメーターを使いやすい名前でグループ化するために使われます。各contextは3つのパラメータ、cluster、namespace、userを持ちます。デフォルトでは、<code>kubectl</code>コマンドラインツールはクラスターとの通信に<em>current context</em>のパラメーターを使用します。</p><p>current contextを選択するには、以下のコマンドを使用します。</p><pre tabindex=0><code>kubectl config use-context
</code></pre><h2 id=kubeconfig環境変数>KUBECONFIG環境変数</h2><p><code>KUBECONFIG</code>環境変数には、kubeconfigファイルのリストを指定できます。LinuxとMacでは、リストはコロン区切りです。Windowsでは、セミコロン区切りです。<code>KUBECONFIG</code>環境変数は必須ではありません。<code>KUBECONFIG</code>環境変数が存在しない場合は、<code>kubectl</code>はデフォルトのkubeconfigファイルである<code>$HOME/.kube/config</code>を使用します。</p><p><code>KUBECONFIG</code>環境変数が存在する場合は、<code>kubectl</code>は<code>KUBECONFIG</code>環境変数にリストされているファイルをマージした結果を有効な設定として使用します。</p><h2 id=kubeconfigファイルのマージ>kubeconfigファイルのマージ</h2><p>設定ファイルを確認するには、以下のコマンドを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>上で説明したように、出力は1つのkubeconfigファイルから作られる場合も、複数のkubeconfigファイルをマージした結果となる場合もあります。</p><p><code>kubectl</code>がkubeconfigファイルをマージするときに使用するルールを以下に示します。</p><ol><li><p>もし<code>--kubeconfig</code>フラグが設定されていた場合、指定したファイルだけが使用されます。マージは行いません。このフラグに指定できるのは1つのファイルだけです。</p><p>そうでない場合、<code>KUBECONFIG</code>環境変数が設定されていた場合には、それをマージするべきファイルのリストとして使用します。<code>KUBECONFIG</code>環境変数にリストされたファイルのマージは、次のようなルールに従って行われます。</p><ul><li>空のファイルを無視する。</li><li>デシリアライズできない内容のファイルに対してエラーを出す。</li><li>特定の値やmapのキーを設定する最初のファイルが勝つ。</li><li>値やmapのキーは決して変更しない。
例: 最初のファイルが指定した<code>current-context</code>を保持する。
例: 2つのファイルが<code>red-user</code>を指定した場合、1つ目のファイルの<code>red-user</code>だけを使用する。もし2つ目のファイルの<code>red-user</code>以下に競合しないエントリーがあったとしても、それらは破棄する。</li></ul><p><code>KUBECONFIG</code>環境変数を設定する例については、<a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable>KUBECONFIG環境変数を設定する</a>を参照してください。</p><p>それ以外の場合は、デフォルトのkubeconfigファイル<code>$HOME/.kube/config</code>をマージせずに使用します。</p></li><li><p>以下のチェーンで最初に見つかったものをもとにして、使用するcontextを決定する。</p><ol><li><code>--context</code>コマンドラインフラグが存在すれば、それを使用する。</li><li>マージしたkubeconrfigファイルから<code>current-context</code>を使用する。</li></ol><p>この時点では、空のcontextも許容されます。</p></li><li><p>クラスターとユーザーを決定する。この時点では、contextである場合もそうでない場合もあります。以下のチェーンで最初に見つかったものをもとにして、クラスターとユーザーを決定します。この手順はユーザーとクラスターについてそれぞれ1回ずつ、合わせて2回実行されます。</p><ol><li>もし存在すれば、コマンドラインフラグ<code>--user</code>または<code>--cluster</code>を使用する。</li><li>もしcontextが空でなければ、contextからユーザーまたはクラスターを取得する。</li></ol><p>この時点では、ユーザーとクラスターは空である可能性があります。</p></li><li><p>使用する実際のクラスター情報を決定する。この時点では、クラスター情報は存在しない可能性があります。以下のチェーンで最初に見つかったものをもとにして、クラスター情報の各パーツをそれぞれを構築します。</p><ol><li>もし存在すれば、<code>--server</code>、<code>--certificate-authority</code>、<code>--insecure-skip-tls-verify</code>コマンドラインフラグを使用する。</li><li>もしマージしたkubeconfigファイルにクラスター情報の属性が存在すれば、それを使用する。</li><li>もしサーバーの場所が存在しなければ、マージは失敗する。</li></ol></li><li><p>使用する実際のユーザー情報を決定する。クラスター情報の場合と同じルールを使用して、ユーザー情報を構築します。ただし、ユーザーごとに許可される認証方法は1つだけです。</p><ol><li>もし存在すれば、<code>--client-certificate</code>、<code>--client-key</code>、<code>--username</code>、<code>--password</code>、<code>--token</code>コマンドラインフラグを使用する。</li><li>マージしたkubeconfigファイルの<code>user</code>フィールドを使用する。</li><li>もし2つの競合する方法が存在する場合、マージは失敗する。</li></ol></li><li><p>もし何らかの情報がまだ不足していれば、デフォルトの値を使用し、認証情報については場合によってはプロンプトを表示する。</p></li></ol><h2 id=ファイルリファレンス>ファイルリファレンス</h2><p>kubeconfigファイル内のファイルとパスのリファレンスは、kubeconfigファイルの位置からの相対パスで指定します。コマンドライン上のファイルのリファレンスは、現在のワーキングディレクトリからの相対パスです。<code>$HOME/.kube/config</code>内では、相対パスは相対のまま、絶対パスは絶対のまま保存されます。</p><h2 id=プロキシー>プロキシー</h2><p>kubeconfigファイルで<code>proxy-url</code>を使用すると、以下のようにクラスターごとにプロキシーを使用するように<code>kubectl</code>を設定することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>proxy-url</span>:<span style=color:#bbb> </span>http://proxy.example.org:3128<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://k8s.example.org/k8s/clusters/c-xxyyzz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>複数のクラスターへのアクセスを設定する</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ed4ae5e4344d619bc6df6e1278efae74>7.6 - Podの優先度とプリエンプション</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code></div><p><a href=/ja/docs/concepts/workloads/pods/>Pod</a>は <em>priority</em>（優先度）を持つことができます。
優先度は他のPodに対する相対的なPodの重要度を示します。
もしPodをスケジューリングできないときには、スケジューラーはそのPodをスケジューリングできるようにするため、優先度の低いPodをプリエンプトする（追い出す）ことを試みます。</p><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong><p>クラスターの全てのユーザーが信用されていない場合、悪意のあるユーザーが可能な範囲で最も高い優先度のPodを作成することが可能です。これは他のPodが追い出されたりスケジューリングできない状態を招きます。
管理者はResourceQuotaを使用して、ユーザーがPodを高い優先度で作成することを防ぐことができます。</p><p>詳細は<a href=/ja/docs/concepts/policy/resource-quotas/#limit-priority-class-consumption-by-default>デフォルトで優先度クラスの消費を制限する</a>
を参照してください。</p></div><h2 id=優先度とプリエンプションを使う方法>優先度とプリエンプションを使う方法</h2><p>優先度とプリエンプションを使うには、</p><ol><li><p>1つまたは複数の<a href=#priorityclass>PriorityClass</a>を追加します</p></li><li><p>追加したPriorityClassを<a href=#pod-priority><code>priorityClassName</code></a>に設定したPodを作成します。
もちろんPodを直接作る必要はありません。
一般的には<code>priorityClassName</code>をDeploymentのようなコレクションオブジェクトのPodテンプレートに追加します。</p></li></ol><p>これらの手順のより詳しい情報については、この先を読み進めてください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Kubernetesには最初から既に2つのPriorityClassが設定された状態になっています。
<code>system-cluster-critical</code>と<code>system-node-critical</code>です。
これらは汎用のクラスであり、<a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/>重要なコンポーネントが常に最初にスケジュールされることを保証する</a>ために使われます。</div><h2 id=priorityclass>PriorityClass</h2><p>PriorityClassはnamespaceによらないオブジェクトで、優先度クラスの名称から優先度を表す整数値への対応を定義します。
PriorityClassオブジェクトのメタデータの<code>name</code>フィールドにて名称を指定します。
値は<code>value</code>フィールドで指定し、必須です。
値が大きいほど、高い優先度を示します。
PriorityClassオブジェクトの名称は<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>として適切であり、かつ<code>system-</code>から始まってはいけません。</p><p>PriorityClassオブジェクトは10億以下の任意の32ビットの整数値を持つことができます。
それよりも大きな値は通常はプリエンプトや追い出すべきではない重要なシステム用のPodのために予約されています。
クラスターの管理者は割り当てたい優先度に対して、PriorityClassオブジェクトを1つずつ作成すべきです。</p><p>PriorityClassは任意でフィールド<code>globalDefault</code>と<code>description</code>を設定可能です。
<code>globalDefault</code>フィールドは<code>priorityClassName</code>が指定されないPodはこのPriorityClassを使うべきであることを示します。<code>globalDefault</code>がtrueに設定されたPriorityClassはシステムで一つのみ存在可能です。<code>globalDefault</code>が設定されたPriorityClassが存在しない場合は、<code>priorityClassName</code>が設定されていないPodの優先度は0に設定されます。</p><p><code>description</code>フィールドは任意の文字列です。クラスターの利用者に対して、PriorityClassをどのような時に使うべきか示すことを意図しています。</p><h3 id=podpriorityと既存のクラスターに関する注意>PodPriorityと既存のクラスターに関する注意</h3><ul><li><p>もし既存のクラスターをこの機能がない状態でアップグレードすると、既存のPodの優先度は実質的に0になります。</p></li><li><p><code>globalDefault</code>が<code>true</code>に設定されたPriorityClassを追加しても、既存のPodの優先度は変わりません。PriorityClassのそのような値は、PriorityClassが追加された以後に作成されたPodのみに適用されます。</p></li><li><p>PriorityClassを削除した場合、削除されたPriorityClassの名前を使用する既存のPodは変更されませんが、削除されたPriorityClassの名前を使うPodをそれ以上作成することはできなくなります。</p></li></ul><h3 id=priorityclassの例>PriorityClassの例</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;この優先度クラスはXYZサービスのPodに対してのみ使用すべきです。&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=non-preempting-priority-class>非プリエンプトのPriorityClass</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p><code>PreemptionPolicy: Never</code>と設定されたPodは、スケジューリングのキューにおいて他の優先度の低いPodよりも優先されますが、他のPodをプリエンプトすることはありません。
スケジューリングされるのを待つ非プリエンプトのPodは、リソースが十分に利用可能になるまでスケジューリングキューに残ります。
非プリエンプトのPodは、他のPodと同様に、スケジューラーのバックオフの対象になります。これは、スケジューラーがPodをスケジューリングしようと試みたものの失敗した場合、低い頻度で再試行するようにして、より優先度の低いPodが先にスケジューリングされることを許します。</p><p>非プリエンプトのPodは、他の優先度の高いPodにプリエンプトされる可能性はあります。</p><p><code>PreemptionPolicy</code>はデフォルトでは<code>PreemptLowerPriority</code>に設定されており、これが設定されているPodは優先度の低いPodをプリエンプトすることを許容します。これは既存のデフォルトの挙動です。
<code>PreemptionPolicy</code>を<code>Never</code>に設定すると、これが設定されたPodはプリエンプトを行わないようになります。</p><p>ユースケースの例として、データサイエンスの処理を挙げます。
ユーザーは他の処理よりも優先度を高くしたいジョブを追加できますが、そのとき既存の実行中のPodの処理結果をプリエンプトによって破棄させたくはありません。
<code>PreemptionPolicy: Never</code>が設定された優先度の高いジョブは、他の既にキューイングされたPodよりも先に、クラスターのリソースが「自然に」開放されたときにスケジューリングされます。</p><h3 id=非プリエンプトのpriorityclassの例>非プリエンプトのPriorityClassの例</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority-nonpreempting<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preemptionPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;この優先度クラスは他のPodをプリエンプトさせません。&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=pod-priority>Podの優先度</h2><p>一つ以上のPriorityClassがあれば、仕様にPriorityClassを指定したPodを作成することができるようになります。優先度のアドミッションコントローラーは<code>priorityClassName</code>フィールドを使用し、優先度の整数値を設定します。PriorityClassが見つからない場合、そのPodの作成は拒否されます。</p><p>下記のYAMLは上記の例で作成したPriorityClassを使用するPodの設定の例を示します。優先度のアドミッションコントローラーは仕様を確認し、このPodの優先度は1000000であると設定します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=スケジューリング順序におけるpodの優先度の効果>スケジューリング順序におけるPodの優先度の効果</h3><p>Podの優先度が有効な場合、スケジューラーは待機状態のPodをそれらの優先度順に並べ、スケジューリングキューにおいてより優先度の低いPodよりも前に来るようにします。その結果、その条件を満たしたときには優先度の高いPodは優先度の低いPodより早くスケジューリングされます。優先度の高いPodがスケジューリングできない場合は、スケジューラーは他の優先度の低いPodのスケジューリングも試みます。</p><h2 id=プリエンプション>プリエンプション</h2><p>Podが作成されると、スケジューリング待ちのキューに入り待機状態になります。スケジューラーはキューからPodを取り出し、ノードへのスケジューリングを試みます。Podに指定された条件を全て満たすノードが見つからない場合は、待機状態のPodのためにプリエンプションロジックが発動します。待機状態のPodをPと呼ぶことにしましょう。プリエンプションロジックはPよりも優先度の低いPodを一つ以上追い出せばPをスケジューリングできるようになるノードを探します。そのようなノードがあれば、優先度の低いPodはノードから追い出されます。Podが追い出された後に、Pはノードへスケジューリング可能になります。</p><h3 id=ユーザーへ開示される情報>ユーザーへ開示される情報</h3><p>Pod PがノードNのPodをプリエンプトした場合、ノードNの名称がPのステータスの<code>nominatedNodeName</code>フィールドに設定されます。このフィールドはスケジューラーがPod Pのために予約しているリソースの追跡を助け、ユーザーにクラスターにおけるプリエンプトに関する情報を与えます。</p><p>Pod Pは必ずしも「指名したノード」へスケジューリングされないことに注意してください。Podがプリエンプトされると、そのPodは終了までの猶予期間を得ます。スケジューラーがPodの終了を待つ間に他のノードが利用可能になると、スケジューラーは他のノードをPod Pのスケジューリング先にします。この結果、Podの<code>nominatedNodeName</code>と<code>nodeName</code>は必ずしも一致しません。また、スケジューラーがノードNのPodをプリエンプトさせた後に、Pod Pよりも優先度の高いPodが来た場合、スケジューラーはノードNをその新しい優先度の高いPodへ与えます。このような場合は、スケジューラーはPod Pの<code>nominatedNodeName</code>を消去します。これによって、スケジューラーはPod Pが他のノードのPodをプリエンプトさせられるようにします。</p><h3 id=プリエンプトの制限>プリエンプトの制限</h3><h4 id=プリエンプトされるpodの正常終了>プリエンプトされるPodの正常終了</h4><p>Podがプリエンプトされると、<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>猶予期間</a>が与えられます。</p><p>Podは作業を完了し、終了するために十分な時間が与えられます。仮にそうでない場合、強制終了されます。この猶予期間によって、スケジューラーがPodをプリエンプトした時刻と、待機状態のPod Pがノード Nにスケジュール可能になるまでの時刻の間に間が開きます。この間、スケジューラーは他の待機状態のPodをスケジュールしようと試みます。プリエンプトされたPodが終了したら、スケジューラーは待ち行列にあるPodをスケジューリングしようと試みます。そのため、Podがプリエンプトされる時刻と、Pがスケジュールされた時刻には間が開くことが一般的です。この間を最小にするには、優先度の低いPodの猶予期間を0または小さい値にする方法があります。</p><h4 id=poddisruptionbudgetは対応するが-保証されない>PodDisruptionBudgetは対応するが、保証されない</h4><p><a href=/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a> (PDB)は、アプリケーションのオーナーが冗長化されたアプリケーションのPodが意図的に中断される数の上限を設定できるようにするものです。KubernetesはPodをプリエンプトする際にPDBに対応しますが、PDBはベストエフォートで考慮します。スケジューラーはプリエンプトさせたとしてもPDBに違反しないPodを探します。そのようなPodが見つからない場合でもプリエンプションは実行され、PDBに反しますが優先度の低いPodが追い出されます。</p><h4 id=優先度の低いpodにおけるpod間のアフィニティ>優先度の低いPodにおけるPod間のアフィニティ</h4><p>次の条件が真の場合のみ、ノードはプリエンプションの候補に入ります。
「待機状態のPodよりも優先度の低いPodをノードから全て追い出したら、待機状態のPodをノードへスケジュールできるか」</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> プリエンプションは必ずしも優先度の低いPodを全て追い出しません。
優先度の低いPodを全て追い出さなくても待機状態のPodがスケジューリングできる場合、一部のPodのみ追い出されます。
このような場合であったとしても、上記の条件は真である必要があります。偽であれば、そのノードはプリエンプションの対象とはされません。</div><p>待機状態のPodが、優先度の低いPodとの間でPod間のアフィニティを持つ場合、Pod間のアフィニティはそれらの優先度の低いPodがなければ満たされません。この場合、スケジューラーはノードのどのPodもプリエンプトしようとはせず、代わりに他のノードを探します。スケジューラーは適切なノードを探せる場合と探せない場合があります。この場合、待機状態のPodがスケジューリングされる保証はありません。</p><p>この問題に対して推奨される解決策は、優先度が同一または高いPodに対してのみPod間のアフィニティを作成することです。</p><h4 id=複数ノードに対するプリエンプション>複数ノードに対するプリエンプション</h4><p>Pod PがノードNにスケジューリングできるよう、ノードNがプリエンプションの対象となったとします。
他のノードのPodがプリエンプトされた場合のみPが実行可能になることもあります。下記に例を示します。</p><ul><li>Pod PをノードNに配置することを検討します。</li><li>Pod QはノードNと同じゾーンにある別のノードで実行中です。</li><li>Pod Pはゾーンに対するQへのアンチアフィニティを持ちます (<code>topologyKey: topology.kubernetes.io/zone</code>)。</li><li>Pod Pと、ゾーン内の他のPodに対しては他のアンチアフィニティはない状態です。</li><li>Pod PをノードNへスケジューリングするには、Pod Qをプリエンプトすることが考えられますが、スケジューラーは複数ノードにわたるプリエンプションは行いません。そのため、Pod PはノードNへはスケジューリングできないとみなされます。</li></ul><p>Pod Qがそのノードから追い出されると、Podアンチアフィニティに違反しなくなるので、Pod PはノードNへスケジューリング可能になります。</p><p>複数ノードに対するプリエンプションに関しては、十分な需要があり、合理的な性能を持つアルゴリズムを見つけられた場合に、追加することを検討する可能性があります。</p><h2 id=トラブルシューティング>トラブルシューティング</h2><p>Podの優先度とプリエンプションは望まない副作用をもたらす可能性があります。
いくつかの起こりうる問題と、その対策について示します。</p><h3 id=podが不必要にプリエンプトされる>Podが不必要にプリエンプトされる</h3><p>プリエンプションは、リソースが不足している場合に優先度の高い待機状態のPodのためにクラスターの既存のPodを追い出します。
誤って高い優先度をPodに割り当てると、意図しない高い優先度のPodはクラスター内でプリエンプションを引き起こす可能性があります。Podの優先度はPodの仕様の<code>priorityClassName</code>フィールドにて指定されます。優先度を示す整数値へと変換された後、<code>podSpec</code>の<code>priority</code>へ設定されます。</p><p>この問題に対処するには、Podの<code>priorityClassName</code>をより低い優先度に変更するか、このフィールドを未設定にすることができます。<code>priorityClassName</code>が未設定の場合、デフォルトでは優先度は0とされます。</p><p>Podがプリエンプトされたとき、プリエンプトされたPodのイベントが記録されます。
プリエンプションはPodに必要なリソースがクラスターにない場合のみ起こるべきです。
このような場合、プリエンプションはプリエンプトされるPodよりも待機状態のPodの優先度が高い場合のみ発生します。
プリエンプションは待機状態のPodがない場合や待機状態のPodがプリエンプト対象のPod以下の優先度を持つ場合には決して発生しません。そのような状況でプリエンプションが発生した場合、問題を報告してください。</p><h3 id=podはプリエンプトされたが-プリエンプトさせたpodがスケジューリングされない>Podはプリエンプトされたが、プリエンプトさせたPodがスケジューリングされない</h3><p>Podがプリエンプトされると、それらのPodが要求した猶予期間が与えられます。そのデフォルトは30秒です。
Podがその期間内に終了しない場合、強制終了されます。プリエンプトされたPodがなくなれば、プリエンプトさせたPodはスケジューリング可能です。</p><p>プリエンプトさせたPodがプリエンプトされたPodの終了を待っている間に、より優先度の高いPodが同じノードに対して作成されることもあります。この場合、スケジューラーはプリエンプトさせたPodの代わりに優先度の高いPodをスケジューリングします。</p><p>これは予期された挙動です。優先度の高いPodは優先度の低いPodに取って代わります。</p><h3 id=優先度の高いpodが優先度の低いpodより先にプリエンプトされる>優先度の高いPodが優先度の低いPodより先にプリエンプトされる</h3><p>スケジューラーは待機状態のPodが実行可能なノードを探します。ノードが見つからない場合、スケジューラーは任意のノードから優先度の低いPodを追い出し、待機状態のPodのためのリソースを確保しようとします。
仮に優先度の低いPodが動いているノードが待機状態のPodを動かすために適切ではない場合、スケジューラーは他のノードで動いているPodと比べると、優先度の高いPodが動いているノードをプリエンプションの対象に選ぶことがあります。この場合もプリエンプトされるPodはプリエンプトを起こしたPodよりも優先度が低い必要があります。</p><p>複数のノードがプリエンプションの対象にできる場合、スケジューラーは優先度が最も低いPodのあるノードを選ぼうとします。しかし、そのようなPodがPodDisruptionBudgetを持っており、プリエンプトするとPDBに反する場合はスケジューラーは優先度の高いPodのあるノードを選ぶこともあります。</p><p>複数のノードがプリエンプションの対象として利用可能で、上記の状況に当てはまらない場合、スケジューラーは優先度の最も低いノードを選択します。</p><h2 id=interactions-of-pod-priority-and-qos>Podの優先度とQoSの相互作用</h2><p>Podの優先度と<a class=glossary-tooltip title='QoS Class (Quality of Service Class) provides a way for Kubernetes to classify pods within the cluster into several classes and make decisions about scheduling and eviction.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-qos-class' target=_blank aria-label=QoSクラス>QoSクラス</a>は直交する機能で、わずかに相互作用がありますが、デフォルトではQoSクラスによる優先度の設定の制約はありません。スケジューラーのプリエンプションのロジックはプリエンプションの対象を決めるときにQoSクラスは考慮しません。
プリエンプションはPodの優先度を考慮し、優先度が最も低いものを候補とします。より優先度の高いPodは優先度の低いPodを追い出すだけではプリエンプトを起こしたPodのスケジューリングに不十分な場合と、<code>PodDisruptionBudget</code>により優先度の低いPodが保護されている場合のみ対象になります。</p><p>QoSとPodの優先度の両方を考慮するコンポーネントは<a href=/docs/tasks/administer-cluster/out-of-resource/>リソース不足によりkubeletがPodを追い出す</a>のみです。
kubeletは追い出すPodの順位付けを次の順で行います。枯渇したリソースを要求以上に使用しているか、優先度、枯渇したリソースの消費量の複数のPodの要求に対する相対値。
詳細は<a href=/docs/tasks/administer-cluster/out-of-resource/#evicting-end-user-pods>エンドユーザーのPodの追い出し</a>を参照してください。</p><p>kubeletによるリソース不足時のPodの追い出しでは、リソースの消費が要求を超えないPodは追い出されません。優先度の低いPodのリソースの利用量がその要求を超えていなければ、追い出されることはありません。より優先度が高く、要求を超えてリソースを使用しているPodが追い出されます。</p><h2 id=次の項目>次の項目</h2><ul><li>PriorityClassと関連付けてResourceQuotaを使用することに関して <a href=/ja/docs/concepts/policy/resource-quotas/#limit-priority-class-consumption-by-default>デフォルトで優先度クラスの消費を制限する</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-712cb3c03ff14a39e5a83a6d9b71d203>8 - セキュリティ</h1><div class=lead>クラウドネイティブなワークロードをセキュアに維持するための概念</div></div><div class=td-content><h1 id=pg-1fb24c1dd155f43849da490a74c4b8c5>8.1 - Podセキュリティの標準</h1><p>Podに対するセキュリティの設定は通常<a href=/docs/tasks/configure-pod-container/security-context/>Security Context</a>を使用して適用されます。Security ContextはPod単位での特権やアクセスコントロールの定義を実現します。</p><p>クラスターにおけるSecurity Contextの強制やポリシーベースの定義は<a href=/docs/concepts/policy/pod-security-policy/>Pod Security Policy</a>によって実現されてきました。
<em>Pod Security Policy</em> はクラスターレベルのリソースで、Pod定義のセキュリティに関する設定を制御します。</p><p>しかし、PodSecurityPolicyを拡張したり代替する、ポリシーを強制するための多くの方法が生まれてきました。
このページの意図は、推奨されるPodのセキュリティプロファイルを特定の実装から切り離して詳しく説明することです。</p><h2 id=ポリシーの種別>ポリシーの種別</h2><p>まず、幅広いセキュリティの範囲をカバーできる、基礎となるポリシーの定義が必要です。
それらは強く制限をかけるものから自由度の高いものまでをカバーすべきです。</p><ul><li><strong><em>特権</em></strong> - 制限のかかっていないポリシーで、可能な限り幅広い権限を提供します。このポリシーは既知の特権昇格を認めます。</li><li><strong><em>ベースライン、デフォルト</em></strong> - 制限は最小限にされたポリシーですが、既知の特権昇格を防止します。デフォルト（最小の指定）のPod設定を許容します。</li><li><strong><em>制限</em></strong> - 厳しく制限されたポリシーで、Podを強化するための現在のベストプラクティスに沿っています。</li></ul><h2 id=ポリシー>ポリシー</h2><h3 id=特権>特権</h3><p>特権ポリシーは意図的に開放されていて、完全に制限がかけられていません。この種のポリシーは通常、特権ユーザーまたは信頼されたユーザーが管理する、システムまたはインフラレベルのワークロードに対して適用されることを意図しています。</p><p>特権ポリシーは制限がないことと定義されます。gatekeeperのようにデフォルトで許可される仕組みでは、特権プロファイルはポリシーを設定せず、何も制限を適用しないことにあたります。
一方で、Pod Security Policyのようにデフォルトで拒否される仕組みでは、特権ポリシーでは全ての制限を無効化してコントロールできるようにする必要があります。</p><h3 id=ベースライン-デフォルト>ベースライン、デフォルト</h3><p>ベースライン、デフォルトのプロファイルは一般的なコンテナ化されたランタイムに適用しやすく、かつ既知の特権昇格を防ぐことを意図しています。
このポリシーはクリティカルではないアプリケーションの運用者または開発者を対象にしています。
次の項目は強制、または無効化すべきです。</p><table><caption style=display:none>ベースラインポリシーの定義</caption><tbody><tr><td><strong>項目</strong></td><td><strong>ポリシー</strong></td></tr><tr><td>ホストのプロセス</td><td><p>Windows Podは、Windowsノードへの特権的なアクセスを可能にする<a href=/docs/tasks/configure-pod-container/create-hostprocess-pod>HostProcess</a>コンテナ</a>を実行する機能を提供します。ベースラインポリシーでは、ホストへの特権的なアクセスは禁止されています。HostProcess Podは、Kubernetes v1.22時点ではアルファ版の機能です。
ホストのネームスペースの共有は無効化すべきです。</p><p><strong>制限されるフィールド</strong></p><ul><li><code>spec.securityContext.windowsOptions.hostProcess</code></li><li><code>spec.containers[*].securityContext.windowsOptions.hostProcess</code></li><li><code>spec.initContainers[*].securityContext.windowsOptions.hostProcess</code></li><li><code>spec.ephemeralContainers[*].securityContext.windowsOptions.hostProcess</code></li></ul><p><strong>認められる値</strong></p><ul><li>Undefined/nil</li><li><code>false</code></li></ul></td></tr><tr><td>ホストのネームスペース</td><td>ホストのネームスペースの共有は無効化すべきです。<br><br><b>制限されるフィールド:</b><br>spec.hostNetwork<br>spec.hostPID<br>spec.hostIPC<br><br><b>認められる値:</b> false, Undefined/nil<br></td></tr><tr><td>特権コンテナ</td><td>特権を持つPodはほとんどのセキュリティ機構を無効化できるので、禁止すべきです。<br><br><b>制限されるフィールド:</b><br>spec.containers[*].securityContext.privileged<br>spec.initContainers[*].securityContext.privileged<br>spec.ephemeralContainers[*].securityContext.privileged<br><br><b>認められる値:</b> false, undefined/nil<br></td></tr><tr><td>ケーパビリティー</td><td><a href=https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities>デフォルト</a>よりも多くのケーパビリティーを与えることは禁止すべきです。<br><br><b>制限されるフィールド:</b><br>spec.containers[*].securityContext.capabilities.add<br>spec.initContainers[*].securityContext.capabilities.add<br>spec.ephemeralContainers[*].securityContext.capabilities.add<br><br><b>認められる値:</b>
Undefined/nil<br>AUDIT_WRITE<br>CHOWN<br>DAC_OVERRIDE<br>FOWNER<br>FSETID<br>KILL<br>MKNOD<br>NET_BIND_SERVICE<br>SETFCAP<br>SETGID<br>SETPCAP<br>SETUID<br>SYS_CHROOT<br></td></tr><tr><td>HostPathボリューム</td><td>HostPathボリュームは禁止すべきです。<br><br><b>制限されるフィールド:</b><br>spec.volumes[*].hostPath<br><br><b>認められる値:</b> undefined/nil<br></td></tr><tr><td>ホストのポート</td><td>HostPortは禁止するか、最小限の既知のリストに限定すべきです。<br><br><b>制限されるフィールド:</b><br>spec.containers[*].ports[*].hostPort<br>spec.initContainers[*].ports[*].hostPort<br>spec.ephemeralContainers[*].ports[*].hostPort<br><br><b>認められる値:</b> 0, undefined (または既知のリストに限定)<br></td></tr><tr><td>AppArmor<em>(任意)</em></td><td>サポートされるホストでは、AppArmorの'runtime/default'プロファイルがデフォルトで適用されます。デフォルトのポリシーはポリシーの上書きや無効化を防ぎ、許可されたポリシーのセットを上書きできないよう制限すべきです。<br><br><b>制限されるフィールド:</b><br>metadata.annotations['container.apparmor.security.beta.kubernetes.io/*']<br><br><b>認められる値:</b> 'runtime/default', undefined, localhost/*<br></td></tr><tr><td>SELinux <em>(任意)</em></td><td>SELinuxのオプションをカスタムで設定することは禁止すべきです。<br><br><b>制限されるフィールド:</b><br>spec.securityContext.seLinuxOptions<br>spec.containers[*].securityContext.seLinuxOptions<br>spec.initContainers[*].securityContext.seLinuxOptions<br>spec.ephemeralContainers[*].securityContext.seLinuxOptions.type<br><br><b>認められる値:</b>undefined/nil<br>Undefined/""<br>container_t<br>container_init_t<br>container_kvm_t<br><hr><br><b>制限されるフィールド:</b><br>spec.securityContext.seLinuxOptions.user<br>spec.containers[*].securityContext.seLinuxOptions.user<br>spec.initContainers[*].securityContext.seLinuxOptions.user<br>spec.ephemeralContainers[*].securityContext.seLinuxOptions.user<br>spec.securityContext.seLinuxOptions.role<br>spec.containers[*].securityContext.seLinuxOptions.role<br>spec.initContainers[*].securityContext.seLinuxOptions.role<br>spec.ephemeralContainers[*].securityContext.seLinuxOptions.role<br><br><b>認められる値:</b>undefined/nil<br>Undefined/""</td></tr><tr><td>/procマウントタイプ</td><td>攻撃対象を縮小するため/procのマスクを設定し、必須とすべきです。<br><br><b>制限されるフィールド:</b><br>spec.containers[*].securityContext.procMount<br>spec.initContainers[*].securityContext.procMount<br>spec.ephemeralContainers[*].securityContext.procMount<br><br><b>認められる値:</b>undefined/nil, 'Default'<br></td></tr><tr><td>Seccomp</td><td><p>Seccompプロファイルを明示的に<code>Unconfined</code>に設定することはできません。</p><p><strong>Restricted Fields</strong></p><ul><li><code>spec.securityContext.seccompProfile.type</code></li><li><code>spec.containers[*].securityContext.seccompProfile.type</code></li><li><code>spec.initContainers[*].securityContext.seccompProfile.type</code></li><li><code>spec.ephemeralContainers[*].securityContext.seccompProfile.type</code></li></ul><p><strong>Allowed Values</strong></p><ul><li>Undefined/nil</li><li><code>RuntimeDefault</code></li><li><code>Localhost</code></li></ul></td></tr><tr><td>Sysctl</td><td>Sysctlはセキュリティ機構を無効化したり、ホストの全てのコンテナに影響を与えたりすることが可能なので、「安全」なサブネットを除いては禁止すべきです。
コンテナまたはPodの中にsysctlがありネームスペースが分離されていて、同じノードの別のPodやプロセスから分離されている場合はsysctlは安全だと考えられます。<br><br><b>制限されるフィールド:</b><br>spec.securityContext.sysctls<br><br><b>認められる値:</b><br>kernel.shm_rmid_forced<br>net.ipv4.ip_local_port_range<br>net.ipv4.tcp_syncookies<br>net.ipv4.ping_group_range<br>undefined/空文字列<br></td></tr></tbody></table><h3 id=制限>制限</h3><p>制限ポリシーはいくらかの互換性を犠牲にして、Podを強化するためのベストプラクティスを強制することを意図しています。
セキュリティ上クリティカルなアプリケーションの運用者や開発者、また信頼度の低いユーザーも対象にしています。
下記の項目を強制、無効化すべきです。</p><table><caption style=display:none>制限ポリシーの定義</caption><tbody><tr><td><strong>項目</strong></td><td><strong>ポリシー</strong></td></tr><tr><td colspan=2><em>デフォルトプロファイルにある項目全て</em></td></tr><tr><td>Volumeタイプ</td><td>HostPathボリュームの制限に加え、制限プロファイルではコアでない種類のボリュームの利用をPersistentVolumeにより定義されたものに限定します。<br><br><b>制限されるフィールド:</b><br>spec.volumes[*].hostPath<br>spec.volumes[*].gcePersistentDisk<br>spec.volumes[*].awsElasticBlockStore<br>spec.volumes[*].gitRepo<br>spec.volumes[*].nfs<br>spec.volumes[*].iscsi<br>spec.volumes[*].glusterfs<br>spec.volumes[*].rbd<br>spec.volumes[*].flexVolume<br>spec.volumes[*].cinder<br>spec.volumes[*].cephfs<br>spec.volumes[*].flocker<br>spec.volumes[*].fc<br>spec.volumes[*].azureFile<br>spec.volumes[*].vsphereVolume<br>spec.volumes[*].quobyte<br>spec.volumes[*].azureDisk<br>spec.volumes[*].portworxVolume<br>spec.volumes[*].scaleIO<br>spec.volumes[*].storageos<br>spec.volumes[*].photonPersistentDisk<br><br><b>認められる値:</b> undefined/nil<br></td></tr><tr><td>特権昇格</td><td>特権昇格(ファイルモードのset-user-IDまたはset-group-IDのような方法による)は禁止すべきです。<br><br><b>制限されるフィールド:</b><br>spec.containers[*].securityContext.allowPrivilegeEscalation<br>spec.initContainers[*].securityContext.allowPrivilegeEscalation<br>spec.ephemeralContainers[*].securityContext.allowPrivilegeEscalation<br><br><b>認められる値:</b> false<br></td></tr><tr><td>root以外での実行</td><td>コンテナはroot以外のユーザーで実行する必要があります。<br><br><b>制限されるフィールド:</b><br>spec.securityContext.runAsNonRoot<br>spec.containers[*].securityContext.runAsNonRoot<br>spec.initContainers[*].securityContext.runAsNonRoot<br>spec.ephemeralContainers[*].securityContext.runAsNonRoot<br><br><b>認められる値:</b> true<br></td></tr><tr><td>root以外のグループ <em>(任意)</em></td><td>コンテナをrootのプライマリまたは補助GIDで実行することを禁止すべきです。<br><br><b>制限されるフィールド:</b><br>spec.securityContext.runAsGroup<br>spec.securityContext.supplementalGroups[*]<br>spec.securityContext.fsGroup<br>spec.containers[*].securityContext.runAsGroup<br>spec.initContainers[*].securityContext.runAsGroup<br><br><b>認められる値:</b><br>0以外<br>undefined / nil (`*.runAsGroup`を除く)<br></td></tr><tr><td>Seccomp</td><td>SeccompのRuntimeDefaultを必須とする、または特定の追加プロファイルを許可することが必要です。<br><br><b>制限されるフィールド:</b><br>spec.securityContext.seccompProfile.type<br>spec.containers[*].securityContext.seccompProfile<br>spec.initContainers[*].securityContext.seccompProfile<br><br><b>認められる値:</b><br>'runtime/default'<br>undefined / nil<br></td></tr><tr><td style=white-space:nowrap>Capabilities (v1.22+)</td><td><p>コンテナはすべてのケイパビリティを削除する必要があり、<code>NET_BIND_SERVICE</code>ケイパビリティを追加することだけが許可されています。</p><p><strong>Restricted Fields</strong></p><ul><li><code>spec.containers[*].securityContext.capabilities.drop</code></li><li><code>spec.initContainers[*].securityContext.capabilities.drop</code></li><li><code>spec.ephemeralContainers[*].securityContext.capabilities.drop</code></li></ul><p><strong>Allowed Values</strong></p><ul><li>Any list of capabilities that includes <code>ALL</code></li></ul><hr><p><strong>Restricted Fields</strong></p><ul><li><code>spec.containers[*].securityContext.capabilities.add</code></li><li><code>spec.initContainers[*].securityContext.capabilities.add</code></li><li><code>spec.ephemeralContainers[*].securityContext.capabilities.add</code></li></ul><p><strong>Allowed Values</strong></p><ul><li>Undefined/nil</li><li><code>NET_BIND_SERVICE</code></li></ul></td></tr></tbody></table><h2 id=ポリシーの実例>ポリシーの実例</h2><p>ポリシーの定義とポリシーの実装を切り離すことによって、ポリシーを強制する機構とは独立して、汎用的な理解や複数のクラスターにわたる共通言語とすることができます。</p><p>機構が成熟してきたら、ポリシーごとに下記に定義されます。それぞれのポリシーを強制する方法についてはここでは定義しません。</p><p><a href=/docs/concepts/policy/pod-security-policy/><strong>PodSecurityPolicy</strong></a></p><ul><li><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/privileged-psp.yaml>特権</a></li><li><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/baseline-psp.yaml>ベースライン</a></li><li><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml>制限</a></li></ul><h2 id=faq>FAQ</h2><h3 id=特権とデフォルトの間のプロファイルがないのはどうしてですか>特権とデフォルトの間のプロファイルがないのはどうしてですか?</h3><p>ここで定義されている3つのプロファイルは最も安全(制限)から最も安全ではない(特権)まで、直線的に段階が設定されており、幅広いワークロードをカバーしています。
ベースラインを超える特権が必要な場合、その多くはアプリケーションに特化しているため、その限られた要求に対して標準的なプロファイルを提供することはできません。
これは、このような場合に必ず特権プロファイルを使用すべきだという意味ではなく、場合に応じてポリシーを定義する必要があります。</p><p>将来、他のプロファイルの必要性が明らかになった場合、SIG Authはこの方針について再考する可能性があります。</p><h3 id=セキュリティポリシーとセキュリティコンテキストの違いは何ですか>セキュリティポリシーとセキュリティコンテキストの違いは何ですか?</h3><p><a href=/docs/tasks/configure-pod-container/security-context/>Security Context</a>は実行時のコンテナやPodを設定するものです。
Security ContextはPodのマニフェストの中でPodやコンテナの仕様の一部として定義され、コンテナランタイムへ渡されるパラメータを示します。</p><p>セキュリティポリシーはコントロールプレーンの機構で、Security Contextとそれ以外も含め、特定の設定を強制するものです。
2020年2月時点では、ネイティブにサポートされているポリシー強制の機構は<a href=/docs/concepts/policy/pod-security-policy/>Pod Security
Policy</a>です。これはクラスター全体にわたってセキュリティポリシーを中央集権的に強制するものです。
セキュリティポリシーを強制する他の手段もKubernetesのエコシステムでは開発が進められています。例えば<a href=https://github.com/open-policy-agent/gatekeeper>OPA
Gatekeeper</a>があります。</p><h3 id=windowsのpodにはどのプロファイルを適用すればよいですか>WindowsのPodにはどのプロファイルを適用すればよいですか?</h3><p>Kubernetesでは、Linuxベースのワークロードと比べてWindowsの使用は制限や差異があります。
特に、PodのSecurityContextフィールドは<a href=/ja/docs/setup/production-environment/windows/intro-windows-in-kubernetes/#v1-podsecuritycontext>Windows環境では効果がありません</a>。
したがって、現段階では標準化されたセキュリティポリシーは存在しません。</p><p>Windows Podに制限付きプロファイルを適用すると、実行時にPodに影響が出る場合があります。
制限付きプロファイルでは、Linux固有の制限(seccompプロファイルや特権昇格の不許可など)を適用する必要があります。
kubeletおよび/またはそのコンテナランタイムがこれらのLinux固有の値を無視した場合、Windows Podは制限付きプロファイル内で正常に動作します。
ただし、強制力がないため、Windows コンテナを使用するPodについては、ベースラインプロファイルと比較して追加の制限はありません。</p><p>HostProcess Podを作成するためのHostProcessフラグの使用は、特権的なポリシーに沿ってのみ行われるべきです。
Windows HostProcess Podの作成は、ベースラインおよび制限されたポリシーの下でブロックされているため、いかなるHostProcess Podも特権的であるとみなされるべきです。</p><h3 id=サンドボックス化されたpodはどのように扱えばよいでしょうか>サンドボックス化されたPodはどのように扱えばよいでしょうか?</h3><p>現在のところ、Podがサンドボックス化されていると見なされるかどうかを制御できるAPI標準はありません。
サンドボックス化されたPodはサンドボックス化されたランタイム（例えばgVisorやKata Containers）の使用により特定することは可能ですが、サンドボックス化されたランタイムの標準的な定義は存在しません。</p><p>サンドボックス化されたランタイムに対して必要な保護は、それ以外に対するものとは異なります。
例えば、ワークロードがその基になるカーネルと分離されている場合、特権を制限する必要性は小さくなります。
これにより、強い権限を必要とするワークロードが隔離された状態を維持できます。</p><p>加えて、サンドボックス化されたワークロードの保護はサンドボックス化の実装に強く依存します。
したがって、全てのサンドボックス化されたワークロードに推奨される単一のポリシーは存在しません。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-04eeb110d75afc8acb2cf7a3db743985>8.2 - クラウドネイティブセキュリティの概要</h1><p>この概要では、クラウドネイティブセキュリティにおけるKubernetesのセキュリティを考えるためのモデルを定義します。</p><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> コンテナセキュリティモデルは、実証済の情報セキュリティポリシーではなく提案を提供します。</div><h2 id=クラウドネイティブセキュリティの４c>クラウドネイティブセキュリティの４C</h2><p>セキュリティは階層で考えることができます。クラウドネイティブの4Cは、クラウド、クラスター、コンテナ、そしてコードです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 階層化されたアプローチは、セキュリティに対する<a href=https://en.wikipedia.org/wiki/Defense_in_depth_(computing)>多層防御</a>のアプローチを強化します。これはソフトウェアシステムを保護するベストプラクティスとして幅広く認知されています。</div><figure><img src=/images/docs/4c.png><figcaption><h4>クラウドネイティブセキュリティの４C</h4></figcaption></figure><p>クラウドネイティブセキュリティモデルの各レイヤーは次の最も外側のレイヤー上に構築します。コードレイヤーは、強固な基盤(クラウド、クラスター、コンテナ)セキュリティレイヤーから恩恵を受けます。コードレベルのセキュリティに対応しても基盤レイヤーが低い水準のセキュリティでは守ることができません。</p><h2 id=クラウド>クラウド</h2><p>いろいろな意味でも、クラウド(または同じ場所に設置されたサーバー、企業のデータセンター)はKubernetesクラスターの<a href=https://en.wikipedia.org/wiki/Trusted_computing_base>トラステッド・コンピューティング・ベース</a>です。クラウドレイヤーが脆弱な(または脆弱な方法で構成されている)場合、この基盤の上に構築されたコンポーネントが安全であるという保証はありません。各クラウドプロバイダーは、それぞれの環境でワークロードを安全に実行させるためのセキュリティの推奨事項を作成しています。</p><h3 id=クラウドプロバイダーのセキュリティ>クラウドプロバイダーのセキュリティ</h3><p>Kubernetesクラスターを所有しているハードウェアや様々なクラウドプロバイダー上で実行している場合、セキュリティのベストプラクティスに関するドキュメントを参考にしてください。ここでは人気のあるクラウドプロバイダーのセキュリティドキュメントの一部のリンクを紹介します。</p><table><caption style=display:none>Cloud provider security</caption><thead><tr><th>IaaSプロバイダー</th><th>リンク</th></tr></thead><tbody><tr><td>Alibaba Cloud</td><td><a href=https://www.alibabacloud.com/trust-center>https://www.alibabacloud.com/trust-center</a></td></tr><tr><td>Amazon Web Services</td><td><a href=https://aws.amazon.com/security/>https://aws.amazon.com/security/</a></td></tr><tr><td>Google Cloud Platform</td><td><a href=https://cloud.google.com/security/>https://cloud.google.com/security/</a></td></tr><tr><td>IBM Cloud</td><td><a href=https://www.ibm.com/cloud/security>https://www.ibm.com/cloud/security</a></td></tr><tr><td>Microsoft Azure</td><td><a href=https://docs.microsoft.com/en-us/azure/security/azure-security>https://docs.microsoft.com/en-us/azure/security/azure-security</a></td></tr><tr><td>Oracle Cloud Infrastructure</td><td><a href=https://www.oracle.com/security/>https://www.oracle.com/security/</a></td></tr><tr><td>VMWare VSphere</td><td><a href=https://www.vmware.com/security/hardening-guides.html>https://www.vmware.com/security/hardening-guides.html</a></td></tr></tbody></table><h3 id=infrastructure-security>インフラのセキュリティ</h3><p>Kubernetesクラスターのインフラを保護するための提案です。</p><table><caption style=display:none>Infrastructure security</caption><thead><tr><th>Kubernetesインフラに関する懸念事項</th><th>推奨事項</th></tr></thead><tbody><tr><td>API Server(コントロールプレーン)へのネットワークアクセス</td><td>Kubernetesコントロールプレーンへのすべてのアクセスは、インターネット上での一般公開は許されず、クラスター管理に必要なIPアドレスに制限するネットワークアクセス制御リストによって制御されます。</td></tr><tr><td>Nodeへのネットワークアクセス</td><td>Nodeはコントロールプレーンの特定ポート <em>のみ</em> 接続(ネットワークアクセス制御リストを介して)を受け入れるよう設定し、NodePortとLoadBalancerタイプのKubernetesのServiceに関する接続を受け入れるよう設定する必要があります。可能であれば、それらのNodeはパブリックなインターネットに完全公開しないでください。</td></tr><tr><td>KubernetesからのクラウドプロバイダーAPIへのアクセス</td><td>各クラウドプロバイダーはKubernetesコントロールプレーンとNodeに異なる権限を与える必要があります。<a href=https://en.wikipedia.org/wiki/Principle_of_least_privilege>最小権限の原則</a>に従い、管理に必要なリソースに対してクラウドプロバイダーへのアクセスをクラスターに提供するのが最善です。<a href=https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles>Kopsドキュメント</a>にはIAMのポリシーとロールについての情報が記載されています。</td></tr><tr><td>etcdへのアクセス</td><td>etcd(Kubernetesのデータストア)へのアクセスはコントロールプレーンのみに制限すべきです。設定によっては、TLS経由でetcdを利用する必要があります。詳細な情報は<a href=https://github.com/etcd-io/etcd/tree/master/Documentation>etcdドキュメント</a>を参照してください。</td></tr><tr><td>etcdの暗号化</td><td>可能な限り、保存時に全ドライブを暗号化することは良いプラクティスですが、etcdはクラスター全体(Secretを含む)の状態を保持しているため、そのディスクは特に暗号化する必要があります。</td></tr></tbody></table><h2 id=クラスター>クラスター</h2><p>Kubernetesを保護する為には２つの懸念事項があります。</p><ul><li>設定可能なクラスターコンポーネントの保護</li><li>クラスターで実行されるアプリケーションの保護</li></ul><h3 id=cluster-components>クラスターのコンポーネント</h3><p>想定外または悪意のあるアクセスからクラスターを保護して適切なプラクティスを採用したい場合、<a href=/docs/tasks/administer-cluster/securing-a-cluster/>クラスターの保護</a>に関するアドバイスを読み従ってください。</p><h3 id=cluster-applications>クラスター内のコンポーネント(アプリケーション)</h3><p>アプリケーションを対象にした攻撃に応じて、セキュリティの特定側面に焦点をあてたい場合があります。例:他のリソースとの連携で重要なサービス(サービスA)と、リソース枯渇攻撃に対して脆弱な別のワークロード(サービスB)が実行されている場合、サービスBのリソースを制限していないとサービスAが危険にさらされるリスクが高くなります。次の表はセキュリティの懸念事項とKubernetesで実行されるワークロードを保護するための推奨事項を示しています。</p><table><thead><tr><th>ワークロードセキュリティに関する懸念事項</th><th>推奨事項</th></tr></thead><tbody><tr><td>RBAC認可(Kubernetes APIへのアクセス)</td><td><a href=https://kubernetes.io/ja/docs/reference/access-authn-authz/rbac/>https://kubernetes.io/ja/docs/reference/access-authn-authz/rbac/</a></td></tr><tr><td>認証</td><td><a href=https://kubernetes.io/docs/concepts/security/controlling-access/>https://kubernetes.io/docs/concepts/security/controlling-access/</a></td></tr><tr><td>アプリケーションのSecret管理(およびetcdへの保存時に暗号化)</td><td><a href=https://kubernetes.io/ja/docs/concepts/configuration/secret/>https://kubernetes.io/ja/docs/concepts/configuration/secret/</a><br><a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/>https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/</a></td></tr><tr><td>PodSecurityPolicy</td><td><a href=https://kubernetes.io/docs/concepts/policy/pod-security-policy/>https://kubernetes.io/docs/concepts/policy/pod-security-policy/</a></td></tr><tr><td>Quality of Service (およびクラスターリソース管理)</td><td><a href=https://kubernetes.io/ja/docs/tasks/configure-pod-container/quality-service-pod/>https://kubernetes.io/ja/docs/tasks/configure-pod-container/quality-service-pod/</a></td></tr><tr><td>NetworkPolicy</td><td><a href=https://kubernetes.io/ja/docs/concepts/services-networking/network-policies/>https://kubernetes.io/ja/docs/concepts/services-networking/network-policies/</a></td></tr><tr><td>Kubernetes IngressのTLS</td><td><a href=https://kubernetes.io/ja/docs/concepts/services-networking/ingress/#tls>https://kubernetes.io/ja/docs/concepts/services-networking/ingress/#tls</a></td></tr></tbody></table><h2 id=コンテナ>コンテナ</h2><p>コンテナセキュリティは本ガイドの範囲外になります。このトピックを検索するために一般的な推奨事項とリンクを以下に示します。</p><table><thead><tr><th>コンテナに関する懸念事項</th><th>推奨事項</th></tr></thead><tbody><tr><td>コンテナの脆弱性スキャンとOS依存のセキュリティ</td><td>イメージをビルドする手順の一部として、既知の脆弱性がないかコンテナをスキャンする必要があります。</td></tr><tr><td>イメージの署名と実施</td><td>コンテナイメージを署名し、コンテナの中身に関する信頼性を維持します。</td></tr><tr><td>特権ユーザーを許可しない</td><td>コンテナの構成時に、コンテナの目的を実行するために必要最低限なOS特権を持ったユーザーをコンテナ内部に作成する方法のドキュメントを参考にしてください。</td></tr></tbody></table><h2 id=コード>コード</h2><p>アプリケーションコードは、あなたが最も制御できる主要な攻撃対象のひとつです。アプリケーションコードを保護することはKubernetesのセキュリティトピックの範囲外ですが、アプリケーションコードを保護するための推奨事項を以下に示します。</p><h3 id=コードセキュリティ>コードセキュリティ</h3><table><caption style=display:none>Code security</caption><thead><tr><th>コードに関する懸念事項</th><th>推奨事項</th></tr></thead><tbody><tr><td>TLS経由のアクセスのみ</td><td>コードがTCP通信を必要とする場合は、事前にクライアントとのTLSハンドシェイクを実行してください。 いくつかの例外を除いて、全ての通信を暗号化してください。さらに一歩すすめて、サービス間のネットワークトラフィックを暗号化することはよい考えです。これは、サービスを特定した2つの証明書で通信の両端を検証する相互認証、または<a href=https://en.wikipedia.org/wiki/Mutual_authentication>mTLS</a>して知られているプロセスを通じて実行できます。</td></tr><tr><td>通信ポートの範囲制限</td><td>この推奨事項は一目瞭然かもしれませんが、可能なかぎり、通信とメトリクス収集に必要不可欠なサービスのポートのみを公開します。</td></tr><tr><td>サードパティに依存するセキュリティ</td><td>既知の脆弱性についてアプリケーションのサードパーティ製ライブラリーを定期的にスキャンすることを推奨します。それぞれの言語は自動でこのチェックを実行するツールを持っています。</td></tr><tr><td>静的コード解析</td><td>ほとんどの言語ではコードのスニペットを解析して、安全でない可能性のあるコーディングを分析する方法が提供しています。可能な限り、コードベースでスキャンして、よく起こるセキュリティエラーを検出できる自動ツールを使用してチェックを実行すべきです。一部のツールはここで紹介されています。 <a href=https://owasp.org/www-community/Source_Code_Analysis_Tools>https://owasp.org/www-community/Source_Code_Analysis_Tools</a></td></tr><tr><td>動的プロービング攻撃</td><td>よく知られているいくつかのサービス攻撃をサービスに対して試すことができる自動ツールがいくつかあります。これにはSQLインジェクション、CSRF、そしてXSSが含まれます。よく知られている動的解析ツールは<a href=https://owasp.org/www-project-zap/>OWASP Zed Attack proxy</a>toolです。</td></tr></tbody></table><h2 id=次の項目>次の項目</h2><p>関連するKubernetesセキュリティについて学びます。</p><ul><li><a href=/ja/docs/concepts/security/pod-security-standards/>Podセキュリティの標準</a></li><li><a href=/ja/docs/concepts/services-networking/network-policies/>Podのネットワークポリシー</a></li><li><a href=/docs/concepts/security/controlling-access>Kubernetes APIへのアクセスを制御する</a></li><li><a href=/docs/tasks/administer-cluster/securing-a-cluster/>クラスターの保護</a></li><li>コントロールプレーンとの<a href=/docs/tasks/tls/managing-tls-in-a-cluster/>通信時のデータ暗号化</a></li><li><a href=/docs/tasks/administer-cluster/encrypt-data/>保存時のデータ暗号化</a></li><li><a href=/ja/docs/concepts/configuration/secret/>Kubernetes Secret</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bc9934fccfeaf880eec6ea79025c0381>8.3 - Podのセキュリティアドミッション</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code></div><p>Kubernetesの<a href=/ja/docs/concepts/security/pod-security-standards/>Podセキュリティの標準</a>はPodに対して異なる分離レベルを定義します。
これらの標準によって、Podの動作をどのように制限したいかを、明確かつ一貫した方法で定義することができます。</p><p>ベータ版機能として、Kubernetesは<a href=/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>の後継である組み込みの <em>Pod Security</em> <a class=glossary-tooltip title='A piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/admission-controllers/ target=_blank aria-label=アドミッションコントローラー>アドミッションコントローラー</a>を提供しています。
Podセキュリティの制限は、Pod作成時に<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=名前空間>名前空間</a>レベルで適用されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> PodSecurityPolicy APIは非推奨であり、v1.25でKubernetesから<a href=/docs/reference/using-api/deprecation-guide/#v1-25>削除</a>される予定です。</div><h2 id=enabling-the-podsecurity-admission-plugin><code>PodSecurity</code>アドミッションプラグインの有効化</h2><p>v1.23において、<code>PodSecurity</code>の<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>はベータ版の機能で、デフォルトで有効化されています。
v1.22において、<code>PodSecurity</code>の<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>はアルファ版の機能で、組み込みのアドミッションプラグインを使用するには、<code>kube-apiserver</code>で有効にする必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--feature-gates<span style=color:#666>=</span><span style=color:#b44>&#34;...,PodSecurity=true&#34;</span>
</span></span></code></pre></div><h2 id=webhook>代替案:<code>PodSecurity</code>アドミッションwebhookのインストール</h2><p>クラスターがv1.22より古い、あるいは<code>PodSecurity</code>機能を有効にできないなどの理由で、ビルトインの<code>PodSecurity</code>アドミッションプラグインが使えない環境では、<code>PodSecurity</code>はアドミッションロジックはベータ版の<a href=https://git.k8s.io/pod-security-admission/webhook>validating admission webhook</a>としても提供されています。</p><p>ビルド前のコンテナイメージ、証明書生成スクリプト、マニフェストの例は、<a href=https://git.k8s.io/pod-security-admission/webhook>https://git.k8s.io/pod-security-admission/webhook</a>で入手可能です。</p><p>インストール方法:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>git clone git@github.com:kubernetes/pod-security-admission.git
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> pod-security-admission/webhook
</span></span><span style=display:flex><span>make certs
</span></span><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 生成された証明書の有効期限は2年間です。有効期限が切れる前に、証明書を再生成するか、内蔵のアドミッションプラグインを使用してWebhookを削除してください。</div><h2 id=pod-security-levels>Podのセキュリティレベル</h2><p>Podのセキュリティアドミッションは、Podの<a href=/docs/tasks/configure-pod-container/security-context/>Security Context</a>とその他の関連フィールドに、<a href=/ja/docs/concepts/security/pod-security-standards>Podセキュリティの標準</a>で定義された3つのレベル、<code>privileged</code>、<code>baseline</code>、<code>restricted</code>に従って要件を設定するものです。
これらの要件の詳細については、<a href=/ja/docs/concepts/security/pod-security-standards>Podセキュリティの標準</a>のページを参照してください。</p><h2 id=pod-security-admission-labels-for-namespaces>Podの名前空間に対するセキュリティアドミッションラベル</h2><p>この機能を有効にするか、Webhookをインストールすると、名前空間を設定して、各名前空間でPodセキュリティに使用したいadmission controlモードを定義できます。
Kubernetesは、名前空間に使用したい定義済みのPodセキュリティの標準レベルのいずれかを適用するために設定できる<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>のセットを用意しています。
選択したラベルは、以下のように違反の可能性が検出された場合に<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>が取るアクションを定義します。</p><table><caption style=display:none>Podのセキュリティアドミッションのモード</caption><thead><tr><th style=text-align:left>モード</th><th style=text-align:left>説明</th></tr></thead><tbody><tr><td style=text-align:left><strong>enforce</strong></td><td style=text-align:left>ポリシーに違反した場合、Podは拒否されます。</td></tr><tr><td style=text-align:left><strong>audit</strong></td><td style=text-align:left>ポリシー違反は、<a href=/ja/docs/tasks/debug-application-cluster/audit/>監査ログ</a>に記録されるイベントに監査アノテーションを追加するトリガーとなりますが、それ以外は許可されます。</td></tr><tr><td style=text-align:left><strong>warn</strong></td><td style=text-align:left>ポリシーに違反した場合は、ユーザーへの警告がトリガーされますが、それ以外は許可されます。</td></tr></tbody></table><p>名前空間は、任意のまたはすべてのモードを設定することができ、異なるモードに対して異なるレベルを設定することもできます。</p><p>各モードには、使用するポリシーを決定する2つのラベルがあります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># モードごとのレベルラベルは、そのモードに適用するポリシーレベルを示す。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># MODEは`enforce`、`audit`、`warn`のいずれかでなければならない。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># LEVELは`privileged`、`baseline`、`restricted`のいずれかでなければならない。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>pod-security.kubernetes.io/&lt;MODE&gt;</span>:<span style=color:#bbb> </span>&lt;LEVEL&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># オプション: モードごとのバージョンラベルは、Kubernetesのマイナーバージョンに同梱される</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># バージョンにポリシーを固定するために使用できる（例えばv1.25など）。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># MODEは`enforce`、`audit`、`warn`のいずれかでなければならない。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># VERSIONは有効なKubernetesのマイナーバージョンか`latest`でなければならない。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>pod-security.kubernetes.io/&lt;MODE&gt;-version</span>:<span style=color:#bbb> </span>&lt;VERSION&gt;<span style=color:#bbb>
</span></span></span></code></pre></div><p><a href=/docs/tasks/configure-pod-container/enforce-standards-namespace-labels>名前空間ラベルでのPodセキュリティの標準の適用</a>で使用例を確認できます。</p><h2 id=workload-resources-and-pod-templates>WorkloadのリソースとPodテンプレート</h2><p>Podは、<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>や<a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>のような<a href=/ja/docs/concepts/workloads/controllers/>ワークロードオブジェクト</a>を作成することによって、しばしば間接的に生成されます。
ワークロードオブジェクトは_Pod template_を定義し、ワークロードリソースの<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>はそのテンプレートに基づきPodを作成します。
違反の早期発見を支援するために、auditモードとwarningモードは、ワークロードリソースに適用されます。
ただし、enforceモードはワークロードリソースには<strong>適用されず</strong>、結果としてのPodオブジェクトにのみ適用されます。</p><h2 id=exemptions>適用除外(Exemption)</h2><p>Podセキュリティの施行から <em>exemptions</em> を定義することで、特定の名前空間に関連するポリシーのために禁止されていたPodの作成を許可することができます。
Exemptionは<a href=/docs/tasks/configure-pod-container/enforce-standards-admission-controller/#configure-the-admission-controller>アドミッションコントローラーの設定</a>で静的に設定することができます。</p><p>Exemptionは明示的に列挙する必要があります。
Exemptionを満たしたリクエストは、アドミッションコントローラーによって <em>無視</em> されます(<code>enforce</code>、<code>audit</code>、<code>warn</code>のすべての動作がスキップされます)。Exemptionの次元は以下の通りです。</p><ul><li><strong>Usernames:</strong> 認証されていない(あるいは偽装された)ユーザー名を持つユーザーからの要求は無視されます。</li><li><strong>RuntimeClassNames:</strong> Podと<a href=#workload-resources-and-pod-templates>ワークロードリソース</a>で指定された除外ランタイムクラス名は、無視されます。</li><li><strong>Namespaces:</strong> 除外された名前空間のPodと<a href=#workload-resources-and-pod-templates>ワークロードリソース</a>は、無視されます。</li></ul><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> ほとんどのPodは、<a href=#workload-resources-and-pod-templates>ワークロードリソース</a>に対応してコントローラーが作成します。つまり、エンドユーザーを適用除外にするのはPodを直接作成する場合のみで、ワークロードリソースを作成する場合は適用除外になりません。
コントローラーサービスアカウント(<code>system:serviceaccount:kube-system:replicaset-controller</code>など)は通常、除外してはいけません。そうした場合、対応するワークロードリソースを作成できるすべてのユーザーを暗黙的に除外してしまうためです。</div><p>以下のPodフィールドに対する更新は、ポリシーチェックの対象外となります。つまり、Podの更新要求がこれらのフィールドを変更するだけであれば、Podが現在のポリシーレベルに違反していても拒否されることはありません。</p><ul><li>すべてのメタデータの更新(seccompまたはAppArmorアノテーションへの変更を<strong>除く</strong>)<ul><li><code>seccomp.security.alpha.kubernetes.io/pod</code>(非推奨)</li><li><code>container.seccomp.security.alpha.kubernetes.io/*</code>(非推奨)</li><li><code>container.apparmor.security.beta.kubernetes.io/*</code></li></ul></li><li><code>.spec.activeDeadlineSeconds</code>に対する有効な更新</li><li><code>.spec.tolerations</code>に対する有効な更新</li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/security/pod-security-standards>Podセキュリティの標準</a></li><li><a href=/docs/setup/best-practices/enforcing-pod-security-standards>Podセキュリティの標準の適用</a></li><li><a href=/docs/tasks/configure-pod-container/enforce-standards-admission-controller>ビルトインのアドミッションコントローラーの設定によるPodセキュリティの標準の適用</a></li><li><a href=/docs/tasks/configure-pod-container/enforce-standards-namespace-labels>名前空間ラベルでのPodセキュリティの標準の適用</a></li><li><a href=/docs/tasks/configure-pod-container/migrate-from-psp>PodSecurityPolicyからビルトインのPodSecurityアドミッションコントローラーへの移行</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4d77d1ae4c06aa14f54b385191627881>8.4 - Kubernetes APIへのアクセスコントロール</h1><p>このページではKubernetes APIへのアクセスコントロールの概要を説明します。</p><p><a href=/ja/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>には<code>kubectl</code>やクライアントライブラリ、あるいはRESTリクエストを用いてアクセスします。
APIアクセスには、人間のユーザーと<a href=/docs/tasks/configure-pod-container/configure-service-account/>Kubernetesサービスアカウント</a>の両方が認証可能です。
リクエストがAPIに到達すると、次の図のようにいくつかの段階を経ます。</p><p><img src=/images/docs/admin/access-control-overview.svg alt="Kubernetes APIリクエストの処理手順図"></p><h2 id=transport-security>トランスポート層のセキュリティ</h2><p>一般的なKubernetesクラスターでは、APIはTLSで保護された443番ポートで提供されます。
APIサーバーは証明書を提示します。
この証明書は、プライベート認証局(CA)を用いて署名することも、一般に認知されているCAと連携した公開鍵基盤に基づき署名することも可能です。</p><p>クラスターがプライベート認証局を使用している場合、接続を信頼し、傍受されていないと確信できるように、クライアント上の<code>~/.kube/config</code>に設定されたそのCA証明書のコピーが必要です。</p><p>クライアントは、この段階でTLSクライアント証明書を提示することができます。</p><h2 id=authentication>認証</h2><p>TLSが確立されると、HTTPリクエストは認証のステップに移行します。
これは図中のステップ<strong>1</strong>に該当します。
クラスター作成スクリプトまたはクラスター管理者は、1つまたは複数のAuthenticatorモジュールを実行するようにAPIサーバーを設定します。
Authenticatorについては、<a href=/ja/docs/reference/access-authn-authz/authentication/>認証</a>で詳しく説明されています。</p><p>認証ステップへの入力はHTTPリクエスト全体ですが、通常はヘッダとクライアント証明書の両方、またはどちらかを調べます。</p><p>認証モジュールには、クライアント証明書、パスワード、プレーントークン、ブートストラップトークン、JSON Web Tokens(サービスアカウントに使用)などがあります。</p><p>複数の認証モジュールを指定することができ、その場合、1つの認証モジュールが成功するまで、それぞれを順番に試行します。</p><p>認証できない場合、HTTPステータスコード401で拒否されます。
そうでなければ、ユーザーは特定の<code>username</code>として認証され、そのユーザー名は後続のステップでの判断に使用できるようになります。
また、ユーザーのグループメンバーシップを提供する認証機関と、提供しない認証機関があります。</p><p>Kubernetesはアクセスコントロールの決定やリクエストログにユーザー名を使用しますが、<code>User</code>オブジェクトを持たず、ユーザー名やその他のユーザーに関する情報をAPIはに保存しません。</p><h2 id=authorization>認可</h2><p>リクエストが特定のユーザーからのものであると認証された後、そのリクエストは認可される必要があります。
これは図のステップ<strong>2</strong>に該当します。</p><p>リクエストには、リクエスト者のユーザー名、リクエストされたアクション、そのアクションによって影響を受けるオブジェクトを含める必要があります。
既存のポリシーで、ユーザーが要求されたアクションを完了するための権限を持っていると宣言されている場合、リクエストは承認されます。</p><p>例えば、Bobが以下のようなポリシーを持っている場合、彼は名前空間<code>projectCaribou</code>内のPodのみを読むことができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;bob&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;projectCaribou&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Bobが次のようなリクエストをした場合、Bobは名前空間<code>projectCaribou</code>のオブジェクトを読むことが許可されているので、このリクエストは認可されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;resourceAttributes&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;projectCaribou&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;get&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;unicorn.example.org&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Bobが名前空間<code>projectCaribou</code>のオブジェクトに書き込み(<code>create</code>または<code>update</code>)のリクエストをした場合、承認は拒否されます。
また、もしBobが<code>projectFish</code>のような別の名前空間にあるオブジェクトを読み込む(<code>get</code>)リクエストをした場合も、承認は拒否されます。</p><p>Kubernetesの認可では、組織全体またはクラウドプロバイダー全体の既存のアクセスコントロールシステムと対話するために、共通のREST属性を使用する必要があります。
これらのコントロールシステムは、Kubernetes API以外のAPIとやり取りする可能性があるため、REST形式を使用することが重要です。</p><p>Kubernetesは、ABACモード、RBACモード、Webhookモードなど、複数の認可モジュールをサポートしています。
管理者はクラスターを作成する際に、APIサーバーで使用する認証モジュールを設定します。
複数の認可モジュールが設定されている場合、Kubernetesは各モジュールをチェックし、いずれかのモジュールがリクエストを認可した場合、リクエストを続行することができます。
すべてのモジュールがリクエストを拒否した場合、リクエストは拒否されます(HTTPステータスコード403)。</p><p>サポートされている認可モジュールを使用したポリシー作成の詳細を含む、Kubernetesの認可については、<a href=/docs/reference/access-authn-authz/authorization/>認可</a>を参照してください。</p><h2 id=admission-control>アドミッションコントロール</h2><p>アドミッションコントロールモジュールは、リクエストを変更したり拒否したりすることができるソフトウェアモジュールです。
認可モジュールが利用できる属性に加えて、アドミッションコントロールモジュールは、作成または修正されるオブジェクトのコンテンツにアクセスすることができます。</p><p>アドミッションコントローラーは、オブジェクトの作成、変更、削除、または接続(プロキシ)を行うリクエストに対して動作します。
アドミッションコントローラーは、単にオブジェクトを読み取るだけのリクエストには動作しません。
複数のアドミッションコントローラーが設定されている場合は、順番に呼び出されます。</p><p>これは図中のステップ<strong>3</strong>に該当します。</p><p>認証・認可モジュールとは異なり、いずれかのアドミッションコントローラーモジュールが拒否した場合、リクエストは即座に拒否されます。</p><p>オブジェクトを拒否するだけでなく、アドミッションコントローラーは、フィールドに複雑なデフォルトを設定することもできます。</p><p>利用可能なアドミッションコントロールモジュールは、<a href=/docs/reference/access-authn-authz/admission-controllers/>アドミッションコントローラー</a>に記載されています。</p><p>リクエストがすべてのアドミッションコントローラーを通過すると、対応するAPIオブジェクトの検証ルーチンを使って検証され、オブジェクトストアに書き込まれます(図のステップ<strong>4</strong>に該当します)。</p><h2 id=auditing>監査</h2><p>Kubernetesの監査は、クラスター内の一連のアクションを文書化した、セキュリティに関連する時系列の記録を提供します。
クラスターは、ユーザー、Kubernetes APIを使用するアプリケーション、およびコントロールプレーン自身によって生成されるアクティビティを監査します。</p><p>詳しくは<a href=/ja/docs/tasks/debug-application-cluster/audit/>監査</a>をご覧ください。</p><h2 id=api-server-ports-and-ips>APIサーバーのIPとポート</h2><p>これまでの説明は、APIサーバーのセキュアポートに送信されるリクエストに適用されます(典型的なケース)。
APIサーバーは、実際には2つのポートでサービスを提供することができます。</p><p>デフォルトでは、Kubernetes APIサーバーは2つのポートでHTTPを提供します。</p><ol><li><p><code>localhost</code>ポート:</p><ul><li>テストとブートストラップ用で、マスターノードの他のコンポーネント(スケジューラー、コントローラーマネージャー)がAPIと通信するためのものです。</li><li>TLSは使用しません。</li><li>デフォルトポートは8080です。</li><li>デフォルトのIPはlocalhostですが、<code>--insecure-bind-address</code>フラグで変更することができます。</li><li>リクエストは認証と認可のモジュールを<strong>バイパス</strong>します。</li><li>リクエストは、アドミッションコントロールモジュールによって処理されます。</li><li>ホストにアクセスする必要があるため、保護されています。</li></ul></li><li><p>“セキュアポート”:</p><ul><li>可能な限りこちらを使用してください。</li><li>TLSを使用します。証明書は<code>--tls-cert-file</code>フラグで、鍵は<code>--tls-private-key-file</code>フラグで設定します。</li><li>デフォルトポートは6443です。<code>--secure-port</code>フラグで変更することができます。</li><li>デフォルトのIPは、最初の非localhostのネットワークインターフェースです。<code>--bind-address</code>フラグで変更することができます。</li><li>リクエストは、認証・認可モジュールによって処理されます。</li><li>リクエストは、アドミッションコントロールモジュールによって処理されます。</li><li>認証・認可モジュールが実行されます。</li></ul></li></ol><h2 id=次の項目>次の項目</h2><p>認証、認可、APIアクセスコントロールに関する詳しいドキュメントはこちらをご覧ください。</p><ul><li><a href=/ja/docs/reference/access-authn-authz/authentication/>認証</a><ul><li><a href=/docs/reference/access-authn-authz/bootstrap-tokens/>ブートストラップトークンでの認証</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/admission-controllers/>アドミッションコントローラー</a><ul><li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>動的アドミッションコントロール</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/authorization/>認可</a><ul><li><a href=/ja/docs/reference/access-authn-authz/rbac/>ロールに基づいたアクセスコントロール</a></li><li><a href=/docs/reference/access-authn-authz/abac/>属性に基づいたアクセスコントロール</a></li><li><a href=/docs/reference/access-authn-authz/node/>Nodeの認可</a></li><li><a href=/docs/reference/access-authn-authz/webhook/>Webhookの認可</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/>証明書の署名要求</a><ul><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection>CSRの承認</a>と<a href=/docs/reference/access-authn-authz/certificate-signing-requests/#signing>証明書の署名</a>を含む</li></ul></li><li>サービスアカウント<ul><li><a href=/docs/tasks/configure-pod-container/configure-service-account/>Developer guide</a></li><li><a href=/docs/reference/access-authn-authz/service-accounts-admin/>Administration</a></li></ul></li></ul><p>以下についても知ることができます。</p><ul><li>PodがAPIクレデンシャルを取得するために<a href=/ja/docs/concepts/configuration/secret/#service-accounts-automatically-create-and-attach-secrets-with-api-credentials>Secrets</a>を使用する方法について。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c21d05f31057c5bcd2ebdd01f4e62a0e>9 - スケジューリングと退避</h1><div class=lead>Kubernetesにおいてスケジューリングとは、稼働させたいPodをNodeにマッチさせ、kubeletが実行できるようにすることを指します。 退避とは、リソース不足のNodeで1つ以上のPodを積極的に停止させるプロセスです。</div></div><div class=td-content><h1 id=pg-598f36d691ab197f9d995784574b0a12>9.1 - Kubernetesのスケジューラー</h1><p>Kubernetesにおいて、<em>スケジューリング</em> とは、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>が<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>を稼働させるために<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>に割り当てることを意味します。</p><h2 id=scheduling>スケジューリングの概要</h2><p>スケジューラーは新規に作成されたPodで、Nodeに割り当てられていないものを監視します。スケジューラーは発見した各Podのために、稼働させるべき最適なNodeを見つけ出す責務を担っています。そのスケジューラーは下記で説明するスケジューリングの原理を考慮に入れて、NodeへのPodの割り当てを行います。</p><p>Podが特定のNodeに割り当てられる理由を理解したい場合や、カスタムスケジューラーを自身で作ろうと考えている場合、このページはスケジューリングに関して学ぶのに役立ちます。</p><h2 id=kube-scheduler>kube-scheduler</h2><p><a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a>はKubernetesにおけるデフォルトのスケジューラーで、<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>の一部分として稼働します。
kube-schedulerは、もし希望するのであれば自分自身でスケジューリングのコンポーネントを実装でき、それを代わりに使用できるように設計されています。</p><p>kube-schedulerは、新規に作成された各Podや他のスケジューリングされていないPodを稼働させるために最適なNodeを選択します。
しかし、Pod内の各コンテナにはそれぞれ異なるリソースの要件があり、各Pod自体にもそれぞれ異なる要件があります。そのため、既存のNodeは特定のスケジューリング要求によってフィルターされる必要があります。</p><p>クラスター内でPodに対する割り当て要求を満たしたNodeは <em>割り当て可能</em> なNodeと呼ばれます。
もし適切なNodeが一つもない場合、スケジューラーがNodeを割り当てることができるまで、そのPodはスケジュールされずに残ります。</p><p>スケジューラーはPodに対する割り当て可能なNodeをみつけ、それらの割り当て可能なNodeにスコアをつけます。その中から最も高いスコアのNodeを選択し、Podに割り当てるためのいくつかの関数を実行します。
スケジューラーは <em>binding</em> と呼ばれる処理中において、APIサーバーに対して割り当てが決まったNodeの情報を通知します。</p><p>スケジューリングを決定する上で考慮が必要な要素としては、個別または複数のリソース要求や、ハードウェア/ソフトウェアのポリシー制約、affinityやanti-affinityの設定、データの局所性や、ワークロード間での干渉などが挙げられます。</p><h2 id=kube-scheduler-implementation>kube-schedulerによるスケジューリング</h2><p>kube-schedulerは2ステップの操作によってPodに割り当てるNodeを選択します。</p><ol><li><p>フィルタリング</p></li><li><p>スコアリング</p></li></ol><p><em>フィルタリング</em> ステップでは、Podに割り当て可能なNodeのセットを探します。例えばPodFitsResourcesフィルターは、Podのリソース要求を満たすのに十分なリソースをもつNodeがどれかをチェックします。このステップの後、候補のNodeのリストは、要求を満たすNodeを含みます。
たいてい、リストの要素は複数となります。もしこのリストが空の場合、そのPodはスケジュール可能な状態とはなりません。</p><p><em>スコアリング</em> ステップでは、Podを割り当てるのに最も適したNodeを選択するために、スケジューラーはリストの中のNodeをランク付けします。
スケジューラーは、フィルタリングによって選ばれた各Nodeに対してスコアを付けます。このスコアはアクティブなスコア付けのルールに基づいています。</p><p>最後に、kube-schedulerは最も高いランクのNodeに対してPodを割り当てます。もし同一のスコアのNodeが複数ある場合は、kube-schedulerがランダムに1つ選択します。</p><p>スケジューラーのフィルタリングとスコアリングの動作に関する設定には2つのサポートされた手法があります。</p><ol><li><a href=/docs/reference/scheduling/policies>スケジューリングポリシー</a> は、フィルタリングのための <em>Predicates</em> とスコアリングのための <em>Priorities</em> の設定することができます。</li><li><a href=/docs/reference/scheduling/config/#profiles>スケジューリングプロファイル</a>は、<code>QueueSort</code>、 <code>Filter</code>、 <code>Score</code>、 <code>Bind</code>、 <code>Reserve</code>、 <code>Permit</code>やその他を含む異なるスケジューリングの段階を実装するプラグインを設定することができます。kube-schedulerを異なるプロファイルを実行するように設定することもできます。</li></ol><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/scheduling-eviction/scheduler-perf-tuning/>スケジューラーのパフォーマンスチューニング</a>を参照してください。</li><li><a href=/docs/concepts/workloads/pods/pod-topology-spread-constraints/>Podトポロジーの分散制約</a>を参照してください。</li><li>kube-schedulerの<a href=/docs/reference/command-line-tools-reference/kube-scheduler/>リファレンスドキュメント</a>を参照してください。</li><li><a href=/docs/tasks/administer-cluster/configure-multiple-schedulers/>複数のスケジューラーの設定</a>について学んでください。</li><li><a href=/ja/docs/tasks/administer-cluster/topology-manager/>トポロジーの管理ポリシー</a>について学んでください。</li><li><a href=/ja/docs/concepts/scheduling-eviction/pod-overhead/>Podのオーバーヘッド</a>について学んでください。</li><li>ボリュームを使用するPodのスケジューリングについて以下で学んでください。<ul><li><a href=/docs/concepts/storage/storage-classes/#volume-binding-mode>Volume Topology Support</a></li><li><a href=/ja/docs/concepts/storage/storage-capacity/>ストレージ容量の追跡</a></li><li><a href=/docs/concepts/storage/storage-limits/>Node-specific Volume Limits</a></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-21169f516071aea5d16734a4c27789a5>9.2 - Node上へのPodのスケジューリング</h1><p><a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>が稼働する<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>を特定のものに指定したり、優先条件を指定して制限することができます。
これを実現するためにはいくつかの方法がありますが、推奨されている方法は<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルでの選択</a>です。
スケジューラーが最適な配置を選択するため、一般的にはこのような制限は不要です(例えば、複数のPodを別々のNodeへデプロイしたり、Podを配置する際にリソースが不十分なNodeにはデプロイされないことが挙げられます)が、
SSDが搭載されているNodeにPodをデプロイしたり、同じアベイラビリティーゾーン内で通信する異なるサービスのPodを同じNodeにデプロイする等、柔軟な制御が必要なこともあります。</p><h2 id=nodeselector>nodeSelector</h2><p><code>nodeSelector</code>は、Nodeを選択するための、最も簡単で推奨されている手法です。
<code>nodeSelector</code>はPodSpecのフィールドです。これはkey-valueペアのマップを特定します。
あるノードでPodを稼働させるためには、そのノードがラベルとして指定されたkey-valueペアを保持している必要があります(複数のラベルを保持することも可能です)。
最も一般的な使用方法は、1つのkey-valueペアを付与する方法です。</p><p>以下に、<code>nodeSelector</code>の使用例を紹介します。</p><h3 id=ステップ0-前提条件>ステップ0: 前提条件</h3><p>この例では、KubernetesのPodに関して基本的な知識を有していることと、<a href=/ja/docs/setup/>Kubernetesクラスターのセットアップ</a>がされていることが前提となっています。</p><h3 id=ステップ1-nodeへのラベルの付与>ステップ1: Nodeへのラベルの付与</h3><p><code>kubectl get nodes</code>で、クラスターのノードの名前を取得してください。
そして、ラベルを付与するNodeを選び、<code>kubectl label nodes &lt;node-name> &lt;label-key>=&lt;label-value></code>で選択したNodeにラベルを付与します。
例えば、Nodeの名前が'kubernetes-foo-node-1.c.a-robinson.internal'、付与するラベルが'disktype=ssd'の場合、<code>kubectl label nodes kubernetes-foo-node-1.c.a-robinson.internal disktype=ssd</code>によってラベルが付与されます。</p><p><code>kubectl get nodes --show-labels</code>によって、ノードにラベルが付与されたかを確認することができます。
また、<code>kubectl describe node "nodename"</code>から、そのNodeの全てのラベルを表示することもできます。</p><h3 id=ステップ2-podへのnodeselectorフィールドの追加>ステップ2: PodへのnodeSelectorフィールドの追加</h3><p>該当のPodのconfigファイルに、nodeSelectorのセクションを追加します:
例として以下のconfigファイルを扱います:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div><p>nodeSelectorを以下のように追加します:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-yaml")' title="Copy pods/pod-nginx.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p><code>kubectl apply -f https://k8s.io/examples/pods/pod-nginx.yaml</code>により、Podは先ほどラベルを付与したNodeへスケジュールされます。
<code>kubectl get pods -o wide</code>で表示される"NODE"の列から、PodがデプロイされているNodeを確認することができます。</p><h2 id=built-in-node-labels>補足: ビルトインNodeラベル</h2><p>明示的に<a href=#step-one-attach-label-to-the-node>付与</a>するラベルの他に、事前にNodeへ付与されているものもあります。
これらのラベルのリストは、<a href=/docs/reference/kubernetes-api/labels-annotations-taints/>Well-Known Labels, Annotations and Taints</a>を参照してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> これらのラベルは、クラウドプロバイダー固有であり、確実なものではありません。
例えば、<code>kubernetes.io/hostname</code>の値はNodeの名前と同じである環境もあれば、異なる環境もあります。</div><h2 id=nodeの隔離や制限>Nodeの隔離や制限</h2><p>Nodeにラベルを付与することで、Podは特定のNodeやNodeグループにスケジュールされます。
これにより、特定のPodを、確かな隔離性や安全性、特性を持ったNodeで稼働させることができます。
この目的でラベルを使用する際に、Node上のkubeletプロセスに上書きされないラベルキーを選択することが強く推奨されています。
これは、安全性が損なわれたNodeがkubeletの認証情報をNodeのオブジェクトに設定したり、スケジューラーがそのようなNodeにデプロイすることを防ぎます。</p><p><code>NodeRestriction</code>プラグインは、kubeletが<code>node-restriction.kubernetes.io/</code>プレフィックスを有するラベルの設定や上書きを防ぎます。
Nodeの隔離にラベルのプレフィックスを使用するためには、以下のようにします。</p><ol><li><a href=/docs/reference/access-authn-authz/node/>Node authorizer</a>を使用していることと、<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a>が <em>有効</em> になっていること。</li><li>Nodeに<code>node-restriction.kubernetes.io/</code> プレフィックスのラベルを付与し、そのラベルがnode selectorに指定されていること。
例えば、<code>example.com.node-restriction.kubernetes.io/fips=true</code> または <code>example.com.node-restriction.kubernetes.io/pci-dss=true</code>のようなラベルです。</li></ol><h2 id=affinity-and-anti-affinity>アフィニティとアンチアフィニティ</h2><p><code>nodeSelector</code>はPodの稼働を特定のラベルが付与されたNodeに制限する最も簡単な方法です。
アフィニティ/アンチアフィニティでは、より柔軟な指定方法が提供されています。
拡張機能は以下の通りです。</p><ol><li>アフィニティ/アンチアフィニティという用語はとても表現豊かです。この用語は論理AND演算で作成された完全一致だけではなく、より多くのマッチングルールを提供します。</li><li>必須条件ではなく優先条件を指定でき、条件を満たさない場合でもPodをスケジュールさせることができます。</li><li>Node自体のラベルではなく、Node(または他のトポロジカルドメイン)上で稼働している他のPodのラベルに対して条件を指定することができ、そのPodと同じ、または異なるドメインで稼働させることができます。</li></ol><p>アフィニティは"Nodeアフィニティ"と"Pod間アフィニティ/アンチアフィニティ"の2種類から成ります。
Nodeアフィニティは<code>nodeSelector</code>(前述の2つのメリットがあります)に似ていますが、Pod間アフィニティ/アンチアフィニティは、上記の3番目の機能に記載している通り、NodeのラベルではなくPodのラベルに対して制限をかけます。</p><h3 id=nodeアフィニティ>Nodeアフィニティ</h3><p>Nodeアフィニティは概念的には、NodeのラベルによってPodがどのNodeにスケジュールされるかを制限する<code>nodeSelector</code>と同様です。</p><p>現在は2種類のNodeアフィニティがあり、<code>requiredDuringSchedulingIgnoredDuringExecution</code>と<code>preferredDuringSchedulingIgnoredDuringExecution</code>です。
前者はNodeにスケジュールされるPodが条件を満たすことが必須(<code>nodeSelector</code>に似ていますが、より柔軟に条件を指定できます)であり、後者は条件を指定できますが保証されるわけではなく、優先的に考慮されます。
"IgnoredDuringExecution"の意味するところは、<code>nodeSelector</code>の機能と同様であり、Nodeのラベルが変更され、Podがその条件を満たさなくなった場合でも
PodはそのNodeで稼働し続けるということです。
将来的には、<code>requiredDuringSchedulingIgnoredDuringExecution</code>に、PodのNodeアフィニティに記された必須要件を満たさなくなったNodeからそのPodを退避させることができる機能を備えた<code>requiredDuringSchedulingRequiredDuringExecution</code>が提供される予定です。</p><p>それぞれの使用例として、
<code>requiredDuringSchedulingIgnoredDuringExecution</code> は、"インテルCPUを供えたNode上でPodを稼働させる"、
<code>preferredDuringSchedulingIgnoredDuringExecution</code>は、"ゾーンXYZでPodの稼働を試みますが、実現不可能な場合には他の場所で稼働させる"
といった方法が挙げられます。</p><p>Nodeアフィニティは、PodSpecの<code>affinity</code>フィールドにある<code>nodeAffinity</code>フィールドで特定します。</p><p>Nodeアフィニティを使用したPodの例を以下に示します:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-with-node-affinity.yaml download=pods/pod-with-node-affinity.yaml><code>pods/pod-with-node-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-with-node-affinity-yaml")' title="Copy pods/pod-with-node-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-with-node-affinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-node-affinity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/e2e-az-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- e2e-az1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- e2e-az2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>preference</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>another-node-label-key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- another-node-label-value<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-node-affinity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0</span></span></code></pre></div></div></div><p>このNodeアフィニティでは、Podはキーが<code>kubernetes.io/e2e-az-name</code>、値が<code>e2e-az1</code>または<code>e2e-az2</code>のラベルが付与されたNodeにしか配置されません。
加えて、キーが<code>another-node-label-key</code>、値が<code>another-node-label-value</code>のラベルが付与されたNodeが優先されます。</p><p>この例ではオペレーター<code>In</code>が使われています。
Nodeアフィニティでは、<code>In</code>、<code>NotIn</code>、<code>Exists</code>、<code>DoesNotExist</code>、<code>Gt</code>、<code>Lt</code>のオペレーターが使用できます。
<code>NotIn</code>と<code>DoesNotExist</code>はNodeアンチアフィニティ、またはPodを特定のNodeにスケジュールさせない場合に使われる<a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>Taints</a>に使用します。</p><p><code>nodeSelector</code>と<code>nodeAffinity</code>の両方を指定した場合、Podは<strong>両方の</strong>条件を満たすNodeにスケジュールされます。</p><p><code>nodeAffinity</code>内で複数の<code>nodeSelectorTerms</code>を指定した場合、Podは<strong>いずれかの</strong><code>nodeSelectorTerms</code>を満たしたNodeへスケジュールされます。</p><p><code>nodeSelectorTerms</code>内で複数の<code>matchExpressions</code>を指定した場合にはPodは<strong>全ての</strong><code>matchExpressions</code>を満たしたNodeへスケジュールされます。</p><p>PodがスケジュールされたNodeのラベルを削除したり変更しても、Podは削除されません。
言い換えると、アフィニティはPodをスケジュールする際にのみ考慮されます。</p><p><code>preferredDuringSchedulingIgnoredDuringExecution</code>内の<code>weight</code>フィールドは、1から100の範囲で指定します。
全ての必要条件(リソースやRequiredDuringSchedulingアフィニティ等)を満たしたNodeに対して、スケジューラーはそのNodeがMatchExpressionsを満たした場合に、このフィルードの"weight"を加算して合計を計算します。
このスコアがNodeの他の優先機能のスコアと組み合わせれ、最も高いスコアを有したNodeが優先されます。</p><h3 id=pod間アフィニティとアンチアフィニティ>Pod間アフィニティとアンチアフィニティ</h3><p>Pod間アフィニティとアンチアフィニティは、Nodeのラベルではなく、すでにNodeで稼働しているPodのラベルに従ってPodがスケジュールされるNodeを制限します。
このポリシーは、"XにてルールYを満たすPodがすでに稼働している場合、このPodもXで稼働させる(アンチアフィニティの場合は稼働させない)"という形式です。
Yはnamespaceのリストで指定したLabelSelectorで表されます。
Nodeと異なり、Podはnamespaceで区切られているため(それゆえPodのラベルも暗黙的にnamespaceで区切られます)、Podのラベルを指定するlabel selectorは、どのnamespaceにselectorを適用するかを指定する必要があります。
概念的に、XはNodeや、ラック、クラウドプロバイダゾーン、クラウドプロバイダのリージョン等を表すトポロジードメインです。
これらを表すためにシステムが使用するNodeラベルのキーである<code>topologyKey</code>を使うことで、トポロジードメインを指定することができます。
先述のセクション<a href=#interlude-built-in-node-labels>補足: ビルトインNodeラベル</a>にてラベルの例が紹介されています。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Pod間アフィニティとアンチアフィニティは、大規模なクラスター上で使用する際にスケジューリングを非常に遅くする恐れのある多くの処理を要します。
そのため、数百台以上のNodeから成るクラスターでは使用することを推奨されません。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Podのアンチアフィニティは、Nodeに必ずラベルが付与されている必要があります。
言い換えると、クラスターの全てのNodeが、<code>topologyKey</code>で指定されたものに合致する適切なラベルが必要になります。
それらが付与されていないNodeが存在する場合、意図しない挙動を示すことがあります。</div><p>Nodeアフィニティと同様に、PodアフィニティとPodアンチアフィニティにも必須条件と優先条件を示す<code>requiredDuringSchedulingIgnoredDuringExecution</code>と<code>preferredDuringSchedulingIgnoredDuringExecution</code>があります。
前述のNodeアフィニティのセクションを参照してください。
<code>requiredDuringSchedulingIgnoredDuringExecution</code>を指定するアフィニティの使用例は、"Service AのPodとService BのPodが密に通信する際、それらを同じゾーンで稼働させる場合"です。
また、<code>preferredDuringSchedulingIgnoredDuringExecution</code>を指定するアンチアフィニティの使用例は、"ゾーンをまたいでPodのサービスを稼働させる場合"(Podの数はゾーンの数よりも多いため、必須条件を指定すると合理的ではありません)です。</p><p>Pod間アフィニティは、PodSpecの<code>affinity</code>フィールド内に<code>podAffinity</code>で指定し、Pod間アンチアフィニティは、<code>podAntiAffinity</code>で指定します。</p><h4 id=podアフィニティを使用したpodの例>Podアフィニティを使用したPodの例</h4><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-with-pod-affinity.yaml download=pods/pod-with-pod-affinity.yaml><code>pods/pod-with-pod-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-with-pod-affinity-yaml")' title="Copy pods/pod-with-pod-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-with-pod-affinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-pod-affinity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>security<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- S1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAffinityTerm</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>security<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- S2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>kubernetes.io/hostname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-pod-affinity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>このPodのアフィニティは、PodアフィニティとPodアンチアフィニティを1つずつ定義しています。
この例では、<code>podAffinity</code>に<code>requiredDuringSchedulingIgnoredDuringExecution</code>、<code>podAntiAffinity</code>に<code>preferredDuringSchedulingIgnoredDuringExecution</code>が設定されています。
Podアフィニティは、「キーが"security"、値が"S1"のラベルが付与されたPodが少なくとも1つは稼働しているNodeが同じゾーンにあれば、PodはそのNodeにスケジュールされる」という条件を指定しています(より正確には、キーが"security"、値が"S1"のラベルが付与されたPodが稼働しており、キーが<code>topology.kubernetes.io/zone</code>、値がVであるNodeが少なくとも1つはある状態で、
Node Nがキー<code>topology.kubernetes.io/zone</code>、値Vのラベルを持つ場合に、PodはNode Nで稼働させることができます)。
Podアンチアフィニティは、「すでにあるNode上で、キーが"security"、値が"S2"であるPodが稼働している場合に、Podを可能な限りそのNode上で稼働させない」という条件を指定しています
(<code>topologyKey</code>が<code>topology.kubernetes.io/zone</code>であった場合、キーが"security"、値が"S2"であるであるPodが稼働しているゾーンと同じゾーン内のNodeにはスケジュールされなくなります)。
PodアフィニティとPodアンチアフィニティや、<code>requiredDuringSchedulingIgnoredDuringExecution</code>と<code>preferredDuringSchedulingIgnoredDuringExecution</code>に関する他の使用例は<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/podaffinity.md>デザインドック</a>を参照してください。</p><p>PodアフィニティとPodアンチアフィニティで使用できるオペレーターは、<code>In</code>、<code>NotIn</code>、 <code>Exists</code>、 <code>DoesNotExist</code>です。</p><p>原則として、<code>topologyKey</code>には任意のラベルとキーが使用できます。
しかし、パフォーマンスやセキュリティの観点から、以下の制約があります:</p><ol><li>アフィニティと、<code>requiredDuringSchedulingIgnoredDuringExecution</code>を指定したPodアンチアフィニティは、<code>topologyKey</code>を指定しないことは許可されていません。</li><li><code>requiredDuringSchedulingIgnoredDuringExecution</code>を指定したPodアンチアフィニティでは、<code>kubernetes.io/hostname</code>の<code>topologyKey</code>を制限するため、アドミッションコントローラー<code>LimitPodHardAntiAffinityTopology</code>が導入されました。
トポロジーをカスタマイズする場合には、アドミッションコントローラーを修正または無効化する必要があります。</li><li><code>preferredDuringSchedulingIgnoredDuringExecution</code>を指定したPodアンチアフィニティでは、<code>topologyKey</code>を省略することはできません。</li><li>上記の場合を除き、<code>topologyKey</code> は任意のラベルとキーを指定することができます。</li></ol><p><code>labelSelector</code>と<code>topologyKey</code>に加え、<code>labelSelector</code>が合致すべき<code>namespaces</code>のリストを特定することも可能です(これは<code>labelSelector</code>と<code>topologyKey</code>を定義することと同等です)。
省略した場合や空の場合は、アフィニティとアンチアフィニティが定義されたPodのnamespaceがデフォルトで設定されます。</p><p><code>requiredDuringSchedulingIgnoredDuringExecution</code>が指定されたアフィニティとアンチアフィニティでは、<code>matchExpressions</code>に記載された全ての条件が満たされるNodeにPodがスケジュールされます。</p><h4 id=実際的なユースケース>実際的なユースケース</h4><p>Pod間アフィニティとアンチアフィニティは、ReplicaSet、StatefulSet、Deploymentなどのより高レベルなコレクションと併せて使用するとさらに有用です。
Workloadが、Node等の定義された同じトポロジーに共存させるよう、簡単に設定できます。</p><h5 id=常に同じnodeで稼働させる場合>常に同じNodeで稼働させる場合</h5><p>３つのノードから成るクラスターでは、ウェブアプリケーションはredisのようにインメモリキャッシュを保持しています。
このような場合、ウェブサーバーは可能な限りキャッシュと共存させることが望ましいです。</p><p>ラベル<code>app=store</code>を付与した3つのレプリカから成るredisのdeploymentを記述したyamlファイルを示します。
Deploymentには、1つのNodeにレプリカを共存させないために<code>PodAntiAffinity</code>を付与しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-cache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span>- store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis:3.2-alpine<span style=color:#bbb>
</span></span></span></code></pre></div><p>ウェブサーバーのDeploymentを記載した以下のyamlファイルには、<code>podAntiAffinity</code> と<code>podAffinity</code>が設定されています。
全てのレプリカが<code>app=store</code>のラベルが付与されたPodと同じゾーンで稼働するよう、スケジューラーに設定されます。
また、それぞれのウェブサーバーは1つのノードで稼働されないことも保証されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>web-store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>web-store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span>- web-store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span>- store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16-alpine<span style=color:#bbb>
</span></span></span></code></pre></div><p>上記2つのDeploymentが生成されると、3つのノードは以下のようになります。</p><table><thead><tr><th style=text-align:center>node-1</th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center><em>webserver-1</em></td><td style=text-align:center><em>webserver-2</em></td><td style=text-align:center><em>webserver-3</em></td></tr><tr><td style=text-align:center><em>cache-1</em></td><td style=text-align:center><em>cache-2</em></td><td style=text-align:center><em>cache-3</em></td></tr></tbody></table><p>このように、3つの<code>web-server</code>は期待通り自動的にキャッシュと共存しています。</p><pre tabindex=0><code>kubectl get pods -o wide
</code></pre><p>出力は以下のようになります:</p><pre tabindex=0><code>NAME                           READY     STATUS    RESTARTS   AGE       IP           NODE
redis-cache-1450370735-6dzlj   1/1       Running   0          8m        10.192.4.2   kube-node-3
redis-cache-1450370735-j2j96   1/1       Running   0          8m        10.192.2.2   kube-node-1
redis-cache-1450370735-z73mh   1/1       Running   0          8m        10.192.3.1   kube-node-2
web-server-1287567482-5d4dz    1/1       Running   0          7m        10.192.2.3   kube-node-1
web-server-1287567482-6f7v5    1/1       Running   0          7m        10.192.4.3   kube-node-3
web-server-1287567482-s330j    1/1       Running   0          7m        10.192.3.2   kube-node-2
</code></pre><h5 id=同じnodeに共存させない場合>同じNodeに共存させない場合</h5><p>上記の例では <code>PodAntiAffinity</code>を<code>topologyKey: "kubernetes.io/hostname"</code>と合わせて指定することで、redisクラスター内の2つのインスタンスが同じホストにデプロイされない場合を扱いました。
同様の方法で、アンチアフィニティを用いて高可用性を実現したStatefulSetの使用例は<a href=/docs/tutorials/stateful-application/zookeeper/#tolerating-node-failure>ZooKeeper tutorial</a>を参照してください。</p><h2 id=nodename>nodeName</h2><p><code>nodeName</code>はNodeの選択を制限する最も簡単な方法ですが、制約があることからあまり使用されません。
<code>nodeName</code>はPodSpecのフィールドです。
ここに値が設定されると、schedulerはそのPodを考慮しなくなり、その名前が付与されているNodeのkubeletはPodを稼働させようとします。
そのため、PodSpecに<code>nodeName</code>が指定されると、上述のNodeの選択方法よりも優先されます。</p><p><code>nodeName</code>を使用することによる制約は以下の通りです:</p><ul><li>その名前のNodeが存在しない場合、Podは起動されす、自動的に削除される場合があります。</li><li>その名前のNodeにPodを稼働させるためのリソースがない場合、Podの起動は失敗し、理由は例えばOutOfmemoryやOutOfcpuになります。</li><li>クラウド上のNodeの名前は予期できず、変更される可能性があります。</li></ul><p><code>nodeName</code>を指定したPodの設定ファイルの例を示します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>kube-01<span style=color:#bbb>
</span></span></span></code></pre></div><p>上記のPodはkube-01という名前のNodeで稼働します。</p><h2 id=次の項目>次の項目</h2><p><a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>Taints</a>を使うことで、NodeはPodを追い出すことができます。</p><p><a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/nodeaffinity.md>Nodeアフィニティ</a>と
<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/podaffinity.md>Pod間アフィニティ/アンチアフィニティ</a>
のデザインドキュメントには、これらの機能の追加のバックグラウンドの情報が記載されています。</p><p>一度PodがNodeに割り当たると、kubeletはPodを起動してノード内のリソースを確保します。
<a href=/docs/tasks/administer-cluster/topology-manager/>トポロジーマネージャー</a>はNodeレベルのリソース割り当てを決定する際に関与します。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-da22fe2278df236f71efbe672f392677>9.3 - Podのオーバーヘッド</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [stable]</code></div><p>PodをNode上で実行する時に、Pod自身は大量のシステムリソースを消費します。これらのリソースは、Pod内のコンテナ(群)を実行するために必要なリソースとして追加されます。Podのオーバーヘッドは、コンテナの要求と制限に加えて、Podのインフラストラクチャで消費されるリソースを計算するための機能です。</p><p>Kubernetesでは、Podの<a href=/docs/concepts/containers/runtime-class/>RuntimeClass</a>に関連するオーバーヘッドに応じて、<a href=/ja/docs/reference/access-authn-authz/extensible-admission-controllers/#what-are-admission-webhooks>アドミッション</a>時にPodのオーバーヘッドが設定されます。</p><p>Podのオーバーヘッドを有効にした場合、Podのスケジューリング時にコンテナのリソース要求の合計に加えて、オーバーヘッドも考慮されます。同様に、Kubeletは、Podのcgroupのサイズ決定時およびPodの退役の順位付け時に、Podのオーバーヘッドを含めます。</p><h2 id=set-up>Podのオーバーヘッドの有効化　</h2><p>クラスター全体で<code>PodOverhead</code>の<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>が有効になっていること（1.18時点ではデフォルトでオンになっています）と、<code>overhead</code>フィールドを定義する<code>RuntimeClass</code>が利用されていることを確認する必要があります。</p><h2 id=使用例>使用例</h2><p>Podのオーバーヘッド機能を使用するためには、<code>overhead</code>フィールドが定義されたRuntimeClassが必要です。例として、仮想マシンとゲストOSにPodあたり約120MiBを使用する仮想化コンテナランタイムで、次のようなRuntimeClassを定義できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kata-fc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>kata-fc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>overhead</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podFixed</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;120Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>kata-fc</code>RuntimeClassハンドラーを指定して作成されたワークロードは、リソースクォータの計算や、Nodeのスケジューリング、およびPodのcgroupのサイズ決定にメモリーとCPUのオーバーヘッドが考慮されます。</p><p>次のtest-podのワークロードの例を実行するとします。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>kata-fc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stdin</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tty</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>1500m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span></code></pre></div><p>アドミッション時、RuntimeClass<a href=/docs/reference/access-authn-authz/admission-controllers/>アドミッションコントローラー</a>は、RuntimeClass内に記述された<code>オーバーヘッド</code>を含むようにワークロードのPodSpecを更新します。もし既にPodSpec内にこのフィールドが定義済みの場合、そのPodは拒否されます。この例では、RuntimeClassの名前しか指定されていないため、アドミッションコントローラーは<code>オーバーヘッド</code>を含むようにPodを変更します。</p><p>RuntimeClassのアドミッションコントローラーの後、更新されたPodSpecを確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pod test-pod -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.overhead}&#39;</span>
</span></span></code></pre></div><p>出力は次の通りです:</p><pre tabindex=0><code>map[cpu:250m memory:120Mi]
</code></pre><p>ResourceQuotaが定義されている場合、コンテナ要求の合計と<code>オーバーヘッド</code>フィールドがカウントされます。</p><p>kube-schedulerが新しいPodを実行すべきNodeを決定する際、スケジューラーはそのPodの<code>オーバーヘッド</code>と、そのPodに対するコンテナ要求の合計を考慮します。この例だと、スケジューラーは、要求とオーバーヘッドを追加し、2.25CPUと320MiBのメモリを持つNodeを探します。</p><p>PodがNodeにスケジュールされると、そのNodeのkubeletはPodのために新しい<a class=glossary-tooltip title='A group of Linux processes with optional resource isolation, accounting and limits.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-cgroup' target=_blank aria-label=cgroup>cgroup</a>を生成します。基盤となるコンテナランタイムがコンテナを作成するのは、このPod内です。</p><p>リソースにコンテナごとの制限が定義されている場合(制限が定義されているGuaranteed QoSまたはBustrable QoS)、kubeletはそのリソース(CPUはcpu.cfs_quota_us、メモリはmemory.limit_in_bytes)に関連するPodのcgroupの上限を設定します。この上限は、コンテナの制限とPodSpecで定義された<code>オーバーヘッド</code>の合計に基づきます。</p><p>CPUについては、PodがGuaranteedまたはBurstable QoSの場合、kubeletはコンテナの要求の合計とPodSpecに定義された<code>オーバーヘッド</code>に基づいて<code>cpu.share</code>を設定します。</p><p>次の例より、ワークロードに対するコンテナの要求を確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pod test-pod -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.containers[*].resources.limits}&#39;</span>
</span></span></code></pre></div><p>コンテナの要求の合計は、CPUは2000m、メモリーは200MiBです。</p><pre tabindex=0><code>map[cpu: 500m memory:100Mi] map[cpu:1500m memory:100Mi]
</code></pre><p>Nodeで観測される値と比較してみましょう。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe node | grep test-pod -B2
</span></span></code></pre></div><p>出力では、2250mのCPUと320MiBのメモリーが要求されており、Podのオーバーヘッドが含まれていることが分かります。</p><pre tabindex=0><code>  Namespace    Name       CPU Requests  CPU Limits   Memory Requests  Memory Limits  AGE
  ---------    ----       ------------  ----------   ---------------  -------------  ---
  default      test-pod   2250m (56%)   2250m (56%)  320Mi (1%)       320Mi (1%)     36m
</code></pre><h2 id=podのcgroupの制限を確認>Podのcgroupの制限を確認</h2><p>ワークロードで実行中のNode上にある、Podのメモリーのcgroupを確認します。次に示す例では、CRI互換のコンテナランタイムのCLIを提供するNodeで<a href=https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md><code>crictl</code></a>を使用しています。これはPodのオーバーヘッドの動作を示すための高度な例であり、ユーザーがNode上で直接cgroupsを確認する必要はありません。</p><p>まず、特定のNodeで、Podの識別子を決定します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># PodがスケジュールされているNodeで実行</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>POD_ID</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>sudo crictl pods --name test-pod -q<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div><p>ここから、Podのcgroupのパスが決定します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># PodがスケジュールされているNodeで実行</span>
</span></span><span style=display:flex><span>sudo crictl inspectp -o<span style=color:#666>=</span>json <span style=color:#b8860b>$POD_ID</span> | grep cgroupsPath
</span></span></code></pre></div><p>結果のcgroupパスにはPodの<code>ポーズ中</code>コンテナも含まれます。Podレベルのcgroupは１つ上のディレクトリです。</p><pre tabindex=0><code>  &#34;cgroupsPath&#34;: &#34;/kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2/7ccf55aee35dd16aca4189c952d83487297f3cd760f1bbf09620e206e7d0c27a&#34;
</code></pre><p>今回のケースでは、Podのcgroupパスは、<code>kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2</code>となります。メモリーのPodレベルのcgroupの設定を確認しましょう。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># PodがスケジュールされているNodeで実行</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># また、Podに割り当てられたcgroupと同じ名前に変更</span>
</span></span><span style=display:flex><span> cat /sys/fs/cgroup/memory/kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2/memory.limit_in_bytes
</span></span></code></pre></div><p>予想通り320MiBです。</p><pre tabindex=0><code>335544320
</code></pre><h3 id=observability>Observability</h3><p>Podのオーバヘッドが利用されているタイミングを特定し、定義されたオーバーヘッドで実行されているワークロードの安定性を観察するため、<a href=https://github.com/kubernetes/kube-state-metrics>kube-state-metrics</a>には<code>kube_pod_overhead</code>というメトリクスが用意されています。この機能はv1.9のkube-state-metricsでは利用できませんが、次のリリースで期待されています。それまでは、kube-state-metricsをソースからビルドする必要があります。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/containers/runtime-class/>RuntimeClass</a></li><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/688-pod-overhead>Podのオーバーヘッドの設計</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ede4960b56a3529ee0bfe7c8fe2d09a5>9.4 - TaintとToleration</h1><p><a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity><em>Nodeアフィニティ</em></a>は
<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>の属性であり、ある<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>群を<em>引きつけます</em>（優先条件または必須条件）。反対に <em>taint</em> はNodeがある種のPodを排除できるようにします。</p><p><em>toleration</em> はPodに適用され、一致するtaintが付与されたNodeへPodがスケジューリングされることを認めるものです。ただしそのNodeへ必ずスケジューリングされるとは限りません。</p><p>taintとtolerationは組になって機能し、Podが不適切なNodeへスケジューリングされないことを保証します。taintはNodeに一つまたは複数個付与することができます。これはそのNodeがtaintを許容しないPodを受け入れるべきではないことを示します。</p><h2 id=コンセプト>コンセプト</h2><p>Nodeにtaintを付与するには<a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a>コマンドを使用します。
例えば、次のコマンドは</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule
</span></span></code></pre></div><p><code>node1</code>にtaintを設定します。このtaintのキーは<code>key1</code>、値は<code>value1</code>、taintの効果は<code>NoSchedule</code>です。
これは<code>node1</code>にはPodに合致するtolerationがなければスケジューリングされないことを意味します。</p><p>上記のコマンドで付与したtaintを外すには、下記のコマンドを使います。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule-
</span></span></code></pre></div><p>PodのtolerationはPodSpecの中に指定します。下記のtolerationはどちらも、上記の<code>kubectl taint</code>コマンドで追加したtaintと合致するため、どちらのtolerationが設定されたPodも<code>node1</code>へスケジューリングされることができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>tolerationを設定したPodの例を示します。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-with-toleration.yaml download=pods/pod-with-toleration.yaml><code>pods/pod-with-toleration.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-with-toleration-yaml")' title="Copy pods/pod-with-toleration.yaml to clipboard"></img></div><div class=includecode id=pods-pod-with-toleration-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-key&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p><code>operator</code>のデフォルトは<code>Equal</code>です。</p><p>tolerationがtaintと合致するのは、<code>key</code>と<code>effect</code>が同一であり、さらに下記の条件のいずれかを満たす場合です。</p><ul><li><code>operator</code>が<code>Exists</code>（<code>value</code>を指定すべきでない場合）</li><li><code>operator</code>が<code>Equal</code>であり、かつ<code>value</code>が同一である場合</li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>2つ特殊な場合があります。</p><p>空の<code>key</code>と演算子<code>Exists</code>は全ての<code>key</code>、<code>value</code>、<code>effect</code>と一致するため、すべてのtaintと合致します。</p><p>空の<code>effect</code>は<code>key1</code>が一致する全てのeffectと合致します。</p></div><p>上記の例では<code>effect</code>に<code>NoSchedule</code>を指定しました。代わりに、<code>effect</code>に<code>PreferNoSchedule</code>を指定することができます。
これは<code>NoSchedule</code>の「ソフトな」バージョンであり、システムはtaintに対応するtolerationが設定されていないPodがNodeへ配置されることを避けようとしますが、必須の条件とはしません。3つ目の<code>effect</code>の値として<code>NoExecute</code>がありますが、これについては後述します。</p><p>同一のNodeに複数のtaintを付与することや、同一のPodに複数のtolerationを設定することができます。
複数のtaintやtolerationが設定されている場合、Kubernetesはフィルタのように扱います。最初はNodeの全てのtaintがある状態から始め、Podが対応するtolerationを持っているtaintは無視され外されていきます。無視されずに残ったtaintが効果を及ぼします。
具体的には、</p><ul><li>effect <code>NoSchedule</code>のtaintが無視されず残った場合、KubernetesはそのPodをNodeへスケジューリングしません。</li><li>effect <code>NoSchedule</code>のtaintは残らず、effect <code>PreferNoSchedule</code>のtaintは残った場合、KubernetesはそのNodeへのスケジューリングをしないように試みます。</li><li>effect <code>NoExecute</code>のtaintが残った場合、既に稼働中のPodはそのNodeから排除され、まだ稼働していないPodはスケジューリングされないようになります。</li></ul><p>例として、下記のようなtaintが付与されたNodeを考えます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule
</span></span><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoExecute
</span></span><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key2</span><span style=color:#666>=</span>value2:NoSchedule
</span></span></code></pre></div><p>Podには2つのtolerationが設定されています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>この例では、3つ目のtaintと合致するtolerationがないため、PodはNodeへはスケジューリングされません。
しかし、これらのtaintが追加された時点で、そのNodeでPodが稼働していれば続けて稼働することが可能です。 これは、Podのtolerationと合致しないtaintは3つあるtaintのうちの3つ目のtaintのみであり、それが<code>NoSchedule</code>であるためです。</p><p>一般に、effect <code>NoExecute</code>のtaintがNodeに追加されると、合致するtolerationが設定されていないPodは即時にNodeから排除され、合致するtolerationが設定されたPodが排除されることは決してありません。
しかし、effect<code>NoExecute</code>に対するtolerationは<code>tolerationSeconds</code>フィールドを任意で指定することができ、これはtaintが追加された後にそのNodeにPodが残る時間を示します。例えば、</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>この例のPodが稼働中で、対応するtaintがNodeへ追加された場合、PodはそのNodeに3600秒残り、その後排除されます。仮にtaintがそれよりも前に外された場合、Podは排除されません。</p><h2 id=ユースケースの例>ユースケースの例</h2><p>taintとtolerationは、実行されるべきではないNodeからPodを遠ざけたり、排除したりするための柔軟な方法です。いくつかのユースケースを示します。</p><ul><li><p><strong>専有Node</strong>: あるNode群を特定のユーザーに専有させたい場合、そのNode群へtaintを追加し(<code>kubectl taint nodes nodename dedicated=groupName:NoSchedule</code>) 対応するtolerationをPodへ追加します（これを実現する最も容易な方法はカスタム
<a href=/docs/reference/access-authn-authz/admission-controllers/>アドミッションコントローラー</a>を書くことです）。
tolerationが設定されたPodはtaintの設定された（専有の）Nodeと、クラスターにあるその他のNodeの使用が認められます。もしPodが必ず専有Node<em>のみ</em>を使うようにしたい場合は、taintと同様のラベルをそのNode群に設定し(例: <code>dedicated=groupName</code>)、アドミッションコントローラーはNodeアフィニティを使ってPodが<code>dedicated=groupName</code>のラベルの付いたNodeへスケジューリングすることが必要であるということも設定する必要があります。</p></li><li><p><strong>特殊なハードウェアを備えるNode</strong>: クラスターの中の少数のNodeが特殊なハードウェア（例えばGPU）を備える場合、そのハードウェアを必要としないPodがスケジューリングされないようにして、後でハードウェアを必要とするPodができたときの余裕を確保したいことがあります。
これは特殊なハードウェアを持つNodeにtaintを追加(例えば <code>kubectl taint nodes nodename special=true:NoSchedule</code> または
<code>kubectl taint nodes nodename special=true:PreferNoSchedule</code>)して、ハードウェアを使用するPodに対応するtolerationを追加することで可能です。
専有Nodeのユースケースと同様に、tolerationを容易に適用する方法はカスタム
<a href=/docs/reference/access-authn-authz/admission-controllers/>アドミッションコントローラー</a>を使うことです。
例えば、特殊なハードウェアを表すために<a href=/docs/concepts/configuration/manage-compute-resources-container/#extended-resources>拡張リソース</a>
を使い、ハードウェアを備えるNodeに拡張リソースの名称のtaintを追加して、
<a href=/docs/reference/access-authn-authz/admission-controllers/#extendedresourcetoleration>拡張リソースtoleration</a>
アドミッションコントローラーを実行することが推奨されます。Nodeにはtaintが付与されているため、tolerationのないPodはスケジューリングされません。しかし拡張リソースを要求するPodを作成しようとすると、<code>拡張リソースtoleration</code> アドミッションコントローラーはPodに自動的に適切なtolerationを設定し、Podはハードウェアを備えるNodeへスケジューリングされます。
これは特殊なハードウェアを備えたNodeではそれを必要とするPodのみが稼働し、Podに対して手作業でtolerationを追加しなくて済むようにします。</p></li><li><p><strong>taintを基にした排除</strong>: Nodeに問題が起きたときにPodごとに排除する設定を行うことができます。次のセクションにて説明します。</p></li></ul><h2 id=taintを基にした排除>taintを基にした排除</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>上述したように、effect <code>NoExecute</code>のtaintはNodeで実行中のPodに次のような影響を与えます。</p><ul><li>対応するtolerationのないPodは即座に除外される</li><li>対応するtolerationがあり、それに<code>tolerationSeconds</code>が指定されていないPodは残り続ける</li><li>対応するtolerationがあり、それに<code>tolerationSeconds</code>が指定されているPodは指定された間、残される</li></ul><p>Nodeコントローラーは特定の条件を満たす場合に自動的にtaintを追加します。
組み込まれているtaintは下記の通りです。</p><ul><li><code>node.kubernetes.io/not-ready</code>: Nodeの準備ができていない場合。これはNodeCondition <code>Ready</code>が<code>False</code>である場合に対応します。</li><li><code>node.kubernetes.io/unreachable</code>: NodeがNodeコントローラーから到達できない場合。これはNodeCondition<code>Ready</code>が<code>Unknown</code>の場合に対応します。</li><li><code>node.kubernetes.io/out-of-disk</code>: Nodeのディスクの空きがない場合。</li><li><code>node.kubernetes.io/memory-pressure</code>: Nodeのメモリーが不足している場合。</li><li><code>node.kubernetes.io/disk-pressure</code>: Nodeのディスクが不足している場合。</li><li><code>node.kubernetes.io/network-unavailable</code>: Nodeのネットワークが利用できない場合。</li><li><code>node.kubernetes.io/unschedulable</code>: Nodeがスケジューリングできない場合。</li><li><code>node.cloudprovider.kubernetes.io/uninitialized</code>: kubeletが外部のクラウド事業者により起動されたときに設定されるtaintで、このNodeは利用不可能であることを示します。cloud-controller-managerによるコントローラーがこのNodeを初期化した後にkubeletはこのtaintを外します。</li></ul><p>Nodeから追い出すときには、Nodeコントローラーまたはkubeletは関連するtaintを<code>NoExecute</code>効果の状態で追加します。
不具合のある状態から通常の状態へ復帰した場合は、kubeletまたはNodeコントローラーは関連するtaintを外すことができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> コントロールプレーンは新しいtaintをNodeに加えるレートを制限しています。
このレート制限は一度に多くのNodeが到達不可能になった場合（例えばネットワークの断絶）に、退役させられるNodeの数を制御します。</div><p>Podに<code>tolerationSeconds</code>を指定することで不具合があるか応答のないNodeに残る時間を指定することができます。</p><p>例えば、ローカルの状態を多数持つアプリケーションとネットワークが分断された場合を考えます。ネットワークが復旧して、Podを排除しなくて済むことを見込んで、長時間Nodeから排除されないようにしたいこともあるでしょう。
この場合Podに設定するtolerationは次のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;node.kubernetes.io/unreachable&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>6000</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>Kubernetesはユーザーまたはコントローラーが明示的に指定しない限り、自動的に<code>node.kubernetes.io/not-ready</code>と<code>node.kubernetes.io/unreachable</code>に対するtolerationを<code>tolerationSeconds=300</code>にて設定します。</p><p>自動的に設定されるtolerationは、taintに対応する問題がNodeで検知されても5分間はそのNodeにPodが残されることを意味します。</p></div><p><a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>のPodは次のtaintに対して<code>NoExecute</code>のtolerationが<code>tolerationSeconds</code>を指定せずに設定されます。</p><ul><li><code>node.kubernetes.io/unreachable</code></li><li><code>node.kubernetes.io/not-ready</code></li></ul><p>これはDaemonSetのPodはこれらの問題によって排除されないことを保証します。</p><h2 id=条件によるtaintの付与>条件によるtaintの付与</h2><p>NodeのライフサイクルコントローラーはNodeの状態に応じて<code>NoSchedule</code>効果のtaintを付与します。
スケジューラーはNodeの状態ではなく、taintを確認します。
Nodeに何がスケジューリングされるかは、そのNodeの状態に影響されないことを保証します。ユーザーは適切なtolerationをPodに付与することで、どの種類のNodeの問題を無視するかを選ぶことができます。</p><p>DaemonSetのコントローラーは、DaemonSetが中断されるのを防ぐために自動的に次の<code>NoSchedule</code>tolerationを全てのDaemonSetに付与します。</p><ul><li><code>node.kubernetes.io/memory-pressure</code></li><li><code>node.kubernetes.io/disk-pressure</code></li><li><code>node.kubernetes.io/out-of-disk</code> (<em>重要なPodのみ</em>)</li><li><code>node.kubernetes.io/unschedulable</code> (1.10またはそれ以降)</li><li><code>node.kubernetes.io/network-unavailable</code> (<em>ホストネットワークのみ</em>)</li></ul><p>これらのtolerationを追加することは後方互換性を保証します。DaemonSetに任意のtolerationを加えることもできます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/tasks/administer-cluster/out-of-resource/>リソース枯渇の対処</a>とどのような設定ができるかについてを読む</li><li><a href=/docs/concepts/configuration/pod-priority-preemption/>Podの優先度</a>を読む</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b87723bf81b079042860f0ebd37b0a64>9.5 - APIを起点とした退避</h1><p>APIを起点とした退避は、<a href=/docs/reference/generated/kubernetes-api/v1.25/#create-eviction-pod-v1-core>Eviction API</a>を使用して退避オブジェクトを作成し、Podの正常終了を起動させるプロセスです。</br></p><p>Eviction APIを直接呼び出すか、<code>kubectl drain</code>コマンドのように<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>のクライアントを使って退避を要求することが可能です。これにより、<code>Eviction</code>オブジェクトを作成し、APIサーバーにPodを終了させます。</p><p>APIを起点とした退避は<a href=/docs/tasks/run-application/configure-pdb/><code>PodDisruptionBudgets</code></a>と<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle#pod-termination><code>terminationGracePeriodSeconds</code></a>の設定を優先します。</p><p>APIを使用してPodのEvictionオブジェクトを作成することは、Podに対してポリシー制御された<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#delete-delete-a-pod><code>DELETE</code>操作</a>を実行することに似ています。</p><h2 id=calling-the-eviction-api>Eviction APIの実行</h2><p>Kubernetes APIへアクセスして<code>Eviction</code>オブジェクトを作るために<a href=/docs/tasks/administer-cluster/access-cluster-api/#programmatic-access-to-the-api>Kubernetesのプログラミング言語のクライアント</a>を使用できます。
そのためには、次の例のようなデータをPOSTすることで操作を試みることができます。</p><ul class="nav nav-tabs" id=eviction-example role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#eviction-example-0 role=tab aria-controls=eviction-example-0 aria-selected=true>policy/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#eviction-example-1 role=tab aria-controls=eviction-example-1>policy/v1beta1</a></li></ul><div class=tab-content id=eviction-example><div id=eviction-example-0 class="tab-pane show active" role=tabpanel aria-labelledby=eviction-example-0><p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>policy/v1</code>においてEvictionはv1.22以上で利用可能です。それ以前のリリースでは、<code>policy/v1beta1</code>を使用してください。</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;policy/v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Eviction&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;quux&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><div id=eviction-example-1 class=tab-pane role=tabpanel aria-labelledby=eviction-example-1><p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> v1.22で非推奨となり、<code>policy/v1</code>が採用されました。</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;policy/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Eviction&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;quux&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></div><p>また、以下の例のように<code>curl</code>や<code>wget</code>を使ってAPIにアクセスすることで、操作を試みることもできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -v -H <span style=color:#b44>&#39;Content-type: application/json&#39;</span> https://your-cluster-api-endpoint.example/api/v1/namespaces/default/pods/quux/eviction -d @eviction.json
</span></span></code></pre></div><h2 id=how-api-initiated-eviction-works>APIを起点とした退避の仕組み</h2><p>APIを使用して退去を要求した場合、APIサーバーはアドミッションチェックを行い、以下のいずれかを返します。</p><ul><li><code>200 OK</code>:この場合、退去が許可されると<code>Eviction</code>サブリソースが作成され、PodのURLに<code>DELETE</code>リクエストを送るのと同じように、Podが削除されます。</li><li><code>429 Too Many Requests</code>:<a class=glossary-tooltip title='An object that limits the number of  of a replicated application, that are down simultaneously from voluntary disruptions.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-pod-disruption-budget' target=_blank aria-label=PodDisruptionBudget>PodDisruptionBudget</a>の設定により、現在退去が許可されていないことを示します。しばらく時間を空けてみてください。また、APIのレート制限のため、このようなレスポンスが表示されることもあります。</li><li><code>500 Internal Server Error</code>:複数のPodDisruptionBudgetが同じPodを参照している場合など、設定に誤りがあり退去が許可されないことを示します。</li></ul><p>退去させたいPodがPodDisruptionBudgetを持つワークロードの一部でない場合、APIサーバーは常に<code>200 OK</code>を返して退去を許可します。</p><p>APIサーバーが退去を許可した場合、以下の流れでPodが削除されます。</p><ol><li>APIサーバーの<code>Pod</code>リソースの削除タイムスタンプが更新され、APIサーバーは<code>Pod</code>リソースが終了したと見なします。また<code>Pod</code>リソースは、設定された猶予期間が設けられます。</li><li>ローカルのPodが動作しているNodeの<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>は、<code>Pod</code>リソースが終了するようにマークされていることに気付き、Podの適切なシャットダウンを開始します。</li><li>kubeletがPodをシャットダウンしている間、コントロールプレーンは<a class=glossary-tooltip title='Endpoints track the IP addresses of Pods with matching Service selectors.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-endpoint' target=_blank aria-label=Endpoint>Endpoint</a>オブジェクトからPodを削除します。その結果、コントローラーはPodを有効なオブジェクトと見なさないようになります。</li><li>Podの猶予期間が終了すると、kubeletはローカルPodを強制的に終了します。</li><li>kubeletはAPIサーバーに<code>Pod</code>リソースを削除するように指示します。</li><li>APIサーバーは<code>Pod</code>リソースを削除します。</li></ol><h2 id=troubleshooting-stuck-evictions>トラブルシューティング</h2><p>場合によっては、アプリケーションが壊れた状態になり、対処しない限りEviction APIが<code>429</code>または<code>500</code>レスポンスを返すだけとなることがあります。例えば、ReplicaSetがアプリケーション用のPodを作成しても、新しいPodが<code>Ready</code>状態にならない場合などです。また、最後に退去したPodの終了猶予期間が長い場合にも、この事象が見られます。</p><p>退去が進まない場合は、以下の解決策を試してみてください。</p><ul><li>問題を引き起こしている自動化された操作を中止または一時停止し、操作を再開する前に、スタックしているアプリケーションを調査を行ってください。</li><li>しばらく待ってから、Eviction APIを使用する代わりに、クラスターのコントロールプレーンから直接Podを削除してください。</li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/tasks/run-application/configure-pdb/>Pod Disruption Budget</a>でアプリケーションを保護する方法について学ぶ</li><li><a href=/docs/concepts/scheduling-eviction/node-pressure-eviction/>Node不足による退避</a>について学ぶ</li><li><a href=/docs/concepts/scheduling-eviction/pod-priority-preemption/>Podの優先度とプリエンプション</a>について学ぶ</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d9574a30fcbc631b0d2a57850e161e89>9.6 - スケジューラーのパフォーマンスチューニング</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.14 [beta]</code></div><p><a href=/ja/docs/concepts/scheduling-eviction/kube-scheduler/#kube-scheduler>kube-scheduler</a>はKubernetesのデフォルトのスケジューラーです。クラスター内のノード上にPodを割り当てる責務があります。</p><p>クラスター内に存在するノードで、Podのスケジューリング要求を満たすものはPodに対して<em>割り当て可能</em>なノードと呼ばれます。スケジューラーはPodに対する割り当て可能なノードをみつけ、それらの割り当て可能なノードにスコアをつけます。その中から最も高いスコアのノードを選択し、Podに割り当てるためのいくつかの関数を実行します。スケジューラーは<em>Binding</em>と呼ばれる処理中において、APIサーバーに対して割り当てが決まったノードの情報を通知します。</p><p>このページでは、大規模のKubernetesクラスターにおけるパフォーマンス最適化のためのチューニングについて説明します。</p><p>大規模クラスターでは、レイテンシー(新規Podをすばやく配置)と精度(スケジューラーが不適切な配置を行うことはめったにありません)の間でスケジューリング結果を調整するスケジューラーの動作をチューニングできます。</p><p>このチューニング設定は、kube-scheduler設定の<code>percentageOfNodesToScore</code>で設定できます。KubeSchedulerConfiguration設定は、クラスター内のノードにスケジュールするための閾値を決定します。</p><h3 id=閾値の設定>閾値の設定</h3><p><code>percentageOfNodesToScore</code>オプションは、0から100までの数値を受け入れます。0は、kube-schedulerがコンパイル済みのデフォルトを使用することを示す特別な値です。
<code>percentageOfNodesToScore</code>に100より大きな値を設定した場合、kube-schedulerの挙動は100を設定した場合と同様となります。</p><p>この値を変更するためには、kube-schedulerの設定ファイル(これは<code>/etc/kubernetes/config/kube-scheduler.yaml</code>の可能性が高い)を編集し、スケジューラーを再起動します。</p><p>この変更をした後、</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pods -n kube-system | grep kube-scheduler
</span></span></code></pre></div><p>を実行して、kube-schedulerコンポーネントが正常であることを確認できます。</p><h2 id=percentage-of-nodes-to-score>ノードへのスコア付けの閾値</h2><p>スケジューリング性能を改善するため、kube-schedulerは割り当て可能なノードが十分に見つかるとノードの検索を停止できます。大規模クラスターでは、すべてのノードを考慮する単純なアプローチと比較して時間を節約できます。</p><p>クラスター内のすべてのノードに対する十分なノード数を整数パーセンテージで指定します。kube-schedulerは、これをノード数に変換します。スケジューリング中に、kube-schedulerが設定されたパーセンテージを超える十分な割り当て可能なノードを見つけた場合、kube-schedulerはこれ以上割り当て可能なノードを探すのを止め、<a href=/ja/docs/concepts/scheduling-eviction/kube-scheduler/#kube-scheduler-implementation>スコアリングフェーズ</a>に進みます。</p><p><a href=#how-the-scheduler-iterates-over-nodes>スケジューラーはどのようにノードを探索するか</a>で処理を詳しく説明しています。</p><h3 id=デフォルトの閾値>デフォルトの閾値</h3><p>閾値を指定しない場合、Kubernetesは100ノードのクラスタでは50%、5000ノードのクラスタでは10%になる線形方程式を使用して数値を計算します。自動計算の下限は5%です。</p><p>つまり、明示的に<code>percentageOfNodesToScore</code>を5未満の値を設定しない限り、クラスターの規模に関係なく、kube-schedulerは常に少なくともクラスターの5%のノードに対してスコア付けをします。</p><p>スケジューラーにクラスター内のすべてのノードに対してスコア付けをさせる場合は、<code>percentageOfNodesToScore</code>の値に100を設定します。</p><h2 id=例>例</h2><p><code>percentageOfNodesToScore</code>の値を50%に設定する例は下記のとおりです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>algorithmSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>provider</span>:<span style=color:#bbb> </span>DefaultProvider<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>percentageOfNodesToScore</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=percentageofnodestoscoreのチューニング>percentageOfNodesToScoreのチューニング</h2><p><code>percentageOfNodesToScore</code>は1から100の間の範囲である必要があり、デフォルト値はクラスターのサイズに基づいて計算されます。また、クラスターのサイズの最小値は50ノードとハードコードされています。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>割り当て可能なノードが50以下のクラスタでは、スケジューラの検索を早期に停止するのに十分な割り当て可能なノードがないため、スケジューラはすべてのノードをチェックします。</p><p>小規模クラスタでは、<code>percentageOfNodesToScore</code>に低い値を設定したとしても、同様の理由で変更による影響は全くないか、ほとんどありません。</p><p>クラスターのノード数が数百以下の場合は、この設定オプションをデフォルト値のままにします。変更してもスケジューラの性能を大幅に改善する可能性はほとんどありません。</p></div><p>この値を設定する際に考慮するべき重要な注意事項として、割り当て可能ノードのチェック対象のノードが少ないと、一部のノードはPodの割り当てのためにスコアリングされなくなります。結果として、高いスコアをつけられる可能性のあるノードがスコアリングフェーズに渡されることがありません。これにより、Podの配置が理想的なものでなくなります。</p><p>kube-schedulerが頻繁に不適切なPodの配置を行わないよう、<code>percentageOfNodesToScore</code>をかなり低い値を設定することは避けるべきです。スケジューラのスループットがアプリケーションにとって致命的で、ノードのスコアリングが重要でない場合を除いて、10%未満に設定することは避けてください。言いかえると、割り当て可能な限り、Podは任意のノード上で稼働させるのが好ましいです。</p><h2 id=how-the-scheduler-iterates-over-nodes>スケジューラーはどのようにノードを探索するか</h2><p>このセクションでは、この機能の内部の詳細を理解したい人向けになります。</p><p>クラスター内の全てのノードに対して平等にPodの割り当ての可能性を持たせるため、スケジューラーはラウンドロビン方式でノードを探索します。複数のノードの配列になっているイメージです。スケジューラーはその配列の先頭から探索を開始し、<code>percentageOfNodesToScore</code>によって指定された数のノードを検出するまで、割り当て可能かどうかをチェックしていきます。次のPodでは、スケジューラーは前のPodの割り当て処理でチェックしたところから探索を再開します。</p><p>ノードが複数のゾーンに存在するとき、スケジューラーは様々なゾーンのノードを探索して、異なるゾーンのノードが割り当て可能かどうかのチェック対象になるようにします。例えば2つのゾーンに6つのノードがある場合を考えます。</p><pre tabindex=0><code>Zone 1: Node 1, Node 2, Node 3, Node 4
Zone 2: Node 5, Node 6
</code></pre><p>スケジューラーは、下記の順番でノードの割り当て可能性を評価します。</p><pre tabindex=0><code>Node 1, Node 5, Node 2, Node 6, Node 3, Node 4
</code></pre><p>全てのノードのチェックを終えたら、1番目のノードに戻ってチェックをします。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-961126cd43559012893979e568396a49>9.7 - 拡張リソースのリソースビンパッキング</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>kube-schedulerでは、優先度関数<code>RequestedToCapacityRatioResourceAllocation</code>を使用した、
拡張リソースを含むリソースのビンパッキングを有効化できます。優先度関数はそれぞれのニーズに応じて、kube-schedulerを微調整するために使用できます。</p><h2 id=requestedtocapacityratioresourceallocation-を使用したビンパッキングの有効化><code>RequestedToCapacityRatioResourceAllocation</code>を使用したビンパッキングの有効化</h2><p>Kubernetesでは、キャパシティー比率への要求に基づいたNodeのスコアリングをするために、各リソースの重みと共にリソースを指定することができます。これにより、ユーザーは適切なパラメーターを使用することで拡張リソースをビンパックすることができ、大規模クラスターにおける希少なリソースを有効活用できるようになります。優先度関数<code>RequestedToCapacityRatioResourceAllocation</code>の動作は<code>RequestedToCapacityRatioArgs</code>と呼ばれる設定オプションによって変わります。この引数は<code>shape</code>と<code>resources</code>パラメーターによって構成されます。<code>shape</code>パラメーターは<code>utilization</code>と<code>score</code>の値に基づいて、最も要求が多い場合か最も要求が少ない場合の関数をチューニングできます。<code>resources</code>パラメーターは、スコアリングの際に考慮されるリソース名の<code>name</code>と、各リソースの重みを指定する<code>weight</code>で構成されます。</p><p>以下は、拡張リソース<code>intel.com/foo</code>と<code>intel.com/bar</code>のビンパッキングに<code>requestedToCapacityRatioArguments</code>を設定する例になります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pluginConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>RequestedToCapacityRatio<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>shape</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>utilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>utilization</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>intel.com/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>intel.com/bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>スケジューラーには、kube-schedulerフラグ<code>--config=/path/to/config/file</code>を使用して<code>KubeSchedulerConfiguration</code>のファイルを指定することで渡すことができます。</p><p><strong>この機能はデフォルトで無効化されています</strong></p><h3 id=優先度関数のチューニング>優先度関数のチューニング</h3><p><code>shape</code>は<code>RequestedToCapacityRatioPriority</code>関数の動作を指定するために使用されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>shape</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>- <span style=color:green;font-weight:700>utilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>- <span style=color:green;font-weight:700>utilization</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>上記の引数は、<code>utilization</code>が0%の場合は0、<code>utilization</code>が100%の場合は10という<code>score</code>をNodeに与え、ビンパッキングの動作を有効にしています。最小要求を有効にするには、次のようにスコアを反転させる必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>shape</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>utilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>utilization</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>resources</code>はオプションパラメーターで、デフォルトでは以下の通りです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>以下のように拡張リソースの追加に利用できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>intel.com/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>weight</code>はオプションパラメーターで、指定されてない場合1が設定されます。また、マイナスの値は設定できません。</p><h3 id=キャパシティ割り当てのためのnodeスコアリング>キャパシティ割り当てのためのNodeスコアリング</h3><p>このセクションは、本機能の内部詳細について理解したい方を対象としています。以下は、与えられた値に対してNodeのスコアがどのように計算されるかの例です。</p><p>要求されたリソース:</p><pre tabindex=0><code>intel.com/foo : 2
memory: 256MB
cpu: 2
</code></pre><p>リソースの重み:</p><pre tabindex=0><code>intel.com/foo : 5
memory: 1
cpu: 3
</code></pre><p><code>shape</code>の値 {{0, 0}, {100, 10}}</p><p>Node1のスペック:</p><pre tabindex=0><code>Available:
  intel.com/foo: 4
  memory: 1 GB
  cpu: 8

Used:
  intel.com/foo: 1
  memory: 256MB
  cpu: 1
</code></pre><p>Nodeのスコア:</p><pre tabindex=0><code>intel.com/foo  = resourceScoringFunction((2+1),4)
               = (100 - ((4-3)*100/4)
               = (100 - 25)
               = 75                       # requested + used = 75% * available
               = rawScoringFunction(75)
               = 7                        # floor(75/10)

memory         = resourceScoringFunction((256+256),1024)
               = (100 -((1024-512)*100/1024))
               = 50                       # requested + used = 50% * available
               = rawScoringFunction(50)
               = 5                        # floor(50/10)

cpu            = resourceScoringFunction((2+1),8)
               = (100 -((8-3)*100/8))
               = 37.5                     # requested + used = 37.5% * available
               = rawScoringFunction(37.5)
               = 3                        # floor(37.5/10)

NodeScore   =  (7 * 5) + (5 * 1) + (3 * 3) / (5 + 1 + 3)
            =  5
</code></pre><p>Node2のスペック:</p><pre tabindex=0><code>Available:
  intel.com/foo: 8
  memory: 1GB
  cpu: 8
Used:
  intel.com/foo: 2
  memory: 512MB
  cpu: 6
</code></pre><p>Nodeのスコア:</p><pre tabindex=0><code>intel.com/foo  = resourceScoringFunction((2+2),8)
               =  (100 - ((8-4)*100/8)
               =  (100 - 50)
               =  50
               =  rawScoringFunction(50)
               = 5

memory         = resourceScoringFunction((256+512),1024)
               = (100 -((1024-768)*100/1024))
               = 75
               = rawScoringFunction(75)
               = 7

cpu            = resourceScoringFunction((2+6),8)
               = (100 -((8-8)*100/8))
               = 100
               = rawScoringFunction(100)
               = 10

NodeScore   =  (5 * 5) + (7 * 1) + (10 * 3) / (5 + 1 + 3)
            =  7
</code></pre><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/scheduling-eviction/scheduling-framework/>スケジューリングフレームワーク</a>について更に読む</li><li><a href=/docs/reference/scheduling/config/>スケジューラーの設定</a>について更に読む</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-602208c95fe7b1f1170310ce993f5814>9.8 - スケジューリングフレームワーク</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code></div><p>スケジューリングフレームワークはKubernetesのスケジューラーに対してプラグイン可能なアーキテクチャです。
このアーキテクチャは、既存のスケジューラーに新たに「プラグイン」としてAPI群を追加するもので、プラグインはスケジューラー内部にコンパイルされます。このAPI群により、スケジューリングの「コア」の軽量かつ保守しやすい状態に保ちながら、ほとんどのスケジューリングの機能をプラグインとして実装することができます。このフレームワークの設計に関する技術的な情報についてはこちらの<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/624-scheduling-framework/README.md>スケジューリングフレームワークの設計提案</a>をご覧ください。</p><h1 id=フレームワークのワークフロー>フレームワークのワークフロー</h1><p>スケジューリングフレームワークは、いくつかの拡張点を定義しています。スケジューラープラグインは、1つ以上の拡張点で呼び出されるように登録します。これらのプラグインの中には、スケジューリングの決定を変更できるものから、単に情報提供のみを行うだけのものなどがあります。</p><p>この1つのPodをスケジュールしようとする各動作は<strong>Scheduling Cycle</strong>と<strong>Binding Cycle</strong>の2つのフェーズに分けられます。</p><h2 id=scheduling-cycle-binding-cycle>Scheduling Cycle & Binding Cycle</h2><p>Scheduling CycleではPodが稼働するNodeを決定し、Binding Cycleではそれをクラスターに適用します。この2つのサイクルを合わせて「スケジューリングコンテキスト」と呼びます。</p><p>Scheduling CycleではPodに対して1つ1つが順番に実行され、Binding Cyclesでは並列に実行されます。</p><p>Podがスケジューリング不能と判断された場合や、内部エラーが発生した場合、Scheduling CycleまたはBinding Cycleを中断することができます。その際、Podはキューに戻され再試行されます。</p><h2 id=拡張点>拡張点</h2><p>次の図はPodに対するスケジューリングコンテキストとスケジューリングフレームワークが公開する拡張点を示しています。この図では「Filter」がフィルタリングのための「Predicate」、「Scoring」がスコアリングのための「Priorities」機能に相当します。</p><p>1つのプラグインを複数の拡張点に登録することで、より複雑なタスクやステートフルなタスクを実行することができます。</p><figure class=diagram-large><img src=/images/docs/scheduling-framework-extensions.png><figcaption><h4>scheduling framework extension points</h4></figcaption></figure><h3 id=queue-sort>QueueSort</h3><p>これらのプラグインはスケジューリングキュー内のPodをソートするために使用されます。このプラグインは、基本的に<code>Less(Pod1, Pod2)</code>という関数を提供します。また、このプラグインは、1つだけ有効化できます。</p><h3 id=pre-filter>PreFilter</h3><p>これらのプラグインは、Podに関する情報を前処理したり、クラスターやPodが満たすべき特定の条件をチェックするために使用されます。もし、PreFilterプラグインのいずれかがエラーを返した場合、Scheduling Cycleは中断されます。</p><h3 id=filter>Filter</h3><p>FilterプラグインはPodを実行できないNodeを候補から除外します。各Nodeに対して、スケジューラーは設定された順番でFilterプラグインを呼び出します。もし、いずれかのFilterプラグインが途中でそのNodeを実行不可能とした場合、残りのプラグインではそのNodeは呼び出されません。Nodeは同時に評価されることがあります。</p><h3 id=post-filter>PostFilter</h3><p>これらのプラグインはFilterフェーズで、Podに対して実行可能なNodeが見つからなかった場合にのみ呼び出されます。このプラグインは設定された順番で呼び出されます。もしいずれかのPostFilterプラグインが、あるNodeを「スケジュール可能(Schedulable)」と目星をつけた場合、残りのプラグインは呼び出されません。典型的なPostFilterの実装はプリエンプション方式で、他のPodを先取りして、Podをスケジューリングできるようにしようとします。</p><h3 id=pre-score>PreScore</h3><p>これらのプラグインは、Scoreプラグインが使用する共有可能な状態を生成する「スコアリングの事前」作業を行うために使用されます。このプラグインがエラーを返した場合、Scheduling Cycleは中断されます。</p><h3 id=scoring>Score</h3><p>これらのプラグインはフィルタリングのフェーズを通過したNodeをランク付けするために使用されます。スケジューラーはそれぞれのNodeに対して、それぞれのscoringプラグインを呼び出します。スコアの最小値と最大値の範囲が明確に定義されます。<a href=#normalize-scoring>NormalizeScore</a>フェーズの後、スケジューラーは設定されたプラグインの重みに従って、全てのプラグインからNodeのスコアを足し合わせます。</p><h3 id=normalize-scoring>NormalizeScore</h3><p>これらのプラグインはスケジューラーが最終的なNodeの順位を計算する前にスコアを修正するために使用されます。この拡張点に登録されたプラグインは、同じプラグインの<a href=#scoring>Score</a>の結果を使用して呼び出されます。各プラグインはScheduling Cycle毎に、1回呼び出されます。</p><p>例えば、<code>BlinkingLightScorer</code>というプラグインが、点滅する光の数に基づいてランク付けをするとします。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>ScoreNode</span>(_ <span style=color:#666>*</span>v1.pod, n <span style=color:#666>*</span>v1.Node) (<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#0b0;font-weight:700>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>getBlinkingLightCount</span>(n)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ただし、<code>NodeScoreMax</code>に比べ、点滅をカウントした最大値の方が小さい場合があります。これを解決するために、<code>BlinkingLightScorer</code>も拡張点に登録する必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>NormalizeScores</span>(scores <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]<span style=color:#0b0;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>    highest <span style=color:#666>:=</span> <span style=color:#666>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> _, score <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> scores {
</span></span><span style=display:flex><span>        highest = <span style=color:#00a000>max</span>(highest, score)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> node, score <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> scores {
</span></span><span style=display:flex><span>        scores[node] = score<span style=color:#666>*</span>NodeScoreMax<span style=color:#666>/</span>highest
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>NormalizeScoreプラグインが途中でエラーを返した場合、Scheduling Cycleは中断されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 「Reserveの事前」作業を行いたいプラグインは、NormalizeScore拡張点を使用してください。</div><h3 id=reserve>Reserve</h3><p>Reserve拡張を実装したプラグインには、ReserveとUnreserve　という2つのメソッドがあり、それぞれ<code>Reserve</code>
と<code>Unreserve</code>と呼ばれる2つの情報スケジューリングフェーズを返します。
実行状態を保持するプラグイン（別名「ステートフルプラグイン」）は、これらのフェーズを使用して、Podに対してNodeのリソースが予約されたり予約解除された場合に、スケジューラーから通知を受け取ります。</p><p>Reserveフェーズは、スケジューラーが実際にPodを指定されたNodeにバインドする前に発生します。このフェーズはスケジューラーがバインドが成功するのを待つ間にレースコンディションの発生を防ぐためにあります。
各Reserveプラグインの<code>Reserve</code>メソッドは成功することも失敗することもあります。もしどこかの<code>Reserve</code>メソッドの呼び出しが失敗すると、後続のプラグインは実行されず、Reserveフェーズは失敗したものとみなされます。全てのプラグインの<code>Reserve</code>メソッドが成功した場合、Reserveフェーズは成功とみなされ、残りのScheduling CycleとBinding Cycleが実行されます。</p><p>Unreserveフェーズは、Reserveフェーズまたは後続のフェーズが失敗した場合に、呼び出されます。この時、<strong>全ての</strong>Reserveプラグインの<code>Unreserve</code>メソッドが、<code>Reserve</code>メソッドの呼び出された逆の順序で実行されます。このフェーズは予約されたPodに関連する状態をクリーンアップするためにあります。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> <code>Unreserve</code>メソッドの実装は冪等性を持つべきであり、この処理で問題があった場合に失敗させてはなりません。</div><h3 id=permit>Permit</h3><p><em>Permit</em> プラグインは、各PodのScheduling Cycleの終了時に呼び出され、候補Nodeへのバインドを阻止もしくは遅延させるために使用されます。permitプラグインは次の3つのうちどれかを実行できます。</p><ol><li><p><strong>承認(approve)</strong><br>全てのPermitプラグインから承認(approve)されたPodは、バインド処理へ送られます。</p></li><li><p><strong>拒否(deny)</strong><br>もしどれか1つのPermitプラグインがPodを拒否(deny)した場合、そのPodはスケジューリングキューに戻されます。
これは<a href=#reserve>Reserveプラグイン</a>内のUnreserveフェーズで呼び出されます。</p></li><li><p><strong>待機(wait)</strong> (タイムアウトあり)<br>もしPermitプラグインが「待機(wait)」を返した場合、そのPodは内部の「待機中」Podリストに保持され、このPodに対するBinding Cycleは開始されるものの、承認(approve)されるまで直接ブロックされます。もしタイムアウトが発生した場合、この<strong>待機(wait)<strong>は</strong>deny</strong>へ変わり、対象のPodはスケジューリングキューに戻されると共に、<a href=#reserve>Reserveプラグイン</a>のUnreserveフェーズが呼び出されます。</p></li></ol><div class="alert alert-info note callout" role=alert><strong>備考:</strong> どのプラグインも「待機中」Podリストにアクセスして、それらを承認(approve)することができますが(参考:<a href=https://git.k8s.io/enhancements/keps/sig-scheduling/624-scheduling-framework#frameworkhandle><code>FrameworkHandle</code></a>)、その中の予約済みPodのバインドを承認(approve)できるのはPermitプラグインだけであると予想します。承認(approve)されたPodは、<a href=#pre-bind>PreBind</a>フェーズへ送られます。</div><h3 id=pre-bind>PreBind</h3><p>これらのプラグインは、Podがバインドされる前に必要な作業を行うために使用されます。例えば、Podの実行を許可する前に、ネットワークボリュームをプロビジョニングし、Podを実行予定のNodeにマウントすることができます。</p><p>もし、いずれかのPreBindプラグインがエラーを返した場合、Podは<a href=#reserve>拒否</a>され、スケジューリングキューに戻されます。</p><h3 id=bind>Bind</h3><p>これらのプラグインはPodをNodeにバインドするために使用されます。このプラグインは全てのPreBindプラグインの処理が完了するまで呼ばれません。それぞれのBindプラグインは設定された順序で呼び出されます。このプラグインは、与えられたPodを処理するかどうかを選択することができます。もしPodを処理することを選択した場合、<strong>残りのBindプラグインは全てスキップされます。</strong></p><h3 id=post-bind>PostBind</h3><p>これは単に情報提供のための拡張点です。Post-bindプラグインはPodのバインドが成功した後に呼び出されます。これはBinding Cycleの最後であり、関連するリソースのクリーンアップに使用されます。</p><h2 id=プラグインapi>プラグインAPI</h2><p>プラグインAPIには2つの段階があります。まず、プラグインを登録し設定することです。そして、拡張点インターフェースを使用することです。このインターフェースは次のような形式をとります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> Plugin <span style=color:#a2f;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#00a000>Name</span>() <span style=color:#0b0;font-weight:700>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> QueueSortPlugin <span style=color:#a2f;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>    Plugin
</span></span><span style=display:flex><span>    <span style=color:#00a000>Less</span>(<span style=color:#666>*</span>v1.pod, <span style=color:#666>*</span>v1.pod) <span style=color:#0b0;font-weight:700>bool</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> PreFilterPlugin <span style=color:#a2f;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>    Plugin
</span></span><span style=display:flex><span>    <span style=color:#00a000>PreFilter</span>(context.Context, <span style=color:#666>*</span>framework.CycleState, <span style=color:#666>*</span>v1.pod) <span style=color:#0b0;font-weight:700>error</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>// ...
</span></span></span></code></pre></div><h2 id=プラグインの設定>プラグインの設定</h2><p>スケジューラーの設定でプラグインを有効化・無効化することができます。Kubernetes v1.18以降を使用しているなら、ほとんどのスケジューリング<a href=/docs/reference/scheduling/config/#scheduling-plugins>プラグイン</a>は使用されており、デフォルトで有効になっています。</p><p>デフォルトのプラグインに加えて、独自のスケジューリングプラグインを実装し、デフォルトのプラグインと一緒に使用することも可能です。詳しくは<a href=https://github.com/kubernetes-sigs/scheduler-plugins>スケジューラープラグイン</a>をご覧下さい。</p><p>Kubernetes v1.18以降を使用しているなら、プラグインのセットをスケジューラープロファイルとして設定し、様々な種類のワークロードに適合するように複数のプロファイルを定義することが可能です。詳しくは<a href=/docs/reference/scheduling/config/#multiple-profiles>複数のプロファイル</a>をご覧下さい。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ac9161c6d952925b083ad9602b4e8e7f>10 - ポリシー</h1></div><div class=td-content><h1 id=pg-a935ff8c59eb116b43494255cc67f69a>10.1 - Limit Range</h1><p>デフォルトでは、コンテナは、Kubernetesクラスター上の<a href=/ja/docs/concepts/configuration/manage-resources-containers/>計算リソース</a>の消費を制限されずに実行されます。リソースクォータを利用すれば、クラスター管理者はリソースの消費と作成を<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=名前空間>名前空間</a>ベースで制限することができます。名前空間内では、Podやコンテナは名前空間のリソースクォータで定義された範囲内でできるだけ多くのCPUとメモリーを消費できてしまうため、1つのPodまたはコンテナが利用可能なすべてのリソースを専有してしまう恐れがあります。LimitRangeを利用すれば、このような名前空間内での(Podやコンテナへの)リソースの割り当てを制限するポリシーを定めることができます。</p><p><em>LimitRange</em>を利用すると、次のような制約を課せるようになります。</p><ul><li>名前空間内のPodまたはコンテナごとに、計算リソースの使用量の最小値と最大値を強制する。</li><li>名前空間内のPersistentVolumeClaimごとに、ストレージリクエストの最小値と最大値を強制する。</li><li>名前空間内で、リソースのrequestとlimitの割合を強制する。</li><li>名前空間内の計算リソースのデフォルトのrequest/limitの値を設定して、実行時にコンテナに自動的に注入する。</li></ul><h2 id=limitrangeを有効にする>LimitRangeを有効にする</h2><p>Kubernetes 1.10以降では、LimitRangeのサポートはデフォルトで有効になりました。</p><p>LimitRangeが特定の名前空間内で強制されるのは、その名前空間内にLimitRangeオブジェクトが存在する場合です。</p><p>LimitRangeオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>でなければなりません。</p><h3 id=limit-rangeの概要>Limit Rangeの概要</h3><ul><li>管理者は、1つの名前空間に1つのLimitRangeを作成します。</li><li>ユーザーは、Pod、コンテナ、PersistentVolumeClaimのようなリソースを名前空間内に作成します。</li><li><code>LimitRanger</code>アドミッションコントローラーは、計算リソース要求が設定されていないすべてのPodとコンテナに対して、デフォルト値と制限値を強制します。そして、リソースの使用量を追跡し、名前空間内に存在するすべてのLimitRangeで定義された最小値、最大値、割合を外れないことを保証します。</li><li>LimitRangeの制約を破るようなリソース(Pod、コンテナ、PersistentVolumeClaim)の作成や更新を行うと、APIサーバーへのリクエストがHTTPステータスコード<code>403 FORBIDDEN</code>で失敗し、破られた制約を説明するメッセージが返されます。</li><li>名前空間内でLimitRangeが<code>cpu</code>や<code>memory</code>などの計算リソースに対して有効になっている場合、ユーザーはrequestsやlimitsに値を指定しなければなりません。指定しなかった場合、システムはPodの作成を拒否する可能性があります。</li><li>LimitRangeの検証は、Podのアドミッションステージでのみ発生し、実行中のPodでは発生しません。</li></ul><p>以下は、LimitRangeを使用して作成できるポリシーの例です。</p><ul><li>8GiBのRAMと16コアのCPUの容量がある2ノードのクラスター上で、名前空間内のPodに対して、CPUには100mのrequestと最大500mのlimitの制約を課し、メモリーには200Miのrequestと600Miのlimitの制約を課す。</li><li>Spec内のrequestsにcpuやmemoryを指定せずに起動したコンテナに対して、CPUにはデフォルトで150mのlimitとrequestを、メモリーにはデフォルトで300Miのrequestをそれぞれ定義する。</li></ul><p>名前空間のlimitの合計が、Podやコンテナのlimitの合計よりも小さくなる場合、リソースの競合が起こる可能性があります。その場合、コンテナやPodは作成されません。</p><p>LimitRangeに対する競合や変更は、すでに作成済みのリソースに対しては影響しません。</p><h2 id=次の項目>次の項目</h2><p>より詳しい情報は、<a href=https://git.k8s.io/design-proposals-archive/resource-management/admission_control_limit_range.md>LimitRangerの設計ドキュメント</a>を参照してください。</p><p>制限の使用例については、以下のページを読んでください。</p><ul><li><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>名前空間ごとにCPUの最小値と最大値の制約を設定する方法</a>。</li><li><a href=/ja/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>名前空間ごとにメモリーの最小値と最大値の制約を設定する方法</a>。</li><li><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>名前空間ごとにCPUのRequestとLimitのデフォルト値を設定する方法</a>。</li><li><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>名前空間ごとにメモリーのRequestとLimitのデフォルト値を設定する方法</a>。</li><li><a href=/docs/tasks/administer-cluster/limit-storage-consumption/#limitrange-to-limit-requests-for-storage>名前空間ごとにストレージ消費量の最小値と最大値を設定する方法</a>。</li><li><a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>名前空間ごとのクォータを設定する詳細な例</a>。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-94ddc6e901c30f256138db11d09f05a3>10.2 - リソースクォータ</h1><p>複数のユーザーやチームが決められた数のノードを持つクラスターを共有しているとき、1つのチームが公平に使えるリソース量を超えて使用するといった問題が出てきます。</p><p>リソースクォータはこの問題に対処するための管理者向けツールです。</p><p><code>ResourceQuota</code>オブジェクトによって定義されるリソースクォータは、名前空間ごとの総リソース消費を制限するための制約を提供します。リソースクォータは同じ名前空間のクラスター内でタイプごとに作成できるオブジェクト数や、名前空間内のリソースによって消費されるコンピュートリソースの総量を制限できます。</p><p>リソースクォータは下記のように働きます。</p><ul><li>異なる名前空間で異なるチームが存在するとき。現時点ではこれは自主的なものですが、将来的にはACLsを介してリソースクォータの設定を強制するように計画されています。</li><li>管理者は各名前空間で1つの<code>ResourceQuota</code>を作成します。</li><li>ユーザーが名前空間内でリソース(Pod、Serviceなど)を作成し、クォータシステムが<code>ResourceQuota</code>によって定義されたハードリソースリミットを超えないことを保証するために、リソースの使用量をトラッキングします。</li><li>リソースの作成や更新がクォータの制約に違反しているとき、そのリクエストはHTTPステータスコード<code>403 FORBIDDEN</code>で失敗し、違反した制約を説明するメッセージが表示されます。</li><li><code>cpu</code>や<code>memory</code>といったコンピューターリソースに対するクォータが名前空間内で有効になっているとき、ユーザーはそれらの値に対する<code>requests</code>や<code>limits</code>を設定する必要があります。設定しないとクォータシステムがPodの作成を拒否します。 ヒント: コンピュートリソースの要求を設定しないPodに対してデフォルト値を強制するために、<code>LimitRanger</code>アドミッションコントローラーを使用してください。この問題を解決する例は<a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>walkthrough</a>で参照できます。</li></ul><p>ResourceQuotaのオブジェクト名は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります.</p><p>名前空間とクォータを使用して作成できるポリシーの例は以下の通りです。</p><ul><li>32GiB RAM、16コアのキャパシティーを持つクラスターで、Aチームに20GiB、10コアを割り当て、Bチームに10GiB、4コアを割り当て、将来の割り当てのために2GiB、2コアを予約しておく。</li><li>"testing"という名前空間に対して1コア、1GiB RAMの使用制限をかけ、"production"という名前空間には制限をかけない。</li></ul><p>クラスターの総キャパシティーが、その名前空間のクォータの合計より少ない場合、リソースの競合が発生する場合があります。このとき、リソースの先着順で処理されます。</p><p>リソースの競合もクォータの変更も、作成済みのリソースには影響しません。</p><h2 id=リソースクォータを有効にする>リソースクォータを有効にする</h2><p>多くのKubernetesディストリビューションにおいてリソースクォータはデフォルトで有効になっています。APIサーバーで<code>--enable-admission-plugins=</code>の値に<code>ResourceQuota</code>が含まれるときに有効になります。</p><p>特定の名前空間にResourceQuotaがあるとき、そのリソースクォータはその名前空間に適用されます。</p><h2 id=リソースクォータの計算>リソースクォータの計算</h2><p>特定の名前空間において、<a href=/ja/docs/concepts/configuration/manage-resources-containers/>コンピュートリソース</a>の合計に上限を設定できます。</p><p>下記のリソースタイプがサポートされています。</p><table><thead><tr><th>リソース名</th><th>説明</th></tr></thead><tbody><tr><td><code>limits.cpu</code></td><td>停止していない状態の全てのPodで、CPUリミットの合計がこの値を超えることができません。</td></tr><tr><td><code>limits.memory</code></td><td>停止していない状態の全てのPodで、メモリーの合計がこの値を超えることができません。</td></tr><tr><td><code>requests.cpu</code></td><td>停止していない状態の全てのPodで、CPUリクエストの合計がこの値を超えることができません。</td></tr><tr><td><code>requests.memory</code></td><td>停止していない状態の全てのPodで、メモリーリクエストの合計がこの値を超えることができません。</td></tr><tr><td><code>hugepages-&lt;size></code></td><td>停止していない状態の全てのPodで, 指定されたサイズのHuge Pageリクエスト数がこの値を超えることができません。</td></tr><tr><td><code>cpu</code></td><td><code>requests.cpu</code>と同じ。</td></tr><tr><td><code>memory</code></td><td><code>requests.memory</code>と同じ。</td></tr></tbody></table><h3 id=拡張リソースのためのリソースクォータ>拡張リソースのためのリソースクォータ</h3><p>上記で取り上げたリソースに加えて、Kubernetes v1.10において、<a href=/docs/concepts/configuration/manage-resources-containers/#extended-resources>拡張リソース</a>のためのリソースクォータのサポートが追加されました。</p><p>拡張リソースに対するオーバーコミットが禁止されているのと同様に、リソースクォータで拡張リソース用に<code>requests</code>と<code>limits</code>の両方を指定しても意味がありません。現在、拡張リソースに対しては<code>requests.</code>というプレフィックスのついたクォータアイテムのみ設定できます。</p><p>GPUリソースを例にすると、もしリソース名が<code>nvidia.com/gpu</code>で、ユーザーが名前空間内でリクエストされるGPUの上限を4に指定するとき、下記のようにリソースクォータを定義します。</p><ul><li><code>requests.nvidia.com/gpu: 4</code></li></ul><p>さらなる詳細は<a href=#viewing-and-setting-quotas>クォータの確認と設定</a>を参照してください。</p><h2 id=ストレージのリソースクォータ>ストレージのリソースクォータ</h2><p>特定の名前空間において<a href=/ja/docs/concepts/storage/persistent-volumes/>ストレージリソース</a>の総数に上限をかけることができます。</p><p>さらに、関連するストレージクラスに基づいて、ストレージリソースの消費量に上限をかけることもできます。</p><table><thead><tr><th>リソース名</th><th>説明</th></tr></thead><tbody><tr><td><code>requests.storage</code></td><td>全てのPersistentVolumeClaimにおいて、ストレージのリクエストの合計がこの値を超えないようにします。</td></tr><tr><td><code>persistentvolumeclaims</code></td><td>特定の名前空間内で作成可能な<a href=/ja/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaim</a>の総数。</td></tr><tr><td><code>&lt;storage-class-name>.storageclass.storage.k8s.io/requests.storage</code></td><td>ストレージクラス名<code>&lt;storage-class-name></code>に関連する全てのPersistentVolumeClaimにおいて、ストレージリクエストの合計がこの値を超えないようにします。</td></tr><tr><td><code>&lt;storage-class-name>.storageclass.storage.k8s.io/persistentvolumeclaims</code></td><td>ストレージクラス名<code>&lt;storage-class-name></code>に関連する全てのPersistentVolumeClaimにおいて、特定の名前空間内で作成可能な<a href=/ja/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaim</a>の総数。</td></tr></tbody></table><p>例えば、もし管理者が<code>gold</code>ストレージクラスを<code>bronze</code>ストレージクラスと分けてリソースクォータを設定するとき、管理者はリソースクォータを下記のように指定できます。</p><ul><li><code>gold.storageclass.storage.k8s.io/requests.storage: 500Gi</code></li><li><code>bronze.storageclass.storage.k8s.io/requests.storage: 100Gi</code></li></ul><p>Kubernetes v1.8において、ローカルのエフェメラルストレージに対するリソースクォータのサポートがα版の機能として追加されました。</p><table><thead><tr><th>リソース名</th><th>説明</th></tr></thead><tbody><tr><td><code>requests.ephemeral-storage</code></td><td>名前空間内の全てのPodで、ローカルのエフェメラルストレージのリクエストの合計がこの値を超えないようにします。</td></tr><tr><td><code>limits.ephemeral-storage</code></td><td>名前空間内の全てのPodで、ローカルのエフェメラルストレージのリミットの合計がこの値を超えないようにします。</td></tr><tr><td><code>ephemeral-storage</code></td><td><code>requests.ephemeral-storage</code>と同じ。</td></tr></tbody></table><h2 id=オブジェクト数に対するクォータ>オブジェクト数に対するクォータ</h2><p>下記のシンタックスを使用して、名前空間に紐づいた全ての標準であるリソースタイプの中の特定のリソースの総数に対するリソースクォータを設定できます。</p><ul><li><code>count/&lt;resource>.&lt;group></code> コアでないグループのリソース用</li><li><code>count/&lt;resource></code> コアグループのリソース用</li></ul><p>オブジェクト数に対するクォータでユーザーが設定するリソースの例は下記の通りです。</p><ul><li><code>count/persistentvolumeclaims</code></li><li><code>count/services</code></li><li><code>count/secrets</code></li><li><code>count/configmaps</code></li><li><code>count/replicationcontrollers</code></li><li><code>count/deployments.apps</code></li><li><code>count/replicasets.apps</code></li><li><code>count/statefulsets.apps</code></li><li><code>count/jobs.batch</code></li><li><code>count/cronjobs.batch</code></li></ul><p>カスタムリソースに対して同じシンタックスを使用できます。例えば、<code>example.com</code>というAPIグループ内の<code>widgets</code>というカスタムリソースのリソースクォータを設定するには<code>count/widgets.example.com</code>と記述します。</p><p><code>count/*</code>リソースクォータの使用において、オブジェクトがサーバーストレージに存在するときオブジェクトはクォータの計算対象となります。このようなタイプのリソースクォータはストレージリソース浪費の防止に有効です。例えば、もしSecretが大量に存在するとき、そのSecretリソースの総数に対してリソースクォータの制限をかけたい場合です。クラスター内でSecretが大量にあると、サーバーとコントローラーの起動を妨げることになります。適切に設定されていないCronJobから保護するためにジョブのクォータを設定できます。名前空間内で大量のJobを作成するCronJobは、サービスを利用不可能にする可能性があります。</p><p>また、限定されたリソースのセットにおいて汎用オブジェクトカウントのリソースクォータを実行可能です。</p><p>下記のタイプのリソースがサポートされています。</p><table><thead><tr><th>リソース名</th><th>説明</th></tr></thead><tbody><tr><td><code>configmaps</code></td><td>名前空間内で存在可能なConfigMapの総数。</td></tr><tr><td><code>persistentvolumeclaims</code></td><td>名前空間内で存在可能な<a href=/ja/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaim</a>の総数。</td></tr><tr><td><code>pods</code></td><td>名前空間内で存在可能な停止していないPodの総数。<code>.status.phase in (Failed, Succeeded)</code>がtrueのとき、Podは停止状態にあります。</td></tr><tr><td><code>replicationcontrollers</code></td><td>名前空間内で存在可能なReplicationControlerの総数。</td></tr><tr><td><code>resourcequotas</code></td><td>名前空間内で存在可能なResourceQuotaの総数。</td></tr><tr><td><code>services</code></td><td>名前空間内で存在可能なServiceの総数。</td></tr><tr><td><code>services.loadbalancers</code></td><td>名前空間内で存在可能なtype:LoadBalancerであるServiceの総数。</td></tr><tr><td><code>services.nodeports</code></td><td>名前空間内で存在可能なtype:NodePortであるServiceの総数。</td></tr><tr><td><code>secrets</code></td><td>名前空間内で存在可能なSecretの総数。</td></tr></tbody></table><p>例えば、<code>pods</code>のリソースクォータは<code>Pod</code>の総数をカウントし、特定の名前空間内で作成された<code>Pod</code>の総数の最大数を設定します。またユーザーが多くのPodを作成し、クラスターのPodのIPが枯渇する状況を避けるために<code>pods</code>のリソースクォータを名前空間に設定したい場合があります。</p><h2 id=クォータのスコープについて>クォータのスコープについて</h2><p>各リソースクォータには関連する<code>scope</code>のセットを関連づけることができます。クォータは、列挙されたscopeの共通部分と一致する場合にのみリソースの使用量を計測します。</p><p>スコープがクォータに追加されると、サポートするリソースの数がスコープに関連するリソースに制限されます。許可されたセット以外のクォータ上でリソースを指定するとバリデーションエラーになります。</p><table><thead><tr><th>スコープ</th><th>説明</th></tr></thead><tbody><tr><td><code>Terminating</code></td><td><code>.spec.activeDeadlineSeconds >= 0</code>であるPodに一致します。</td></tr><tr><td><code>NotTerminating</code></td><td><code>.spec.activeDeadlineSecondsがnil</code>であるPodに一致します。</td></tr><tr><td><code>BestEffort</code></td><td>ベストエフォート型のサービス品質のPodに一致します。</td></tr><tr><td><code>NotBestEffort</code></td><td>ベストエフォート型のサービス品質でないPodに一致します。</td></tr><tr><td><code>PriorityClass</code></td><td>指定された<a href=/ja/docs/concepts/configuration/pod-priority-preemption>優先度クラス</a>と関連付いているPodに一致します。</td></tr></tbody></table><p><code>BestEffort</code>スコープはリソースクォータを次のリソースに対するトラッキングのみに制限します:</p><ul><li><code>pods</code></li></ul><p><code>Terminating</code>、<code>NotTerminating</code>、<code>NotBestEffort</code>、<code>PriorityClass</code>スコープは、リソースクォータを次のリソースに対するトラッキングのみに制限します:</p><ul><li><code>pods</code></li><li><code>cpu</code></li><li><code>memory</code></li><li><code>requests.cpu</code></li><li><code>requests.memory</code></li><li><code>limits.cpu</code></li><li><code>limits.memory</code></li></ul><p>同じクォータで<code>Terminating</code>と<code>NotTerminating</code>の両方のスコープを指定することはできず、また同じクォータで<code>BestEffort</code>と<code>NotBestEffort</code>の両方のスコープを指定することもできないことに注意してください。</p><p><code>scopeSelector</code>は<code>operator</code> フィールドにおいて下記の値をサポートしています。:</p><ul><li><code>In</code></li><li><code>NotIn</code></li><li><code>Exists</code></li><li><code>DoesNotExist</code></li></ul><p><code>scopeSelector</code>の定義において<code>scopeName</code>に下記のいずれかの値を使用する場合、<code>operator</code>に<code>Exists</code>を指定してください。</p><ul><li><code>Terminating</code></li><li><code>NotTerminating</code></li><li><code>BestEffort</code></li><li><code>NotBestEffort</code></li></ul><p><code>operator</code>が<code>In</code>または<code>NotIn</code>の場合、<code>values</code>フィールドには少なくとも1つの値が必要です。例えば以下のように記述します：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- middle<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>operator</code>が<code>Exists</code>または<code>DoesNotExist</code>の場合、<code>values</code>フィールドは指定<em>しないでください</em>。</p><h3 id=priorityclass毎のリソースクォータ>PriorityClass毎のリソースクォータ</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code></div><p>Podは特定の<a href=/ja/docs/concepts/configuration/pod-priority-preemption/#pod-priority>優先度</a>で作成されます。リソースクォータのSpec内にある<code>scopeSelector</code>フィールドを使用して、Podの優先度に基づいてPodのシステムリソースの消費をコントロールできます。</p><p>リソースクォータのSpec内の<code>scopeSelector</code>によってPodが選択されたときのみ、そのリソースクォータが一致し、消費されます。</p><p>リソースクォータが<code>scopeSelector</code>フィールドを使用して優先度クラスに対してスコープされる場合、リソースクォータのオプジェクトは、次のリソースのみトラッキングするように制限されます:</p><ul><li><code>pods</code></li><li><code>cpu</code></li><li><code>memory</code></li><li><code>ephemeral-storage</code></li><li><code>limits.cpu</code></li><li><code>limits.memory</code></li><li><code>limits.ephemeral-storage</code></li><li><code>requests.cpu</code></li><li><code>requests.memory</code></li><li><code>requests.ephemeral-storage</code></li></ul><p>この例ではリソースクォータのオブジェクトを作成し、特定の優先度を持つPodに一致させます。この例は下記のように動作します。</p><ul><li>クラスター内のPodは"low"、"medium"、"high"の3つの優先度クラスのうち1つをもちます。</li><li>1つのリソースクォータのオブジェクトは優先度毎に作成されます。</li></ul><p>下記のYAMLを<code>quota.yml</code>というファイルに保存します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>List<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-high<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;high&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-medium<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;medium&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-low<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;low&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>kubectl create</code>を実行してYAMLの内容を適用します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./quota.yml
</span></span></code></pre></div><pre tabindex=0><code>resourcequota/pods-high created
resourcequota/pods-medium created
resourcequota/pods-low created
</code></pre><p><code>kubectl describe quota</code>を実行して<code>Used</code>クォータが<code>0</code>であることを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota
</span></span></code></pre></div><pre tabindex=0><code>Name:       pods-high
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     1k
memory      0     200Gi
pods        0     10


Name:       pods-low
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     5
memory      0     10Gi
pods        0     10


Name:       pods-medium
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     10
memory      0     20Gi
pods        0     10
</code></pre><p>プライオリティーが"high"であるPodを作成します。下記の内容を<code>high-priority-pod.yml</code>というファイルに保存します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>ubuntu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while true; do echo hello; sleep 10;done&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>high<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>kubectl create</code>でマニフェストを適用します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./high-priority-pod.yml
</span></span></code></pre></div><p><code>pods-high</code>という名前のプライオリティーが"high"のクォータにおける"Used"項目の値が変更され、それ以外の2つの値は変更されていないことを確認してください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota
</span></span></code></pre></div><pre tabindex=0><code>Name:       pods-high
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         500m  1k
memory      10Gi  200Gi
pods        1     10


Name:       pods-low
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     5
memory      0     10Gi
pods        0     10


Name:       pods-medium
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     10
memory      0     20Gi
pods        0     10
</code></pre><h2 id=リクエスト-vs-リミット>リクエスト vs リミット</h2><p>コンピュートリソースを分配する際に、各コンテナはCPUとメモリーそれぞれのリクエストとリミット値を指定します。クォータはそれぞれの値を設定できます。</p><p>クォータに<code>requests.cpu</code>や<code>requests.memory</code>の値が指定されている場合は、コンテナはそれらのリソースに対する明示的な要求を行います。同様に、クォータに<code>limits.cpu</code>や<code>limits.memory</code>の値が指定されている場合は、コンテナはそれらのリソースに対する明示的な制限を行います。</p><h2 id=viewing-and-setting-quotas>クォータの確認と設定</h2><p>kubectlでは、クォータの作成、更新、確認をサポートしています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; compute-resources.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: ResourceQuota
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: compute-resources
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  hard:
</span></span></span><span style=display:flex><span><span style=color:#b44>    requests.cpu: &#34;1&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    requests.memory: 1Gi
</span></span></span><span style=display:flex><span><span style=color:#b44>    limits.cpu: &#34;2&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    limits.memory: 2Gi
</span></span></span><span style=display:flex><span><span style=color:#b44>    requests.nvidia.com/gpu: 4
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./compute-resources.yaml --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; object-counts.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: ResourceQuota
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: object-counts
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  hard:
</span></span></span><span style=display:flex><span><span style=color:#b44>    configmaps: &#34;10&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    persistentvolumeclaims: &#34;4&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    pods: &#34;4&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    replicationcontrollers: &#34;20&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    secrets: &#34;10&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    services: &#34;10&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    services.loadbalancers: &#34;2&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./object-counts.yaml --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get quota --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><pre tabindex=0><code>NAME                    AGE
compute-resources       30s
object-counts           32s
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota compute-resources --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><pre tabindex=0><code>Name:                    compute-resources
Namespace:               myspace
Resource                 Used  Hard
--------                 ----  ----
limits.cpu               0     2
limits.memory            0     2Gi
requests.cpu             0     1
requests.memory          0     1Gi
requests.nvidia.com/gpu  0     4
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota object-counts --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><pre tabindex=0><code>Name:                   object-counts
Namespace:              myspace
Resource                Used    Hard
--------                ----    ----
configmaps              0       10
persistentvolumeclaims  0       4
pods                    0       4
replicationcontrollers  0       20
secrets                 1       10
services                0       10
services.loadbalancers  0       2
</code></pre><p>また、kubectlは<code>count/&lt;resource>.&lt;group></code>というシンタックスを用いることにより、名前空間に依存した全ての主要なリソースに対するオブジェクト数のクォータをサポートしています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create quota <span style=color:#a2f>test</span> --hard<span style=color:#666>=</span>count/deployments.apps<span style=color:#666>=</span>2,count/replicasets.apps<span style=color:#666>=</span>4,count/pods<span style=color:#666>=</span>3,count/secrets<span style=color:#666>=</span><span style=color:#666>4</span> --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>myspace --replicas<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><pre tabindex=0><code>Name:                         test
Namespace:                    myspace
Resource                      Used  Hard
--------                      ----  ----
count/deployments.apps        1     2
count/pods                    2     3
count/replicasets.apps        1     4
count/secrets                 1     4
</code></pre><h2 id=クォータとクラスター容量>クォータとクラスター容量</h2><p>ResourceQuotaはクラスター容量に依存しません。またユニット数の絶対値で表されます。そのためクラスターにノードを追加したことにより、各名前空間が自動的により多くのリソースを消費するような機能が提供されるわけでは<em>ありません</em>。</p><p>下記のようなより複雑なポリシーが必要な状況があります。</p><ul><li>複数チーム間でクラスターリソースの総量を分けあう。</li><li>各テナントが必要な時にリソース使用量を増やせるようにするが、偶発的なリソースの枯渇を防ぐために上限を設定する。</li><li>1つの名前空間に対してリソース消費の需要を検出し、ノードを追加し、クォータを増加させる。</li></ul><p>このようなポリシーは、クォータの使用量の監視と、他のシグナルにしたがってクォータのハードの制限を調整する"コントローラー"を記述することにより、ResourceQuotaをビルディングブロックのように使用して実装できます。</p><p>リソースクォータは集約されたクラスターリソースを分割しますが、ノードに対しては何の制限も行わないことに注意して下さい。例: 複数の名前空間のPodは同一のノード上で稼働する可能性があります。</p><h2 id=limit-priority-class-consumption-by-default>デフォルトで優先度クラスの消費を制限する</h2><p>例えば"cluster-services"のように、条件に一致するクォータオブジェクトが存在する場合に限り、特定の優先度のPodを名前空間で許可することが望ましい場合があります。</p><p>このメカニズムにより、オペレーターは特定の高優先度クラスの使用を限られた数の名前空間に制限することができ、全ての名前空間でこれらの優先度クラスをデフォルトで使用することはできなくなります。</p><p>これを実施するには、<code>kube-apiserver</code>の<code>--admission-control-config-file</code>というフラグを使い、下記の設定ファイルに対してパスを渡す必要がります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ResourceQuota&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuotaConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limitedResources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchScopes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;cluster-services&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>なお、"cluster-services"Podは、条件に一致する<code>scopeSelector</code>を持つクォータオブジェクトが存在する名前空間でのみ許可されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;cluster-services&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=次の項目>次の項目</h2><ul><li>さらなる情報は<a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_resource_quota.md>クォータの design doc</a>を参照してください。</li><li><a href=/docs/tasks/administer-cluster/quota-api-object/>リソースクォータの使用方法の例</a>を参照してください。</li><li><a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/pod-priority-resourcequota.md>優先度クラスに対するクォータサポートの design doc</a>を参照してください。</li><li><a href=https://github.com/kubernetes/kubernetes/pull/36765>LimitedResources</a>を参照してください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-285a3785fd3d20f437c28d87ca4dadca>11 - クラスターの管理</h1></div><div class=td-content><h1 id=pg-fb494ea3b1874bd753dcd11c3f35c2dc>11.1 - クラスター管理の概要</h1><p>このページはKubernetesクラスターの作成や管理者向けの内容です。Kubernetesのコア<a href=/ja/docs/concepts/>コンセプト</a>についてある程度精通していることを前提とします。</p><h2 id=クラスターのプランニング>クラスターのプランニング</h2><p>Kubernetesクラスターの計画、セットアップ、設定の例を知るには<a href=/ja/docs/setup/>設定</a>のガイドを参照してください。この記事で列挙されているソリューションは<em>ディストリビューション</em> と呼ばれます。</p><p>ガイドを選択する前に、いくつかの考慮事項を挙げます。</p><ul><li>ユーザーのコンピューター上でKubernetesを試したいでしょうか、それとも高可用性のあるマルチノードクラスターを構築したいでしょうか？あなたのニーズにあったディストリビューションを選択してください。</li><li><strong>もしあなたが高可用性を求める場合</strong>、 <a href=/docs/concepts/cluster-administration/federation/>複数ゾーンにまたがるクラスター</a>の設定について学んでください。</li><li><a href=https://cloud.google.com/kubernetes-engine/>Google Kubernetes Engine</a>のような<strong>ホストされているKubernetesクラスター</strong>を使用するのか、それとも<strong>自分自身でクラスターをホストするのでしょうか</strong>？</li><li>使用するクラスターは<strong>オンプレミス</strong>なのか、それとも<strong>クラウド(IaaS)</strong> でしょうか？Kubernetesはハイブリッドクラスターを直接サポートしていません。その代わりユーザーは複数のクラスターをセットアップできます。</li><li>Kubernetesを <strong>「ベアメタル」なハードウェア</strong>上で稼働させますか？それとも<strong>仮想マシン(VMs)</strong> 上で稼働させますか？</li><li><strong>もしオンプレミスでKubernetesを構築する場合</strong>、どの<a href=/ja/docs/concepts/cluster-administration/networking/>ネットワークモデル</a>が最適か検討してください。</li><li><strong>ただクラスターを稼働させたいだけ</strong>でしょうか、それとも<strong>Kubernetesプロジェクトのコードの開発</strong>を行いたいでしょうか？もし後者の場合、開発が進行中のディストリビューションを選択してください。いくつかのディストリビューションはバイナリリリースのみ使用していますが、多くの選択肢があります。</li><li>クラスターを稼働させるのに必要な<a href=/ja/docs/concepts/overview/components/>コンポーネント</a>についてよく理解してください。</li></ul><p>注意: 全てのディストリビューションがアクティブにメンテナンスされている訳ではありません。最新バージョンのKubernetesでテストされたディストリビューションを選択してください。</p><h2 id=クラスターの管理>クラスターの管理</h2><ul><li><p><a href=/ja/docs/concepts/architecture/nodes/>ノードの管理</a>方法について学んでください。</p></li><li><p>共有クラスターにおける<a href=/ja/docs/concepts/policy/resource-quotas/>リソースクォータ</a>のセットアップと管理方法について学んでください。</p></li></ul><h2 id=クラスターをセキュアにする>クラスターをセキュアにする</h2><ul><li><p><a href=/ja/docs/concepts/cluster-administration/certificates/>Certificates</a>では、異なるツールチェインを使用して証明書を作成する方法を説明します。</p></li><li><p><a href=/ja/docs/concepts/containers/container-environment/>Kubernetes コンテナの環境</a>では、Kubernetesノード上でのKubeletが管理するコンテナの環境について説明します。</p></li><li><p><a href=/docs/concepts/security/controlling-access>Kubernetes APIへのアクセス制御</a>では、Kubernetesで自身のAPIに対するアクセスコントロールがどのように実装されているかを説明します。</p></li><li><p><a href=/docs/reference/access-authn-authz/authentication/>認証</a>では、様々な認証オプションを含むKubernetesでの認証について説明します。</p></li><li><p><a href=/docs/reference/access-authn-authz/authorization/>認可</a>では、認証とは別に、HTTPリクエストの処理方法を制御します。</p></li><li><p><a href=/docs/reference/access-authn-authz/admission-controllers/>アドミッションコントローラーの使用</a>では、認証と認可の後にKubernetes APIに対するリクエストをインターセプトするプラグインについて説明します。</p></li><li><p><a href=/docs/concepts/cluster-administration/sysctl-cluster/>Kubernetesクラスターでのsysctlの使用</a>では、管理者向けにカーネルパラメーターを設定するため<code>sysctl</code>コマンドラインツールの使用方法について解説します。</p></li><li><p><a href=/docs/tasks/debug-application-cluster/audit/>クラスターの監査</a>では、Kubernetesの監査ログの扱い方について解説します。</p></li></ul><h3 id=kubeletをセキュアにする>kubeletをセキュアにする</h3><ul><li><a href=/ja/docs/concepts/architecture/master-node-communication/>マスターとノードのコミュニケーション</a></li><li><a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLSのブートストラップ</a></li><li><a href=/docs/admin/kubelet-authentication-authorization/>Kubeletの認証/認可</a></li></ul><h2 id=オプションのクラスターサービス>オプションのクラスターサービス</h2><ul><li><p><a href=/ja/docs/concepts/services-networking/dns-pod-service/>DNSのインテグレーション</a>では、DNS名をKubernetes Serviceに直接名前解決する方法を解説します。</p></li><li><p><a href=/docs/concepts/cluster-administration/logging/>クラスターアクティビィのロギングと監視</a>では、Kubernetesにおけるロギングがどのように行われ、どう実装されているかについて解説します。</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf9a93ab5ba014fb6ff70b22c29d432>11.2 - 証明書</h1><p>クライアント証明書認証を使用する場合、<code>easyrsa</code>や<code>openssl</code>、<code>cfssl</code>を用いて、手動で証明書を生成できます。</p><h3 id=easyrsa>easyrsa</h3><p><strong>easyrsa</strong>を用いると、クラスターの証明書を手動で生成できます。</p><ol><li><p>パッチを当てたバージョンのeasyrsa3をダウンロードして解凍し、初期化します。</p><pre><code>curl -LO https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz
tar xzf easy-rsa.tar.gz
cd easy-rsa-master/easyrsa3
./easyrsa init-pki
</code></pre></li><li><p>新しい認証局(CA)を生成します。<code>--batch</code>は自動モードを設定し、<code>--req-cn</code>はCAの新しいルート証明書の共通名(CN)を指定します。</p><pre><code>./easyrsa --batch &quot;--req-cn=${MASTER_IP}@`date +%s`&quot; build-ca nopass
</code></pre></li><li><p>サーバー証明書と鍵を生成します。
引数<code>--subject-alt-name</code>は、APIサーバーへのアクセスに使用できるIPおよびDNS名を設定します。
<code>MASTER_CLUSTER_IP</code>は通常、APIサーバーとコントローラーマネージャーコンポーネントの両方で引数<code>--service-cluster-ip-range</code>として指定されるサービスCIDRの最初のIPです。
引数<code>--days</code>は、証明書の有効期限が切れるまでの日数を設定するために使われます。
以下の例は、デフォルトのDNSドメイン名として<code>cluster.local</code>を使用していることを前提とします。</p><pre><code>./easyrsa --subject-alt-name=&quot;IP:${MASTER_IP},&quot;\
&quot;IP:${MASTER_CLUSTER_IP},&quot;\
&quot;DNS:kubernetes,&quot;\
&quot;DNS:kubernetes.default,&quot;\
&quot;DNS:kubernetes.default.svc,&quot;\
&quot;DNS:kubernetes.default.svc.cluster,&quot;\
&quot;DNS:kubernetes.default.svc.cluster.local&quot; \
--days=10000 \
build-server-full server nopass
</code></pre></li><li><p><code>pki/ca.crt</code>、<code>pki/issued/server.crt</code>、<code>pki/private/server.key</code>をディレクトリーにコピーします。</p></li><li><p>以下のパラメーターを、APIサーバーの開始パラメーターとして追加します。</p><pre><code>--client-ca-file=/yourdirectory/ca.crt
--tls-cert-file=/yourdirectory/server.crt
--tls-private-key-file=/yourdirectory/server.key
</code></pre></li></ol><h3 id=openssl>openssl</h3><p><strong>openssl</strong>はクラスターの証明書を手動で生成できます。</p><ol><li><p>2048ビットのca.keyを生成します。</p><pre><code>openssl genrsa -out ca.key 2048
</code></pre></li><li><p>ca.keyに応じて、ca.crtを生成します。証明書の有効期間を設定するには、-daysを使用します。</p><pre><code>openssl req -x509 -new -nodes -key ca.key -subj &quot;/CN=${MASTER_IP}&quot; -days 10000 -out ca.crt
</code></pre></li><li><p>2048ビットのserver.keyを生成します。</p><pre><code>openssl genrsa -out server.key 2048
</code></pre></li><li><p>証明書署名要求(CSR)を生成するための設定ファイルを生成します。
ファイル(例: <code>csr.conf</code>)に保存する前に、かぎ括弧で囲まれた値(例: <code>&lt;MASTER_IP></code>)を必ず実際の値に置き換えてください。
<code>MASTER_CLUSTER_IP</code>の値は、前節で説明したAPIサーバーのサービスクラスターIPであることに注意してください。
以下の例は、デフォルトのDNSドメイン名として<code>cluster.local</code>を使用していることを前提とします。</p><pre><code>[ req ]
default_bits = 2048
prompt = no
default_md = sha256
req_extensions = req_ext
distinguished_name = dn

[ dn ]
C = &lt;country&gt;
ST = &lt;state&gt;
L = &lt;city&gt;
O = &lt;organization&gt;
OU = &lt;organization unit&gt;
CN = &lt;MASTER_IP&gt;

[ req_ext ]
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster
DNS.5 = kubernetes.default.svc.cluster.local
IP.1 = &lt;MASTER_IP&gt;
IP.2 = &lt;MASTER_CLUSTER_IP&gt;

[ v3_ext ]
authorityKeyIdentifier=keyid,issuer:always
basicConstraints=CA:FALSE
keyUsage=keyEncipherment,dataEncipherment
extendedKeyUsage=serverAuth,clientAuth
subjectAltName=@alt_names
</code></pre></li><li><p>設定ファイルに基づいて、証明書署名要求を生成します。</p><pre><code>openssl req -new -key server.key -out server.csr -config csr.conf
</code></pre></li><li><p>ca.key、ca.crt、server.csrを使用してサーバー証明書を生成します。</p><pre><code>openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key \
-CAcreateserial -out server.crt -days 10000 \
-extensions v3_ext -extfile csr.conf
</code></pre></li><li><p>証明書を表示します。</p><pre><code>openssl x509  -noout -text -in ./server.crt
</code></pre></li></ol><p>最後にAPIサーバーの起動パラメーターに、同様のパラメーターを追加します。</p><h3 id=cfssl>cfssl</h3><p><strong>cfssl</strong>も証明書を生成するためのツールです。</p><ol><li><p>以下のように、ダウンロードして解凍し、コマンドラインツールを用意します。
使用しているハードウェアアーキテクチャやcfsslのバージョンに応じて、サンプルコマンドの調整が必要な場合があります。</p><pre><code>curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl_1.5.0_linux_amd64 -o cfssl
chmod +x cfssl
curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssljson_1.5.0_linux_amd64 -o cfssljson
chmod +x cfssljson
curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl-certinfo_1.5.0_linux_amd64 -o cfssl-certinfo
chmod +x cfssl-certinfo
</code></pre></li><li><p>アーティファクトを保持するディレクトリーを生成し、cfsslを初期化します。</p><pre><code>mkdir cert
cd cert
../cfssl print-defaults config &gt; config.json
../cfssl print-defaults csr &gt; csr.json
</code></pre></li><li><p>CAファイルを生成するためのJSON設定ファイル(例: <code>ca-config.json</code>)を生成します。</p><pre><code>{
  &quot;signing&quot;: {
    &quot;default&quot;: {
      &quot;expiry&quot;: &quot;8760h&quot;
    },
    &quot;profiles&quot;: {
      &quot;kubernetes&quot;: {
        &quot;usages&quot;: [
          &quot;signing&quot;,
          &quot;key encipherment&quot;,
          &quot;server auth&quot;,
          &quot;client auth&quot;
        ],
        &quot;expiry&quot;: &quot;8760h&quot;
      }
    }
  }
}
</code></pre></li><li><p>CA証明書署名要求(CSR)用のJSON設定ファイル(例: <code>ca-csr.json</code>)を生成します。
かぎ括弧で囲まれた値は、必ず使用したい実際の値に置き換えてください。</p><pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;:[{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre></li><li><p>CA鍵(<code>ca-key.pem</code>)と証明書(<code>ca.pem</code>)を生成します。</p><pre><code>../cfssl gencert -initca ca-csr.json | ../cfssljson -bare ca
</code></pre></li><li><p>APIサーバーの鍵と証明書を生成するためのJSON設定ファイル(例: <code>server-csr.json</code>)を生成します。
かぎ括弧で囲まれた値は、必ず使用したい実際の値に置き換えてください。
<code>MASTER_CLUSTER_IP</code>の値は、前節で説明したAPIサーバーのサービスクラスターIPです。
以下の例は、デフォルトのDNSドメイン名として<code>cluster.local</code>を使用していることを前提とします。</p><pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;hosts&quot;: [
    &quot;127.0.0.1&quot;,
    &quot;&lt;MASTER_IP&gt;&quot;,
    &quot;&lt;MASTER_CLUSTER_IP&gt;&quot;,
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local&quot;
  ],
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre></li><li><p>APIサーバーの鍵と証明書を生成します。デフォルトでは、それぞれ<code>server-key.pem</code>と<code>server.pem</code>というファイルに保存されます。</p><pre><code>../cfssl gencert -ca=ca.pem -ca-key=ca-key.pem \
--config=ca-config.json -profile=kubernetes \
server-csr.json | ../cfssljson -bare server
</code></pre></li></ol><h2 id=自己署名ca証明書の配布>自己署名CA証明書の配布</h2><p>クライアントノードは、自己署名CA証明書を有効だと認識しないことがあります。
プロダクション用でない場合や、会社のファイアウォールの背後で実行する場合は、自己署名CA証明書をすべてのクライアントに配布し、有効な証明書のローカルリストを更新できます。</p><p>各クライアントで、以下の操作を実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo cp ca.crt /usr/local/share/ca-certificates/kubernetes.crt
</span></span><span style=display:flex><span>sudo update-ca-certificates
</span></span></code></pre></div><pre tabindex=0><code>Updating certificates in /etc/ssl/certs...
1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....
done.
</code></pre><h2 id=証明書api>証明書API</h2><p><code>certificates.k8s.io</code>APIを用いることで、<a href=/ja/docs/tasks/tls/managing-tls-in-a-cluster>こちら</a>のドキュメントにあるように、認証に使用するx509証明書をプロビジョニングすることができます。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3aeeecf7cdb2a21eb4b31db7a71c81e2>11.3 - リソースの管理</h1><p>アプリケーションをデプロイし、Serviceを介して外部に公開できました。さて、どうしますか？Kubernetesは、スケーリングや更新など、アプリケーションのデプロイを管理するための多くのツールを提供します。
我々が取り上げる機能についての詳細は<a href=/ja/docs/concepts/configuration/overview/>設定ファイル</a>と<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>について詳細に説明します。</p><h2 id=リソースの設定を管理する>リソースの設定を管理する</h2><p>多くのアプリケーションではDeploymentやServiceなど複数のリソースの作成を要求します。複数のリソースの管理は、同一のファイルにひとまとめにしてグループ化すると簡単になります(YAMLファイル内で<code>---</code>で区切る)。
例えば:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/nginx-app.yaml download=application/nginx-app.yaml><code>application/nginx-app.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-nginx-app-yaml")' title="Copy application/nginx-app.yaml to clipboard"></img></div><div class=includecode id=application-nginx-app-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx-svc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>複数のリソースは単一のリソースと同様の方法で作成できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx-app.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>service/my-nginx-svc created
</span></span><span style=display:flex><span>deployment.apps/my-nginx created
</span></span></code></pre></div><p>リソースは、ファイル内に記述されている順番通りに作成されます。そのため、Serviceを最初に指定するのが理想です。スケジューラーがServiceに関連するPodを、Deploymentなどのコントローラーによって作成されるときに確実に拡散できるようにするためです。</p><p><code>kubectl apply</code>もまた、複数の<code>-f</code>による引数指定を許可しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx/nginx-svc.yaml -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml
</span></span></code></pre></div><p>個別のファイルに加えて、-fの引数としてディレクトリ名も指定できます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx/
</span></span></code></pre></div><p><code>kubectl</code>は<code>.yaml</code>、<code>.yml</code>、<code>.json</code>といったサフィックスの付くファイルを読み込みます。</p><p>同じマイクロサービス、アプリケーションティアーのリソースは同一のファイルにまとめ、アプリケーションに関するファイルをグループ化するために、それらのファイルを同一のディレクトリに配備するのを推奨します。アプリケーションのティアーがDNSを通じて互いにバインドされると、アプリケーションスタックの全てのコンポーネントをひとまとめにして簡単にデプロイできます。</p><p>リソースの設定ソースとして、URLも指定できます。githubから取得した設定ファイルから直接手軽にデプロイができます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/application/nginx/nginx-deployment.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/my-nginx created
</span></span></code></pre></div><h2 id=kubectlによる一括操作>kubectlによる一括操作</h2><p><code>kubectl</code>が一括して実行できる操作はリソースの作成のみではありません。作成済みのリソースの削除などの他の操作を実行するために、設定ファイルからリソース名を取得することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete -f https://k8s.io/examples/application/nginx-app.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps <span style=color:#b44>&#34;my-nginx&#34;</span> deleted
</span></span><span style=display:flex><span>service <span style=color:#b44>&#34;my-nginx-svc&#34;</span> deleted
</span></span></code></pre></div><p>2つのリソースだけを削除する場合には、コマンドラインでリソース/名前というシンタックスを使うことで簡単に指定できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployments/my-nginx services/my-nginx-svc
</span></span></code></pre></div><p>さらに多くのリソースに対する操作では、リソースをラベルでフィルターするために<code>-l</code>や<code>--selector</code>を使ってセレクター(ラベルクエリ)を指定するのが簡単です:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment,services -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps <span style=color:#b44>&#34;my-nginx&#34;</span> deleted
</span></span><span style=display:flex><span>service <span style=color:#b44>&#34;my-nginx-svc&#34;</span> deleted
</span></span></code></pre></div><p><code>kubectl</code>は同様のシンタックスでリソース名を出力するので、<code>$()</code>や<code>xargs</code>を使ってパイプで操作するのが容易です:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get <span style=color:#a2f;font-weight:700>$(</span>kubectl create -f docs/concepts/cluster-administration/nginx/ -o name | grep service<span style=color:#a2f;font-weight:700>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME           TYPE           CLUSTER-IP   EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>      AGE
</span></span><span style=display:flex><span>my-nginx-svc   LoadBalancer   10.0.0.208   &lt;pending&gt;     80/TCP       0s
</span></span></code></pre></div><p>上記のコマンドで、最初に<code>examples/application/nginx/</code>配下でリソースを作成し、<code>-o name</code>という出力フォーマットにより、作成されたリソースの名前を表示します(各リソースをresource/nameという形式で表示)。そして"service"のみ<code>grep</code>し、<code>kubectl get</code>を使って表示させます。</p><p>あるディレクトリ内の複数のサブディレクトリをまたいでリソースを管理するような場合、<code>--filename,-f</code>フラグと合わせて<code>--recursive</code>や<code>-R</code>を指定することでサブディレクトリに対しても再帰的に操作が可能です。</p><p>例えば、開発環境用に必要な全ての<a class=glossary-tooltip title='A serialized specification of one or more Kubernetes API objects.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-manifest' target=_blank aria-label=マニフェスト>マニフェスト</a>をリソースタイプによって整理している<code>project/k8s/development</code>というディレクトリがあると仮定します。</p><pre tabindex=0><code>project/k8s/development
├── configmap
│   └── my-configmap.yaml
├── deployment
│   └── my-deployment.yaml
└── pvc
    └── my-pvc.yaml
</code></pre><p>デフォルトでは、<code>project/k8s/development</code>における一括操作は、どのサブディレクトリも処理せず、ディレクトリの第1階層で処理が止まります。下記のコマンドによってこのディレクトリ配下でリソースを作成しようとすると、エラーが発生します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f project/k8s/development
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>error: you must provide one or more resources by argument or filename <span style=color:#666>(</span>.json|.yaml|.yml|stdin<span style=color:#666>)</span>
</span></span></code></pre></div><p>代わりに、下記のように<code>--filename,-f</code>フラグと合わせて<code>--recursive</code>や<code>-R</code>を指定してください:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f project/k8s/development --recursive
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>configmap/my-config created
</span></span><span style=display:flex><span>deployment.apps/my-deployment created
</span></span><span style=display:flex><span>persistentvolumeclaim/my-pvc created
</span></span></code></pre></div><p><code>--recursive</code>フラグは<code>kubectl {create,get,delete,describe,rollout}</code>などのような<code>--filename,-f</code>フラグを扱うどの操作でも有効です。</p><p>また、<code>--recursive</code>フラグは複数の<code>-f</code>フラグの引数を指定しても有効です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f project/k8s/namespaces -f project/k8s/development --recursive
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>namespace/development created
</span></span><span style=display:flex><span>namespace/staging created
</span></span><span style=display:flex><span>configmap/my-config created
</span></span><span style=display:flex><span>deployment.apps/my-deployment created
</span></span><span style=display:flex><span>persistentvolumeclaim/my-pvc created
</span></span></code></pre></div><p><code>kubectl</code>についてさらに知りたい場合は、<a href=/ja/docs/reference/kubectl/overview/>kubectlの概要</a>を参照してください。</p><h2 id=ラベルを有効に使う>ラベルを有効に使う</h2><p>これまで取り上げた例では、リソースに対して最大1つのラベルを適用してきました。リソースのセットを他のセットと区別するために、複数のラベルが必要な状況があります。</p><p>例えば、異なるアプリケーション間では、異なる<code>app</code>ラベルを使用したり、<a href=https://github.com/kubernetes/examples/tree/master/guestbook/>ゲストブックの例</a>のようなマルチティアーのアプリケーションでは、各ティアーを区別する必要があります。frontendというティアーでは下記のラベルを持ちます。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span></code></pre></div><p>Redisマスターやスレーブでは異なる<code>tier</code>ラベルを持ち、加えて<code>role</code>ラベルも持つことでしょう。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span></code></pre></div><p>そして</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>slave<span style=color:#bbb>
</span></span></span></code></pre></div><p>ラベルを使用すると、ラベルで指定された任意の次元に沿ってリソースを分割できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f examples/guestbook/all-in-one/guestbook-all-in-one.yaml
</span></span><span style=display:flex><span>kubectl get pods -Lapp -Ltier -Lrole
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                           READY     STATUS    RESTARTS   AGE       APP         TIER       ROLE
</span></span><span style=display:flex><span>guestbook-fe-4nlpb             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
</span></span><span style=display:flex><span>guestbook-fe-ght6d             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
</span></span><span style=display:flex><span>guestbook-fe-jpy62             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
</span></span><span style=display:flex><span>guestbook-redis-master-5pg3b   1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    master
</span></span><span style=display:flex><span>guestbook-redis-slave-2q2yf    1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    slave
</span></span><span style=display:flex><span>guestbook-redis-slave-qgazl    1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    slave
</span></span><span style=display:flex><span>my-nginx-divi2                 1/1       Running   <span style=color:#666>0</span>          29m       nginx       &lt;none&gt;     &lt;none&gt;
</span></span><span style=display:flex><span>my-nginx-o0ef1                 1/1       Running   <span style=color:#666>0</span>          29m       nginx       &lt;none&gt;     &lt;none&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -lapp<span style=color:#666>=</span>guestbook,role<span style=color:#666>=</span>slave
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                          READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>guestbook-redis-slave-2q2yf   1/1       Running   <span style=color:#666>0</span>          3m
</span></span><span style=display:flex><span>guestbook-redis-slave-qgazl   1/1       Running   <span style=color:#666>0</span>          3m
</span></span></code></pre></div><h2 id=canary-deployments-カナリアデプロイ>Canary deployments カナリアデプロイ</h2><p>複数のラベルが必要な他の状況として、異なるリリース間でのDeploymentや、同一コンポーネントの設定を区別することが挙げられます。よく知られたプラクティスとして、本番環境の実際のトラフィックを受け付けるようにするために、新しいリリースを完全にロールアウトする前に、新しい<em>カナリア版</em>のアプリケーションを過去のリリースと合わせてデプロイする方法があります。</p><p>例えば、異なるリリースバージョンを分けるために<code>track</code>ラベルを使用できます。</p><p>主要な安定板のリリースでは<code>track</code>ラベルに<code>stable</code>という値をつけることがあるでしょう。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gb-frontend:v3<span style=color:#bbb>
</span></span></span></code></pre></div><p>そして2つの異なるPodのセットを上書きしないようにするため、<code>track</code>ラベルに異なる値を持つ(例: <code>canary</code>)ようなguestbookフロントエンドの新しいリリースを作成できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-canary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>canary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gb-frontend:v4<span style=color:#bbb>
</span></span></span></code></pre></div><p>frontend Serviceは、トラフィックを両方のアプリケーションにリダイレクトさせるために、両方のアプリケーションに共通したラベルのサブセットを選択して両方のレプリカを扱えるようにします。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span></code></pre></div><p>安定版とカナリア版リリースで本番環境の実際のトラフィックを転送する割合を決めるため、双方のレプリカ数を変更できます(このケースでは3対1)。
最新版のリリースをしても大丈夫な場合、安定版のトラックを新しいアプリケーションにして、カナリア版を削除します。</p><p>さらに具体的な例については、<a href=https://github.com/kelseyhightower/talks/tree/master/kubecon-eu-2016/demo#deploy-a-canary>tutorial of deploying Ghost</a>を参照してください。</p><h2 id=ラベルの更新>ラベルの更新</h2><p>新しいリソースを作成する前に、既存のPodと他のリソースのラベルの変更が必要な状況があります。これは<code>kubectl label</code>で実行できます。
例えば、全てのnginx Podを frontendティアーとしてラベル付けするには、下記のコマンドを実行するのみです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl label pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx <span style=color:#b8860b>tier</span><span style=color:#666>=</span>fe
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pod/my-nginx-2035384211-j5fhi labeled
</span></span><span style=display:flex><span>pod/my-nginx-2035384211-u2c7e labeled
</span></span><span style=display:flex><span>pod/my-nginx-2035384211-u3t6x labeled
</span></span></code></pre></div><p>これは最初に"app=nginx"というラベルのついたPodをフィルターし、そのPodに対して"tier=fe"というラベルを追加します。
ラベル付けしたPodを確認するには、下記のコマンドを実行してください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -L tier
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                        READY     STATUS    RESTARTS   AGE       TIER
</span></span><span style=display:flex><span>my-nginx-2035384211-j5fhi   1/1       Running   <span style=color:#666>0</span>          23m       fe
</span></span><span style=display:flex><span>my-nginx-2035384211-u2c7e   1/1       Running   <span style=color:#666>0</span>          23m       fe
</span></span><span style=display:flex><span>my-nginx-2035384211-u3t6x   1/1       Running   <span style=color:#666>0</span>          23m       fe
</span></span></code></pre></div><p>このコマンドでは"app=nginx"というラベルのついた全てのPodを出力し、Podのtierという項目も表示します(<code>-L</code>または<code>--label-columns</code>で指定)。</p><p>さらなる情報は、<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>や<a href=/docs/reference/generated/kubectl/kubectl-commands/#label>kubectl label</a>を参照してください。</p><h2 id=アノテーションの更新>アノテーションの更新</h2><p>リソースに対してアノテーションを割り当てたい状況があります。アノテーションは、ツール、ライブラリなどのAPIクライアントによって取得するための任意の非識別メタデータです。アノテーションの割り当ては<code>kubectl annotate</code>で可能です。例:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl annotate pods my-nginx-v4-9gw19 <span style=color:#b8860b>description</span><span style=color:#666>=</span><span style=color:#b44>&#39;my frontend running nginx&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods my-nginx-v4-9gw19 -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: pod
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  annotations:
</span></span><span style=display:flex><span>    description: my frontend running nginx
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>さらなる情報は、<a href=/ja/docs/concepts/overview/working-with-objects/annotations/>アノテーション</a> や、<a href=/docs/reference/generated/kubectl/kubectl-commands/#annotate>kubectl annotate</a>を参照してください。</p><h2 id=アプリケーションのスケール>アプリケーションのスケール</h2><p>アプリケーションの負荷が増減するとき、<code>kubectl</code>を使って簡単にスケールできます。例えば、nginxのレプリカを3から1に減らす場合、下記を実行します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment/my-nginx --replicas<span style=color:#666>=</span><span style=color:#666>1</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/my-nginx scaled
</span></span></code></pre></div><p>実行すると、Deploymentによって管理されるPod数が1となります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                        READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>my-nginx-2035384211-j5fhi   1/1       Running   <span style=color:#666>0</span>          30m
</span></span></code></pre></div><p>システムに対してnginxのレプリカ数を自動で選択させるには、下記のように1から3の範囲で指定します。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment/my-nginx --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>3</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>horizontalpodautoscaler.autoscaling/my-nginx autoscaled
</span></span></code></pre></div><p>実行すると、nginxのレプリカは必要に応じて自動でスケールアップ、スケールダウンします。</p><p>さらなる情報は、<a href=/docs/reference/generated/kubectl/kubectl-commands/#scale>kubectl scale</a>、<a href=/docs/reference/generated/kubectl/kubectl-commands/#autoscale>kubectl autoscale</a> and <a href=/docs/tasks/run-application/horizontal-pod-autoscale/>horizontal pod autoscaler</a>を参照してください。</p><h2 id=リソースの直接的アップデート>リソースの直接的アップデート</h2><p>場合によっては、作成したリソースに対して処理を中断させずに更新を行う必要があります。</p><h3 id=kubectl-apply>kubectl apply</h3><p>開発者が設定するリソースをコードとして管理しバージョニングも行えるように、設定ファイルのセットをソースによって管理する方法が推奨されています。
この場合、クラスターに対して設定の変更をプッシュするために<a href=/docs/reference/generated/kubectl/kubectl-commands/#apply><code>kubectl apply</code></a>を使用できます。</p><p>このコマンドは、リソース設定の過去のバージョンと、今適用した変更を比較し、差分に現れないプロパティーに対して上書き変更することなくクラスターに適用させます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml
</span></span><span style=display:flex><span>deployment.apps/my-nginx configured
</span></span></code></pre></div><p>注意として、前回の変更適用時からの設定の変更内容を決めるため、<code>kubectl apply</code>はリソースに対してアノテーションを割り当てます。変更が実施されると<code>kubectl apply</code>は、1つ前の設定内容と、今回変更しようとする入力内容と、現在のリソースの設定との3つの間で変更内容の差分をとります。</p><p>現在、リソースはこのアノテーションなしで作成されました。そのため、最初の<code>kubectl paply</code>の実行においては、与えられた入力と、現在のリソースの設定の2つの間の差分が取られ、フォールバックします。この最初の実行の間、リソースが作成された時にプロパティーセットの削除を検知できません。この理由により、プロパティーの削除はされません。</p><p><code>kubectl apply</code>の実行後の全ての呼び出しや、<code>kubectl replace</code>や<code>kubectl edit</code>などの設定を変更する他のコマンドではアノテーションを更新します。<code>kubectl apply</code>した後の全ての呼び出しにおいて3-wayの差分取得によってプロパティの検知と削除を実施します。</p><h3 id=kubectl-edit>kubectl edit</h3><p>その他に、<code>kubectl edit</code>によってリソースの更新もできます。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit deployment/my-nginx
</span></span></code></pre></div><p>このコマンドは、最初にリソースを<code>get</code>し、テキストエディタでリソースを編集し、更新されたバージョンでリソースを<code>apply</code>します。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment my-nginx -o yaml &gt; /tmp/nginx.yaml
</span></span><span style=display:flex><span>vi /tmp/nginx.yaml
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># yamlファイルを編集し、ファイルを保存します。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl apply -f /tmp/nginx.yaml
</span></span><span style=display:flex><span>deployment.apps/my-nginx configured
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rm /tmp/nginx.yaml
</span></span></code></pre></div><p>このコマンドによってより重大な変更を簡単に行えます。注意として、あなたの<code>EDITOR</code>や<code>KUBE_EDITOR</code>といった環境変数も指定できます。</p><p>さらなる情報は、<a href=/docs/reference/generated/kubectl/kubectl-commands/#edit>kubectl edit</a>を参照してください。</p><h3 id=kubectl-patch>kubectl patch</h3><p>APIオブジェクトの更新には<code>kubectl patch</code>を使うことができます。このコマンドはJSON patch、JSON merge patch、戦略的merge patchをサポートしています。
<a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>kubectl patchを使ったAPIオブジェクトの更新</a>や<a href=/docs/reference/generated/kubectl/kubectl-commands/#patch>kubectl patch</a>を参照してください。</p><h2 id=破壊的なアップデート>破壊的なアップデート</h2><p>一度初期化された後、更新できないようなリソースフィールドの更新が必要な場合や、Deploymentによって作成され、壊れている状態のPodを修正するなど、再帰的な変更を即座に行いたい場合があります。このようなフィールドを変更するため、リソースの削除と再作成を行う<code>replace --force</code>を使用してください。このケースでは、シンプルに元の設定ファイルを修正するのみです。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml --force
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/my-nginx deleted
</span></span><span style=display:flex><span>deployment.apps/my-nginx replaced
</span></span></code></pre></div><h2 id=サービス停止なしでアプリケーションを更新する>サービス停止なしでアプリケーションを更新する</h2><p>ある時点で、前述したカナリアデプロイのシナリオにおいて、新しいイメージやイメージタグを指定することによって、デプロイされたアプリケーションを更新が必要な場合があります。<code>kubectl</code>ではいくつかの更新操作をサポートしており、それぞれの操作が異なるシナリオに対して適用可能です。</p><p>ここでは、Deploymentを使ってアプリケーションの作成と更新についてガイドします。</p><p>まずnginxのバージョン1.14.2を稼働させていると仮定します。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment my-nginx --image<span style=color:#666>=</span>nginx:1.14.2
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/my-nginx created
</span></span></code></pre></div><p>レプリカ数を3にします(新旧のリビジョンは混在します)。:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment my-nginx --current-replicas<span style=color:#666>=</span><span style=color:#666>1</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</span></span></code></pre></div><pre tabindex=0><code>deployment.apps/my-nginx scaled
</code></pre><p>バージョン1.16.1に更新するには、上述したkubectlコマンドを使って<code>.spec.template.spec.containers[0].image</code>の値を<code>nginx:1.14.2</code>から<code>nginx:1.16.1</code>に変更するだけでできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit deployment/my-nginx
</span></span></code></pre></div><p>できました!Deploymentはデプロイされたnginxのアプリケーションを宣言的にプログレッシブに更新します。更新途中では、決まった数の古いレプリカのみダウンし、一定数の新しいレプリカが希望するPod数以上作成されても良いことを保証します。詳細について学ぶには<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment page</a>を参照してください。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/tasks/debug-application-cluster/debug-application-introspection/>アプリケーションの調査とデバッグのための<code>kubectl</code>の使用方法</a>について学んでください。</li><li><a href=/ja/docs/concepts/configuration/overview/>設定のベストプラクティスとTIPS</a>を参照してください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d649067a69d8d5c7e71564b42b96909e>11.4 - クラスターのネットワーク</h1><p>ネットワークはKubernetesにおける中心的な部分ですが、どのように動作するかを正確に理解することは難解な場合もあります。
Kubernetesには、4つの異なる対応すべきネットワークの問題があります:</p><ol><li>高度に結合されたコンテナ間の通信: これは、<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>および<code>localhost</code>通信によって解決されます。</li><li>Pod間の通信: 本ドキュメントの主な焦点です。</li><li>Podからサービスへの通信: これは<a href=/ja/docs/concepts/services-networking/service/>Service</a>でカバーされています。</li><li>外部からサービスへの通信: これは<a href=/ja/docs/concepts/services-networking/service/>Service</a>でカバーされています。</li></ol><p>Kubernetesは、言ってしまえばアプリケーション間でマシンを共有するためのものです。通常、マシンを共有するには、2つのアプリケーションが同じポートを使用しないようにする必要があります。
複数の開発者間でのポートの調整は、大規模に行うことが非常に難しく、ユーザーが制御できないクラスターレベルの問題に直面することになります。</p><p>動的ポート割り当てはシステムに多くの複雑さをもたらします。すべてのアプリケーションはポートをフラグとして受け取らなければならない、APIサーバーは設定ブロックに動的ポート番号を挿入する方法を知っていなければならない、各サービスは互いを見つける方法を知らなければならない、などです。Kubernetesはこれに対処するのではなく、別のアプローチを取ります。</p><p>Kubernetesネットワークモデルについては、<a href=/ja/docs/concepts/services-networking/>こちら</a>を参照してください。</p><h2 id=how-to-implement-the-kubernetes-network-model>Kubernetesネットワークモデルの実装方法</h2><p>ネットワークモデルは、各ノード上のコンテナランタイムによって実装されます。最も一般的なコンテナランタイムは、<a href=https://github.com/containernetworking/cni>Container Network Interface</a> (CNI)プラグインを使用して、ネットワークとセキュリティ機能を管理します。CNIプラグインは、さまざまなベンダーから多数提供されています。これらの中には、ネットワークインターフェースの追加と削除という基本的な機能のみを提供するものもあれば、他のコンテナオーケストレーションシステムとの統合、複数のCNIプラグインの実行、高度なIPAM機能など、より洗練されたソリューションを提供するものもあります。</p><p>Kubernetesがサポートするネットワークアドオンの非網羅的なリストについては、<a href=/ja/docs/concepts/cluster-administration/addons/#networking-and-network-policy>このページ</a>を参照してください。</p><h2 id=次の項目>次の項目</h2><p>ネットワークモデルの初期設計とその根拠、および将来の計画については、<a href=https://git.k8s.io/design-proposals-archive/network/networking.md>ネットワーク設計ドキュメント</a>で詳細に説明されています。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5cc31ecfba86467f8884856412cfb6b2>11.5 - システムログ</h1><p>システムコンポーネントのログは、クラスター内で起こったイベントを記録します。このログはデバッグのために非常に役立ちます。ログのverbosityを設定すると、ログをどの程度詳細に見るのかを変更できます。ログはコンポーネント内のエラーを表示する程度の荒い粒度にすることも、イベントのステップバイステップのトレース(HTTPのアクセスログ、Podの状態の変更、コントローラーの動作、スケジューラーの決定など)を表示するような細かい粒度に設定することもできます。</p><h2 id=klog>klog</h2><p>klogは、Kubernetesのログライブラリです。<a href=https://github.com/kubernetes/klog>klog</a>は、Kubernetesのシステムコンポーネント向けのログメッセージを生成します。</p><p>klogの設定に関する詳しい情報については、<a href=/docs/reference/command-line-tools-reference/>コマンドラインツールのリファレンス</a>を参照してください。</p><p>klogネイティブ形式の例:</p><pre tabindex=0><code>I1025 00:15:15.525108       1 httplog.go:79] GET /api/v1/namespaces/kube-system/pods/metrics-server-v0.3.1-57c75779f-9p8wg: (1.512ms) 200 [pod_nanny/v0.0.0 (linux/amd64) kubernetes/$Format 10.56.1.19:51756]
</code></pre><h3 id=構造化ログ>構造化ログ</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [alpha]</code></div><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong><p>構造化ログへのマイグレーションは現在進行中の作業です。このバージョンでは、すべてのログメッセージが構造化されているわけではありません。ログファイルをパースする場合、JSONではないログの行にも対処しなければなりません。</p><p>ログの形式と値のシリアライズは変更される可能性があります。</p></div><p>構造化ログは、ログメッセージに単一の構造を導入し、プログラムで情報の抽出ができるようにするものです。構造化ログは、僅かな労力とコストで保存・処理できます。新しいメッセージ形式は後方互換性があり、デフォルトで有効化されます。</p><p>構造化ログの形式:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#b44>&lt;klog header&gt; &#34;&lt;message&gt;&#34; &lt;key1&gt;</span><span style=color:#666>=</span><span style=color:#b44>&#34;&lt;value1&gt;&#34; &lt;key2&gt;=&#34;&lt;value2&gt;&#34; ...</span>
</span></span></code></pre></div><p>例:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#b44>I1025 00:15:15.525108       1 controller_utils.go:116] &#34;Pod status updated&#34; pod</span><span style=color:#666>=</span><span style=color:#b44>&#34;kube-system/kubedns&#34; status=&#34;ready&#34;</span>
</span></span></code></pre></div><h3 id=jsonログ形式>JSONログ形式</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [alpha]</code></div><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong><p>JSONの出力は多数の標準のklogフラグをサポートしていません。非対応のklogフラグの一覧については、<a href=/docs/reference/command-line-tools-reference/>コマンドラインツールリファレンス</a>を参照してください。</p><p>すべてのログがJSON形式で書き込むことに対応しているわけではありません(たとえば、プロセスの開始時など)。ログのパースを行おうとしている場合、JSONではないログの行に対処できるようにしてください。</p><p>フィールド名とJSONのシリアライズは変更される可能性があります。</p></div><p><code>--logging-format=json</code>フラグは、ログの形式をネイティブ形式klogからJSON形式に変更します。以下は、JSONログ形式の例(pretty printしたもの)です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;ts&#34;</span>: <span style=color:#666>1580306777.04728</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;v&#34;</span>: <span style=color:#666>4</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;msg&#34;</span>: <span style=color:#b44>&#34;Pod status updated&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;pod&#34;</span>:{
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx-1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>
</span></span><span style=display:flex><span>   },
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;ready&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>特別な意味を持つキー:</p><ul><li><code>ts</code> - Unix時間のタイムスタンプ(必須、float)</li><li><code>v</code> - verbosity (必須、int、デフォルトは0)</li><li><code>err</code> - エラー文字列 (オプション、string)</li><li><code>msg</code> - メッセージ (必須、string)</li></ul><p>現在サポートされているJSONフォーマットの一覧:</p><ul><li><a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a></li><li><a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a></li><li><a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a></li><li><a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a></li></ul><h3 id=ログのサニタイズ>ログのサニタイズ</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code></div><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> ログのサニタイズ大きな計算のオーバーヘッドを引き起こす可能性があるため、本番環境では有効にするべきではありません。</div><p><code>--experimental-logging-sanitization</code>フラグはklogのサニタイズフィルタを有効にします。有効にすると、すべてのログの引数が機密データ(パスワード、キー、トークンなど)としてタグ付けされたフィールドについて検査され、これらのフィールドのログの記録は防止されます。</p><p>現在ログのサニタイズをサポートしているコンポーネント一覧:</p><ul><li>kube-controller-manager</li><li>kube-apiserver</li><li>kube-scheduler</li><li>kubelet</li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ログのサニタイズフィルターは、ユーザーのワークロードのログが機密データを漏洩するのを防げるわけではありません。</div><h3 id=ログのverbosityレベル>ログのverbosityレベル</h3><p><code>-v</code>フラグはログのverbosityを制御します。値を増やすとログに記録されるイベントの数が増えます。値を減らすとログに記録されるイベントの数が減ります。verbosityの設定を増やすと、ますます多くの深刻度の低いイベントをログに記録するようになります。verbosityの設定を0にすると、クリティカルなイベントだけをログに記録します。</p><h3 id=ログの場所>ログの場所</h3><p>システムコンポーネントには2種類あります。コンテナ内で実行されるコンポーネントと、コンテナ内で実行されないコンポーネントです。たとえば、次のようなコンポーネントがあります。</p><ul><li>Kubernetesのスケジューラーやkube-proxyはコンテナ内で実行されます。</li><li>kubeletやDockerのようなコンテナランタイムはコンテナ内で実行されません。</li></ul><p>systemdを使用しているマシンでは、kubeletとコンテナランタイムはjournaldに書き込みを行います。それ以外のマシンでは、<code>/var/log</code>ディレクトリ内の<code>.log</code>ファイルに書き込みます。コンテナ内部のシステムコンポーネントは、デフォルトのログ機構をバイパスするため、常に<code>/var/log</code>ディレクトリ内の<code>.log</code>ファイルに書き込みます。コンテナのログと同様に、<code>/var/log</code>ディレクトリ内のシステムコンポーネントのログはローテートする必要があります。<code>kube-up.sh</code>スクリプトによって作成されたKubernetesクラスターでは、ログローテーションは<code>logrotate</code>ツールで設定されます。<code>logrotate</code>ツールはログを1日ごとまたはログのサイズが100MBを超えたときにローテートします。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/concepts/cluster-administration/logging/>Kubernetesのログのアーキテクチャ</a>について読む。</li><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/1602-structured-logging>構造化ログ</a>について読む。</li><li><a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>ログの深刻度の慣習</a>について読む。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c4b1e87a84441f8a90699a345ce48d68>11.6 - ロギングのアーキテクチャ</h1><p>アプリケーションログは、アプリケーション内で何が起こっているかを理解するのに役立ちます。ログは、問題のデバッグとクラスターアクティビティの監視に特に役立ちます。最近のほとんどのアプリケーションには、何らかのロギングメカニズムがあります。同様に、コンテナエンジンはロギングをサポートするように設計されています。コンテナ化されたアプリケーションで、最も簡単で最も採用されているロギング方法は、標準出力と標準エラーストリームへの書き込みです。</p><p>ただし、コンテナエンジンまたはランタイムによって提供されるネイティブ機能は、たいていの場合、完全なロギングソリューションには十分ではありません。</p><p>たとえば、コンテナがクラッシュした場合やPodが削除された場合、またはノードが停止した場合に、アプリケーションのログにアクセスしたい場合があります。</p><p>クラスターでは、ノードやPod、またはコンテナに関係なく、ノードに個別のストレージとライフサイクルが必要です。この概念は、<em>クラスターレベルロギング</em> と呼ばれます。</p><p>クラスターレベルロギングのアーキテクチャでは、ログを保存、分析、およびクエリするための個別のバックエンドが必要です。Kubernetesは、ログデータ用のネイティブストレージソリューションを提供していません。代わりに、Kubernetesに統合される多くのロギングソリューションがあります。次のセクションでは、ノードでログを処理および保存する方法について説明します。</p><h2 id=basic-logging-in-kubernetes>Kubernetesでの基本的なロギング</h2><p>この例では、1秒に1回標準出力ストリームにテキストを書き込むコンテナを利用する、<code>Pod</code> specificationを使います。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/debug/counter-pod.yaml download=debug/counter-pod.yaml><code>debug/counter-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("debug-counter-pod-yaml")' title="Copy debug/counter-pod.yaml to clipboard"></img></div><div class=includecode id=debug-counter-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#39;i=0; while true; do echo &#34;$i: $(date)&#34;; i=$((i+1)); sleep 1; done&#39;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>このPodを実行するには、次のコマンドを使用します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/debug/counter-pod.yaml
</span></span></code></pre></div><p>出力は次のようになります:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>pod/counter created
</span></span></span></code></pre></div><p>ログを取得するには、以下のように<code>kubectl logs</code>コマンドを使用します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter
</span></span></code></pre></div><p>出力は次のようになります:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>0: Mon Jan  1 00:00:00 UTC 2001
</span></span></span><span style=display:flex><span><span style=color:#888>1: Mon Jan  1 00:00:01 UTC 2001
</span></span></span><span style=display:flex><span><span style=color:#888>2: Mon Jan  1 00:00:02 UTC 2001
</span></span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span></code></pre></div><p>コンテナの以前のインスタンスからログを取得するために、<code>kubectl logs --previous</code>を使用できます。Podに複数のコンテナがある場合は、次のように-cフラグでコマンドにコンテナ名を追加することで、アクセスするコンテナのログを指定します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>kubectl logs counter -c count
</span></span></span></code></pre></div><p>詳細については、<a href=/docs/reference/generated/kubectl/kubectl-commands#logs><code>kubectl logs</code>ドキュメント</a>を参照してください。</p><h2 id=logging-at-the-node-level>ノードレベルでのロギング</h2><p><img src=/images/docs/user-guide/logging/logging-node-level.png alt="Node level logging"></p><p>コンテナエンジンは、生成された出力を処理して、コンテナ化されたアプリケーションの<code>stdout</code>と<code>stderr</code>ストリームにリダイレクトします。たとえば、Dockerコンテナエンジンは、これら2つのストリームを<a href=https://docs.docker.com/engine/admin/logging/overview>ロギングドライバー</a>にリダイレクトします。ロギングドライバーは、JSON形式でファイルに書き込むようにKubernetesで設定されています。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Docker JSONロギングドライバーは、各行を個別のメッセージとして扱います。Dockerロギングドライバーを使用する場合、複数行メッセージを直接サポートすることはできません。ロギングエージェントレベルあるいはそれ以上のレベルで、複数行のメッセージを処理する必要があります。</div><p>デフォルトでは、コンテナが再起動すると、kubeletは1つの終了したコンテナをログとともに保持します。Podがノードから削除されると、対応する全てのコンテナが、ログとともに削除されます。</p><p>ノードレベルロギングでの重要な考慮事項は、ノードで使用可能な全てのストレージをログが消費しないように、ログローテーションを実装することです。Kubernetesはログのローテーションを担当しませんが、デプロイツールでそれに対処するソリューションを構築する必要があります。たとえば、<code>kube-up.sh</code>スクリプトによってデプロイされたKubernetesクラスターには、1時間ごとに実行するように構成された<a href=https://linux.die.net/man/8/logrotate><code>logrotate</code></a>ツールがあります。アプリケーションのログを自動的にローテーションするようにコンテナランタイムを構築することもできます。</p><p>例として、<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/gce/gci/configure-helper.sh><code>configure-helper</code> script</a>に対応するスクリプトである<code>kube-up.sh</code>が、どのようにGCPでCOSイメージのロギングを構築しているかについて、詳細な情報を見つけることができます。</p><p><strong>CRIコンテナランタイム</strong>を使用する場合、kubeletはログのローテーションとログディレクトリ構造の管理を担当します。kubeletはこの情報をCRIコンテナランタイムに送信し、ランタイムはコンテナログを指定された場所に書き込みます。2つのkubeletパラメーター、<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration><code>container-log-max-size</code>と<code>container-log-max-files</code></a>を<a href=/docs/tasks/administer-cluster/kubelet-config-file/>kubelet設定ファイル</a>で使うことで、各ログファイルの最大サイズと各コンテナで許可されるファイルの最大数をそれぞれ設定できます。</p><p>基本的なロギングの例のように、<a href=/docs/reference/generated/kubectl/kubectl-commands#logs><code>kubectl logs</code></a>を実行すると、ノード上のkubeletがリクエストを処理し、ログファイルから直接読み取ります。kubeletはログファイルの内容を返します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 外部システムがローテーションを実行した場合、またはCRIコンテナランタイムが使用されている場合は、最新のログファイルの内容のみが<code>kubectl logs</code>で利用可能になります。例えば、10MBのファイルがある場合、<code>logrotate</code>によるローテーションが実行されると、2つのファイルが存在することになります: 1つはサイズが10MBのファイルで、もう1つは空のファイルです。この例では、<code>kubectl logs</code>は最新のログファイルの内容、つまり空のレスポンスを返します。</div><h3 id=system-component-logs>システムコンポーネントログ</h3><p>システムコンポーネントには、コンテナ内で実行されるものとコンテナ内で実行されないものの2種類があります。例えば以下のとおりです。</p><ul><li>Kubernetesスケジューラーとkube-proxyはコンテナ内で実行されます。</li><li>kubeletとコンテナランタイムはコンテナ内で実行されません。</li></ul><p>systemdを搭載したマシンでは、kubeletとコンテナランタイムがjournaldに書き込みます。systemdが存在しない場合、kubeletとコンテナランタイムは<code>var/log</code>ディレクトリ内の<code>.log</code>ファイルに書き込みます。コンテナ内のシステムコンポーネントは、デフォルトのロギングメカニズムを迂回して、常に<code>/var/log</code>ディレクトリに書き込みます。それらは<a href=https://github.com/kubernetes/klog><code>klog</code></a>というロギングライブラリを使用します。これらのコンポーネントのロギングの重大性に関する規則は、<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>development docs on logging</a>に記載されています。</p><p>コンテナログと同様に、<code>/var/log</code>ディレクトリ内のシステムコンポーネントログはローテーションする必要があります。<code>kube-up.sh</code>スクリプトによって生成されたKubernetesクラスターでは、これらのログは、<code>logrotate</code>ツールによって毎日、またはサイズが100MBを超えた時にローテーションされるように設定されています。</p><h2 id=cluster-level-logging-architectures>クラスターレベルロギングのアーキテクチャ</h2><p>Kubernetesはクラスターレベルロギングのネイティブソリューションを提供していませんが、検討可能な一般的なアプローチがいくつかあります。ここにいくつかのオプションを示します:</p><ul><li>全てのノードで実行されるノードレベルのロギングエージェントを使用します。</li><li>アプリケーションのPodにログインするための専用のサイドカーコンテナを含めます。</li><li>アプリケーション内からバックエンドに直接ログを送信します。</li></ul><h3 id=using-a-node-logging-agent>ノードロギングエージェントの使用</h3><p><img src=/images/docs/user-guide/logging/logging-with-node-agent.png alt="Using a node level logging agent"></p><p>各ノードに <em>ノードレベルのロギングエージェント</em> を含めることで、クラスターレベルロギングを実装できます。ロギングエージェントは、ログを公開したり、ログをバックエンドに送信したりする専用のツールです。通常、ロギングエージェントは、そのノード上の全てのアプリケーションコンテナからのログファイルを含むディレクトリにアクセスできるコンテナです。</p><p>ロギングエージェントは全てのノードで実行する必要があるため、エージェントを<code>DaemonSet</code>として実行することをおすすめします。</p><p>ノードレベルのロギングは、ノードごとに1つのエージェントのみを作成し、ノードで実行されているアプリケーションに変更を加える必要はありません。</p><p>コンテナはstdoutとstderrに書き込みますが、合意された形式はありません。ノードレベルのエージェントはこれらのログを収集し、集約のために転送します。</p><h3 id=sidecar-container-with-logging-agent>ロギングエージェントでサイドカーコンテナを使用する</h3><p>サイドカーコンテナは、次のいずれかの方法で使用できます:</p><ul><li>サイドカーコンテナは、アプリケーションログを自身の<code>stdout</code>にストリーミングします。</li><li>サイドカーコンテナは、アプリケーションコンテナからログを取得するように設定されたロギングエージェントを実行します。</li></ul><h4 id=streaming-sidecar-container>ストリーミングサイドカーコンテナ</h4><p><img src=/images/docs/user-guide/logging/logging-with-streaming-sidecar.png alt="Sidecar container with a streaming container"></p><p>サイドカーコンテナに自身の<code>stdout</code>や<code>stderr</code>ストリームへの書き込みを行わせることで、各ノードですでに実行されているkubeletとロギングエージェントを利用できます。サイドカーコンテナは、ファイル、ソケット、またはjournaldからログを読み取ります。各サイドカーコンテナは、ログを自身の<code>stdout</code>または<code>stderr</code>ストリームに出力します。</p><p>このアプローチにより、<code>stdout</code>または<code>stderr</code>への書き込みのサポートが不足している場合も含め、アプリケーションのさまざまな部分からいくつかのログストリームを分離できます。ログのリダイレクトの背後にあるロジックは最小限であるため、大きなオーバーヘッドにはなりません。さらに、<code>stdout</code>と<code>stderr</code>はkubeletによって処理されるため、<code>kubectl logs</code>のような組み込みツールを使用できます。</p><p>たとえば、Podは単一のコンテナを実行し、コンテナは2つの異なる形式を使用して2つの異なるログファイルに書き込みます。Podの構成ファイルは次のとおりです:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/logging/two-files-counter-pod.yaml download=admin/logging/two-files-counter-pod.yaml><code>admin/logging/two-files-counter-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-yaml")' title="Copy admin/logging/two-files-counter-pod.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>両方のコンポーネントをコンテナの<code>stdout</code>ストリームにリダイレクトできたとしても、異なる形式のログエントリを同じログストリームに書き込むことはおすすめしません。代わりに、2つのサイドカーコンテナを作成できます。各サイドカーコンテナは、共有ボリュームから特定のログファイルを追跡し、ログを自身の<code>stdout</code>ストリームにリダイレクトできます。</p><p>2つのサイドカーコンテナを持つPodの構成ファイルは次のとおりです:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/logging/two-files-counter-pod-streaming-sidecar.yaml download=admin/logging/two-files-counter-pod-streaming-sidecar.yaml><code>admin/logging/two-files-counter-pod-streaming-sidecar.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-streaming-sidecar-yaml")' title="Copy admin/logging/two-files-counter-pod-streaming-sidecar.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-streaming-sidecar-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -f /var/log/1.log&#39;]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -f /var/log/2.log&#39;]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>これで、このPodを実行するときに、次のコマンドを実行して、各ログストリームに個別にアクセスできます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter count-log-1
</span></span></code></pre></div><p>出力は次のようになります:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>0: Mon Jan  1 00:00:00 UTC 2001
</span></span></span><span style=display:flex><span><span style=color:#888>1: Mon Jan  1 00:00:01 UTC 2001
</span></span></span><span style=display:flex><span><span style=color:#888>2: Mon Jan  1 00:00:02 UTC 2001
</span></span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter count-log-2
</span></span></code></pre></div><p>出力は次のようになります:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>Mon Jan  1 00:00:00 UTC 2001 INFO 0
</span></span></span><span style=display:flex><span><span style=color:#888>Mon Jan  1 00:00:01 UTC 2001 INFO 1
</span></span></span><span style=display:flex><span><span style=color:#888>Mon Jan  1 00:00:02 UTC 2001 INFO 2
</span></span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span></code></pre></div><p>クラスターにインストールされているノードレベルのエージェントは、それ以上の設定を行わなくても、これらのログストリームを自動的に取得します。必要があれば、ソースコンテナに応じてログをパースするようにエージェントを構成できます。</p><p>CPUとメモリーの使用量が少ない(CPUの場合は数ミリコアのオーダー、メモリーの場合は数メガバイトのオーダー)にも関わらず、ログをファイルに書き込んでから<code>stdout</code>にストリーミングすると、ディスクの使用量が2倍になる可能性があることに注意してください。単一のファイルに書き込むアプリケーションがある場合は、ストリーミングサイドカーコンテナアプローチを実装するのではなく、<code>/dev/stdout</code>を宛先として設定することをおすすめします。</p><p>サイドカーコンテナを使用して、アプリケーション自体ではローテーションできないログファイルをローテーションすることもできます。このアプローチの例は、<code>logrotate</code>を定期的に実行する小さなコンテナです。しかし、<code>stdout</code>と<code>stderr</code>を直接使い、ローテーションと保持のポリシーをkubeletに任せることをおすすめします。</p><h4 id=sidecar-container-with-a-logging-agent>ロギングエージェントを使用したサイドカーコンテナ</h4><p><img src=/images/docs/user-guide/logging/logging-with-sidecar-agent.png alt="Sidecar container with a logging agent"></p><p>ノードレベルロギングのエージェントが、あなたの状況に必要なだけの柔軟性を備えていない場合は、アプリケーションで実行するように特別に構成した別のロギングエージェントを使用してサイドカーコンテナを作成できます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> サイドカーコンテナでロギングエージェントを使用すると、大量のリソースが消費される可能性があります。さらに、これらのログはkubeletによって制御されていないため、<code>kubectl logs</code>を使用してこれらのログにアクセスすることができません。</div><p>ロギングエージェントを使用したサイドカーコンテナを実装するために使用できる、2つの構成ファイルを次に示します。最初のファイルには、fluentdを設定するための<a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/><code>ConfigMap</code></a>が含まれています。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/logging/fluentd-sidecar-config.yaml download=admin/logging/fluentd-sidecar-config.yaml><code>admin/logging/fluentd-sidecar-config.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-fluentd-sidecar-config-yaml")' title="Copy admin/logging/fluentd-sidecar-config.yaml to clipboard"></img></div><div class=includecode id=admin-logging-fluentd-sidecar-config-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fluentd.conf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type tail
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      format none
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      path /var/log/1.log
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      pos_file /var/log/1.log.pos
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      tag count.format1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type tail
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      format none
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      path /var/log/2.log
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      pos_file /var/log/2.log.pos
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      tag count.format2
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;match **&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type google_cloud
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/match&gt;</span><span style=color:#bbb>    
</span></span></span></code></pre></div></div></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> fluentdの構成については、<a href=https://docs.fluentd.org/>fluentd documentation</a>を参照してください。</div><p>2番目のファイルは、fluentdを実行しているサイドカーコンテナを持つPodを示しています。Podは、fluentdが構成データを取得できるボリュームをマウントします。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/logging/two-files-counter-pod-agent-sidecar.yaml download=admin/logging/two-files-counter-pod-agent-sidecar.yaml><code>admin/logging/two-files-counter-pod-agent-sidecar.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-agent-sidecar-yaml")' title="Copy admin/logging/two-files-counter-pod-agent-sidecar.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-agent-sidecar-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/fluentd-gcp:1.30<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>FLUENTD_ARGS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>-c /etc/fluentd-config/fluentd.conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/fluentd-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>サンプル構成では、fluentdを任意のロギングエージェントに置き換えて、アプリケーションコンテナ内の任意のソースから読み取ることができます。</p><h3 id=exposing-logs-directly-from-the-application>アプリケーションから直接ログを公開する</h3><p><img src=/images/docs/user-guide/logging/logging-from-application.png alt="Exposing logs directly from the application"></p><p>すべてのアプリケーションから直接ログを公開または送信するクラスターロギングは、Kubernetesのスコープ外です。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2e05a56491965ae320c2662590b2ca18>11.7 - コンテナイメージのガベージコレクション</h1><p>ガベージコレクションは、未使用の<a href=/ja/docs/concepts/containers/#container-images>イメージ</a>と未使用の<a href=/ja/docs/concepts/containers/>コンテナ</a>をクリーンアップするkubeletの便利な機能です。kubeletコンテナのガベージコレクションを1分ごとに行い、イメージのガベージコレクションは5分ごとに行います。</p><p>存在することが期待されているコンテナを削除してkubeletの動作を壊す可能性があるため、外部のガベージコレクションのツールは推奨されません。</p><h2 id=イメージのガベージコレクション>イメージのガベージコレクション</h2><p>Kubernetesでは、すべてのイメージのライフサイクルの管理はcadvisorと協調してimageManager経由で行います。</p><p>イメージのガベージコレクションのポリシーについて考えるときは、<code>HighThresholdPercent</code>および<code>LowThresholdPercent</code>という2つの要因について考慮する必要があります。ディスク使用量がhigh thresholdを超えると、ガベージコレクションがトリガされます。ガベージコレクションは、low
thresholdが満たされるまで、最後に使われてから最も時間が経った(least recently used)イメージを削除します。</p><h2 id=コンテナのガベージコレクション>コンテナのガベージコレクション</h2><p>コンテナのガベージコレクションのポリシーは、3つのユーザー定義の変数を考慮に入れます。<code>MinAge</code>は、ガベージコレクションできるコンテナの最小の年齢です。<code>MaxPerPodContainer</code>は、すべての単一のPod(UID、コンテナ名)が保持することを許されているdead状態のコンテナの最大値です。<code>MaxContainers</code>はdead状態のコンテナの合計の最大値です。これらの変数は、<code>MinAge</code>は0に、<code>MaxPerPodContainer</code>と<code>MaxContainers</code>は0未満にそれぞれ設定することで個別に無効にできます。</p><p>kubeletは、未指定のコンテナ、削除されたコンテナ、前述のフラグにより設定された境界の外にあるコンテナに対して動作します。一般に、最も古いコンテナが最初に削除されます。<code>MaxPerPodContainer</code>と<code>MaxContainer</code>は、Podごとの保持するコンテナの最大値(<code>MaxPerPodContainer</code>)がグローバルのdead状態のコンテナの許容範囲(<code>MaxContainers</code>)外である場合には、互いに競合する可能性があります。このような状況では、<code>MaxPerPodContainer</code>が調整されます。最悪のケースのシナリオでは、<code>MaxPerPodContainer</code>が1にダウングレードされ、最も古いコンテナが強制退去されます。さらに、<code>MinAge</code>より古くなると、削除済みのPodが所有するコンテナが削除されます。</p><p>kubeletによって管理されないコンテナは、コンテナのガベージコレクションの対象にはなりません。</p><h2 id=ユーザー設定>ユーザー設定</h2><p>イメージのガベージコレクションを調整するために、以下のkubeletのフラグを使用して次のようなしきい値を調整できます。</p><ol><li><code>image-gc-high-threshold</code>: イメージのガベージコレクションをトリガするディスク使用量の割合(%)。デフォルトは85%。</li><li><code>image-gc-low-threshold</code>: イメージのガベージコレクションが解放を試みるディスク使用量の割合(%)。デフォルトは80%。</li></ol><p>ガベージコレクションのポリシーは、以下のkubeletのフラグを使用してカスタマイズできます。</p><ol><li><code>minimum-container-ttl-duration</code>: 完了したコンテナがガベージコレクションされる前に経過するべき最小期間。デフォルトは0分です。つまり、すべての完了したコンテナはガベージコレクションされます。</li><li><code>maximum-dead-containers-per-container</code>: コンテナごとに保持される古いインスタンスの最大値です。デフォルトは1です。</li><li><code>maximum-dead-containers</code>: グローバルに保持するべき古いコンテナのインスタンスの最大値です。デフォルトは-1です。つまり、グローバルなリミットは存在しません。</li></ol><p>コンテナは役に立たなくなる前にガベージコレクションされる可能性があります。こうしたコンテナには、トラブルシューティングに役立つログや他のデータが含まれるかもしれません。そのため、期待されるコンテナごとに最低でも1つのdead状態のコンテナが許容されるようにするために、<code>maximum-dead-containers-per-container</code>には十分大きな値を設定することが強く推奨されます。同様の理由で、<code>maximum-dead-containers</code>にも、より大きな値を設定することが推奨されます。詳しくは、<a href=https://github.com/kubernetes/kubernetes/issues/13287>こちらのissue</a>を読んでください。</p><h2 id=廃止>廃止</h2><p>このドキュメントにあるkubeletの一部のガベージコレクションの機能は、将来kubelet evictionで置換される予定です。</p><p>これには以下のものが含まれます。</p><table><thead><tr><th>既存のフラグ</th><th>新しいフラグ</th><th>理由</th></tr></thead><tbody><tr><td><code>--image-gc-high-threshold</code></td><td><code>--eviction-hard</code>または<code>--eviction-soft</code></td><td>既存のevictionのシグナルがイメージのガベージコレクションをトリガする可能性がある</td></tr><tr><td><code>--image-gc-low-threshold</code></td><td><code>--eviction-minimum-reclaim</code></td><td>eviction reclaimが同等の動作を実現する</td></tr><tr><td><code>--maximum-dead-containers</code></td><td></td><td>古いログがコンテナのコンテキストの外部に保存されるようになったら廃止</td></tr><tr><td><code>--maximum-dead-containers-per-container</code></td><td></td><td>古いログがコンテナのコンテキストの外部に保存されるようになったら廃止</td></tr><tr><td><code>--minimum-container-ttl-duration</code></td><td></td><td>古いログがコンテナのコンテキストの外部に保存されるようになったら廃止</td></tr><tr><td><code>--low-diskspace-threshold-mb</code></td><td><code>--eviction-hard</code> or <code>eviction-soft</code></td><td>evictionはディスクのしきい値を他のリソースに一般化している</td></tr><tr><td><code>--outofdisk-transition-frequency</code></td><td><code>--eviction-pressure-transition-period</code></td><td>evictionはディスクのpressure transitionを他のリソースに一般化している</td></tr></tbody></table><h2 id=次の項目>次の項目</h2><p>詳細については、<a href=/docs/tasks/administer-cluster/out-of-resource/>リソース不足のハンドリング方法を設定する</a>を参照してください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-08e94e6a480e0d6b2de72d84a1b97617>11.8 - Kubernetesのプロキシー</h1><p>このページではKubernetesと併用されるプロキシーについて説明します。</p><h2 id=プロキシー>プロキシー</h2><p>Kubernetesを使用する際に、いくつかのプロキシーを使用する場面があります。</p><ol><li><p><a href=/docs/tasks/access-application-cluster/access-cluster/#directly-accessing-the-rest-api>kubectlのプロキシー</a>:</p><ul><li>ユーザーのデスクトップ上かPod内で稼働します</li><li>ローカルホストのアドレスからKubernetes apiserverへのプロキシーを行います</li><li>クライアントからプロキシー間ではHTTPを使用します</li><li>プロキシーからapiserverへはHTTPSを使用します</li><li>apiserverの場所を示します</li><li>認証用のヘッダーを追加します</li></ul></li><li><p><a href=/docs/tasks/access-application-cluster/access-cluster/#discovering-builtin-services>apiserverのプロキシー</a>:</p><ul><li>apiserver内で動作する踏み台となります</li><li>これがなければ到達不可能であるクラスターIPへ、クラスターの外部からのユーザーを接続します</li><li>apiserverのプロセス内で稼働します</li><li>クライアントからプロキシー間ではHTTPSを使用します(apiserverの設定により、HTTPを使用します)</li><li>プロキシーからターゲット間では利用可能な情報を使用して、プロキシーによって選択されたHTTPかHTTPSのいずれかを使用します</li><li>Node、Pod、Serviceへ到達するのに使えます</li><li>Serviceへ到達するときは負荷分散を行います</li></ul></li><li><p><a href=/ja/docs/concepts/services-networking/service/#ips-and-vips>kube proxy</a>:</p><ul><li>各ノード上で稼働します</li><li>UDP、TCP、SCTPをプロキシーします</li><li>HTTPを解釈しません</li><li>負荷分散機能を提供します</li><li>Serviceへ到達させるためのみに使用されます</li></ul></li><li><p>apiserverの前段にあるプロキシー/ロードバランサー:</p><ul><li>実際に存在するかどうかと実装はクラスターごとに異なります(例: nginx)</li><li>全てのクライアントと、1つ以上のapiserverの間に位置します</li><li>複数のapiserverがあるときロードバランサーとして稼働します</li></ul></li><li><p>外部サービス上で稼働するクラウドロードバランサー:</p><ul><li>いくつかのクラウドプロバイダーによって提供されます(例: AWS ELB、Google Cloud Load Balancer)</li><li><code>LoadBalancer</code>というtypeのKubernetes Serviceが作成されたときに自動で作成されます</li><li>たいていのクラウドロードバランサーはUDP/TCPのみサポートしています</li><li>SCTPのサポートはクラウドプロバイダーのロードバランサーの実装によって異なります</li><li>ロードバランサーの実装はクラウドプロバイダーによって異なります</li></ul></li></ol><p>Kubernetesユーザーのほとんどは、最初の2つのタイプ以外に心配する必要はありません。クラスター管理者はそれ以外のタイプのロードバランサーを正しくセットアップすることを保証します。</p><h2 id=リダイレクトの要求>リダイレクトの要求</h2><p>プロキシーはリダイレクトの機能を置き換えました。リダイレクトの使用は非推奨となります。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-85d633ae590aa20ec024f1b7af1d74fc>11.9 - アドオンのインストール</h1><div class="alert alert-secondary callout third-party-content" role=alert><strong>備考:</strong>
このセクションでは、Kubernetesが必要とする機能を提供するサードパーティープロジェクトにリンクしています。これらのプロジェクトはアルファベット順に記載されていて、Kubernetesプロジェクトの作者は責任を持ちません。このリストにプロジェクトを追加するには、変更を提出する前に<a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a>をお読みください。<a href=#third-party-content-disclaimer>詳細はこちら。</a></div><p>アドオンはKubernetesの機能を拡張するものです。</p><p>このページでは、利用可能なアドオンの一部の一覧と、それぞれのアドオンのインストール方法へのリンクを提供します。この一覧は、すべてを網羅するものではありません。</p><h2 id=networking-and-network-policy>ネットワークとネットワークポリシー</h2><ul><li><a href=https://www.github.com/noironetworks/aci-containers>ACI</a>は、統合されたコンテナネットワークとネットワークセキュリティをCisco ACIを使用して提供します。</li><li><a href=https://antrea.io/>Antrea</a>は、L3またはL4で動作して、Open vSwitchをネットワークデータプレーンとして活用する、Kubernetes向けのネットワークとセキュリティサービスを提供します。</li><li><a href=https://docs.projectcalico.org/latest/introduction/>Calico</a>はネットワークとネットワークポリシーのプロバイダーです。Calicoは、BGPを使用または未使用の非オーバーレイおよびオーバーレイネットワークを含む、フレキシブルなさまざまなネットワークオプションをサポートします。Calicoはホスト、Pod、そして(IstioとEnvoyを使用している場合には)サービスメッシュ上のアプリケーションに対してネットワークポリシーを強制するために、同一のエンジンを使用します。</li><li><a href=https://projectcalico.docs.tigera.io/getting-started/kubernetes/flannel/flannel>Canal</a>はFlannelとCalicoをあわせたもので、ネットワークとネットワークポリシーを提供します。</li><li><a href=https://github.com/cilium/cilium>Cilium</a>は、L3のネットワークとネットワークポリシーのプラグインで、HTTP/API/L7のポリシーを透過的に強制できます。ルーティングとoverlay/encapsulationモードの両方をサポートしており、他のCNIプラグイン上で機能できます。</li><li><a href=https://github.com/cni-genie/CNI-Genie>CNI-Genie</a>は、KubernetesをCalico、Canal、Flannel、Weaveなど選択したCNIプラグインをシームレスに接続できるようにするプラグインです。</li><li><a href=https://contivpp.io/>Contiv</a>は、さまざまなユースケースと豊富なポリシーフレームワーク向けに設定可能なネットワーク(BGPを使用したネイティブのL3、vxlanを使用したオーバーレイ、古典的なL2、Cisco-SDN/ACI)を提供します。Contivプロジェクトは完全に<a href=https://github.com/contiv>オープンソース</a>です。<a href=https://github.com/contiv/install>インストーラー</a>はkubeadmとkubeadm以外の両方をベースとしたインストールオプションがあります。</li><li><a href=https://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/>Contrail</a>は、<a href=https://tungsten.io>Tungsten Fabric</a>をベースにしている、オープンソースでマルチクラウドに対応したネットワーク仮想化およびポリシー管理プラットフォームです。ContrailおよびTungsten Fabricは、Kubernetes、OpenShift、OpenStack、Mesosなどのオーケストレーションシステムと統合されており、仮想マシン、コンテナ/Pod、ベアメタルのワークロードに隔離モードを提供します。</li><li><a href=https://github.com/flannel-io/flannel#deploying-flannel-manually>Flannel</a>は、Kubernetesで使用できるオーバーレイネットワークプロバイダーです。</li><li><a href=https://github.com/ZTE/Knitter/>Knitter</a>は、1つのKubernetes Podで複数のネットワークインターフェイスをサポートするためのプラグインです。</li><li><a href=https://github.com/k8snetworkplumbingwg/multus-cni>Multus</a>は、すべてのCNIプラグイン(たとえば、Calico、Cilium、Contiv、Flannel)に加えて、SRIOV、DPDK、OVS-DPDK、VPPをベースとするKubernetes上のワークロードをサポートする、複数のネットワークサポートのためのマルチプラグインです。</li><li><a href=https://github.com/ovn-org/ovn-kubernetes/>OVN-Kubernetes</a>は、Open vSwitch(OVS)プロジェクトから生まれた仮想ネットワーク実装である<a href=https://github.com/ovn-org/ovn/>OVN(Open Virtual Network)</a>をベースとする、Kubernetesのためのネットワークプロバイダーです。OVN-Kubernetesは、OVSベースのロードバランサーおよびネットワークポリシーの実装を含む、Kubernetes向けのオーバーレイベースのネットワーク実装を提供します。</li><li><a href=https://github.com/akraino-edge-stack/icn-nodus>Nodus</a>は、OVNベースのCNIコントローラープラグインで、クラウドネイティブベースのService function chaining(SFC)を提供します。</li><li><a href=https://docs.vmware.com/en/VMware-NSX-T-Data-Center/index.html>NSX-T</a> Container Plug-in(NCP)は、VMware NSX-TとKubernetesなどのコンテナオーケストレーター間のインテグレーションを提供します。また、NSX-Tと、Pivotal Container Service(PKS)とOpenShiftなどのコンテナベースのCaaS/PaaSプラットフォームとのインテグレーションも提供します。</li><li><a href=https://github.com/nuagenetworks/nuage-kubernetes/blob/v5.1.1-1/docs/kubernetes-1-installation.rst>Nuage</a>は、Kubernetes Podと非Kubernetes環境間で可視化とセキュリティモニタリングを使用してポリシーベースのネットワークを提供するSDNプラットフォームです。</li><li><a href=https://github.com/romana>Romana</a>は、<a href=/ja/docs/concepts/services-networking/network-policies/>NetworkPolicy</a> APIもサポートするPodネットワーク向けのL3のネットワークソリューションです。</li><li><a href=https://www.weave.works/docs/net/latest/kubernetes/kube-addon/>Weave Net</a>は、ネットワークパーティションの両面で機能し、外部データベースを必要とせずに、ネットワークとネットワークポリシーを提供します。</li></ul><h2 id=service-discovery>サービスディスカバリー</h2><ul><li><a href=https://coredns.io>CoreDNS</a>は、フレキシブルで拡張可能なDNSサーバーです。Pod向けのクラスター内DNSとして<a href=https://github.com/coredns/deployment/tree/master/kubernetes>インストール</a>できます。</li></ul><h2 id=visualization-amp-control>可視化と制御</h2><ul><li><a href=https://github.com/kubernetes/dashboard#kubernetes-dashboard>Dashboard</a>はKubernetes向けのダッシュボードを提供するウェブインターフェイスです。</li><li><a href=https://www.weave.works/documentation/scope-latest-installing/#k8s>Weave Scope</a>は、コンテナ、Pod、Serviceなどをグラフィカルに可視化するツールです。<a href=https://cloud.weave.works/>Weave Cloud account</a>と組み合わせて使うか、UIを自分でホストして使います。</li></ul><h2 id=infrastructure>インフラストラクチャ</h2><ul><li><a href=https://kubevirt.io/user-guide/#/installation/installation>KubeVirt</a>は仮想マシンをKubernetes上で実行するためのアドオンです。通常、ベアメタルのクラスタで実行します。</li><li><a href=https://github.com/kubernetes/node-problem-detector>node problem detector</a>はLinuxノード上で動作し、システムの問題を<a href=/docs/reference/kubernetes-api/cluster-resources/event-v1/>Event</a>または<a href=/ja/docs/concepts/architecture/nodes/#condition>ノードのCondition</a>として報告します。</li></ul><h2 id=legacy-add-ons>レガシーなアドオン</h2><p>いくつかのアドオンは、廃止された<a href=https://git.k8s.io/kubernetes/cluster/addons>cluster/addons</a>ディレクトリに掲載されています。</p><p>よくメンテナンスされたアドオンはここにリンクしてください。PRを歓迎しています。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-7e0d97616b15e2c383c6a0a96ec442cb>12 - Kubernetesを拡張する</h1><div class=lead>Kubernetesクラスターの挙動を変えるいろいろな方法</div><p>Kubernetesは柔軟な設定が可能で、高い拡張性を持っています。
結果として、Kubernetesのプロジェクトソースコードをフォークしたり、パッチを当てて利用することは滅多にありません。
このガイドは、Kubernetesクラスターをカスタマイズするための選択肢を記載します。
管理しているKubernetesクラスターを、動作環境の要件にどのように適合させるべきかを理解したい<a class=glossary-tooltip title=クラスターを設定、管理そして、監視する人 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-cluster-operator' target=_blank aria-label=クラスター管理者>クラスター管理者</a>を対象にしています。
将来の <a class=glossary-tooltip title=自身のプロジェクトの要件に合わせ、Kubernetesプラットフォームをカスタマイズする人 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-platform-developer' target=_blank aria-label=プラットフォーム開発者>プラットフォーム開発者</a> 、またはKubernetesプロジェクトの<a class=glossary-tooltip title=Kubernetesプロジェクトやコミュニティのために、コード、ドキュメント、またはその他の作業に自身の時間を使って貢献している人々 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-contributor' target=_blank aria-label=コントリビューター>コントリビューター</a>にとっても、どのような拡張のポイントやパターンが存在するのか、また、それぞれのトレードオフや制限事項を学ぶための導入として役立つでしょう。</p><h2 id=概要>概要</h2><p>カスタマイズのアプローチには大きく分けて、フラグ、ローカル設定ファイル、またはAPIリソースの変更のみを含んだ <em>設定</em> と、稼働しているプログラムまたはサービスも含んだ <em>拡張</em> があります。このドキュメントでは、主に拡張について説明します。</p><h2 id=設定>設定</h2><p><em>設定ファイル</em> と <em>フラグ</em> はオンラインドキュメントのリファレンスセクションの中の、各項目に記載されています:</p><ul><li><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a>.</li></ul><p>ホスティングされたKubernetesサービスやマネージドなKubernetesでは、フラグと設定ファイルが常に変更できるとは限りません。変更可能な場合でも、通常はクラスターの管理者のみが変更できます。また、それらは将来のKubernetesバージョンで変更される可能性があり、設定変更にはプロセスの再起動が必要になるかもしれません。これらの理由により、この方法は他の選択肢が無いときにのみ利用するべきです。</p><p><a href=/ja/docs/concepts/policy/resource-quotas/>ResourceQuota</a>、<a href=/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>、<a href=/ja/docs/concepts/services-networking/network-policies/>NetworkPolicy</a>、そしてロールベースアクセス制御(<a href=/ja/docs/reference/access-authn-authz/rbac/>RBAC</a>)といった <em>ビルトインポリシーAPI</em> は、ビルトインのKubernetes APIです。APIは通常、ホスティングされたKubernetesサービスやマネージドなKubernetesで利用されます。これらは宣言的で、Podのような他のKubernetesリソースと同じ慣例に従っています。そのため、新しいクラスターの設定は繰り返し再利用することができ、アプリケーションと同じように管理することが可能です。さらに、安定版(stable)を利用している場合、他のKubernetes APIのような<a href=/docs/reference/deprecation-policy/>定義済みのサポートポリシー</a>を利用することができます。これらの理由により、この方法は、適切な用途の場合、 <em>設定ファイル</em> や <em>フラグ</em> よりも好まれます。</p><h2 id=拡張>拡張</h2><p>拡張はKubernetesを拡張し、深く統合されたソフトウェアの構成要素です。
これは新しいタイプと、新しい種類のハードウェアをサポートするために利用されます。</p><p>ほとんどのクラスター管理者は、ホスティングされている、またはディストリビューションとしてのKubernetesを使っているでしょう。
結果として、ほとんどのKubernetesユーザーは既存の拡張を使えばよいため、新しい拡張を書く必要は無いと言えます。</p><h2 id=extension-patterns>拡張パターン</h2><p>Kubernetesは、クライアントのプログラムを書くことで自動化ができるようにデザインされています。
Kubernetes APIに読み書きをするどのようなプログラムも、役に立つ自動化機能を提供することができます。
<em>自動化機能</em> はクラスター上、またはクラスター外で実行できます。
このドキュメントに後述のガイダンスに従うことで、高い可用性を持つ頑強な自動化機能を書くことができます。
自動化機能は通常、ホスティングされているクラスター、マネージドな環境など、どのKubernetesクラスター上でも動きます。</p><p>Kubernetes上でうまく動くクライアントプログラムを書くために、<em>コントローラー</em> パターンという明確なパターンがあります。
コントローラーは通常、オブジェクトの <code>.spec</code> を読み取り、何らかの処理をして、オブジェクトの <code>.status</code> を更新します。</p><p>コントローラーはKubernetesのクライアントです。Kubernetesがクライアントとして動き、外部のサービスを呼び出す場合、それは <em>Webhook</em> と呼ばれます。
呼び出されるサービスは <em>Webhookバックエンド</em> と呼ばれます。コントローラーのように、Webhookも障害点を追加します。</p><p>Webhookのモデルでは、Kubernetesは外部のサービスを呼び出します。
<em>バイナリプラグイン</em> モデルでは、Kubernetesはバイナリ(プログラム)を実行します。
バイナリプラグインはkubelet(例、<a href=/docs/concepts/storage/volumes/#flexVolume>FlexVolumeプラグイン</a>、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>)、またkubectlで利用されています。</p><p>下図は、それぞれの拡張ポイントが、Kubernetesのコントロールプレーンとどのように関わっているかを示しています。</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vQBRWyXLVUlQPlp7BvxvV9S1mxyXSM6rAc_cbLANvKlu6kCCf-kGTporTMIeG5GZtUdxXz1xowN7RmL/pub?w=960&h=720"><h2 id=拡張ポイント>拡張ポイント</h2><p>この図は、Kubernetesにおける拡張ポイントを示しています。</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vSH5ZWUO2jH9f34YHenhnCd14baEb4vT-pzfxeFC7NzdNqRDgdz4DDAVqArtH4onOGqh0bhwMX0zGBb/pub?w=425&h=809"><ol><li>ユーザーは頻繁に<code>kubectl</code>を使って、Kubernetes APIとやり取りをします。<a href=/docs/tasks/extend-kubectl/kubectl-plugins/>Kubectlプラグイン</a>は、kubectlのバイナリを拡張します。これは個別ユーザーのローカル環境のみに影響を及ぼすため、サイト全体にポリシーを強制することはできません。</li><li>APIサーバーは全てのリクエストを処理します。APIサーバーのいくつかの拡張ポイントは、リクエストを認可する、コンテキストに基づいてブロックする、リクエストを編集する、そして削除を処理することを可能にします。これらは<a href=/docs/concepts/extend-kubernetes/#api-access-extensions>APIアクセス拡張</a>セクションに記載されています。</li><li>APIサーバーは様々な種類の <em>リソース</em> を扱います。<code>Pod</code>のような <em>ビルトインリソース</em> はKubernetesプロジェクトにより定義され、変更できません。ユーザーも、自身もしくは、他のプロジェクトで定義されたリソースを追加することができます。それは <em>カスタムリソース</em> と呼ばれ、<a href=/docs/concepts/extend-kubernetes/#user-defined-types>カスタムリソース</a>セクションに記載されています。カスタムリソースは度々、APIアクセス拡張と一緒に使われます。</li><li>KubernetesのスケジューラーはPodをどのノードに配置するかを決定します。スケジューリングを拡張するには、いくつかの方法があります。それらは<a href=/docs/concepts/extend-kubernetes/#scheduler-extensions>スケジューラー拡張</a>セクションに記載されています。</li><li>Kubernetesにおける多くの振る舞いは、APIサーバーのクライアントであるコントローラーと呼ばれるプログラムに実装されています。コントローラーは度々、カスタムリソースと共に使われます。</li><li>kubeletはサーバー上で実行され、Podが仮想サーバーのようにクラスターネットワーク上にIPを持った状態で起動することをサポートします。<a href=/docs/concepts/extend-kubernetes/#network-plugins>ネットワークプラグイン</a>がPodのネットワーキングにおける異なる実装を適用することを可能にします。</li><li>kubeletはまた、コンテナのためにボリュームをマウント、アンマウントします。新しい種類のストレージは<a href=/docs/concepts/extend-kubernetes/#storage-plugins>ストレージプラグイン</a>を通じてサポートされます。</li></ol><p>もしあなたがどこから始めるべきかわからない場合、このフローチャートが役立つでしょう。一部のソリューションは、いくつかの種類の拡張を含んでいることを留意してください。</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vRWXNNIVWFDqzDY0CsKZJY3AR8sDeFDXItdc5awYxVH8s0OLherMlEPVUpxPIB1CSUu7GPk7B2fEnzM/pub?w=1440&h=1080"><h2 id=api拡張>API拡張</h2><h3 id=ユーザー定義タイプ>ユーザー定義タイプ</h3><p>新しいコントローラー、アプリケーションの設定に関するオブジェクト、また宣言型APIを定義し、それらを<code>kubectl</code>のようなKubernetesのツールから管理したい場合、Kubernetesにカスタムリソースを追加することを検討して下さい。</p><p>カスタムリソースはアプリケーション、ユーザー、監視データのデータストレージとしては使わないで下さい。</p><p>カスタムリソースに関するさらなる情報は、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソースコンセプトガイド</a>を参照して下さい。</p><h3 id=新しいapiと自動化機能の連携>新しいAPIと自動化機能の連携</h3><p>カスタムリソースAPIと制御ループの組み合わせは<a href=/ja/docs/concepts/extend-kubernetes/operator/>オペレーターパターン</a>と呼ばれています。オペレーターパターンは、通常ステートフルな特定のアプリケーションを管理するために利用されます。これらのカスタムAPIと制御ループは、ストレージ、またはポリシーのような他のリソースを管理するためにも利用されます。</p><h3 id=ビルトインリソースの変更>ビルトインリソースの変更</h3><p>カスタムリソースを追加し、KubernetesAPIを拡張する場合、新たに追加されたリソースは常に新しいAPIグループに分類されます。既存のAPIグループを置き換えたり、変更することはできません。APIを追加することは直接、既存のAPI(例、Pod)の振る舞いに影響を与えることは無いですが、APIアクセス拡張の場合、その可能性があります。</p><h3 id=api-access-extensions>APIアクセス拡張</h3><p>リクエストがKubernetes APIサーバーに到達すると、まず最初に認証が行われ、次に認可、その後、様々なAdmission Controlの対象になります。このフローの詳細は<a href=/docs/concepts/security/controlling-access/>Kubernetes APIへのアクセスをコントロールする</a>を参照して下さい。</p><p>これらの各ステップごとに拡張ポイントが用意されています。</p><p>Kubdernetesはいくつかのビルトイン認証方式をサポートしています。それは認証プロキシの後ろに配置することも可能で、認可ヘッダーを通じて(Webhookの)検証のために外部サービスにトークンを送ることもできます。全てのこれらの方法は<a href=/ja/docs/reference/access-authn-authz/authentication/>認証ドキュメント</a>でカバーされています。</p><h3 id=認証>認証</h3><p><a href=/ja/docs/reference/access-authn-authz/authentication/>認証</a>は、全てのリクエストのヘッダーまたは証明書情報を、リクエストを投げたクライアントのユーザー名にマッピングします。</p><p>Kubernetesはいくつかのビルトイン認証方式と、それらが要件に合わない場合、<a href=/ja/docs/reference/access-authn-authz/authentication/#webhook-token-authentication>認証Webhook</a>を提供します。</p><h3 id=認可>認可</h3><p><a href=/docs/reference/access-authn-authz/webhook/>認可</a>は特定のユーザーがAPIリソースに対して、読み込み、書き込み、そしてその他の操作が可能かどうかを決定します。それはオブジェクト全体のレベルで機能し、任意のオブジェクトフィールドに基づいての区別は行いません。もしビルトインの認可メカニズムが要件に合わない場合、<a href=/docs/reference/access-authn-authz/webhook/>認可Webhook</a>が、ユーザー提供のコードを呼び出し認可の決定を行うことを可能にします。</p><h3 id=動的admission-control>動的Admission Control</h3><p>リクエストが認可された後、もしそれが書き込み操作だった場合、リクエストは<a href=/docs/reference/access-authn-authz/admission-controllers/>Admission Control</a>のステップを通ります。ビルトインのステップに加え、いくつかの拡張が存在します:</p><ul><li><a href=/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook>イメージポリシーWebhook</a>は、コンテナでどのイメージを実行することができるかを制限する</li><li>任意のAdmission Controlの決定を行うには、一般的な<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Admission webhook</a>が利用できる。Admission Webhookは作成、更新を拒絶できる</li></ul><h2 id=インフラストラクチャ拡張>インフラストラクチャ拡張</h2><h3 id=ストレージプラグイン>ストレージプラグイン</h3><p><a href=/docs/concepts/storage/volumes/#flexVolume>Flex Volumes</a>は、Kubeletがバイナリプラグインを呼び出してボリュームをマウントすることにより、ユーザーはビルトインのサポートなしでボリュームタイプをマウントすることを可能にします。</p><h3 id=デバイスプラグイン>デバイスプラグイン</h3><p><a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a>を通じて、ノードが新たなノードのリソース(CPU、メモリなどのビルトインのものに加え)を見つけることを可能にします。</p><h3 id=ネットワークプラグイン>ネットワークプラグイン</h3><p>他のネットワークファブリックが<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>を通じてサポートされます。</p><h3 id=スケジューラー拡張>スケジューラー拡張</h3><p>スケジューラーは特別な種類のコントローラーで、Podを監視し、Podをノードに割り当てます。デフォルトのコントローラーを完全に置き換えることもできますが、他のKubernetesのコンポーネントの利用を継続する、または<a href=/docs/tasks/extend-kubernetes/configure-multiple-schedulers/>複数のスケジューラー</a>を同時に動かすこともできます。</p><p>これはかなりの大きな作業で、ほとんど全てのKubernetesユーザーはスケジューラーを変更する必要はありません。</p><p>スケジューラは<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/scheduler_extender.md>Webhook</a>もサポートしており、Webhookバックエンド(スケジューラー拡張)を通じてPodを配置するために選択されたノードをフィルタリング、優先度付けすることが可能です。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>についてより深く学ぶ</li><li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>動的Admission control</a>について学ぶ</li><li>インフラストラクチャ拡張についてより深く学ぶ<ul><li><a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a></li><li><a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a></li></ul></li><li><a href=/docs/tasks/extend-kubectl/kubectl-plugins/>kubectlプラグイン</a>について学ぶ</li><li><a href=/ja/docs/concepts/extend-kubernetes/operator/>オペレーターパターン</a>について学ぶ</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5c2b36cd0ddbe006b575d4e54c63d508>12.1 - Kubernetesクラスターの拡張</h1><p>Kubernetesは柔軟な設定が可能で、高い拡張性を持っています。
結果として、Kubernetesのプロジェクトソースコードをフォークしたり、パッチを当てて利用することは滅多にありません。</p><p>このガイドは、Kubernetesクラスターをカスタマイズするための選択肢を記載します。
管理しているKubernetesクラスターを、動作環境の要件にどのように適合させるべきかを理解したい<a class=glossary-tooltip title=クラスターを設定、管理そして、監視する人 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-cluster-operator' target=_blank aria-label=クラスター管理者>クラスター管理者</a>を対象にしています。
将来の <a class=glossary-tooltip title=自身のプロジェクトの要件に合わせ、Kubernetesプラットフォームをカスタマイズする人 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-platform-developer' target=_blank aria-label=プラットフォーム開発者>プラットフォーム開発者</a> 、またはKubernetesプロジェクトの<a class=glossary-tooltip title=Kubernetesプロジェクトやコミュニティのために、コード、ドキュメント、またはその他の作業に自身の時間を使って貢献している人々 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-contributor' target=_blank aria-label=コントリビューター>コントリビューター</a>にとっても、どのような拡張のポイントやパターンが存在するのか、また、それぞれのトレードオフや制限事項を学ぶための導入として役立つでしょう。</p><h2 id=概要>概要</h2><p>カスタマイズのアプローチには大きく分けて、フラグ、ローカル設定ファイル、またはAPIリソースの変更のみを含んだ <em>コンフィグレーション</em> と、稼働しているプログラムまたはサービスも含んだ <em>エクステンション</em> があります。このドキュメントでは、主にエクステンションについて説明します。</p><h2 id=コンフィグレーション>コンフィグレーション</h2><p><em>設定ファイル</em> と <em>フラグ</em> はオンラインドキュメントのリファレンスセクションの中の、各項目に記載されています:</p><ul><li><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a></li></ul><p>ホスティングされたKubernetesサービスやマネージドなKubernetesでは、フラグと設定ファイルが常に変更できるとは限りません。変更可能な場合でも、通常はクラスターの管理者のみが変更できます。また、それらは将来のKubernetesバージョンで変更される可能性があり、設定変更にはプロセスの再起動が必要になるかもしれません。これらの理由により、この方法は他の選択肢が無いときにのみ利用するべきです。</p><p><a href=/ja/docs/concepts/policy/resource-quotas/>ResourceQuota</a>、<a href=/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>、<a href=/docs/concepts/services-networking/network-policies/>NetworkPolicy</a>、そしてロールベースアクセス制御(<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>)といった <em>ビルトインポリシーAPI</em> は、ビルトインのKubernetes APIです。APIは通常、ホスティングされたKubernetesサービスやマネージドなKubernetesで利用されます。これらは宣言的で、Podのような他のKubernetesリソースと同じ慣例に従っています。そのため、新しいクラスターの設定は繰り返し再利用することができ、アプリケーションと同じように管理することが可能です。さらに、安定版(stable)を利用している場合、他のKubernetes APIのような<a href=/docs/reference/using-api/deprecation-policy/>定義済みのサポートポリシー</a>を利用することができます。これらの理由により、この方法は、適切な用途の場合、 <em>設定ファイル</em> や <em>フラグ</em> よりも好まれます。</p><h2 id=エクステンション>エクステンション</h2><p>エクステンションはKubernetesを拡張し、深く統合されたソフトウェアの構成要素です。
これは新しいタイプと、新しい種類のハードウェアをサポートするために利用されます。</p><p>ほとんどのクラスター管理者は、ホスティングされている、またはディストリビューションとしてのKubernetesを使っているでしょう。
結果として、ほとんどのKubernetesユーザーは既存のエクステンションを使えばよいため、新しいエクステンションを書く必要は無いと言えます。</p><h2 id=extension-patterns>エクステンションパターン</h2><p>Kubernetesは、クライアントのプログラムを書くことで自動化ができるようにデザインされています。
Kubernetes APIに読み書きをするどのようなプログラムも、役に立つ自動化機能を提供することができます。
<em>自動化機能</em> はクラスター上、またはクラスター外で実行できます。
このドキュメントに後述のガイダンスに従うことで、高い可用性を持つ頑強な自動化機能を書くことができます。
自動化機能は通常、ホスティングされているクラスター、マネージドな環境など、どのKubernetesクラスター上でも動きます。</p><p>Kubernetes上でうまく動くクライアントプログラムを書くために、<em>コントローラー</em> パターンという明確なパターンがあります。
コントローラーは通常、オブジェクトの <code>.spec</code> を読み取り、何らかの処理をして、オブジェクトの <code>.status</code> を更新します。</p><p>コントローラーはKubernetesのクライアントです。Kubernetesがクライアントとして動き、外部のサービスを呼び出す場合、それは <em>Webhook</em> と呼ばれます。
呼び出されるサービスは <em>Webhookバックエンド</em> と呼ばれます。コントローラーのように、Webhookも障害点を追加します。</p><p>Webhookのモデルでは、Kubernetesは外部のサービスを呼び出します。
<em>バイナリプラグイン</em> モデルでは、Kubernetesはバイナリ(プログラム)を実行します。
バイナリプラグインはkubelet(例、<a href=/docs/concepts/storage/volumes/#flexvolume>FlexVolumeプラグイン</a>、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>)、またkubectlで利用されています。</p><p>下図は、それぞれの拡張ポイントが、Kubernetesのコントロールプレーンとどのように関わっているかを示しています。</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vQBRWyXLVUlQPlp7BvxvV9S1mxyXSM6rAc_cbLANvKlu6kCCf-kGTporTMIeG5GZtUdxXz1xowN7RmL/pub?w=960&h=720"><h2 id=拡張ポイント>拡張ポイント</h2><p>この図は、Kubernetesにおける拡張ポイントを示しています。</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vSH5ZWUO2jH9f34YHenhnCd14baEb4vT-pzfxeFC7NzdNqRDgdz4DDAVqArtH4onOGqh0bhwMX0zGBb/pub?w=425&h=809"><ol><li>ユーザーは頻繁に<code>kubectl</code>を使って、Kubernetes APIとやり取りをします。<a href=/docs/tasks/extend-kubectl/kubectl-plugins/>Kubectlプラグイン</a>は、kubectlのバイナリを拡張します。これは個別ユーザーのローカル環境のみに影響を及ぼすため、サイト全体にポリシーを強制することはできません。</li><li>APIサーバーは全てのリクエストを処理します。APIサーバーのいくつかの拡張ポイントは、リクエストを認可する、コンテキストに基づいてブロックする、リクエストを編集する、そして削除を処理することを可能にします。これらは<a href=/ja/docs/concepts/extend-kubernetes/#api-access-extensions>APIアクセスエクステンション</a>セクションに記載されています。</li><li>APIサーバーは様々な種類の <em>リソース</em> を扱います。<code>Pod</code>のような <em>ビルトインリソース</em> はKubernetesプロジェクトにより定義され、変更できません。ユーザーも、自身もしくは、他のプロジェクトで定義されたリソースを追加することができます。それは <em>カスタムリソース</em> と呼ばれ、<a href=/ja/docs/concepts/extend-kubernetes/#user-defined-types>カスタムリソース</a>セクションに記載されています。カスタムリソースは度々、APIアクセスエクステンションと一緒に使われます。</li><li>KubernetesのスケジューラーはPodをどのノードに配置するかを決定します。スケジューリングを拡張するには、いくつかの方法があります。それらは<a href=/ja/docs/concepts/extend-kubernetes/#scheduler-extensions>スケジューラーエクステンション</a>セクションに記載されています。</li><li>Kubernetesにおける多くの振る舞いは、APIサーバーのクライアントであるコントローラーと呼ばれるプログラムに実装されています。コントローラーは度々、カスタムリソースと共に使われます。</li><li>kubeletはサーバー上で実行され、Podが仮想サーバーのようにクラスターネットワーク上にIPを持った状態で起動することをサポートします。<a href=/ja/docs/concepts/extend-kubernetes/#network-plugins>ネットワークプラグイン</a>がPodのネットワーキングにおける異なる実装を適用することを可能にします。</li><li>kubeletはまた、コンテナのためにボリュームをマウント、アンマウントします。新しい種類のストレージは<a href=/ja/docs/concepts/extend-kubernetes/#storage-plugins>ストレージプラグイン</a>を通じてサポートされます。</li></ol><p>もしあなたがどこから始めるべきかわからない場合、このフローチャートが役立つでしょう。一部のソリューションは、いくつかの種類のエクステンションを含んでいることを留意してください。</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vRWXNNIVWFDqzDY0CsKZJY3AR8sDeFDXItdc5awYxVH8s0OLherMlEPVUpxPIB1CSUu7GPk7B2fEnzM/pub?w=1440&h=1080"><h2 id=apiエクステンション>APIエクステンション</h2><h3 id=ユーザー定義タイプ>ユーザー定義タイプ</h3><p>新しいコントローラー、アプリケーションの設定に関するオブジェクト、また宣言型APIを定義し、それらを<code>kubectl</code>のようなKubernetesのツールから管理したい場合、Kubernetesにカスタムリソースを追加することを検討して下さい。</p><p>カスタムリソースはアプリケーション、ユーザー、監視データのデータストレージとしては使わないで下さい。</p><p>カスタムリソースに関するさらなる情報は、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソースコンセプトガイド</a>を参照して下さい。</p><h3 id=新しいapiと自動化機能の連携>新しいAPIと自動化機能の連携</h3><p>カスタムリソースAPIと制御ループの組み合わせは<a href=/ja/docs/concepts/extend-kubernetes/operator/>オペレーターパターン</a>と呼ばれています。オペレーターパターンは、通常ステートフルな特定のアプリケーションを管理するために利用されます。これらのカスタムAPIと制御ループは、ストレージ、またはポリシーのような他のリソースを管理するためにも利用されます。</p><h3 id=ビルトインリソースの変更>ビルトインリソースの変更</h3><p>カスタムリソースを追加し、KubernetesAPIを拡張する場合、新たに追加されたリソースは常に新しいAPIグループに分類されます。既存のAPIグループを置き換えたり、変更することはできません。APIを追加することは直接、既存のAPI(例、Pod)の振る舞いに影響を与えることは無いですが、APIアクセスエクステンションの場合、その可能性があります。</p><h3 id=apiアクセスエクステンション>APIアクセスエクステンション</h3><p>リクエストがKubernetes APIサーバーに到達すると、まず最初に認証が行われ、次に認可、その後、様々なAdmission Controlの対象になります。このフローの詳細は<a href=/docs/concepts/security/controlling-access/>Kubernetes APIへのアクセスをコントロールする</a>を参照して下さい。</p><p>これらの各ステップごとに拡張ポイントが用意されています。</p><p>Kubdernetesはいくつかのビルトイン認証方式をサポートしています。それは認証プロキシの後ろに配置することも可能で、認可ヘッダーを通じて(Webhookの)検証のために外部サービスにトークンを送ることもできます。全てのこれらの方法は<a href=/ja/docs/reference/access-authn-authz/authentication/>認証ドキュメント</a>でカバーされています。</p><h3 id=認証>認証</h3><p><a href=/ja/docs/reference/access-authn-authz/authentication/>認証</a>は、全てのリクエストのヘッダーまたは証明書情報を、リクエストを投げたクライアントのユーザー名にマッピングします。</p><p>Kubernetesはいくつかのビルトイン認証方式と、それらが要件に合わない場合、<a href=/docs/reference/access-authn-authz/authentication/#webhook-token-authentication>認証Webhook</a>を提供します。</p><h3 id=認可>認可</h3><p><a href=/docs/reference/access-authn-authz/webhook/>認可</a>は特定のユーザーがAPIリソースに対して、読み込み、書き込み、そしてその他の操作が可能かどうかを決定します。それはオブジェクト全体のレベルで機能し、任意のオブジェクトフィールドに基づいての区別は行いません。もしビルトインの認可メカニズムが要件に合わない場合、<a href=/docs/reference/access-authn-authz/webhook/>認可Webhook</a>が、ユーザー提供のコードを呼び出し認可の決定を行うことを可能にします。</p><h3 id=動的admission-control>動的Admission Control</h3><p>リクエストが認可された後、もしそれが書き込み操作だった場合、リクエストは<a href=/docs/reference/access-authn-authz/admission-controllers/>Admission Control</a>のステップを通ります。ビルトインのステップに加え、いくつかのエクステンションが存在します:</p><ul><li><a href=/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook>イメージポリシーWebhook</a>は、コンテナでどのイメージを実行することができるかを制限する</li><li>任意のAdmission Controlの決定を行うには、一般的な<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Admission webhook</a>が利用できる。Admission Webhookは作成、更新を拒絶できる</li></ul><h2 id=インフラストラクチャエクステンション>インフラストラクチャエクステンション</h2><h3 id=ストレージプラグイン>ストレージプラグイン</h3><p><a href=/docs/concepts/storage/volumes/#flexvolume>Flex Volumes</a>は、Kubeletがバイナリプラグインを呼び出してボリュームをマウントすることにより、ユーザーはビルトインのサポートなしでボリュームタイプをマウントすることを可能にします。</p><h3 id=デバイスプラグイン>デバイスプラグイン</h3><p><a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a>を通じて、ノードが新たなノードのリソース(CPU、メモリなどのビルトインのものに加え)を見つけることを可能にします。</p><h3 id=ネットワークプラグイン>ネットワークプラグイン</h3><p>他のネットワークファブリックが<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>を通じてサポートされます。</p><h3 id=スケジューラーエクステンション>スケジューラーエクステンション</h3><p>スケジューラーは特別な種類のコントローラーで、Podを監視し、Podをノードに割り当てます。デフォルトのコントローラーを完全に置き換えることもできますが、他のKubernetesのコンポーネントの利用を継続する、または<a href=/docs/tasks/extend-kubernetes/configure-multiple-schedulers/>複数のスケジューラー</a>を同時に動かすこともできます。</p><p>これはかなりの大きな作業で、ほとんど全てのKubernetesユーザーはスケジューラーを変更する必要はありません。</p><p>スケジューラは<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/scheduler_extender.md>Webhook</a>もサポートしており、Webhookバックエンド(スケジューラーエクステンション)を通じてPodを配置するために選択されたノードをフィルタリング、優先度付けすることが可能です。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>についてより深く学ぶ</li><li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>動的Admission control</a>について学ぶ</li><li>インフラストラクチャエクステンションについてより深く学ぶ<ul><li><a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a></li><li><a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a></li></ul></li><li><a href=/docs/tasks/extend-kubectl/kubectl-plugins/>kubectlプラグイン</a>について学ぶ</li><li><a href=/docs/concepts/extend-kubernetes/operator/>オペレーターパターン</a>について学ぶ</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0af41d3bd7c785621b58b7564793396a>12.2 - Kubernetes APIの拡張</h1></div><div class=td-content><h1 id=pg-342388440304e19ce30c0f8ada1c77ce>12.2.1 - カスタムリソース</h1><p><em>カスタムリソース</em> はKubernetes APIの拡張です。このページでは、いつKubernetesのクラスターにカスタムリソースを追加するべきなのか、そしていつスタンドアローンのサービスを利用するべきなのかを議論します。カスタムリソースを追加する2つの方法と、それらの選択方法について説明します。</p><h2 id=カスタムリソース>カスタムリソース</h2><p><em>リソース</em> は、<a href=/ja/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>のエンドポイントで、特定の<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/>APIオブジェクト</a>のコレクションを保持します。例えば、ビルトインの <em>Pods</em> リソースは、Podオブジェクトのコレクションを包含しています。</p><p><em>カスタムリソース</em> は、Kubernetes APIの拡張で、デフォルトのKubernetesインストールでは、必ずしも利用できるとは限りません。つまりそれは、特定のKubernetesインストールのカスタマイズを表します。しかし、今現在、多数のKubernetesのコア機能は、カスタムリソースを用いて作られており、Kubernetesをモジュール化しています。</p><p>カスタムリソースは、稼働しているクラスターに動的に登録され、現れたり、消えたりし、クラスター管理者はクラスター自体とは無関係にカスタムリソースを更新できます。一度、カスタムリソースがインストールされると、ユーザーは<a href=/ja/docs/reference/kubectl/overview/>kubectl</a>を使い、ビルトインのリソースである <em>Pods</em> と同じように、オブジェクトを作成、アクセスすることが可能です。</p><h2 id=カスタムコントローラー>カスタムコントローラー</h2><p>カスタムリソースそれ自身は、単純に構造化データを格納、取り出す機能を提供します。カスタムリソースを <em>カスタムコントローラー</em> と組み合わせることで、カスタムリソースは真の <em>宣言的API</em> を提供します。</p><p><a href=/ja/docs/concepts/overview/kubernetes-api/>宣言的API</a>は、リソースのあるべき状態を <em>宣言</em> または指定することを可能にし、Kubernetesオブジェクトの現在の状態を、あるべき状態に同期し続けるように動きます。
コントローラーは、構造化データをユーザーが指定したあるべき状態と解釈し、その状態を管理し続けます。</p><p>稼働しているクラスターのライフサイクルとは無関係に、カスタムコントローラーをデプロイ、更新することが可能です。カスタムコントローラーはあらゆるリソースと連携できますが、カスタムリソースと組み合わせると特に効果を発揮します。<a href=https://coreos.com/blog/introducing-operators.html>オペレーターパターン</a>は、カスタムリソースとカスタムコントローラーの組み合わせです。カスタムコントローラーにより、特定アプリケーションのドメイン知識を、Kubernetes APIの拡張に変換することができます。</p><h2 id=カスタムリソースをクラスターに追加するべきか>カスタムリソースをクラスターに追加するべきか？</h2><p>新しいAPIを作る場合、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIをKubernetesクラスターAPIにアグリゲート(集約)する</a>か、もしくはAPIをスタンドアローンで動かすかを検討します。</p><table><thead><tr><th>APIアグリゲーションを使う場合:</th><th>スタンドアローンAPIを使う場合:</th></tr></thead><tbody><tr><td>APIが<a href=#%E5%AE%A3%E8%A8%80%E7%9A%84API>宣言的</a></td><td>APIが<a href=#%E5%AE%A3%E8%A8%80%E7%9A%84API>宣言的</a>モデルに適さない</td></tr><tr><td>新しいリソースを<code>kubectl</code>を使い読み込み、書き込みしたい</td><td><code>kubectl</code>のサポートは必要ない</td></tr><tr><td>新しいリソースをダッシュボードのような、Kubernetes UIで他のビルトインリソースと同じように管理したい</td><td>Kubernetes UIのサポートは必要ない</td></tr><tr><td>新しいAPIを開発している</td><td>APIを提供し、適切に機能するプログラムが既に存在している</td></tr><tr><td>APIグループ、名前空間というような、RESTリソースパスに割り当てられた、Kubernetesのフォーマット仕様の制限を許容できる(<a href=/ja/docs/concepts/overview/kubernetes-api/>API概要</a>を参照)</td><td>既に定義済みのREST APIと互換性を持っていなければならない</td></tr><tr><td>リソースはクラスターごとか、クラスター内の名前空間に自然に分けることができる</td><td>クラスター、または名前空間による分割がリソース管理に適さない。特定のリソースパスに基づいて管理したい</td></tr><tr><td><a href=#%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E6%A9%9F%E8%83%BD>Kubernetes APIサポート機能</a>を再利用したい</td><td>これらの機能は必要ない</td></tr></tbody></table><h3 id=宣言的api>宣言的API</h3><p>宣言的APIは、通常、下記に該当します:</p><ul><li>APIは、比較的少数の、比較的小さなオブジェクト(リソース)で構成されている</li><li>オブジェクトは、アプリケーションの設定、インフラストラクチャーを定義する</li><li>オブジェクトは、比較的更新頻度が低い</li><li>人は、オブジェクトの情報をよく読み書きする</li><li>オブジェクトに対する主要な手続きは、CRUD(作成、読み込み、更新、削除)になる</li><li>複数オブジェクトをまたいだトランザクションは必要ない: APIは今現在の状態ではなく、あるべき状態を表現する</li></ul><p>命令的APIは、宣言的ではありません。
APIが宣言的ではない兆候として、次のものがあります:</p><ul><li>クライアントから"これを実行"と命令がきて、完了の返答を同期的に受け取る</li><li>クライアントから"これを実行"と命令がきて、処理IDを取得する。そして処理が完了したかどうかを、処理IDを利用して別途問い合わせる</li><li>リモートプロシージャコール(RPC)という言葉が飛び交っている</li><li>直接、大量のデータを格納している(例、1オブジェクトあたり数kBより大きい、または数千オブジェクトより多い)</li><li>高帯域アクセス(持続的に毎秒数十リクエスト)が必要</li><li>エンドユーザーのデータ(画像、PII、その他)を格納している、またはアプリケーションが処理する大量のデータを格納している</li><li>オブジェクトに対する処理が、CRUDではない</li><li>APIをオブジェクトとして簡単に表現できない</li><li>停止している処理を処理ID、もしくは処理オブジェクトで表現することを選択している</li></ul><h2 id=configmapとカスタムリソースのどちらを使うべきか>ConfigMapとカスタムリソースのどちらを使うべきか？</h2><p>下記のいずれかに該当する場合は、ConfigMapを使ってください:</p><ul><li><code>mysql.cnf</code>、<code>pom.xml</code>のような、十分に文書化された設定ファイルフォーマットが既に存在している</li><li>単一キーのConfigMapに、設定ファイルの内容の全てを格納している</li><li>設定ファイルの主な用途は、クラスター上のPodで実行されているプログラムがファイルを読み込み、それ自体を構成することである</li><li>ファイルの利用者は、Kubernetes APIよりも、Pod内のファイルまたはPod内の環境変数を介して利用することを好む</li><li>ファイルが更新されたときに、Deploymentなどを介してローリングアップデートを行いたい</li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong> センシティブなデータには、ConfigMapに類似していますがよりセキュアな<a href=/ja/docs/concepts/configuration/secret/>secret</a>を使ってください</div><p>下記のほとんどに該当する場合、カスタムリソース(CRD、またはアグリゲートAPI)を使ってください:</p><ul><li>新しいリソースを作成、更新するために、Kubernetesのクライアントライブラリー、CLIを使いたい</li><li>kubectlのトップレベルサポートが欲しい(例、<code>kubectl get my-object object-name</code>)</li><li>新しい自動化の仕組みを作り、新しいオブジェクトの更新をウォッチしたい、その更新を契機に他のオブジェクトのCRUDを実行したい、またはその逆を行いたい</li><li>オブジェクトの更新を取り扱う、自動化の仕組みを書きたい</li><li><code>.spec</code>、<code>.status</code>、<code>.metadata</code>というような、Kubernetes APIの慣習を使いたい</li><li>オブジェクトは、制御されたリソースコレクションの抽象化、または他のリソースのサマリーとしたい</li></ul><h2 id=カスタムリソースを追加する>カスタムリソースを追加する</h2><p>Kubernetesは、クラスターへカスタムリソースを追加する2つの方法を提供しています:</p><ul><li>CRDはシンプルで、プログラミングなしに作成可能</li><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIアグリゲーション</a>は、プログラミングが必要だが、データがどのように格納され、APIバージョン間でどのように変換されるかというような、より詳細なAPIの振る舞いを制御できる</li></ul><p>Kubernetesは、さまざまなユーザーのニーズを満たすためにこれら2つのオプションを提供しており、使いやすさや柔軟性が損なわれることはありません。</p><p>アグリゲートAPIは、プロキシーとして機能するプライマリAPIサーバーの背後にある、下位のAPIServerです。このような配置は<a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIアグリゲーション</a>(AA)と呼ばれています。ユーザーにとっては、単にAPIサーバーが拡張されているように見えます。</p><p>CRDでは、APIサーバーの追加なしに、ユーザーが新しい種類のリソースを作成できます。CRDを使うには、APIアグリゲーションを理解する必要はありません。</p><p>どのようにインストールされたかに関わらず、新しいリソースはカスタムリソースとして参照され、ビルトインのKubernetesリソース(Podなど)とは区別されます。</p><h2 id=customresourcedefinition>CustomResourceDefinition</h2><p><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>APIリソースは、カスタムリソースを定義します。CRDオブジェクトを定義することで、指定した名前、スキーマで新しいカスタムリソースが作成されます。Kubernetes APIは、作成したカスタムリソースのストレージを提供、および処理します。
CRDオブジェクトの名前は<a href=/ja/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names>DNSサブドメイン名</a>に従わなければなりません。</p><p>これはカスタムリソースを処理するために、独自のAPIサーバーを書くことから解放してくれますが、一般的な性質として<a href=#API%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%A2%E3%82%B0%E3%83%AA%E3%82%B2%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3>APIサーバーアグリゲーション</a>と比べると、柔軟性に欠けます。</p><p>新しいカスタムリソースをどのように登録するか、新しいリソースタイプとの連携、そしてコントローラーを使いイベントを処理する方法例について、<a href=https://github.com/kubernetes/sample-controller>カスタムコントローラー例</a>を参照してください。</p><h2 id=apiサーバーアグリゲーション>APIサーバーアグリゲーション</h2><p>通常、Kubernetes APIの各リソースは、RESTリクエストとオブジェクトの永続的なストレージを管理するためのコードが必要です。メインのKubernetes APIサーバーは <em>Pod</em> や <em>Service</em> のようなビルトインのリソースを処理し、またカスタムリソースも<a href=#customresourcedefinition>CRD</a>を通じて同じように管理することができます。</p><p><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>アグリゲーションレイヤー</a>は、独自のAPIサーバーを書き、デプロイすることで、カスタムリソースに特化した実装の提供を可能にします。メインのAPIサーバーが、処理したいカスタムリソースへのリクエストを独自のAPIサーバーに委譲することで、他のクライアントからも利用できるようにします。</p><h2 id=カスタムリソースの追加方法を選択する>カスタムリソースの追加方法を選択する</h2><p>CRDは簡単に使えます。アグリゲートAPIはより柔軟です。ニーズに最も合う方法を選択してください。</p><p>通常、CRDは下記の場合に適しています:</p><ul><li>少数のフィールドしか必要ない</li><li>そのリソースは社内のみで利用している、または小さいオープンソースプロジェクトの一部で利用している(商用プロダクトではない)</li></ul><h3 id=使いやすさの比較>使いやすさの比較</h3><p>CRDは、アグリゲートAPIと比べ、簡単に作れます。</p><table><thead><tr><th>CRD</th><th>アグリゲートAPI</th></tr></thead><tbody><tr><td>プログラミングが不要で、ユーザーはCRDコントローラーとしてどの言語でも選択可能</td><td>Go言語でプログラミングし、バイナリとイメージの作成が必要</td></tr><tr><td>追加のサービスは不要。CRDはAPIサーバーで処理される</td><td>追加のサービス作成が必要で、障害が発生する可能性がある</td></tr><tr><td>CRDが作成されると、継続的なサポートは無い。バグ修正は通常のKubernetesマスターのアップグレードで行われる</td><td>定期的にアップストリームからバグ修正の取り込み、リビルド、そしてアグリゲートAPIサーバーの更新が必要かもしれない</td></tr><tr><td>複数バージョンのAPI管理は不要。例えば、あるリソースを操作するクライアントを管理していた場合、APIのアップグレードと一緒に更新される</td><td>複数バージョンのAPIを管理しなければならない。例えば、世界中に共有されている拡張機能を開発している場合</td></tr></tbody></table><h3 id=高度な機能-柔軟性>高度な機能、柔軟性</h3><p>アグリゲートAPIは、例えばストレージレイヤーのカスタマイズのような、より高度なAPI機能と他の機能のカスタマイズを可能にします。</p><table><thead><tr><th>機能</th><th>詳細</th><th>CRD</th><th>アグリゲートAPI</th></tr></thead><tbody><tr><td>バリデーション</td><td>エラーを予防し、クライアントと無関係にAPIを発達させることができるようになる。これらの機能は多数のクライアントがおり、同時に全てを更新できないときに最も効果を発揮する</td><td>はい、ほとんどのバリデーションは<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 validation</a>で、CRDに指定できる。その他のバリデーションは<a href=/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook-alpha-in-1-8-beta-in-1-9>Webhookのバリデーション</a>によりサポートされている</td><td>はい、任意のバリデーションが可能</td></tr><tr><td>デフォルト設定</td><td>上記を参照</td><td>はい、<a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#defaulting>OpenAPI v3.0 validation</a>の<code>default</code>キーワード(1.17でGA)、または<a href=/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook>Mutating Webhook</a>を通じて可能 (ただし、この方法は古いオブジェクトをetcdから読み込む場合には動きません)</td><td>はい</td></tr><tr><td>複数バージョニング</td><td>同じオブジェクトを、違うAPIバージョンで利用可能にする。フィールドの名前を変更するなどのAPIの変更を簡単に行うのに役立つ。クライアントのバージョンを管理する場合、重要性は下がる</td><td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning>はい</a></td><td>はい</td></tr><tr><td>カスタムストレージ</td><td>異なる性能のストレージが必要な場合(例えば、キーバリューストアの代わりに時系列データベース)または、セキュリティの分離(例えば、機密情報の暗号化、その他)</td><td>いいえ</td><td>はい</td></tr><tr><td>カスタムビジネスロジック</td><td>オブジェクトが作成、読み込み、更新、また削除されるときに任意のチェック、アクションを実行する</td><td>はい、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Webhooks</a>を利用</td><td>はい</td></tr><tr><td>サブリソースのスケール</td><td>HorizontalPodAutoscalerやPodDisruptionBudgetなどのシステムが、新しいリソースと連携できるようにする</td><td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource>はい</a></td><td>はい</td></tr><tr><td>サブリソースの状態</td><td>ユーザーがspecセクションに書き込み、コントローラーがstatusセクションに書き込む際に、より詳細なアクセスコントロールができるようにする。カスタムリソースのデータ変換時にオブジェクトの世代を上げられるようにする(リソース内のspecとstatusでセクションが分離している必要がある)</td><td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource>はい</a></td><td>はい</td></tr><tr><td>その他のサブリソース</td><td>"logs"や"exec"のような、CRUD以外の処理の追加</td><td>いいえ</td><td>はい</td></tr><tr><td>strategic-merge-patch</td><td><code>Content-Type: application/strategic-merge-patch+json</code>で、PATCHをサポートする新しいエンドポイント。ローカル、サーバー、どちらでも更新されうるオブジェクトに有用。さらなる情報は<a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>"APIオブジェクトをkubectl patchで決まった場所で更新"</a>を参照</td><td>いいえ</td><td>はい</td></tr><tr><td>プロトコルバッファ</td><td>プロトコルバッファを使用するクライアントをサポートする新しいリソース</td><td>いいえ</td><td>はい</td></tr><tr><td>OpenAPIスキーマ</td><td>サーバーから動的に取得できる型のOpenAPI(Swagger)スキーマはあるか、許可されたフィールドのみが設定されるようにすることで、ユーザーはフィールド名のスペルミスから保護されているか、型は強制されているか(言い換えると、「文字列」フィールドに「int」を入れさせない)</td><td>はい、<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 validation</a> スキーマがベース(1.16でGA)</td><td>はい</td></tr></tbody></table><h3 id=一般的な機能>一般的な機能</h3><p>CRD、またはアグリゲートAPI、どちらを使ってカスタムリソースを作った場合でも、Kubernetesプラットフォーム外でAPIを実装するのに比べ、多数の機能が提供されます:</p><table><thead><tr><th>機能</th><th>何を実現するか</th></tr></thead><tbody><tr><td>CRUD</td><td>新しいエンドポイントが、HTTP、<code>kubectl</code>を通じて、基本的なCRUD処理をサポート</td></tr><tr><td>Watch</td><td>新しいエンドポイントが、HTTPを通じて、KubernetesのWatch処理をサポート</td></tr><tr><td>Discovery</td><td><code>kubectl</code>やダッシュボードのようなクライアントが、自動的にリソースの一覧表示、個別表示、フィールドの編集処理を提供</td></tr><tr><td>json-patch</td><td>新しいエンドポイントが<code>Content-Type: application/json-patch+json</code>を用いたPATCHをサポート</td></tr><tr><td>merge-patch</td><td>新しいエンドポイントが<code>Content-Type: application/merge-patch+json</code>を用いたPATCHをサポート</td></tr><tr><td>HTTPS</td><td>新しいエンドポイントがHTTPSを利用</td></tr><tr><td>ビルトイン認証</td><td>拡張機能へのアクセスに認証のため、コアAPIサーバー(アグリゲーションレイヤー)を利用</td></tr><tr><td>ビルトイン認可</td><td>拡張機能へのアクセスにコアAPIサーバーで使われている認可メカニズムを再利用(例、RBAC)</td></tr><tr><td>ファイナライザー</td><td>外部リソースの削除が終わるまで、拡張リソースの削除をブロック</td></tr><tr><td>Admission Webhooks</td><td>拡張リソースの作成/更新/削除処理時に、デフォルト値の設定、バリデーションを実施</td></tr><tr><td>UI/CLI 表示</td><td>kubectl、ダッシュボードで拡張リソースを表示</td></tr><tr><td>未設定 対 空設定</td><td>クライアントは、フィールドの未設定とゼロ値を区別することができる</td></tr><tr><td>クライアントライブラリーの生成</td><td>Kubernetesは、一般的なクライアントライブラリーと、タイプ固有のクライアントライブラリーを生成するツールを提供</td></tr><tr><td>ラベルとアノテーション</td><td>ツールがコアリソースとカスタムリソースの編集方法を知っているオブジェクト間で、共通のメタデータを提供</td></tr></tbody></table><h2 id=カスタムリソースのインストール準備>カスタムリソースのインストール準備</h2><p>クラスターにカスタムリソースを追加する前に、いくつか認識しておくべき事項があります。</p><h3 id=サードパーティのコードと新しい障害点>サードパーティのコードと新しい障害点</h3><p>CRDを作成しても、勝手に新しい障害点が追加されてしまうことはありませんが(たとえば、サードパーティのコードをAPIサーバーで実行することによって)、パッケージ(たとえば、Chart)またはその他のインストールバンドルには、多くの場合、CRDと新しいカスタムリソースのビジネスロジックを実装するサードパーティコードが入ったDeploymentが含まれます。</p><p>アグリゲートAPIサーバーのインストールすると、常に新しいDeploymentが付いてきます。</p><h3 id=ストレージ>ストレージ</h3><p>カスタムリソースは、ConfigMapと同じ方法でストレージの容量を消費します。多数のカスタムリソースを作成すると、APIサーバーのストレージ容量を超えてしまうかもしれません。</p><p>アグリゲートAPIサーバーも、メインのAPIサーバーと同じストレージを利用するかもしれません。その場合、同じ問題が発生しえます。</p><h3 id=認証-認可-そして監査>認証、認可、そして監査</h3><p>CRDでは、APIサーバーのビルトインリソースと同じ認証、認可、そして監査ロギングの仕組みを利用します。</p><p>もしRBACを使っている場合、ほとんどのRBACのロールは新しいリソースへのアクセスを許可しません。(クラスター管理者ロール、もしくはワイルドカードで作成されたロールを除く)新しいリソースには、明示的にアクセスを許可する必要があります。多くの場合、CRDおよびアグリゲートAPIには、追加するタイプの新しいロール定義がバンドルされています。</p><p>アグリゲートAPIサーバーでは、APIサーバーのビルトインリソースと同じ認証、認可、そして監査の仕組みを使う場合と使わない場合があります。</p><h2 id=カスタムリソースへのアクセス>カスタムリソースへのアクセス</h2><p>Kubernetesの<a href=/docs/reference/using-api/client-libraries/>クライアントライブラリー</a>を使い、カスタムリソースにアクセスすることが可能です。全てのクライアントライブラリーがカスタムリソースをサポートしているわけでは無いですが、<em>Go</em> と <em>Python</em> のライブラリーはサポートしています。</p><p>カスタムリソースは、下記のような方法で操作できます:</p><ul><li><code>kubectl</code></li><li>kubernetesの動的クライアント</li><li>自作のRESTクライアント</li><li><a href=https://github.com/kubernetes/code-generator>Kubernetesクライアント生成ツール</a>を使い生成したクライアント(生成は高度な作業ですが、一部のプロジェクトは、CRDまたはAAとともにクライアントを提供する場合があります)</li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Kubernetes APIをアグリゲーションレイヤーで拡張する方法</a>について学ぶ</li><li><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>Kubernetes APIをCustomResourceDefinitionで拡張する方法</a>について学ぶ</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>12.2.2 - アグリゲーションレイヤーを使ったKubernetes APIの拡張</h1><p>アグリゲーションレイヤーを使用すると、KubernetesのコアAPIで提供されている機能を超えて、追加のAPIでKubernetesを拡張できます。追加のAPIは、<a href=/docs/concepts/extend-kubernetes/service-catalog/>service-catalog</a>のような既製のソリューション、または自分で開発したAPIのいずれかです。</p><p>アグリゲーションレイヤーは、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>とは異なり、<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a>に新しい種類のオブジェクトを認識させる方法です。</p><h2 id=アグリゲーションレイヤー>アグリゲーションレイヤー</h2><p>アグリゲーションレイヤーは、kube-apiserverのプロセス内で動きます。拡張リソースが登録されるまでは、アグリゲーションレイヤーは何もしません。APIを登録するには、ユーザーはKubernetes APIで使われるURLのパスを"要求"した、<em>APIService</em> オブジェクトを追加します。それを追加すると、アグリゲーションレイヤーはAPIパス(例、<code>/apis/myextension.mycompany.io/v1/…</code>)への全てのアクセスを、登録されたAPIServiceにプロキシーします。</p><p>APIServiceを実装する最も一般的な方法は、クラスター内で実行されるPodで<em>拡張APIサーバー</em> を実行することです。クラスター内のリソース管理に拡張APIサーバーを使用している場合、拡張APIサーバー("extension-apiserver"とも呼ばれます)は通常、1つ以上の<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>とペアになっています。apiserver-builderライブラリは、拡張APIサーバーと関連するコントローラーの両方にスケルトンを提供します。</p><h3 id=応答遅延>応答遅延</h3><p>拡張APIサーバーは、kube-apiserverとの間の低遅延ネットワーキングが必要です。
kube-apiserverとの間を5秒以内に往復するためには、ディスカバリーリクエストが必要です。</p><p>拡張APIサーバーがそのレイテンシ要件を達成できない場合は、その要件を満たすように変更することを検討してください。また、kube-apiserverで<code>EnableAggregatedDiscoveryTimeout=false</code> <a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を設定することで、タイムアウト制限を無効にすることができます。この非推奨のフィーチャーゲートは将来のリリースで削除される予定です。</p><h2 id=次の項目>次の項目</h2><ul><li>アグリゲーターをあなたの環境で動かすには、まず<a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>アグリゲーションレイヤーを設定</a>します</li><li>そして、アグリゲーションレイヤーと一緒に動作させるために<a href=/docs/tasks/extend-kubernetes/setup-extension-api-server/>extension api-serverをセットアップ</a>します</li><li>また、<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>Custom Resource Definitionを使いKubernetes APIを拡張する</a>方法を学んで下さい</li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#apiservice-v1-apiregistration-k8s-io>APIService</a>の仕様をお読み下さい</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3131452556176159fb269593c1a52012>12.3 - オペレーターパターン</h1><p>オペレーターは<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>を使用するKubernetesへのソフトウェア拡張です。
オペレーターは、特に<a href=/ja/docs/concepts/#kubernetes-control-plane>制御ループ</a>のようなKubernetesが持つ仕組みに準拠しています。</p><h2 id=モチベーション>モチベーション</h2><p>オペレーターパターンはサービス、またはサービス群を管理している運用担当者の主な目的をキャプチャすることが目標です。
特定のアプリケーション、サービスの面倒を見ている運用担当者は、システムがどのように振る舞うべきか、どのようにデプロイをするか、何らかの問題があったときにどのように対応するかについて深い知識を持っています。</p><p>Kubernetes上でワークロードを稼働させている人は、しばしば繰り返し可能なタスクを自動化することを好みます。
オペレーターパターンは、Kubernetes自身が提供している機能を超えて、あなたがタスクを自動化するために、どのようにコードを書くかをキャプチャします。</p><h2 id=kubernetesにおけるオペレーター>Kubernetesにおけるオペレーター</h2><p>Kubernetesは自動化のために設計されています。追加の作業、設定無しに、Kubernetesのコア機能によって多数のビルトインされた自動化機能が提供されます。
ワークロードのデプロイおよび稼働を自動化するためにKubernetesを使うことができます。 <em>さらに</em> Kubernetesがそれをどのように行うかの自動化も可能です。</p><p>Kubernetesの<a class=glossary-tooltip title='A specialized controller used to manage a custom resource' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=オペレーターパターン>オペレーターパターン</a>コンセプトは、Kubernetesのソースコードを修正すること無く、一つ以上のカスタムリソースに<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=カスタムコントローラー>カスタムコントローラー</a>をリンクすることで、クラスターの振る舞いを拡張することを可能にします。
オペレーターはKubernetes APIのクライアントで、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Custom Resource</a>にとっての、コントローラーのように振る舞います。</p><h2 id=example>オペレーターの例</h2><p>オペレーターを使い自動化できるいくつかのことは、下記のようなものがあります:</p><ul><li>必要に応じてアプリケーションをデプロイする</li><li>アプリケーションの状態のバックアップを取得、リストアする</li><li>アプリケーションコードの更新と同時に、例えばデータベーススキーマ、追加の設定修正など必要な変更の対応を行う</li><li>Kubernetes APIをサポートしていないアプリケーションに、サービスを公開してそれらを発見する</li><li>クラスターの回復力をテストするために、全て、または一部分の障害をシミュレートする</li><li>内部のリーダー選出プロセス無しに、分散アプリケーションのリーダーを選択する</li></ul><p>オペレーターをもっと詳しく見るとどのように見えるでしょうか？より詳細な例を示します:</p><ol><li>クラスターに設定可能なSampleDBという名前のカスタムリソース</li><li>オペレーターの、コントローラー部分を含むPodが実行されていることを保証するDeployment</li><li>オペレーターのコードを含んだコンテナイメージ</li><li>設定されているSampleDBのリソースを見つけるために、コントロールプレーンに問い合わせるコントローラーのコード</li><li>オペレーターのコアは、現実を、設定されているリソースにどのように合わせるかをAPIサーバーに伝えるコードです。<ul><li>もし新しいSampleDBを追加した場合、オペレーターは永続化データベースストレージを提供するためにPersistentVolumeClaimsをセットアップし、StatefulSetがSampleDBの起動と、初期設定を担うJobを走らせます</li><li>もしそれを削除した場合、オペレーターはスナップショットを取り、StatefulSetとVolumeも合わせて削除されたことを確認します</li></ul></li><li>オペレーターは定期的なデータベースのバックアップも管理します。それぞれのSampleDBリソースについて、オペレーターはデータベースに接続可能な、バックアップを取得するPodをいつ作成するかを決定します。これらのPodはデータベース接続の詳細情報、クレデンシャルを保持するConfigMapとSecret、もしくはどちらかに依存するでしょう。</li><li>オペレーターは、管理下のリソースの堅牢な自動化を提供することを目的としているため、補助的な追加コードが必要になるかもしれません。この例では、データベースが古いバージョンで動いているかどうかを確認するコードで、その場合、アップグレードを行うJobをあなたに代わり作成します。</li></ol><h2 id=オペレーターのデプロイ>オペレーターのデプロイ</h2><p>オペレーターをデプロイする最も一般的な方法は、Custom Resource Definitionとそれに関連するコントローラーをクラスターに追加することです。
このコントローラーは通常、あなたがコンテナアプリケーションを動かすのと同じように、<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>外で動作します。</p><p>例えば、コントローラーをDeploymentとしてクラスター内で動かすことができます。</p><h2 id=using-operators>オペレーターを利用する</h2><p>一度オペレーターをデプロイすると、そのオペレーターを使って、それ自身が使うリソースの種類を追加、変更、または削除できます。
上記の利用例に従ってオペレーターそのもののためのDeploymentをセットアップし、以下のようなコマンドを実行します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get SampleDB                   <span style=color:#080;font-style:italic># 設定したデータベースを発見します</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl edit SampleDB/example-database <span style=color:#080;font-style:italic># 手動でいくつかの設定を変更します</span>
</span></span></code></pre></div><p>これだけです！オペレーターが変更の適用だけでなく既存のサービスがうまく稼働し続けるように面倒を見てくれます。</p><h2 id=writing-operator>自分でオペレーターを書く</h2><p>必要な振る舞いを実装したオペレーターがエコシステム内に無い場合、自分で作成することができます。
<a href=#whats-next>次の項目</a>で、自分でクラウドネイティブオペレーターを作るときに利用できるライブラリやツールのリンクを見つけることができます。</p><p>オペレーター（すなわち、コントローラー）はどの言語/ランタイムでも実装でき、<a href=/docs/reference/using-api/client-libraries/>Kubernetes APIのクライアント</a>として機能させることができます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Custom Resources</a>をより深く学びます</li><li>ユースケースに合わせた、既製のオペレーターを<a href=https://operatorhub.io/>OperatorHub.io</a>から見つけます</li><li>自前のオペレーターを書くために既存のツールを使います、例:<ul><li><a href=https://juju.is/>Charmed Operator Framework</a></li><li><a href=https://github.com/java-operator-sdk/java-operator-sdk>Java Operator SDK</a></li><li><a href=https://github.com/nolar/kopf>Kopf</a> (Kubernetes Operator Pythonic Framework)</li><li><a href=https://kube.rs/>kube-rs</a> (Rust)</li><li><a href=https://kudo.dev/>KUDO</a>（Kubernetes Universal Declarative Operator）を使います</li><li><a href=https://book.kubebuilder.io/>kubebuilder</a>を使います</li><li><a href=https://buehler.github.io/dotnet-operator-sdk/>KubeOps</a> (dotnet operator SDK)</li><li><a href=https://metacontroller.github.io/metacontroller/intro.html>Metacontroller</a>を自分で実装したWebHooksと一緒に使います</li><li><a href=https://operatorframework.io>Operator Framework</a>を使います</li><li><a href=https://github.com/flant/shell-operator>shell-operator</a></li></ul></li><li>自前のオペレーターを他のユーザーのために<a href=https://operatorhub.io/>公開</a>します</li><li>オペレーターパターンを紹介している<a href=https://coreos.com/blog/introducing-operators.html>CoreOSオリジナル記事</a>を読みます</li><li>Google Cloudが出したオペレーター作成のベストプラクティス<a href=https://cloud.google.com/blog/products/containers-kubernetes/best-practices-for-building-kubernetes-operators-and-stateful-apps>記事</a>を読みます</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>