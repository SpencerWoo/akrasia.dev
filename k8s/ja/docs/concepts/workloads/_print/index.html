<!doctype html><html lang=ja class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/workloads/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/workloads/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/workloads/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/workloads/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/workloads/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/workloads/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/workloads/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/workloads/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/workloads/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>ワークロード | Kubernetes</title><meta property="og:title" content="ワークロード"><meta property="og:description" content="Kubernetesにおけるデプロイ可能な最小のオブジェクトであるPodと、高レベルな抽象化がPodの実行を助けることを理解します。
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/workloads/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="ワークロード"><meta itemprop=description content="Kubernetesにおけるデプロイ可能な最小のオブジェクトであるPodと、高レベルな抽象化がPodの実行を助けることを理解します。
"><meta name=twitter:card content="summary"><meta name=twitter:title content="ワークロード"><meta name=twitter:description content="Kubernetesにおけるデプロイ可能な最小のオブジェクトであるPodと、高レベルな抽象化がPodの実行を助けることを理解します。
"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Kubernetesにおけるデプロイ可能な最小のオブジェクトであるPodと、高レベルな抽象化がPodの実行を助けることを理解します。
"><meta property="og:description" content="Kubernetesにおけるデプロイ可能な最小のオブジェクトであるPodと、高レベルな抽象化がPodの実行を助けることを理解します。
"><meta name=twitter:description content="Kubernetesにおけるデプロイ可能な最小のオブジェクトであるPodと、高レベルな抽象化がPodの実行を助けることを理解します。
"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/workloads/"><meta property="og:title" content="ワークロード"><meta name=twitter:title content="ワークロード"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ja/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ja/docs/>ドキュメント</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/blog/>Blogs</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/training/>トレーニング</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/partners/>パートナー</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/community/>コミュニティ</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/case-studies/>ケーススタディ</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>バージョン</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ja/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/workloads/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/workloads/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/workloads/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/concepts/workloads/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ja/docs/concepts/workloads/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語 (Japanese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/workloads/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/workloads/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/workloads/>한국어 (Korean)</a>
<a class=dropdown-item href=/fr/docs/concepts/workloads/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/workloads/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/workloads/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/concepts/workloads/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/workloads/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.</p><p><a href=/ja/docs/concepts/workloads/>このページの通常のビューに戻る</a>.</p></div><h1 class=title>ワークロード</h1><div class=lead>Kubernetesにおけるデプロイ可能な最小のオブジェクトであるPodと、高レベルな抽象化がPodの実行を助けることを理解します。</div><ul><li>1: <a href=#pg-4d68b0ccf9c683e6368ffdcc40c838d4>Pod</a></li><ul><li>1.1: <a href=#pg-37afa6c66c74400d1579f10faf55e5b6>Podの概観</a></li><li>1.2: <a href=#pg-c3c2b9cf30915ec9d46c147201da3332>Podのライフサイクル</a></li><li>1.3: <a href=#pg-1ccbd4eeded6ab138d98b59175bd557e>Initコンテナ</a></li><li>1.4: <a href=#pg-4e9b9cbc9776b12e7335c53da377c9c8>Pod Preset</a></li><li>1.5: <a href=#pg-53a1005011e1bda2ce81819aad7c8b32>エフェメラルコンテナ</a></li></ul><li>2: <a href=#pg-89637410cacae45a36ab1cc278c482eb>ワークロードリソース</a></li><ul><li>2.1: <a href=#pg-a2dc0393e0c4079e1c504b6429844e86>Deployment</a></li><li>2.2: <a href=#pg-d459b930218774655fa7fd1620625539>ReplicaSet</a></li><li>2.3: <a href=#pg-6d72299952c37ca8cc61b416e5bdbcd4>StatefulSet</a></li><li>2.4: <a href=#pg-41600eb8b6631c88848156f381e9d588>DaemonSet</a></li><li>2.5: <a href=#pg-cc7cc3c4907039d9f863162e20bfbbef>Jobs</a></li><li>2.6: <a href=#pg-9add0d2120634b63073ad08dc8683bd6>ガベージコレクション</a></li><li>2.7: <a href=#pg-4de50a37ebb6f2340484192126cb7a04>終了したリソースのためのTTLコントローラー(TTL Controller for Finished Resources)</a></li><li>2.8: <a href=#pg-2e4cec01c525b45eccd6010e21cc76d9>CronJob</a></li></ul></ul><div class=content><p>ワークロードとは、Kubernetes上で実行中のアプリケーションです。
ワークロードが1つのコンポーネントからなる場合でも、複数のコンポーネントが協調して動作する場合でも、Kubernetesではそれらは<a href=/ja/docs/concepts/workloads/pods>Pod</a>の集合として実行されます。Kubernetesでは、Podはクラスター上で実行中の<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>の集合として表されます。</p><p>Podには定義されたライフサイクルがあります。たとえば、一度Podがクラスター上で実行中になると、そのPodが実行中の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>上で深刻な障害が起こったとき、そのノード上のすべてのPodは停止してしまうことになります。Kubernetesではそのようなレベルの障害を最終的なものとして扱うため、たとえノードが後で復元したとしても、ユーザーは新しいPodを作成し直す必要があります。</p><p>しかし、生活をかなり楽にするためには、それぞれのPodを直接管理する必要はありません。<em>ワークロードリソース</em> を利用すれば、あなたの代わりにPodの集合の管理を行ってもらえます。これらのリソースはあなたが指定した状態に一致するように<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>を設定し、正しい種類のPodが正しい数だけ実行中になることを保証してくれます。</p><p>ワークロードリソースには、次のような種類があります。</p><ul><li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>と<a href=/ja/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>(レガシーなリソース<a class=glossary-tooltip title='A (deprecated) API object that manages a replicated application.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-replication-controller' target=_blank aria-label=ReplicationController>ReplicationController</a>を置き換えるものです)</li><li><a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>(ストレージドライバやネットワークプラグインなど、ノードローカルな機能を提供するためのPodを実行するために使われます)</li><li><a href=/docs/concepts/workloads/controllers/job/>Job</a>と<a href=/ja/docs/concepts/workloads/controllers/cron-jobs/>CronJob</a>(実行後に完了するようなタスクのために使われます)</li></ul><p>多少関連のある2種類の補助的な概念もあります。</p><ul><li><a href=/ja/docs/concepts/workloads/controllers/garbage-collection/>ガベージコレクション</a>は、オブジェクトが <em>所有するリソース</em> が削除された後に、そのオブジェクトをクラスターからクリーンアップします。</li><li><a href=/ja/docs/concepts/workloads/controllers/ttlafterfinished/>終了したリソースのためのTTLコントローラー</a>は、Jobの完了後、定義した時間が経過した後にJobを削除します。</li></ul><h2 id=次の項目>次の項目</h2><p>各リソースについて読む以外にも、以下のページでそれぞれのワークロードに関連する特定のタスクについて学ぶことができます。</p><ul><li><a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>Deploymentを使用してステートレスアプリケーションを実行する</a></li><li><a href=/ja/docs/tasks/run-application/run-single-instance-stateful-application/>単一レプリカ</a>または<a href=/ja/docs/tasks/run-application/run-replicated-stateful-application/>レプリカセット</a>のいずれかとしてステートフルなアプリケーションを実行する</li><li><a href=/ja/docs/tasks/job/automated-tasks-with-cron-jobs/>CronJobを使用して自動タスクを実行する</a></li></ul><p>アプリケーションが実行できるようになったら、インターネット上で公開したくなるかもしれません。その場合には、<a href=/ja/docs/concepts/services-networking/service/>Service</a>として公開したり、ウェブアプリケーションだけの場合、<a href=/ja/docs/concepts/services-networking/ingress>Ingress</a>を使用することができます。</p><p>コードを設定から分離するKubernetesのしくみについて学ぶには、<a href=/ja/docs/concepts/configuration/>設定</a>を読んでください。</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-4d68b0ccf9c683e6368ffdcc40c838d4>1 - Pod</h1><p><em>Pod</em>は、Kubernetes内で作成・管理できるコンピューティングの最小のデプロイ可能なユニットです。</p><p><em>Pod</em>(Podという名前は、たとえばクジラの群れ(pod of whales)やえんどう豆のさや(pea pod)などの表現と同じような意味です)は、1つまたは複数の<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>のグループであり、ストレージやネットワークの共有リソースを持ち、コンテナの実行方法に関する仕様を持っています。同じPodに含まれるリソースは、常に同じ場所で同時にスケジューリングされ、共有されたコンテキストの中で実行されます。Podはアプリケーションに特化した「論理的なホスト」をモデル化します。つまり、1つのPod内には、1つまたは複数の比較的密に結合されたアプリケーションコンテナが含まれます。クラウド外の文脈で説明すると、アプリケーションが同じ物理ホストや同じバーチャルマシンで実行されることが、クラウドアプリケーションの場合には同じ論理ホスト上で実行されることに相当します。</p><p>アプリケーションコンテナと同様に、Podでも、Podのスタートアップ時に実行される<a href=/ja/docs/concepts/workloads/pods/init-containers/>initコンテナ</a>を含めることができます。また、クラスターで利用できる場合には、<a href=/ja/docs/concepts/workloads/pods/ephemeral-containers/>エフェメラルコンテナ</a>を注入してデバッグすることもできます。</p><h2 id=podとは何か>Podとは何か？</h2><div class="alert alert-info note callout" role=alert><strong>備考:</strong> KubernetesはDockerだけでなく複数の<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>をサポートしていますが、<a href=https://www.docker.com/>Docker</a>が最も一般的に知られたランタイムであるため、Docker由来の用語を使ってPodを説明するのが理解の助けとなります。</div><p>Podの共有コンテキストは、Dockerコンテナを隔離するのに使われているのと同じ、Linuxのnamespaces、cgroups、場合によっては他の隔離技術の集合を用いて作られます。Podのコンテキスト内では、各アプリケーションが追加の準隔離技術を適用することもあります。</p><p>Dockerの概念を使って説明すると、Podは共有の名前空間と共有ファイルシステムのボリュームを持つDockerコンテナのグループに似ています。</p><h2 id=podを使用する>Podを使用する</h2><p>以下は、<code>nginx:1.14.2</code>イメージが実行されるコンテナからなるPodの例を記載しています。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/simple-pod.yaml download=pods/simple-pod.yaml><code>pods/simple-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-simple-pod-yaml")' title="Copy pods/simple-pod.yaml to clipboard"></img></div><div class=includecode id=pods-simple-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>上記のようなPodを作成するには、以下のコマンドを実行します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml
</span></span></code></pre></div><p>Podは通常、直接作成されず、ワークロードリソースで作成されます。ワークロードリソースでPodを作成する方法の詳細については、<a href=#working-with-pods>Podを利用する</a>を参照してください。</p><h3 id=podを管理するためのワークロードリソース>Podを管理するためのワークロードリソース</h3><p>通常、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、自分でPodを直接作成する必要はありません。その代わりに、<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>や<a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>などのワークロードリソースを使用してPodを作成します。もしPodが状態を保持する必要がある場合は、<a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>リソースを使用することを検討してください。</p><p>Kubernetesクラスター内のPodは、主に次の2種類の方法で使われます。</p><ul><li><p><strong>単一のコンテナを稼働させるPod</strong>。「1Pod1コンテナ」構成のモデルは、Kubernetesでは最も一般的なユースケースです。このケースでは、ユーザーはPodを単一のコンテナのラッパーとして考えることができます。Kubernetesはコンテナを直接管理するのではなく、Podを管理します。</p></li><li><p><strong>協調して稼働させる必要がある複数のコンテナを稼働させるPod</strong>。単一のPodは、密に結合してリソースを共有する必要があるような、同じ場所で稼働する複数のコンテナからなるアプリケーションをカプセル化することもできます。これらの同じ場所で稼働するコンテナ群は、単一のまとまりのあるサービスのユニットを構成します。たとえば、1つのコンテナが共有ボリュームからファイルをパブリックに配信し、別の<em>サイドカー</em>コンテナがそれらのファイルを更新するという構成が考えられます。Podはこれらの複数のコンテナ、ストレージリソース、一時的なネットワークIDなどを、単一のユニットとしてまとめます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 複数のコンテナを同じ場所で同時に管理するように単一のPod内にグループ化するのは、比較的高度なユースケースです。このパターンを使用するのは、コンテナが密に結合しているような特定のインスタンス内でのみにするべきです。</div></li></ul><p>各Podは、与えられたアプリケーションの単一のインスタンスを稼働するためのものです。もしユーザーのアプリケーションを水平にスケールさせたい場合(例: 複数インスタンスを稼働させる)、複数のPodを使うべきです。1つのPodは各インスタンスに対応しています。Kubernetesでは、これは一般的に<em>レプリケーション</em>と呼ばれます。レプリケーションされたPodは、通常ワークロードリソースと、それに対応する<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>によって、作成・管理されます。</p><p>Kubernetesがワークロードリソースとそのコントローラーを活用して、スケーラブルで自動回復するアプリケーションを実装する方法については、詳しくは<a href=#pods-and-controllers>Podとコントローラー</a>を参照してください。</p><h3 id=podが複数のコンテナを管理する方法>Podが複数のコンテナを管理する方法</h3><p>Podは、まとまりの強いサービスのユニットを構成する、複数の協調する(コンテナとして実行される)プロセスをサポートするために設計されました。単一のPod内の複数のコンテナは、クラスター内の同じ物理または仮想マシン上で、自動的に同じ場所に配置・スケジューリングされます。コンテナ間では、リソースや依存関係を共有したり、お互いに通信したり、停止するときにはタイミングや方法を協調して実行できます。</p><p>たとえば、あるコンテナが共有ボリューム内のファイルを配信するウェブサーバーとして動作し、別の「サイドカー」コンテナがリモートのリソースからファイルをアップデートするような構成が考えられます。この構成を以下のダイアグラムに示します。</p><figure class=diagram-medium><img src=/images/docs/pod.svg alt=Pod作成ダイアグラム></figure><p>Podによっては、<a class=glossary-tooltip title='A container used to run part of a workload. Compare with init container.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-app-container' target=_blank aria-label=appコンテナ>appコンテナ</a>に加えて<a class=glossary-tooltip title='One or more initialization containers that must run to completion before any app containers run.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-init-container' target=_blank aria-label=initコンテナ>initコンテナ</a>を持っている場合があります。initコンテナはappコンテナが起動する前に実行・完了するコンテナです。</p><p>Podは、Podを構成する複数のコンテナに対して、<a href=#pod-networking>ネットワーク</a>と<a href=#pod-storage>ストレージ</a>の2種類の共有リソースを提供します。</p><h2 id=working-with-pods>Podを利用する</h2><p>通常Kubernetesでは、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、個別のPodを直接作成することはめったにありません。その理由は、Podがある程度一時的で使い捨てできる存在として設計されているためです。Podが作成されると(あなたが直接作成した場合でも、<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>が間接的に作成した場合でも)、新しいPodはクラスター内の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>上で実行されるようにスケジューリングされます。Podは、実行が完了するか、Podオブジェクトが削除されるか、リソース不足によって<em>強制退去</em>されるか、ノードが停止するまで、そのノード上にとどまります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Pod内のコンテナの再起動とPodの再起動を混同しないでください。Podはプロセスではなく、コンテナが実行するための環境です。Podは削除されるまでは残り続けます。</div><p>Podオブジェクトのためのマニフェストを作成したときは、指定したPodの名前が有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>であることを確認してください。</p><h3 id=pod-os>Pod OS</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [stable]</code></div><p><code>.spec.os.name</code>フィールドで<code>windows</code>か<code>linux</code>のいずれかを設定し、Podを実行させたいOSを指定する必要があります。Kubernetesは今のところ、この2つのOSだけサポートしています。将来的には増える可能性があります。</p><p>Kubernetes v1.25では、このフィールドに設定した値はPodの<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=スケジューリング>スケジューリング</a>に影響を与えません。<code>.spec.os.name</code>を設定することで、Pod OSに権限を認証することができ、バリデーションにも使用されます。kubeletが実行されているノードのOSが、指定されたPod OSと異なる場合、kubeletはPodの実行を拒否します。
<a href=/ja/docs/concepts/security/pod-security-standards/>Podセキュリティの標準</a>もこのフィールドを使用し、指定したOSと関係ないポリシーの適用を回避しています。</p><h3 id=pods-and-controllers>Podとコンテナコントローラー</h3><p>ワークロードリソースは、複数のPodを作成・管理するために利用できます。リソースに対応するコントローラーが、複製やロールアウトを扱い、Podの障害時には自動回復を行います。たとえば、あるノードに障害が発生した場合、コントローラーはそのノードの動作が停止したことを検知し、代わりのPodを作成します。そして、スケジューラーが代わりのPodを健全なノード上に配置します。</p><p>以下に、1つ以上のPodを管理するワークロードリソースの一例をあげます。</p><ul><li><a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a></li><li><a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a></li><li><a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a></li></ul><h3 id=pod-template>Podテンプレート</h3><p><a class=glossary-tooltip title=ワークロードとは、Kubernetes上で実行中のアプリケーションです。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/ target=_blank aria-label=workload>workload</a>リソース向けのコントローラーは、Podを<em>Podテンプレート</em>を元に作成し、あなたの代わりにPodを管理してくれます。</p><p>PodTemplateはPodを作成するための仕様で、<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>、<a href=/ja/docs/concepts/workloads/controllers/job/>Job</a>、<a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>などのワークロードリソースの中に含まれています。</p><p>ワークロードリソースに対応する各コントローラーは、ワークロードオブジェクト内にある<code>PodTemplate</code>を使用して実際のPodを作成します。<code>PodTemplate</code>は、アプリを実行するために使われるワークロードリソースがどんな種類のものであれ、その目的の状態の一部を構成するものです。</p><p>以下は、単純なJobのマニフェストの一例で、1つのコンテナを実行する<code>template</code>があります。Pod内のコンテナはメッセージを出力した後、一時停止します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># これがPodテンプレートです</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo &#34;Hello, Kubernetes!&#34; &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Podテンプレートはここまでです</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Podテンプレートを修正するか新しいPodに切り替えたとしても、すでに存在するPodには直接の影響はありません。ワークロードリソース内のPodテンプレートを変更すると、そのリソースは更新されたテンプレートを使用して代わりとなるPodを作成する必要があります。</p><p>たとえば、StatefulSetコントローラーは、各StatefulSetごとに、実行中のPodが現在のPodテンプレートに一致することを保証します。Podテンプレートを変更するためにStatefulSetを編集すると、StatefulSetは更新されたテンプレートを元にした新しいPodを作成するようになります。最終的に、すべての古いPodが新しいPodで置き換えられ、更新は完了します。</p><p>各ワークロードリソースは、Podテンプレートへの変更を処理するための独自のルールを実装しています。特にStatefulSetについて更に詳しく知りたい場合は、StatefulSetの基本チュートリアル内の<a href=/ja/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets>アップデート戦略</a>を読んでください。</p><p>ノード上では、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>はPodテンプレートに関する詳細について監視や管理を直接行うわけではありません。こうした詳細は抽象化されています。こうした抽象化や関心の分離のおかげでシステムのセマンティクスが単純化され、既存のコードを変更せずにクラスターの動作を容易に拡張できるようになっているのです。</p><h2 id=podの更新と取替>Podの更新と取替</h2><p>前のセクションで述べたように、ワークロードリソースのPodテンプレートが変更されると、コントローラーは既存のPodを更新したりパッチを適用したりするのではなく、更新されたテンプレートに基づいて新しいPodを作成します。</p><p>KubernetesはPodを直接管理することを妨げません。実行中のPodの一部のフィールドをその場で更新することが可能です。しかし、<a href=/docs/reference/generated/kubernetes-api/v1.25/#patch-pod-v1-core><code>patch</code></a>と<a href=/docs/reference/generated/kubernetes-api/v1.25/#replace-pod-v1-core><code>replace</code></a>といった、Podのアップデート操作にはいくつかの制限があります:</p><ul><li><p>Podのメタデータのほとんどは固定されたものです。たとえば<code>namespace</code>、<code>name</code>、<code>uid</code>または<code>creationTimestamp</code>フィールドは変更できません。<code>generation</code>フィールドは特別で、現在の値を増加させる更新のみを受け付けます。</p></li><li><p><code>metadata.deletionTimestamp</code>が設定されている場合、<code>metadata.finalizers</code>リストに新しい項目を追加することはできません。</p></li><li><p>Podの更新では<code>spec.containers[*].image</code>、<code>spec.initContainers[*].image</code>、<code>spec.activeDeadlineSeconds</code>または<code>spec.tolerations</code>以外のフィールドを変更してはなりません。
<code>spec.tolerations</code>については新しい項目のみを追加することができます。</p></li><li><p><code>spec.activeDeadlineSeconds</code>フィールドを更新する場合、2種類の更新が可能です:</p><ol><li>未割り当てのフィールドに正の数を設定する</li><li>現在の値から負の数でない、より小さい数に更新する</li></ol></li></ul><h2 id=リソースの共有と通信>リソースの共有と通信</h2><p>Podは、データの共有と構成するコンテナ間での通信を可能にします。</p><h3 id=pod-storage>Pod内のストレージ</h3><p>Podでは、共有ストレージである<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>の集合を指定できます。Pod内のすべてのコンテナは共有ボリュームにアクセスできるため、それら複数のコンテナでデータを共有できるようになります。また、ボリュームを利用すれば、Pod内のコンテナの1つに再起動が必要になった場合にも、Pod内の永続化データを保持し続けられるようにできます。Kubernetesの共有ストレージの実装方法とPodで利用できるようにする方法に関するさらに詳しい情報は、<a href=/ja/docs/concepts/storage/>ストレージ</a>を読んでください。</p><h3 id=pod-networking>Podネットワーク</h3><p>各Podには、各アドレスファミリーごとにユニークなIPアドレスが割り当てられます。Pod内のすべてのコンテナは、IPアドレスとネットワークポートを含むネットワーク名前空間を共有します。Podの中では(かつその場合に<strong>のみ</strong>)、そのPod内のコンテナは<code>localhost</code>を使用して他のコンテナと通信できます。Podの内部にあるコンテナが<em>Podの外部にある</em>エンティティと通信する場合、(ポートなどの)共有ネットワークリソースの使い方をコンテナ間で調整しなければなりません。Pod内では、コンテナはIPアドレスとポートの空間を共有するため、<code>localhost</code>で他のコンテナにアクセスできます。また、Pod内のコンテナは、SystemVのセマフォやPOSIXの共有メモリなど、標準のプロセス間通信を使って他のコンテナと通信することもできます。異なるPod内のコンテナは異なるIPアドレスを持つため、特別な設定をしない限り、OSレベルIPCで通信することはできません。異なるPod上で実行中のコンテナ間でやり取りをしたい場合は、IPネットワークを使用して通信できます。</p><p>Pod内のコンテナは、システムのhostnameがPodに設定した<code>name</code>と同一であると考えます。ネットワークについての詳しい情報は、<a href=/ja/docs/concepts/cluster-administration/networking/>ネットワーク</a>で説明しています。</p><h2 id=コンテナの特権モード>コンテナの特権モード</h2><p>Linuxでは、Pod内のどんなコンテナも、<code>privileged</code>フラグをコンテナのspecの<a href=/docs/tasks/configure-pod-container/security-context/>security context</a>に設定することで、特権モード(privileged mode)を有効にできます。これは、ネットワークスタックの操作やハードウェアデバイスへのアクセスなど、オペレーティングシステムの管理者の権限が必要なコンテナの場合に役に立ちます。</p><p><code>WindowsHostProcessContainers</code>機能を有効にしたクラスターの場合、Pod仕様のsecurityContextに<code>windowsOptions.hostProcess</code>フラグを設定することで、<a href=/docs/tasks/configure-pod-container/create-hostprocess-pod>Windows HostProcess Pod</a>を作成することが可能です。これらのPod内のすべてのコンテナは、Windows HostProcessコンテナとして実行する必要があります。HostProcess Podはホスト上で直接実行され、Linuxの特権コンテナで行われるような管理作業を行うのにも使用できます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> この設定を有効にするには、<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>が特権コンテナの概念をサポートしていなければなりません。</div><h2 id=static-pod>static Pod</h2><p><em>static Pod</em>は、<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>には管理されない、特定のノード上でkubeletデーモンによって直接管理されるPodのことです。大部分のPodはコントロープレーン(たとえば<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>)によって管理されますが、static Podの場合はkubeletが各static Podを直接管理します(障害時には再起動します)。</p><p>static Podは常に特定のノード上の1つの<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>に紐付けられます。static Podの主な用途は、セルフホストのコントロールプレーンを実行すること、言い換えると、kubeletを使用して個別の<a href=/ja/docs/concepts/overview/components/#control-plane-components>コントロールプレーンコンポーネント</a>を管理することです。</p><p>kubeletは自動的にKubernetes APIサーバー上に各static Podに対応する<a class=glossary-tooltip title='kubelet上のstatic Podを追跡するAPIサーバー内のオブジェクトです。' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-mirror-pod' target=_blank aria-label=ミラーPod>ミラーPod</a>の作成を試みます。つまり、ノード上で実行中のPodはAPIサーバー上でも見えるようになるけれども、APIサーバー上から制御はできないということです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Static Podの<code>spec</code>は他のAPIオブジェクト
(例えば<a class=glossary-tooltip title='Provides an identity for processes that run in a Pod.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=サービスアカウント>サービスアカウント</a>、
<a class=glossary-tooltip title=機密性のないデータをキーと値のペアで保存するために使用されるAPIオブジェクトです。環境変数、コマンドライン引数、またはボリューム内の設定ファイルとして使用できます。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>、
<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>、など)を参照することはできません。</div><h2 id=コンテナのprobe>コンテナのProbe</h2><p><em>Probe</em> はkubeletがコンテナに対して行う定期診断です。診断を実行するために、kubeletはさまざまなアクションを実行できます:</p><ul><li><code>ExecAction</code> (コンテナランタイムの助けを借りて実行)</li><li><code>TCPSocketAction</code> (kubeletにより直接チェック)</li><li><code>HTTPGetAction</code> (kubeletにより直接チェック)</li></ul><p>更に詳しく知りたい場合は、Podのライフサイクルドキュメントにある<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>Probe</a>を読んでください。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>について学ぶ。</li><li><a href=/ja/docs/concepts/containers/runtime-class/>RuntimeClass</a>と、それを用いてPodごとに異なるコンテナランタイム設定する方法について学ぶ。</li><li><a href=/ja/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>と、それを使用してクラスターの停止(disruption)中にアプリケーションの可用性を管理する方法について読む。</li><li>PodはKubernetes REST API内のトップレベルのリソースです。
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/>Pod</a>オブジェクトの定義では、オブジェクトの詳細について記述されています。</li><li><a href=/blog/2015/06/the-distributed-system-toolkit-patterns/>The Distributed System Toolkit: Patterns for Composite Containers</a>では、2つ以上のコンテナを利用する場合の一般的なレイアウトについて説明しています。</li><li><a href=/docs/concepts/scheduling-eviction/topology-spread-constraints/>Podトポロジー分布制約</a>について読む。</li></ul><p>Kubernetesが共通のPod APIを他のリソース内(たとえば<a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>や<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>など)にラッピングしている理由の文脈を理解するためには、Kubernetes以前から存在する以下のような既存技術について読むのが助けになります。</p><ul><li><a href=https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a></li><li><a href=https://research.google.com/pubs/pub43438.html>Borg</a></li><li><a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a></li><li><a href=https://research.google/pubs/pub41684/>Omega</a></li><li><a href=https://engineering.fb.com/data-center-engineering/tupperware/>Tupperware</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-37afa6c66c74400d1579f10faf55e5b6>1.1 - Podの概観</h1><p>このページでは、Kubernetesのオブジェクトモデルにおいて、デプロイ可能な最小単位のオブジェクトである<code>Pod</code>に関して説明します。</p><h2 id=understanding-pods>Podについて理解する</h2><p><em>Pod</em> は、Kubernetesアプリケーションの基本的な実行単位です。これは、作成またはデプロイするKubernetesオブジェクトモデルの中で最小かつ最も単純な単位です。Podは、<a class=glossary-tooltip title=コンテナ化されたアプリケーションを実行する、ノードと呼ばれるワーカーマシンの集合です。すべてのクラスターには少なくとも1つのワーカーノードがあります。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=クラスター>クラスター</a>で実行されているプロセスを表します。</p><p>Podは、アプリケーションのコンテナ(いくつかの場合においては複数のコンテナ)、ストレージリソース、ユニークなネットワークIP、およびコンテナの実行方法を管理するオプションをカプセル化します。Podはデプロイメントの単位、すなわち<em>Kubernetesのアプリケーションの単一インスタンス</em> で、単一の<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>または密結合なリソースを共有する少数のコンテナで構成される場合があります。</p><p><a href=https://www.docker.com>Docker</a>はKubernetesのPod内で使われる最も一般的なコンテナランタイムですが、Podは他の<a href=/ja/docs/setup/production-environment/container-runtimes/>コンテナランタイム</a>も同様にサポートしています。</p><p>Kubernetesクラスター内でのPodは2つの主な方法で使うことができます。</p><ul><li><strong>単一のコンテナを稼働させるPod</strong> : いわゆる*「1Pod1コンテナ」* 構成のモデルは、最も一般的なKubernetesのユースケースです。
このケースでは、ユーザーはPodを単一のコンテナのラッパーとして考えることができ、Kubernetesはコンテナを直接扱うというよりは、Podを管理することになります。</li><li><strong>協調して稼働させる必要がある複数のコンテナを稼働させるPod</strong> : 単一のPodは、リソースを共有する必要があるような、密接に連携した複数の同じ環境にあるコンテナからなるアプリケーションをカプセル化することもできます。 これらの同じ環境にあるコンテナ群は、サービスの結合力の強いユニットを構成することができます。
-- 1つのコンテナが、共有されたボリュームからファイルをパブリックな場所に送信し、一方では分割された<em>サイドカー</em> コンテナがそれらのファイルを更新します。そのPodはそれらのコンテナとストレージリソースを、単一の管理可能なエンティティとしてまとめます。</li></ul><p><a href=https://kubernetes.io/blog>Kubernetes Blog</a>にて、Podのユースケースに関するいくつかの追加情報を見ることができます。さらなる情報を得たい場合は、下記のページを参照ください。</p><ul><li><a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>The Distributed System Toolkit: Patterns for Composite Containers</a></li><li><a href=https://kubernetes.io/blog/2016/06/container-design-patterns>Container Design Patterns</a></li></ul><p>各Podは、与えられたアプリケーションの単一のインスタンスを稼働するためのものです。もしユーザーのアプリケーションを水平にスケールさせたい場合(例: 複数インスタンスを稼働させる)、複数のPodを使うべきです。1つのPodは各インスタンスに対応しています。
Kubernetesにおいて、これは一般的に <em>レプリケーション</em> と呼ばれます。
レプリケーションされたPodは、通常コントローラーと呼ばれる抽象概念によって単一のグループとして作成、管理されます。
さらなる情報に関しては<a href=#pods-and-controllers>Podとコントローラー</a>を参照して下さい。</p><h3 id=podがどのように複数のコンテナを管理しているか>Podがどのように複数のコンテナを管理しているか</h3><p>Podは凝集性の高いサービスのユニットを構成するような複数の協調プロセス(コンテナ）をサポートするためにデザインされました。
単一のPod内のコンテナ群は、クラスター内において同一の物理マシンもしくは仮想マシン上において自動で同じ環境に配備され、スケジュールされます。コンテナはリソースや依存関係を共有し、お互いにコミュニケートし、それらがいつ、どのように削除されるかを調整できます。</p><p>注意点として、単一のPod内で同じ環境に配備され、同時管理される複数のコンテナをグルーピングするのは、比較的に発展的なユースケースとなります。
ユーザーは、コンテナ群が密接に連携するような、特定のインスタンスにおいてのみこのパターンを使用するべきです。
例えば、ユーザーが共有ボリューム内にあるファイル用のWebサーバとして稼働するコンテナと、下記のダイアグラムにあるような、リモートのソースからファイルを更新するような分離された<em>サイドカー</em> コンテナを持っているような場合です。</p><figure><img src=/images/docs/pod.svg alt=Podのダイアグラム width=50%></figure><p>Podは、Podによって構成されたコンテナ群のために2種類の共有リソースを提供します。 <em>ネットワーキング</em> と<em>ストレージ</em> です。</p><h4 id=ネットワーキング>ネットワーキング</h4><p>各Podは固有のIPアドレスを割り当てられます。単一のPod内の各コンテナは、IPアドレスやネットワークポートを含む、そのネットワークの名前空間を共有します。<em>Pod内の</em> コンテナは<code>localhost</code>を使用してお互いに疎通できます。単一のPod内のコンテナが<em>Pod外</em> のエンティティと疎通する場合、共有されたネットワークリソース(ポートなど）をどのように使うかに関して調整しなければなりません。</p><h4 id=ストレージ>ストレージ</h4><p>単一のPodは共有されたストレージ<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>のセットを指定できます。Pod内の全てのコンテナは、その共有されたボリュームにアクセスでき、コンテナ間でデータを共有することを可能にします。ボリュームもまた、もしPod内のコンテナの1つが再起動が必要になった場合に備えて、データを永続化できます。
単一のPod内での共有ストレージをKubernetesがどう実装しているかについてのさらなる情報については、<a href=/docs/concepts/storage/volumes/>Volumes</a>を参照してください。</p><h2 id=podを利用する>Podを利用する</h2><p>ユーザーはまれに、Kubernetes内で独立したPodを直接作成する場合があります(シングルトンPodなど)。
これはPodが比較的、一時的な使い捨てエンティティとしてデザインされているためです。Podが作成された時(ユーザーによって直接的、またはコントローラーによって間接的に作成された場合)、ユーザーのクラスター内の単一の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>上で稼働するようにスケジューリングされます。そのPodはプロセスが停止されたり、Podオブジェクトが削除されたり、Podがリソースの欠如のために<em>追い出され</em> たり、ノードが故障するまでノード上に残り続けます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 単一のPod内でのコンテナを再起動することと、そのPodを再起動することを混同しないでください。Podはそれ自体は実行されませんが、コンテナが実行される環境であり、削除されるまで存在し続けます。</div><p>Podは、Podそれ自体によって自己修復しません。もし、稼働されていないノード上にPodがスケジュールされた場合や、スケジューリング操作自体が失敗した場合、Podが削除されます。同様に、Podはリソースの欠如や、ノードのメンテナンスによる追い出しがあった場合はそこで停止します。Kubernetesは<em>コントローラー</em> と呼ばれる高レベルの抽象概念を使用し、それは比較的使い捨て可能なPodインスタンスの管理を行います。
このように、Podを直接使うのは可能ですが、コントローラーを使用したPodを管理する方がより一般的です。KubernetesがPodのスケーリングと修復機能を実現するためにコントローラーをどのように使うかに関する情報は<a href=#pods-and-controllers>Podとコントローラー</a>を参照してください。</p><h3 id=podとコントローラー>Podとコントローラー</h3><p>単一のコントローラーは、ユーザーのために複数のPodを作成・管理し、レプリケーションやロールアウト、クラスターのスコープ内で自己修復の機能をハンドリングします。例えば、もしノードが故障した場合、コントローラーは異なるノード上にPodを置き換えるようにスケジューリングすることで、自動的にリプレース可能となります。</p><p>1つまたはそれ以上のPodを含むコントローラーの例は下記の通りです。</p><ul><li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a></li><li><a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li></ul><p>通常は、コントローラーはユーザーが作成したPodテンプレートを使用して、担当するPodを作成します。</p><h2 id=podテンプレート>Podテンプレート</h2><p>Podテンプレートは、<a href=/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>、 <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/>Job</a>や、
<a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>のような他のオブジェクト内で含まれるPodの仕様となります。
コントローラーは実際のPodを作成するためにPodテンプレートを使用します。
下記のサンプルは、メッセージを表示する単一のコンテナを含んだ、シンプルなPodのマニフェストとなります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>myapp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo Hello Kubernetes! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>全てのレプリカの現在の理想的な状態を指定するというよりも、Podテンプレートはクッキーの抜き型のようなものです。一度クッキーがカットされると、そのクッキーは抜き型から離れて関係が無くなります。そこにはいわゆる”量子もつれ”といったものはありません。テンプレートに対するその後の変更や新しいテンプレートへの切り替えは、すでに作成されたPod上には直接的な影響はありません。
同様に、ReplicationControllerによって作成されたPodは、変更後に直接更新されます。これはPodとの意図的な違いとなり、そのPodに属する全てのコンテナの現在の理想的な状態を指定します。このアプローチは根本的にシステムのセマンティクスを単純化し、機能の柔軟性を高めます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/workloads/pods/pod/>Pod</a>についてさらに学びましょう</li><li>Podの振る舞いに関して学ぶには下記を参照してください<ul><li><a href=/ja/docs/concepts/workloads/pods/pod/#termination-of-pods>Podの停止</a></li><li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c3c2b9cf30915ec9d46c147201da3332>1.2 - Podのライフサイクル</h1><p>このページではPodのライフサイクルについて説明します。Podは定義されたライフサイクルに従い <code>Pending</code><a href=#pod-phase>フェーズ</a>から始まり、少なくとも1つのプライマリーコンテナが正常に開始した場合は<code>Running</code>を経由し、次に失敗により終了したコンテナの有無に応じて、<code>Succeeded</code>または<code>Failed</code>フェーズを経由します。</p><p>Podの実行中、kubeletはコンテナを再起動して、ある種の障害を処理できます。Pod内で、Kubernetesはさまざまなコンテナの<a href=#container-states>ステータス</a>を追跡して、回復させるためのアクションを決定します。</p><p>Kubernetes APIでは、Podには仕様と実際のステータスの両方があります。Podオブジェクトのステータスは、<a href=#pod-conditions>PodのCondition</a>のセットで構成されます。<a href=#pod-readiness-gate>カスタムのReadiness情報</a>をPodのConditionデータに挿入することもできます。</p><p>Podはその生存期間に1回だけ<a href=/docs/concepts/scheduling-eviction/>スケジューリング</a>されます。PodがNodeにスケジュール(割り当て)されると、Podは停止または<a href=#pod-termination>終了</a>するまでそのNode上で実行されます。</p><h2 id=podのライフタイム>Podのライフタイム</h2><p>個々のアプリケーションコンテナと同様に、Podは(永続的ではなく)比較的短期間の存在と捉えられます。Podが作成されると、一意のID(<a href=/ja/docs/concepts/overview/working-with-objects/names/#uids>UID</a>)が割り当てられ、(再起動ポリシーに従って)終了または削除されるまでNodeで実行されるようにスケジュールされます。<br><a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>が停止した場合、そのNodeにスケジュールされたPodは、タイムアウト時間の経過後に<a href=#pod-garbage-collection>削除</a>されます。</p><p>Pod自体は、自己修復しません。Podが<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a>にスケジュールされ、その後に失敗、またはスケジュール操作自体が失敗した場合、Podは削除されます。同様に、リソースの不足またはNodeのメンテナンスによりPodはNodeから立ち退きます。Kubernetesは、比較的使い捨てのPodインスタンスの管理作業を処理する、<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>と呼ばれる上位レベルの抽象化を使用します。</p><p>特定のPod(UIDで定義)は新しいNodeに"再スケジュール"されません。代わりに、必要に応じて同じ名前で、新しいUIDを持つ同一のPodに置き換えることができます。</p><p><a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a>など、Podと同じ存続期間を持つものがあると言われる場合、それは(そのUIDを持つ)Podが存在する限り存在することを意味します。そのPodが何らかの理由で削除された場合、たとえ同じ代替物が作成されたとしても、関連するもの(例えばボリューム)も同様に破壊されて再作成されます。</p><figure><img src=/images/docs/pod.svg width=50%><figcaption><h4>Podの図</h4></figcaption></figure><p><em>file puller(ファイル取得コンテナ)とWebサーバーを含むマルチコンテナのPod。コンテナ間の共有ストレージとして永続ボリュームを使用しています。</em></p><h2 id=pod-phase>Podのフェーズ</h2><p>Podの<code>status</code>項目は<a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a>オブジェクトで、それは<code>phase</code>のフィールドがあります。</p><p>Podのフェーズは、そのPodがライフサイクルのどの状態にあるかを、簡単かつ高レベルにまとめたものです。このフェーズはコンテナやPodの状態を包括的にまとめることを目的としたものではなく、また包括的なステートマシンでもありません。</p><p>Podの各フェーズの値と意味は厳重に守られています。ここに記載されているもの以外に<code>phase</code>の値は存在しないと思ってください。</p><p>これらが<code>phase</code>の取りうる値です。</p><table><thead><tr><th style=text-align:left>値</th><th style=text-align:left>概要</th></tr></thead><tbody><tr><td style=text-align:left><code>Pending</code></td><td style=text-align:left>PodがKubernetesクラスターによって承認されましたが、1つ以上のコンテナがセットアップされて稼働する準備ができていません。これには、スケジュールされるまでの時間と、ネットワーク経由でイメージをダウンロードするための時間などが含まれます。</td></tr><tr><td style=text-align:left><code>Running</code></td><td style=text-align:left>PodがNodeにバインドされ、すべてのコンテナが作成されました。少なくとも1つのコンテナがまだ実行されているか、開始または再起動中です。</td></tr><tr><td style=text-align:left><code>Succeeded</code></td><td style=text-align:left>Pod内のすべてのコンテナが正常に終了し、再起動されません。</td></tr><tr><td style=text-align:left><code>Failed</code></td><td style=text-align:left>Pod内のすべてのコンテナが終了し、少なくとも1つのコンテナが異常終了しました。つまり、コンテナはゼロ以外のステータスで終了したか、システムによって終了されました。</td></tr><tr><td style=text-align:left><code>Unknown</code></td><td style=text-align:left>何らかの理由によりPodの状態を取得できませんでした。このフェーズは通常はPodのホストとの通信エラーにより発生します。</td></tr></tbody></table><p>Nodeが停止するか、クラスタの残りの部分から切断された場合、Kubernetesは失われたNode上のすべてのPodの<code>Phase</code>をFailedに設定するためのポリシーを適用します。</p><h2 id=container-states>コンテナのステータス</h2><p>Pod全体の<a href=#pod-phase>フェーズ</a>と同様に、KubernetesはPod内の各コンテナの状態を追跡します。<a href=/ja/docs/concepts/containers/container-lifecycle-hooks/>container lifecycle hooks</a>を使用して、コンテナのライフサイクルの特定のポイントで実行するイベントをトリガーできます。</p><p>Podが<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=scheduler>scheduler</a>によってNodeに割り当てられると、kubeletは<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label='container runtime'>container runtime</a>を使用してコンテナの作成を開始します。コンテナの状態は<code>Waiting</code>、<code>Running</code>または<code>Terminated</code>の3ついずれかです。</p><p>Podのコンテナの状態を確認するには<code>kubectl describe pod [POD_NAME]</code>のコマンドを使用します。Pod内のコンテナごとにStateの項目として表示されます。</p><p>各状態の意味は次のとおりです。</p><h3 id=container-state-waiting><code>Waiting</code></h3><p>コンテナが<code>Running</code>または<code>Terminated</code>のいずれの状態でもない場合コンテナは<code>Waiting</code>の状態になります。Waiting状態のコンテナは引き続きコンテナイメージレジストリからイメージを取得したり<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>を適用したりするなど必要な操作を実行します。<code>Waiting</code>状態のコンテナを持つPodに対して<code>kubectl</code>コマンドを使用すると、そのコンテナが<code>Waiting</code>の状態である理由の要約が表示されます。</p><h3 id=container-state-running><code>Running</code></h3><p><code>Running</code>状態はコンテナが問題なく実行されていることを示します。<code>postStart</code>フックが構成されていた場合、それはすでに実行が完了しています。<code>Running</code>状態のコンテナを持つPodに対して<code>kubectl</code>コマンドを使用すると、そのコンテナが<code>Running</code>状態になった時刻が表示されます。</p><h3 id=container-state-terminated><code>Terminated</code></h3><p><code>Terminated</code>状態のコンテナは実行されて、完了したときまたは何らかの理由で失敗したことを示します。<code>Terminated</code>状態のコンテナを持つPodに対して<code>kubectl</code>コマンドを使用すると、いずれにせよ理由と終了コード、コンテナの開始時刻と終了時刻が表示されます。</p><p>コンテナがTerminatedに入る前に<code>preStop</code>フックがあれば実行されます。</p><h2 id=restart-policy>コンテナの再起動ポリシー</h2><p>Podの<code>spec</code>には、Always、OnFailure、またはNeverのいずれかの値を持つ<code>restartPolicy</code>フィールドがあります。デフォルト値はAlwaysです。</p><p><code>restartPolicy</code>は、Pod内のすべてのコンテナに適用されます。<code>restartPolicy</code>は、同じNode上のkubeletによるコンテナの再起動のみを参照します。Pod内のコンテナが終了した後、kubeletは5分を上限とする指数バックオフ遅延（10秒、20秒、40秒...）でコンテナを再起動します。コンテナが10分間実行されると、kubeletはコンテナの再起動バックオフタイマーをリセットします。</p><h2 id=pod-conditions>PodのCondition</h2><p>PodにはPodStatusがあります。それはPodが成功したかどうかの情報を持つ<a href=/docs/reference/generated/kubernetes-api/v1.25/#podcondition-v1-core>PodConditions</a>の配列です。</p><ul><li><code>PodScheduled</code>: PodがNodeにスケジュールされました。</li><li><code>ContainersReady</code>: Pod内のすべてのコンテナが準備できた状態です。</li><li><code>Initialized</code>: すべての<a href=/ja/docs/concepts/workloads/pods/init-containers>Initコンテナ</a>が正常に実行されました。</li><li><code>Ready</code>: Podはリクエストを処理でき、一致するすべてのサービスの負荷分散プールに追加されます。</li></ul><table><thead><tr><th style=text-align:left>フィールド名</th><th style=text-align:left>内容</th></tr></thead><tbody><tr><td style=text-align:left><code>type</code></td><td style=text-align:left>このPodの状態の名前です。</td></tr><tr><td style=text-align:left><code>status</code></td><td style=text-align:left>その状態が適用可能かどうか示します。可能な値は"<code>True</code>"と"<code>False</code>"、"<code>Unknown</code>"のうちのいずれかです。</td></tr><tr><td style=text-align:left><code>lastProbeTime</code></td><td style=text-align:left>Pod Conditionが最後に確認されたときのタイムスタンプが表示されます。</td></tr><tr><td style=text-align:left><code>lastTransitionTime</code></td><td style=text-align:left>最後にPodのステータスの遷移があった際のタイムスタンプが表示されます。</td></tr><tr><td style=text-align:left><code>reason</code></td><td style=text-align:left>最後の状態遷移の理由を示す、機械可読のアッパーキャメルケースのテキストです。</td></tr><tr><td style=text-align:left><code>message</code></td><td style=text-align:left>ステータスの遷移に関する詳細を示す人間向けのメッセージです。</td></tr></tbody></table><h2 id=pod-readiness-gate>PodのReadiness</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code></div><p>追加のフィードバックやシグナルをPodStatus:_Pod readiness_に注入できるようにします。これを使用するには、Podの<code>spec</code>で<code>readinessGates</code>を設定して、kubeletがPodのReadinessを評価する追加の状態のリストを指定します。</p><p>ReadinessゲートはPodの<code>status.conditions</code>フィールドの現在の状態によって決まります。Kubernetesが<code>Podのstatus.conditions</code>フィールドでそのような状態を発見できない場合、ステータスはデフォルトで<code>False</code>になります。</p><p>以下はその例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>Kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readinessGates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>conditionType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready <span style=color:#bbb> </span><span style=color:#080;font-style:italic># これはビルトインのPodCondition</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># 追加のPodCondition</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://abcd...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>PodのConditionは、Kubernetesの<a href=/ja/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set>label key format</a>に準拠している必要があります。</p><h3 id=pod-readiness-status>PodのReadinessの状態</h3><p><code>kubectl patch</code>コマンドはオブジェクトステータスのパッチ適用をまだサポートしていません。Podにこれらの<code>status.conditions</code>を設定するには、アプリケーションと<a class=glossary-tooltip title='A specialized controller used to manage a custom resource' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operators>operators</a>は<code>PATCH</code>アクションを使用する必要があります。<a href=/docs/reference/using-api/client-libraries/>Kubernetes client library</a>を使用して、PodのReadinessのためにカスタムのPodのConditionを設定するコードを記述できます。</p><p>カスタムのPodのConditionが導入されるとPodは次の両方の条件に当てはまる場合<strong>のみ</strong>準備できていると評価されます:</p><ul><li>Pod内のすべてのコンテナが準備完了している。</li><li><code>ReadinessGates</code>で指定された条件が全て<code>True</code>である。</li></ul><p>Podのコンテナは準備完了ですが、少なくとも1つのカスタムのConditionが欠落しているか「False」の場合、kubeletはPodの<a href=#pod-condition>Condition</a>を<code>ContainersReady</code>に設定します。</p><h2 id=container-probes>コンテナのProbe</h2><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core>Probe</a> は <a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> により定期的に実行されるコンテナの診断です。診断を行うために、kubeletはコンテナに実装された <a href=/docs/reference/generated/kubernetes-api/v1.25/#handler-v1-core>Handler</a>を呼びます。Handlerには次の3つの種類があります:</p><ul><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#execaction-v1-core>ExecAction</a>:
コンテナ内で特定のコマンドを実行します。コマンドがステータス0で終了した場合に診断を成功と見まします。</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#tcpsocketaction-v1-core>TCPSocketAction</a>:
PodのIPの特定のポートにTCPチェックを行います。
そのポートが空いていれば診断を成功とみなします。</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#httpgetaction-v1-core>HTTPGetAction</a>:
PodのIPの特定のポートとパスに対して、HTTP GETのリクエストを送信します。
レスポンスのステータスコードが200以上400未満の際に診断を成功とみなします。</p></li></ul><p>各Probe 次の3つのうちの一つの結果を持ちます:</p><ul><li><code>Success</code>: コンテナの診断が成功しました。</li><li><code>Failure</code>: コンテナの診断が失敗しました。</li><li><code>Unknown</code>: コンテナの診断が失敗し、取れるアクションがありません。</li></ul><p>Kubeletは3種類のProbeを実行中のコンテナで行い、また反応することができます:</p><ul><li><p><code>livenessProbe</code>: コンテナが動いているかを示します。
livenessProbe に失敗すると、kubeletはコンテナを殺します、そしてコンテナは<a href=#restart-policy>restart policy</a>に従います。
コンテナにlivenessProbeが設定されていない場合、デフォルトの状態は<code>Success</code>です。</p></li><li><p><code>readinessProbe</code>: コンテナがリクエスト応答する準備ができているかを示します。
readinessProbeに失敗すると、エンドポイントコントローラーにより、ServiceからそのPodのIPアドレスが削除されます。
initial delay前のデフォルトのreadinessProbeの初期値は<code>Failure</code>です。
コンテナにreadinessProbeが設定されていない場合、デフォルトの状態は<code>Success</code>です。</p></li><li><p><code>startupProbe</code>: コンテナ内のアプリケーションが起動したかどうかを示します。
startupProbeが設定された場合、完了するまでその他のすべてのProbeは無効になります。
startupProbeに失敗すると、kubeletはコンテナを殺します、そしてコンテナは<a href=#restart-policy>restart policy</a>に従います。
コンテナにstartupProbeが設定されていない場合、デフォルトの状態は<code>Success</code>です。</p></li></ul><p>livenessProbe、readinessProbeまたはstartupProbeを設定する方法の詳細については、<a href=/ja/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>Liveness Probe、Readiness ProbeおよびStartup Probeを使用する</a>を参照してください。</p><h3 id=when-should-you-use-a-liveness-probe>livenessProbeをいつ使うべきか?</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code></div><p>コンテナ自体に問題が発生した場合や状態が悪くなった際にクラッシュすることができればlivenessProbeは不要です.
この場合kubeletが自動でPodの<code>restartPolicy</code>に基づいたアクションを実行します。</p><p>Probeに失敗したときにコンテナを殺したり再起動させたりするには、livenessProbeを設定し<code>restartPolicy</code>をAlwaysまたはOnFailureにします。</p><h3 id=when-should-you-use-a-readiness-probe>readinessProbeをいつ使うべきか?</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code></div><p>Probeが成功したときにのみPodにトラフィックを送信したい場合は、readinessProbeを指定します。
この場合readinessProbeはlivenessProbeと同じになる可能性がありますが、readinessProbeが存在するということは、Podがトラフィックを受けずに開始され、Probe成功が開始した後でトラフィックを受け始めることになります。コンテナが起動時に大きなデータ、構成ファイル、またはマイグレーションを読み込む必要がある場合は、readinessProbeを指定します。</p><p>コンテナがメンテナンスのために停止できるようにするには、livenessProbeとは異なる、特定のエンドポイントを確認するreadinessProbeを指定することができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Podが削除されたときにリクエストを来ないようにするためには必ずしもreadinessProbeが必要というわけではありません。Podの削除時にはreadinessProbeが存在するかどうかに関係なくPodは自動的に自身をunreadyにします。Pod内のコンテナが停止するのを待つ間Podはunreadyのままです。</div><h3 id=when-should-you-use-a-startup-probe>startupProbeをいつ使うべきか?</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>startupProbeは、サービスの開始に時間がかかるコンテナを持つPodに役立ちます。livenessProbeの間隔を長く設定するのではなく、コンテナの起動時に別のProbeを構成して、livenessProbeの間隔よりも長い時間を許可できます。
コンテナの起動時間が、<code>initialDelaySeconds + failureThreshold x periodSeconds</code>よりも長い場合は、livenessProbeと同じエンドポイントをチェックするためにstartupProbeを指定します。<code>periodSeconds</code>のデフォルトは30秒です。次に、<code>failureThreshold</code>をlivenessProbeのデフォルト値を変更せずにコンテナが起動できるように、十分に高い値を設定します。これによりデッドロックを防ぐことができます。</p><h2 id=pod-termination>Podの終了</h2><p>Podは、クラスター内のNodeで実行中のプロセスを表すため、不要になったときにそれらのプロセスを正常に終了できるようにすることが重要です(対照的なケースは、KILLシグナルで強制終了され、クリーンアップする機会がない場合)。</p><p>ユーザーは削除を要求可能であるべきで、プロセスがいつ終了するかを知ることができなければなりませんが、削除が最終的に完了することも保証できるべきです。ユーザーがPodの削除を要求すると、システムはPodが強制終了される前に意図された猶予期間を記録および追跡します。強制削除までの猶予期間がある場合、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>正常な終了を試みます。</p><p>通常、コンテナランタイムは各コンテナのメインプロセスにTERMシグナルを送信します。多くのコンテナランタイムは、コンテナイメージで定義されたSTOPSIGNAL値を尊重し、TERMシグナルの代わりにこれを送信します。猶予期間が終了すると、プロセスにKILLシグナルが送信され、Podは<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API server'>API server</a>から削除されます。プロセスの終了を待っている間にkubeletかコンテナランタイムの管理サービスが再起動されると、クラスターは元の猶予期間を含めて、最初からリトライされます。</p><p>フローの例は下のようになります。</p><ol><li>ユーザーがデフォルトの猶予期間(30秒)でPodを削除するために<code>kubectl</code>コマンドを送信する。</li><li>API server内のPodは、猶予期間を越えるとPodが「死んでいる」と見なされるように更新される。<br>削除中のPodに対して<code>kubectl describe</code>コマンドを使用すると、Podは「終了中」と表示される。<br>Podが実行されているNode上で、Podが終了しているとマークされている(正常な終了期間が設定されている)とkubeletが認識するとすぐに、kubeletはローカルでPodの終了プロセスを開始します。<ol><li>Pod内のコンテナの1つが<code>preStop</code><a href=/ja/docs/concepts/containers/container-lifecycle-hooks/#hook-details>フック</a>を定義している場合は、コンテナの内側で呼び出される。猶予期間が終了した後も <code>preStop</code>フックがまだ実行されている場合は、一度だけ猶予期間を延長される(2秒)。<div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>preStop</code>フックが完了するまでにより長い時間が必要な場合は、<code>terminationGracePeriodSeconds</code>を変更する必要があります。</div></li><li>kubeletはコンテナランタイムをトリガーして、コンテナ内のプロセス番号1にTERMシグナルを送信する。<div class="alert alert-info note callout" role=alert><strong>備考:</strong> Pod内のすべてのコンテナが同時にTERMシグナルを受信するわけではなく、シャットダウンの順序が問題になる場合はそれぞれに<code>preStop</code>フックを使用して同期することを検討する。</div></li></ol></li><li>kubeletが正常な終了を開始すると同時に、コントロールプレーンは、終了中のPodをEndpoints(および有効な場合はEndpointSlice)オブジェクトから削除します。これらのオブジェクトは、<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selector>selector</a>が設定された<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を表します。<a class=glossary-tooltip title=ReplicaSetは、指定された数のPodレプリカが一度に動作するように保証します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSets>ReplicaSets</a>とその他のワークロードリソースは、終了中のPodを有効なサービス中のReplicaSetとして扱いません。ゆっくりと終了するPodは、(サービスプロキシーのような)ロードバランサーが終了猶予期間が_始まる_とエンドポイントからそれらのPodを削除するので、トラフィックを継続して処理できません。</li><li>猶予期間が終了すると、kubeletは強制削除を開始する。コンテナランタイムは、Pod内でまだ実行中のプロセスに<code>SIGKILL</code>を送信する。kubeletは、コンテナランタイムが非表示の<code>pause</code>コンテナを使用している場合、そのコンテナをクリーンアップします。</li><li>kubeletは猶予期間を0(即時削除)に設定することでAPI server上のPodの削除を終了する。</li><li>API serverはPodのAPIオブジェクトを削除し、クライアントからは見えなくなります。</li></ol><h3 id=pod-termination-forced>Podの強制削除</h3><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> 強制削除は、Podによっては潜在的に危険な場合があるため、慎重に実行する必要があります。</div><p>デフォルトでは、すべての削除は30秒以内に正常に行われます。<code>kubectl delete</code> コマンドは、ユーザーがデフォルト値を上書きして独自の値を指定できるようにする <code>--grace-period=&lt;seconds></code> オプションをサポートします。</p><p><code>--grace-period</code>を<code>0</code>に設定した場合、PodはAPI serverから即座に強制的に削除されます。PodがNode上でまだ実行されている場合、その強制削除によりkubeletがトリガーされ、すぐにクリーンアップが開始されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 強制削除を実行するために <code>--grace-period=0</code> と共に <code>--force</code> というフラグを追加で指定する必要があります。</div><p>強制削除が実行されると、API serverは、Podが実行されていたNode上でPodが停止されたというkubeletからの確認を待ちません。API内のPodは直ちに削除されるため、新しいPodを同じ名前で作成できるようになります。Node上では、すぐに終了するように設定されるPodは、強制終了される前にわずかな猶予期間が与えられます。</p><p>StatefulSetのPodについては、<a href=/ja/docs/tasks/run-application/force-delete-stateful-set-pod/>StatefulSetからPodを削除するためのタスクのドキュメント</a>を参照してください。</p><h3 id=pod-garbage-collection>終了したPodのガベージコレクション</h3><p>失敗したPodは人間または<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>が明示的に削除するまで存在します。</p><p>コントロールプレーンは終了状態のPod(SucceededまたはFailedの<code>phase</code>を持つ)の数が設定された閾値(kube-controller-manager内の<code>terminated-pod-gc-threshold</code>によって定義される)を超えたとき、それらのPodを削除します。これはPodが作成されて時間とともに終了するため、リソースリークを避けます。</p><h2 id=次の項目>次の項目</h2><ul><li><p><a href=/ja/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>attaching handlers to Container lifecycle events</a>のハンズオンをやってみる</p></li><li><p><a href=/ja/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>Configure Liveness, Readiness and Startup Probes</a>のハンズオンをやってみる</p></li><li><p><a href=/ja/docs/concepts/containers/container-lifecycle-hooks/>Container lifecycle hooks</a>についてもっと学ぶ</p></li><li><p>APIのPod/コンテナステータスの詳細情報は<a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a>および<a href=/docs/reference/generated/kubernetes-api/v1.25/#containerstatus-v1-core>ContainerStatus</a>を参照してください</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ccbd4eeded6ab138d98b59175bd557e>1.3 - Initコンテナ</h1><p>このページでは、Initコンテナについて概観します。Initコンテナとは、<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>内でアプリケーションコンテナの前に実行される特別なコンテナです。
Initコンテナにはアプリケーションコンテナのイメージに存在しないセットアップスクリプトやユーティリティーを含めることができます。</p><p>Initコンテナは、Podの仕様のうち<code>containers</code>という配列(これがアプリケーションコンテナを示します)と並べて指定します。</p><h2 id=understanding-init-containers>Initコンテナを理解する</h2><p>単一の<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>は、Pod内にアプリケーションを実行している複数のコンテナを持つことができますが、同様に、アプリケーションコンテナが起動する前に実行されるInitコンテナも1つ以上持つことができます。</p><p>Initコンテナは下記の項目をのぞいて、通常のコンテナと全く同じものとなります。</p><ul><li>Initコンテナは常に完了するまで稼働します。</li><li>各Initコンテナは、次のInitコンテナが稼働する前に正常に完了しなくてはなりません。</li></ul><p>もしあるPodの単一のInitコンテナが失敗した場合、Kubeletは成功するまで何度もそのInitコンテナを再起動します。しかし、もしそのPodの<code>restartPolicy</code>がNeverで、そのPodの起動時にInitコンテナが失敗した場合、KubernetesはそのPod全体を失敗として扱います。</p><p>PodにInitコンテナを指定するためには、<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec>Podの仕様</a>に<code>initContainers</code>フィールドを<code>container</code>アイテムの配列として追加してください(アプリケーションの<code>containers</code>フィールドとそのコンテンツに似ています)。
詳細については、APIリファレンスの<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>Container</a>を参照してください。</p><p>Initコンテナのステータスは、<code>.status.initContainerStatuses</code>フィールドにコンテナのステータスの配列として返されます(<code>.status.containerStatuses</code>と同様)。</p><h3 id=differences-from-regular-containers>通常のコンテナとの違い</h3><p>Initコンテナは、リソースリミット、ボリューム、セキュリティ設定などのアプリケーションコンテナの全てのフィールドと機能をサポートしています。しかし、Initコンテナに対するリソースリクエストやリソースリミットの扱いは異なります。<a href=#resources>リソース</a>にて説明します。</p><p>また、InitコンテナはそのPodの準備ができる前に完了しなくてはならないため、<code>lifecycle</code>、<code>livenessProbe</code>、<code>readinessProbe</code>および<code>startupProbe</code>をサポートしていません。</p><p>複数のInitコンテナを単一のPodに対して指定した場合、KubeletはそれらのInitコンテナを1つずつ順番に実行します。各Initコンテナは、次のInitコンテナが稼働する前に正常終了しなくてはなりません。全てのInitコンテナの実行が完了すると、KubeletはPodのアプリケーションコンテナを初期化し、通常通り実行します。</p><h2 id=using-init-containers>Initコンテナを使用する</h2><p>Initコンテナはアプリケーションコンテナのイメージとは分離されているため、コンテナの起動に関連したコードにおいていくつかの利点があります。</p><ul><li>Initコンテナはアプリケーションのイメージに存在しないセットアップ用のユーティリティーやカスタムコードを含むことができます。例えば、セットアップ中に<code>sed</code>、<code>awk</code>、<code>python</code>や、<code>dig</code>のようなツールを使うためだけに、別のイメージを元にしてアプリケーションイメージを作る必要がなくなります。</li><li>アプリケーションイメージをビルドする役割とデプロイする役割は、共同で単一のアプリケーションイメージをビルドする必要がないため、それぞれ独立して実施することができます。</li><li>Initコンテナは同一Pod内のアプリケーションコンテナと別のファイルシステムビューで稼働することができます。その結果、アプリケーションコンテナがアクセスできない<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>に対するアクセス権限を得ることができます。</li><li>Initコンテナはアプリケーションコンテナが開始する前に完了するまで実行されるため、Initコンテナを使用することで、特定の前提条件が満たされるまでアプリケーションコンテナの起動をブロックしたり遅らせることができます。前提条件が満たされると、Pod内の全てのアプリケーションコンテナを並行して起動することができます。</li><li>Initコンテナはアプリケーションコンテナイメージの安全性を低下させるようなユーティリティーやカスタムコードを安全に実行することができます。不必要なツールを分離しておくことで、アプリケーションコンテナイメージのアタックサーフィスを制限することができます。</li></ul><h3 id=examples>例</h3><p>Initコンテナを活用する方法について、いくつかのアイデアを次に示します。</p><ul><li><p>シェルコマンドを使って単一の<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>が作成されるのを待機する。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>{</span>1..100<span style=color:#666>}</span>; <span style=color:#a2f;font-weight:700>do</span> sleep 1; <span style=color:#a2f;font-weight:700>if</span> dig myservice; <span style=color:#a2f;font-weight:700>then</span> <span style=color:#a2f>exit</span> 0; <span style=color:#a2f;font-weight:700>fi</span>; <span style=color:#a2f;font-weight:700>done</span>; <span style=color:#a2f>exit</span> <span style=color:#666>1</span>
</span></span></code></pre></div></li><li><p>以下のようなコマンドを使って下位のAPIからPodの情報をリモートサーバに登録する。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X POST http://<span style=color:#b8860b>$MANAGEMENT_SERVICE_HOST</span>:<span style=color:#b8860b>$MANAGEMENT_SERVICE_PORT</span>/register -d <span style=color:#b44>&#39;instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)&#39;</span>
</span></span></code></pre></div></li><li><p>以下のようなコマンドを使ってアプリケーションコンテナの起動を待機する。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sleep <span style=color:#666>60</span>
</span></span></code></pre></div></li><li><p>gitリポジトリを<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a>にクローンする。</p></li><li><p>いくつかの値を設定ファイルに配置し、メインのアプリケーションコンテナのための設定ファイルを動的に生成するためのテンプレートツールを実行する。例えば、そのPodの<code>POD_IP</code>の値を設定ファイルに配置し、Jinjaを使ってメインのアプリケーションコンテナの設定ファイルを生成する。</p></li></ul><h4 id=init-containers-in-use>Initコンテナの具体的な使用方法</h4><p>下記の例は2つのInitコンテナを含むシンプルなPodを定義しています。
1つ目のInitコンテナは<code>myservies</code>の起動を、2つ目のInitコンテナは<code>mydb</code>の起動をそれぞれ待ちます。両方のInitコンテナの実行が完了すると、Podは<code>spec</code>セクションにあるアプリケーションコンテナを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo The app is running! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>次のコマンドを実行して、このPodを開始できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f myapp.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>pod/myapp-pod created
</code></pre><p>そして次のコマンドでステータスを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m
</code></pre><p>より詳細な情報は次のコマンドで確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe -f myapp.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>Name:          myapp-pod
Namespace:     default
[...]
Labels:        app.kubernetes.io/name=MyApp
Status:        Pending
[...]
Init Containers:
  init-myservice:
[...]
    State:         Running
[...]
  init-mydb:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Containers:
  myapp-container:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  ---------    --------    -----    ----                      -------------                           --------      ------        -------
  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container with docker id 5ced34a04634; Security:[seccomp=unconfined]
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container with docker id 5ced34a04634
</code></pre><p>このPod内のInitコンテナのログを確認するためには、次のコマンドを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs myapp-pod -c init-myservice <span style=color:#080;font-style:italic># 1つ目のInitコンテナを調査する</span>
</span></span><span style=display:flex><span>kubectl logs myapp-pod -c init-mydb      <span style=color:#080;font-style:italic># 2つ目のInitコンテナを調査する</span>
</span></span></code></pre></div><p>この時点で、これらのInitコンテナは<code>mydb</code>と<code>myservice</code>という名前のServiceの検出を待機しています。</p><p>これらのServiceを検出させるための構成は以下の通りです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>mydb</code>および<code>myservice</code>というServiceを作成するために、以下のコマンドを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f services.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>service/myservice created
service/mydb created
</code></pre><p>Initコンテナが完了し、<code>myapp-pod</code>というPodがRunning状態に移行したことが確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>NAME        READY     STATUS    RESTARTS   AGE
myapp-pod   1/1       Running   0          9m
</code></pre><p>このシンプルな例を独自のInitコンテナを作成する際の参考にしてください。<a href=#what-s-next>次の項目</a>にさらに詳細な使用例に関するリンクがあります。</p><h2 id=detailed-behavior>Initコンテナのふるまいに関する詳細</h2><p>Podの起動時に、kubeletはネットワークおよびストレージの準備が整うまで、Initコンテナを実行可能な状態にしません。また、kubeletはPodのspecに定義された順番に従ってPodのInitコンテナを起動します。</p><p>各Initコンテナは次のInitコンテナが起動する前に正常に終了しなくてはなりません。もしあるInitコンテナがランタイムにより起動失敗した場合、もしくはエラーで終了した場合、そのPodの<code>restartPolicy</code>の値に従ってリトライされます。しかし、もしPodの<code>restartPolicy</code>が<code>Always</code>に設定されていた場合、Initコンテナの<code>restartPolicy</code>は<code>OnFailure</code>が適用されます。</p><p>Podは全てのInitコンテナが完了するまで<code>Ready</code>状態となりません。Initコンテナ上のポートはServiceによって集約されません。初期化中のPodのステータスは<code>Pending</code>となりますが、<code>Initialized</code>という値はtrueとなります。</p><p>もしそのPodを<a href=#pod-restart-reasons>再起動</a>するとき、または再起動されたとき、全てのInitコンテナは必ず再度実行されます。</p><p>Initコンテナの仕様の変更は、コンテナイメージのフィールドのみに制限されています。
Initコンテナのイメージフィールド値を変更すると、そのPodは再起動されます。</p><p>Initコンテナは何度も再起動、リトライおよび再実行可能なため、べき等(Idempotent)である必要があります。特に、<code>EmptyDirs</code>にファイルを書き込むコードは、書き込み先のファイルがすでに存在している可能性を考慮に入れる必要があります。</p><p>Initコンテナはアプリケーションコンテナの全てのフィールドを持っています。しかしKubernetesは、Initコンテナが完了と異なる状態を定義できないため<code>readinessProbe</code>が使用されることを禁止しています。これはバリデーションの際に適用されます。</p><p>Initコンテナがずっと失敗し続けたままの状態を防ぐために、Podに<code>activeDeadlineSeconds</code>を設定してください。<code>activeDeadlineSeconds</code>の設定はInitコンテナが実行中の時間にも適用されます。しかし<code>activeDeadlineSeconds</code>はInitコンテナが終了した後でも効果があるため、チームがアプリケーションをJobとしてデプロイする場合にのみ使用することが推奨されています。
すでに正しく動作しているPodは<code>activeDeadlineSeconds</code>を設定すると強制終了されます。</p><p>Pod内の各アプリケーションコンテナとInitコンテナの名前はユニークである必要があります。他のコンテナと同じ名前を共有していた場合、バリデーションエラーが返されます。</p><h3 id=resources>リソース</h3><p>Initコンテナの順序と実行を考えるとき、リソースの使用に関して下記のルールが適用されます。</p><ul><li>全てのInitコンテナの中で定義された最も高いリソースリクエストとリソースリミットが、<em>有効なinitリクエスト／リミット</em> になります。いずれかのリソースでリミットが設定されていない場合、これが最上級のリミットとみなされます。</li><li>Podのリソースの<em>有効なリクエスト／リミット</em> は、下記の2つの中のどちらか高い方となります。<ul><li>リソースに対する全てのアプリケーションコンテナのリクエスト／リミットの合計</li><li>リソースに対する有効なinitリクエスト／リミット</li></ul></li><li>スケジューリングは有効なリクエスト／リミットに基づいて実行されます。つまり、InitコンテナはPodの生存中には使用されない初期化用のリソースを確保することができます。</li><li>Podの<em>有効なQoS(quality of service)ティアー</em> は、Initコンテナとアプリケーションコンテナで同様です。</li></ul><p>クォータとリミットは有効なPodリクエストとリミットに基づいて適用されます。</p><p>Podレベルのコントロールグループ(cgroups)は、スケジューラーと同様に、有効なPodリクエストとリミットに基づいています。</p><h3 id=pod-restart-reasons>Podの再起動の理由</h3><p>以下の理由によりPodは再起動し、Initコンテナの再実行も引き起こす可能性があります。</p><ul><li>そのPodのインフラストラクチャーコンテナが再起動された場合。これはあまり起きるものでなく、Nodeに対するルート権限を持ったユーザーにより行われることがあります。</li><li><code>restartPolicy</code>が<code>Always</code>と設定されているPod内の全てのコンテナが停止され、強制的に再起動が行われたことで、ガベージコレクションによりInitコンテナの完了記録が失われた場合。</li></ul><p>Kubernetes v1.20以降では、initコンテナのイメージが変更されたり、ガベージコレクションによってinitコンテナの完了記録が失われたりした場合でも、Podは再起動されません。以前のバージョンを使用している場合は、対応バージョンのドキュメントを参照してください。</p><h2 id=what-s-next>次の項目</h2><ul><li><a href=/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container>Initコンテナを含むPodの作成</a>方法について学ぶ。</li><li><a href=/ja/docs/tasks/debug-application-cluster/debug-init-containers/>Initコンテナのデバッグ</a>を行う方法について学ぶ。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4e9b9cbc9776b12e7335c53da377c9c8>1.4 - Pod Preset</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.6 [alpha]</code></div><p>このページではPodPresetについて概観します。PodPresetは、Podの作成時にそのPodに対して、Secret、Volume、VolumeMountや環境変数など、特定の情報を注入するためのオブジェクトです。</p><h2 id=podpresetを理解する>PodPresetを理解する</h2><p><code>PodPreset</code>はPodの作成時に追加のランタイム要求を注入するためのAPIリソースです。ユーザーはPodPresetを適用する対象のPodを指定するために、<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルセレクター</a>を使用します。</p><p>PodPresetの使用により、Podテンプレートの作者はPodにおいて、全ての情報を明示的に指定する必要がなくなります。この方法により、特定のServiceを使っているPodテンプレートの作者は、そのServiceについて全ての詳細を知る必要がなくなります。</p><h2 id=enable-pod-preset>クラスターでPodPresetを有効にする</h2><p>ユーザーのクラスター内でPodPresetを使うためには、クラスター内の以下の項目をご確認ください。</p><ol><li><code>settings.k8s.io/v1alpha1/podpreset</code>というAPIを有効にします。例えば、これはAPI Serverの <code>--runtime-config</code>オプションに<code>settings.k8s.io/v1alpha1=true</code>を含むことで可能になります。Minikubeにおいては、クラスターの起動時に<code>--extra-config=apiserver.runtime-config=settings.k8s.io/v1alpha1=true</code>をつけることで可能です。</li><li><code>PodPreset</code>に対する管理コントローラーを有効にします。これを行うための1つの方法として、API Serverの<code>--enable-admission-plugins</code>オプションの値に<code>PodPreset</code>を含む方法があります。例えば、Minikubeにおいては、クラスターの起動時に</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--extra-config<span style=color:#666>=</span>apiserver.enable-admission-plugins<span style=color:#666>=</span>NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodPreset
</span></span></code></pre></div><p>を追加することで可能になります。</p><h2 id=podpresetはどのように動くか>PodPresetはどのように動くか</h2><p>Kubernetesは<code>PodPreset</code>に対する管理用コントローラーを提供し、これが有効になっている時、コントローラーはリクエストされたPod作成要求に対してPodPresetを適用します。Pod作成要求が発生した時、Kubernetesシステムは下記の処理を行います。</p><ol><li>使用可能な全ての<code>PodPreset</code>を取得する。</li><li>それらの<code>PodPreset</code>のラベルセレクターが、作成されたPod上のラベルと一致するかチェックする。</li><li><code>PodPreset</code>によって定義された様々なリソースを、作成されたPodにマージしようと試みる。</li><li>エラーが起きた時、そのPod上でマージエラーが起きたことを説明するイベントをスローし、<code>PodPreset</code>からリソースを1つも注入されていないPodを作成します。</li><li><code>PodPreset</code>によって修正されたことを示すために、マージ後の修正されたPodにアノテーションをつけます。そのアノテーションは<code>podpreset.admission.kubernetes.io/podpreset-&lt;PodPreset名>: "&lt;リソースのバージョン>"</code>という形式になります。</li></ol><p>各Podは0以上のPodPresetにマッチすることができます。そして各PodPresetは0以上のPodに適用されます。単一のPodPresetが1以上のPodに適用された時、KubernetesはそのPodのSpecを修正します。<code>env</code>、<code>envFrom</code>、<code>volumeMounts</code>への変更があると、KubernetesはそのPod内の全てのコンテナのSpecを修正します。<code>volumes</code>への変更があった場合、KubernetesはそのPodのSpecを修正します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>単一のPodPresetは必要に応じてPodのspec内の以下のフィールドを修正することができます。</p><ul><li><code>.spec.containers</code>フィールド</li><li><code>.spec.initContainers</code>フィールド</li></ul></div><h3 id=特定のpodに対するpodpresetを無効にする>特定のPodに対するPodPresetを無効にする</h3><p>PodPresetによるPodの変更を受け付けたくないようなインスタンスがある場合があります。このようなケースでは、ユーザーはそのPodの<code>.spec</code>内に次のような形式のアノテーションを追加できます。<br><code>podpreset.admission.kubernetes.io/exclude: "true"</code></p><h2 id=次の項目>次の項目</h2><p><a href=/docs/tasks/inject-data-application/podpreset/>PodPresetを使ったPodへのデータの注入</a></p><p>PodPresetの内部についてのさらなる情報は、<a href=https://git.k8s.io/community/contributors/design-proposals/service-catalog/pod-preset.md>PodPresetのデザインプロポーザル</a>を参照してください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-53a1005011e1bda2ce81819aad7c8b32>1.5 - エフェメラルコンテナ</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>このページでは、特別な種類のコンテナであるエフェメラルコンテナの概要を説明します。エフェメラルコンテナは、トラブルシューティングなどのユーザーが開始するアクションを実行するために、すでに存在する<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>内で一時的に実行するコンテナです。エフェメラルコンテナは、アプリケーションの構築ではなく、serviceの調査のために利用します。</p><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> エフェメラルコンテナは初期のアルファ状態であり、本番クラスタには適しません。<a href=/docs/reference/using-api/deprecation-policy/>Kubernetesの非推奨ポリシー</a>に従って、このアルファ機能は、将来大きく変更されたり、完全に削除される可能性があります。</div><h2 id=エフェメラルコンテナを理解する>エフェメラルコンテナを理解する</h2><p><a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>は、Kubernetesのアプリケーションの基本的なビルディングブロックです。Podは破棄可能かつ置き換え可能であることが想定されているため、一度Podが作成されると新しいコンテナを追加することはできません。その代わりに、通常は<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>を使用してPodを削除して置き換えます。</p><p>たとえば、再現困難なバグのトラブルシューティングなどのために、すでに存在するPodの状態を調査する必要が出てくることがあります。このような場合、既存のPod内でエフェメラルコンテナを実行することで、Podの状態を調査したり、任意のコマンドを実行したりできます。</p><h3 id=エフェメラルコンテナとは何か>エフェメラルコンテナとは何か？</h3><p>エフェメラルコンテナは、他のコンテナと異なり、リソースや実行が保証されず、自動的に再起動されることも決してないため、アプリケーションを構築する目的には適しません。エフェメラルコンテナは、通常のコンテナと同じ<code>ContainerSpec</code>で記述されますが、多くのフィールドに互換性がなかったり、使用できなくなっています。</p><ul><li>エフェメラルコンテナはポートを持つことができないため、<code>ports</code>、<code>livenessProbe</code>、<code>readinessProbe</code>などは使えなくなっています。</li><li>Podリソースの割り当てはイミュータブルであるため、<code>resources</code>の設定が禁止されています。</li><li>利用が許可されているフィールドの一覧については、<a href=/docs/reference/generated/kubernetes-api/v1.25/#ephemeralcontainer-v1-core>EphemeralContainerのリファレンスドキュメント</a>を参照してください。</li></ul><p>エフェメラルコンテナは、直接<code>pod.spec</code>に追加するのではなく、API内の特別な<code>ephemeralcontainers</code>ハンドラを使用して作成します。そのため、エフェメラルコンテナを<code>kubectl edit</code>を使用して追加することはできません。</p><p>エフェメラルコンテナをPodに追加した後は、通常のコンテナのようにエフェメラルコンテナを変更または削除することはできません。</p><h2 id=エフェメラルコンテナの用途>エフェメラルコンテナの用途</h2><p>エフェメラルコンテナは、コンテナがクラッシュしてしまったり、コンテナイメージにデバッグ用ユーティリティが同梱されていない場合など、<code>kubectl exec</code>では不十分なときにインタラクティブなトラブルシューティングを行うために役立ちます。</p><p>特に、<a href=https://github.com/GoogleContainerTools/distroless>distrolessイメージ</a>を利用すると、攻撃対象領域を減らし、バグや脆弱性を露出する可能性を減らせる最小のコンテナイメージをデプロイできるようになります。distrolessイメージにはシェルもデバッグ用のユーティリティも含まれないため、<code>kubectl exec</code>のみを使用してdistrolessイメージのトラブルシューティングを行うのは困難です。</p><p>エフェメラルコンテナを利用する場合には、他のコンテナ内のプロセスにアクセスできるように、<a href=/ja/docs/tasks/configure-pod-container/share-process-namespace/>プロセス名前空間の共有</a>を有効にすると便利です。</p><p>エフェメラルコンテナを利用してトラブルシューティングを行う例については、<a href=/docs/tasks/debug/debug-application/debug-running-pod/#ephemeral-container>デバッグ用のエフェメラルコンテナを使用してデバッグする</a>を参照してください。</p><h2 id=ephemeral-containers-api>Ephemeral containers API</h2><div class="alert alert-info note callout" role=alert><strong>備考:</strong> このセクションの例を実行するには、<code>EphemeralContainers</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にして、Kubernetesクライアントとサーバーのバージョンをv1.16以上にする必要があります。</div><p>このセクションの例では、API内でエフェメラルコンテナを表示する方法を示します。通常は、APIを直接呼び出すのではなく、<code>kubectl alpha debug</code>やその他の<code>kubectl</code><a href=/docs/tasks/extend-kubectl/kubectl-plugins/>プラグイン</a>を使用して、これらのステップを自動化します。</p><p>エフェメラルコンテナは、Podの<code>ephemeralcontainers</code>サブリソースを使用して作成されます。このサブリソースは、<code>kubectl --raw</code>を使用して確認できます。まずはじめに、以下に<code>EphemeralContainers</code>リストとして追加するためのエフェメラルコンテナを示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example-pod&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>: [{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;command&#34;</span>: [
</span></span><span style=display:flex><span>            <span style=color:#b44>&#34;sh&#34;</span>
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>: <span style=color:#b44>&#34;IfNotPresent&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;debugger&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;stdin&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;tty&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>: <span style=color:#b44>&#34;File&#34;</span>
</span></span><span style=display:flex><span>    }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>すでに実行中の<code>example-pod</code>のエフェメラルコンテナを更新するには、次のコマンドを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace --raw /api/v1/namespaces/default/pods/example-pod/ephemeralcontainers -f ec.json
</span></span></code></pre></div><p>このコマンドを実行すると、新しいエフェメラルコンテナのリストが返されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;example-pod&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;selfLink&#34;</span>:<span style=color:#b44>&#34;/api/v1/namespaces/default/pods/example-pod/ephemeralcontainers&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;uid&#34;</span>:<span style=color:#b44>&#34;a14a6d9b-62f2-4119-9d8e-e2ed6bc3a47c&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>:<span style=color:#b44>&#34;15886&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>:<span style=color:#b44>&#34;2019-08-29T06:41:42Z&#34;</span>
</span></span><span style=display:flex><span>   },
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>:[
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;debugger&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;busybox&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;command&#34;</span>:[
</span></span><span style=display:flex><span>            <span style=color:#b44>&#34;sh&#34;</span>
</span></span><span style=display:flex><span>         ],
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;resources&#34;</span>:{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         },
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>:<span style=color:#b44>&#34;File&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>:<span style=color:#b44>&#34;IfNotPresent&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;stdin&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;tty&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>新しく作成されたエフェメラルコンテナの状態を確認するには、<code>kubectl describe</code>を使用します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod example-pod
</span></span></code></pre></div><pre tabindex=0><code>...
Ephemeral Containers:
  debugger:
    Container ID:  docker://cf81908f149e7e9213d3c3644eda55c72efaff67652a2685c1146f0ce151e80f
    Image:         busybox
    Image ID:      docker-pullable://busybox@sha256:9f1003c480699be56815db0f8146ad2e22efea85129b5b5983d0e0fb52d9ab70
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Command:
      sh
    State:          Running
      Started:      Thu, 29 Aug 2019 06:42:21 +0000
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:         &lt;none&gt;
...
</code></pre><p>新しいエフェメラルコンテナとやりとりをするには、他のコンテナと同じように、<code>kubectl attach</code>、<code>kubectl exec</code>、<code>kubectl logs</code>などのコマンドが利用できます。例えば、次のようなコマンドが実行できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it example-pod -c debugger
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-89637410cacae45a36ab1cc278c482eb>2 - ワークロードリソース</h1></div><div class=td-content><h1 id=pg-a2dc0393e0c4079e1c504b6429844e86>2.1 - Deployment</h1><p><em>Deployment</em> は<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>と<a class=glossary-tooltip title=ReplicaSetは、指定された数のPodレプリカが一度に動作するように保証します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSet>ReplicaSet</a>の宣言的なアップデート機能を提供します。</p><p>Deploymentにおいて <em>理想的な状態</em> を記述すると、Deployment<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>は指定された頻度で現在の状態を理想的な状態に変更します。Deploymentを定義することによって、新しいReplicaSetを作成したり、既存のDeploymentを削除して新しいDeploymentで全てのリソースを適用できます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentによって作成されたReplicaSetを管理しないでください。ご自身のユースケースが以下の項目に含まれない場合、メインのKubernetesリポジトリーにIssueを作成することを検討してください。</div><h2 id=ユースケース>ユースケース</h2><p>以下の項目はDeploymentの典型的なユースケースです。</p><ul><li>ReplicaSetをロールアウトするために<a href=#creating-a-deployment>Deploymentの作成</a>を行う: ReplicaSetはバックグラウンドでPodを作成します。Podの作成が完了したかどうかは、ロールアウトのステータスを確認してください。</li><li>DeploymentのPodTemplateSpecを更新することにより<a href=#updating-a-deployment>Podの新しい状態を宣言する</a>: 新しいReplicaSetが作成され、Deploymentは指定された頻度で古いReplicaSetから新しいReplicaSetへのPodの移行を管理します。新しいReplicaSetはDeploymentのリビジョンを更新します。</li><li>Deploymentの現在の状態が不安定な場合、<a href=#rolling-back-a-deployment>Deploymentのロールバック</a>をする: ロールバックによる各更新作業は、Deploymentのリビジョンを更新します。</li><li>より多くの負荷をさばけるように、<a href=#scaling-a-deployment>Deploymentをスケールアップ</a>する。</li><li>PodTemplateSpecに対する複数の修正を適用するために<a href=#pausing-and-resuming-a-deployment>Deploymentを停止(Pause)し</a>、それを再開して新しいロールアウトを開始します。</li><li><a href=#deployment-status>Deploymentのステータス</a> をロールアウトが失敗したサインとして利用する。</li><li>今後必要としない<a href=#clean-up-policy>古いReplicaSetのクリーンアップ</a></li></ul><h2 id=creating-a-deployment>Deploymentの作成</h2><p>以下はDeploymentの例です。これは<code>nginx</code>Podのレプリカを3つ持つReplicaSetを作成します。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/nginx-deployment.yaml download=controllers/nginx-deployment.yaml><code>controllers/nginx-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-nginx-deployment-yaml")' title="Copy controllers/nginx-deployment.yaml to clipboard"></img></div><div class=includecode id=controllers-nginx-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>この例では、</p><ul><li><p><code>.metadata.name</code>フィールドで指定された<code>nginx-deployment</code>という名前のDeploymentが作成されます。</p></li><li><p>このDeploymentは<code>.spec.replicas</code>フィールドで指定された通り、3つのレプリカPodを作成します。</p></li><li><p><code>.spec.selector</code>フィールドは、Deploymentが管理するPodのラベルを定義します。ここでは、Podテンプレートにて定義されたラベル(<code>app: nginx</code>)を選択しています。しかし、PodTemplate自体がそのルールを満たす限り、さらに洗練された方法でセレクターを指定することができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>.spec.selector.matchLabels</code>フィールドはキーバリューペアのマップです。
<code>matchLabels</code>マップにおいて、{key, value}というペアは、keyというフィールドの値が"key"で、その演算子が"In"で、値の配列が"value"のみ含むような<code>matchExpressions</code>の要素と等しくなります。
<code>matchLabels</code>と<code>matchExpressions</code>の両方が設定された場合、条件に一致するには両方とも満たす必要があります。</div></li><li><p><code>template</code>フィールドは、以下のサブフィールドを持ちます。:</p><ul><li>Podは<code>.metadata.labels</code>フィールドによって指定された<code>app: nginx</code>というラベルがつけられます。</li><li>PodTemplate、または<code>.template.spec</code>フィールドは、Podが<code>nginx</code>という名前で<a href=https://hub.docker.com/>Docker Hub</a>にある<code>nginx</code>のバージョン1.14.2が動くコンテナを1つ動かすことを示します。</li><li>1つのコンテナを作成し、<code>.spec.template.spec.containers[0].name</code>フィールドを使って<code>nginx</code>という名前をつけます。</li></ul></li></ul><p>作成を始める前に、Kubernetesクラスターが稼働していることを確認してください。
上記のDeploymentを作成するためには以下のステップにしたがってください:</p><ol><li>以下のコマンドを実行してDeploymentを作成してください。</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml
</span></span></code></pre></div><ol start=2><li>Deploymentが作成されたことを確認するために、<code>kubectl get deployments</code>を実行してください。</li></ol><p>Deploymentがまだ作成中の場合、コマンドの実行結果は以下のとおりです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   0/3     <span style=color:#666>0</span>            <span style=color:#666>0</span>           1s
</span></span></code></pre></div><p>クラスターにてDeploymentを調査するとき、以下のフィールドが出力されます。</p><ul><li><code>NAME</code>は、クラスター内にあるDeploymentの名前一覧です。</li><li><code>READY</code>は、ユーザーが使用できるアプリケーションのレプリカの数です。使用可能な数/理想的な数の形式で表示されます。</li><li><code>UP-TO-DATE</code>は、理想的な状態を満たすためにアップデートが完了したレプリカの数です。</li><li><code>AVAILABLE</code>は、ユーザーが利用可能なレプリカの数です。</li><li><code>AGE</code>は、アプリケーションが稼働してからの時間です。</li></ul><p><code>.spec.replicas</code>フィールドの値によると、理想的なレプリカ数は3であることがわかります。</p><ol start=3><li>Deploymentのロールアウトステータスを確認するために、<code>kubectl rollout status deployment.v1.apps/nginx-deployment</code>を実行してください。</li></ol><p>コマンドの実行結果は以下のとおりです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Waiting <span style=color:#a2f;font-weight:700>for</span> rollout to finish: <span style=color:#666>2</span> out of <span style=color:#666>3</span> new replicas have been updated...
</span></span><span style=display:flex><span>deployment <span style=color:#b44>&#34;nginx-deployment&#34;</span> successfully rolled out
</span></span></code></pre></div><ol start=4><li>数秒後、再度<code>kubectl get deployments</code>を実行してください。
コマンドの実行結果は以下のとおりです。</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   3/3     <span style=color:#666>3</span>            <span style=color:#666>3</span>           18s
</span></span></code></pre></div><p>Deploymentが3つ全てのレプリカを作成して、全てのレプリカが最新(Podが最新のPodテンプレートを含んでいる)になり、利用可能となっていることを確認してください。</p><ol start=5><li>Deploymentによって作成されたReplicaSet(<code>rs</code>)を確認するには<code>kubectl get rs</code>を実行してください。コマンドの実行結果は以下のとおりです:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                          DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>nginx-deployment-75675f5897   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       18s
</span></span></code></pre></div><p>ReplicaSetの出力には次のフィールドが表示されます:</p><ul><li><code>NAME</code>は、名前空間内にあるReplicaSetの名前の一覧です。</li><li><code>DESIRED</code>は、アプリケーションの理想的な <em>レプリカ</em> の値です。これはDeploymentを作成したときに定義したもので、これが <em>理想的な状態</em> と呼ばれるものです。</li><li><code>CURRENT</code>は現在実行されているレプリカの数です。</li><li><code>READY</code>は、ユーザーが使用できるアプリケーションのレプリカの数です。</li><li><code>AGE</code>は、アプリケーションが稼働してからの時間です。</li></ul><p>ReplicaSetの名前は<code>[Deployment名]-[ランダム文字列]</code>という形式になることに注意してください。ランダム文字列はランダムに生成され、pod-template-hashをシードとして使用します。</p><ol start=6><li>各Podにラベルが自動的に付けられるのを確認するには<code>kubectl get pods --show-labels</code>を実行してください。
コマンドの実行結果は以下のとおりです:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                                READY     STATUS    RESTARTS   AGE       LABELS
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-7ci7o   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-kzszj   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-qqcnn   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
</span></span></code></pre></div><p>作成されたReplicaSetは<code>nginx</code>Podを3つ作成することを保証します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>Deploymentに対して適切なセレクターとPodテンプレートのラベルを設定する必要があります(このケースでは<code>app: nginx</code>)。</p><p>ラベルやセレクターを他のコントローラーと重複させないでください(他のDeploymentやStatefulSetを含む)。Kubernetesはユーザーがラベルを重複させることを阻止しないため、複数のコントローラーでセレクターの重複が発生すると、コントローラー間で衝突し予期せぬふるまいをすることになります。</p></div><h3 id=pod-template-hashラベル>pod-template-hashラベル</h3><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> このラベルを変更しないでください。</div><p><code>pod-template-hash</code>ラベルはDeploymentコントローラーによってDeploymentが作成し適用した各ReplicaSetに対して追加されます。</p><p>このラベルはDeploymentが管理するReplicaSetが重複しないことを保証します。このラベルはReplicaSetの<code>PodTemplate</code>をハッシュ化することにより生成され、生成されたハッシュ値はラベル値としてReplicaSetセレクター、Podテンプレートラベル、ReplicaSetが作成した全てのPodに対して追加されます。</p><h2 id=updating-a-deployment>Deploymentの更新</h2><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentのロールアウトは、DeploymentのPodテンプレート(この場合<code>.spec.template</code>)が変更された場合にのみトリガーされます。例えばテンプレートのラベルもしくはコンテナーイメージが更新された場合です。Deploymentのスケールのような更新では、ロールアウトはトリガーされません。</div><p>Deploymentを更新するには以下のステップに従ってください。</p><ol><li><p>nginxのPodで、<code>nginx:1.14.2</code>イメージの代わりに<code>nginx:1.16.1</code>を使うように更新します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</span></span></code></pre></div><p>または単に次のコマンドを使用します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre><p>また、Deploymentを<code>編集</code>して、<code>.spec.template.spec.containers[0].image</code>を<code>nginx:1.14.2</code>から<code>nginx:1.16.1</code>に変更することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment edited
</code></pre></li><li><p>ロールアウトのステータスを確認するには、以下のコマンドを実行してください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
</code></pre><p>もしくは</p><pre tabindex=0><code>deployment &#34;nginx-deployment&#34; successfully rolled out
</code></pre></li></ol><p>更新されたDeploymentのさらなる情報を取得するには、以下を確認してください。</p><ul><li><p>ロールアウトが成功したあと、<code>kubectl get deployments</code>を実行してDeploymentを確認できます。
実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           36s
</code></pre></li><li><p>Deploymentが新しいReplicaSetを作成してPodを更新させたり、新しいReplicaSetのレプリカを3にスケールアップさせたり、古いReplicaSetのレプリカを0にスケールダウンさせるのを確認するには<code>kubectl get rs</code>を実行してください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       6s
nginx-deployment-2035384211   0         0         0       36s
</code></pre></li><li><p><code>get pods</code>を実行させると、新しいPodのみ確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1564180365-khku8   1/1       Running   0          14s
nginx-deployment-1564180365-nacti   1/1       Running   0          14s
nginx-deployment-1564180365-z9gth   1/1       Running   0          14s
</code></pre><p>次にPodを更新させたいときは、DeploymentのPodテンプレートを再度更新するだけです。</p><p>Deploymentは、Podが更新されている間に特定の数のPodのみ停止状態になることを保証します。デフォルトでは、目標とするPod数の少なくとも75%が稼働状態であることを保証します(25% max unavailable)。</p><p>また、DeploymentはPodが更新されている間に、目標とするPod数を特定の数まで超えてPodを稼働させることを保証します。デフォルトでは、目標とするPod数に対して最大でも125%を超えてPodを稼働させることを保証します(25% max surge)。</p><p>例えば、上記で説明したDeploymentの状態を注意深く見ると、最初に新しいPodが作成され、次に古いPodが削除されるのを確認できます。十分な数の新しいPodが稼働するまでは、Deploymentは古いPodを削除しません。また十分な数の古いPodが削除しない限り新しいPodは作成されません。少なくとも2つのPodが利用可能で、最大でもトータルで4つのPodが利用可能になっていることを保証します。</p></li><li><p>Deploymentの詳細情報を取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployments
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=2
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
   Containers:
    nginx:
      Image:        nginx:1.16.1
      Port:         80/TCP
      Environment:  &lt;none&gt;
      Mounts:       &lt;none&gt;
    Volumes:        &lt;none&gt;
  Conditions:
    Type           Status  Reason
    ----           ------  ------
    Available      True    MinimumReplicasAvailable
    Progressing    True    NewReplicaSetAvailable
  OldReplicaSets:  &lt;none&gt;
  NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)
  Events:
    Type    Reason             Age   From                   Message
    ----    ------             ----  ----                   -------
    Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica set nginx-deployment-2035384211 to 3
    Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 1
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 2
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 2
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 1
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 3
    Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 0
</code></pre><p>最初にDeploymentを作成した時、ReplicaSet(nginx-deployment-2035384211)を作成してすぐにレプリカ数を3にスケールするのを確認できます。Deploymentを更新すると新しいReplicaSet(nginx-deployment-1564180365)を作成してレプリカ数を1にスケールアップし、古いReplicaSeetを2にスケールダウンさせます。これは常に最低でも2つのPodが利用可能で、かつ最大4つのPodが作成されている状態にするためです。Deploymentは同じローリングアップ戦略に従って新しいReplicaSetのスケールアップと古いReplicaSetのスケールダウンを続けます。最終的に新しいReplicaSetを3にスケールアップさせ、古いReplicaSetを0にスケールダウンさせます。</p></li></ul><h3 id=ロールオーバー-リアルタイムでの複数のpodの更新>ロールオーバー (リアルタイムでの複数のPodの更新)</h3><p>Deploymentコントローラーにより、新しいDeploymentが観測される度にReplicaSetが作成され、理想とするレプリカ数のPodを作成します。Deploymentが更新されると、既存のReplicaSetが管理するPodのラベルが<code>.spec.selector</code>にマッチするが、テンプレートが<code>.spec.template</code>にマッチしない場合はスケールダウンされます。最終的に、新しいReplicaSetは<code>.spec.replicas</code>の値にスケールアップされ、古いReplicaSetは0にスケールダウンされます。</p><p>Deploymentのロールアウトが進行中にDeploymentを更新すると、Deploymentは更新する毎に新しいReplicaSetを作成してスケールアップさせ、以前にスケールアップしたReplicaSetのロールオーバーを行います。Deploymentは更新前のReplicaSetを古いReplicaSetのリストに追加し、スケールダウンを開始します。</p><p>例えば、5つのレプリカを持つ<code>nginx:1.14.2</code>のDeploymentを作成し、<code>nginx:1.14.2</code>の3つのレプリカが作成されているときに5つのレプリカを持つ<code>nginx:1.16.1</code>に更新します。このケースではDeploymentは作成済みの<code>nginx:1.14.2</code>の3つのPodをすぐに削除し、<code>nginx:1.16.1</code>のPodの作成を開始します。<code>nginx:1.14.2</code>の5つのレプリカを全て作成するのを待つことはありません。</p><h3 id=ラベルセレクターの更新>ラベルセレクターの更新</h3><p>通常、ラベルセレクターを更新することは推奨されません。事前にラベルセレクターの使い方を計画しておきましょう。いかなる場合であっても更新が必要なときは十分に注意を払い、変更時の影響範囲を把握しておきましょう。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>apps/v1</code>API バージョンにおいて、Deploymentのラベルセレクターは作成後に不変となります。</div><ul><li>セレクターの追加は、Deployment Specのテンプレートラベルも新しいラベルで更新する必要があります。そうでない場合はバリデーションエラーが返されます。この変更は重複がない更新となります。これは新しいセレクターは古いセレクターを持つReplicaSetとPodを選択せず、結果として古い全てのReplicaSetがみなし子状態になり、新しいReplicaSetを作成することを意味します。</li><li>セレクターの更新により、セレクターキー内の既存の値が変更されます。これにより、セレクターの追加と同じふるまいをします。</li><li>セレクターの削除により、Deploymentのセレクターから存在している値を削除します。これはPodテンプレートのラベルに関する変更を要求しません。既存のReplicaSetはみなし子状態にならず、新しいReplicaSetは作成されませんが、削除されたラベルは既存のPodとReplicaSetでは残り続けます。</li></ul><h2 id=rolling-back-a-deployment>Deploymentのロールバック</h2><p>例えば、クラッシュループ状態などのようにDeploymentが不安定な場合においては、Deploymentをロールバックしたくなることがあります。Deploymentの全てのロールアウト履歴は、いつでもロールバックできるようにデフォルトでシステムに保持されています(リビジョン履歴の上限は設定することで変更可能です)。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentのリビジョンは、Deploymentのロールアウトがトリガーされた時に作成されます。これはDeploymentのPodテンプレート(<code>.spec.template</code>)が変更されたときのみ新しいリビジョンが作成されることを意味します。Deploymentのスケーリングなど、他の種類の更新においてはDeploymentのリビジョンは作成されません。これは手動もしくはオートスケーリングを同時に行うことができるようにするためです。これは過去のリビジョンにロールバックするとき、DeploymentのPodテンプレートの箇所のみロールバックされることを意味します。</div><ul><li><p><code>nginx:1.16.1</code>の代わりに<code>nginx:1.161</code>というイメージに更新して、Deploymentの更新中にタイプミスをしたと仮定します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.161
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre></li><li><p>このロールアウトはうまくいきません。ロールアウトのステータスを見るとそれを確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Waiting for rollout to finish: 1 out of 3 new replicas have been updated...
</code></pre></li><li><p>ロールアウトのステータスの確認は、Ctrl-Cを押すことで停止できます。ロールアウトがうまく行かないときは、<a href=#deployment-status>Deploymentのステータス</a>を読んでさらなる情報を得てください。</p></li><li><p>古いレプリカ数(<code>nginx-deployment-1564180365</code> and <code>nginx-deployment-2035384211</code>)が2になっていることを確認でき、新しいレプリカ数(nginx-deployment-3066724191)は1になっています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       25s
nginx-deployment-2035384211   0         0         0       36s
nginx-deployment-3066724191   1         1         0       6s
</code></pre></li><li><p>作成されたPodを確認していると、新しいReplicaSetによって作成された1つのPodはコンテナイメージのpullに失敗し続けているのがわかります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                                READY     STATUS             RESTARTS   AGE
nginx-deployment-1564180365-70iae   1/1       Running            0          25s
nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s
nginx-deployment-1564180365-hysrc   1/1       Running            0          25s
nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s
</code></pre><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentコントローラーは、この悪い状態のロールアウトを自動的に停止し、新しいReplicaSetのスケールアップを止めます。これはユーザーが指定したローリングアップデートに関するパラメータ(特に<code>maxUnavailable</code>)に依存します。デフォルトではKubernetesがこの値を25%に設定します。</div></li><li><p>Deploymentの詳細情報を取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Name:           nginx-deployment
Namespace:      default
CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700
Labels:         app=nginx
Selector:       app=nginx
Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable
StrategyType:       RollingUpdate
MinReadySeconds:    0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.161
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    ReplicaSetUpdated
OldReplicaSets:     nginx-deployment-1564180365 (3/3 replicas created)
NewReplicaSet:      nginx-deployment-3066724191 (1/1 replicas created)
Events:
  FirstSeen LastSeen    Count   From                    SubObjectPath   Type        Reason              Message
  --------- --------    -----   ----                    -------------   --------    ------              -------
  1m        1m          1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 1
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1
</code></pre><p>これを修正するために、Deploymentを安定した状態の過去のリビジョンに更新する必要があります。</p></li></ul><h3 id=deploymentのロールアウト履歴の確認>Deploymentのロールアウト履歴の確認</h3><p>ロールアウトの履歴を確認するには、以下の手順に従って下さい。</p><ol><li><p>最初に、Deploymentのリビジョンを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployments &#34;nginx-deployment&#34;
REVISION    CHANGE-CAUSE
1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml
2           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1
3           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.161
</code></pre><p><code>CHANGE-CAUSE</code>はリビジョンの作成時にDeploymentの<code>kubernetes.io/change-cause</code>アノテーションからリビジョンにコピーされます。以下の方法により<code>CHANGE-CAUSE</code>メッセージを指定できます。</p><ul><li><code>kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause="image updated to 1.16.1"</code>の実行によりアノテーションを追加します。</li><li>リソースのマニフェストを手動で編集します。</li></ul></li><li><p>各リビジョンの詳細を確認するためには以下のコマンドを実行してください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment --revision<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployments &#34;nginx-deployment&#34; revision 2
  Labels:       app=nginx
          pod-template-hash=1159050644
  Annotations:  kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1
  Containers:
   nginx:
    Image:      nginx:1.16.1
    Port:       80/TCP
     QoS Tier:
        cpu:      BestEffort
        memory:   BestEffort
    Environment Variables:      &lt;none&gt;
  No volumes.
</code></pre></li></ol><h3 id=rolling-back-to-a-previous-revision>過去のリビジョンにロールバックする</h3><p>現在のリビジョンから過去のリビジョン(リビジョン番号2)にロールバックさせるには、以下の手順に従ってください。</p><ol><li><p>現在のリビジョンから過去のリビジョンにロールバックします。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout undo deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment rolled back
</code></pre><p>その他に、<code>--to-revision</code>を指定することにより特定のリビジョンにロールバックできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment rolled back
</code></pre><p>ロールアウトに関連したコマンドのさらなる情報は<a href=/docs/reference/generated/kubectl/kubectl-commands#rollout><code>kubectl rollout</code></a>を参照してください。</p><p>Deploymentが過去の安定したリビジョンにロールバックされました。Deploymentコントローラーによって、リビジョン番号2にロールバックする<code>DeploymentRollback</code>イベントが作成されたのを確認できます。</p></li><li><p>ロールバックが成功し、Deploymentが正常に稼働していることを確認するために、以下のコマンドを実行してください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           30m
</code></pre></li><li><p>Deploymentの詳細情報を取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=4
                        kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.16.1
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &lt;none&gt;
NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created)
Events:
  Type    Reason              Age   From                   Message
  ----    ------              ----  ----                   -------
  Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica set nginx-deployment-75675f5897 to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 0
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-595696685f to 1
  Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment &#34;nginx-deployment&#34; to revision 2
  Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica set nginx-deployment-595696685f to 0
</code></pre></li></ol><h2 id=scaling-a-deployment>Deploymentのスケーリング</h2><p>以下のコマンドを実行させてDeploymentをスケールできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment.v1.apps/nginx-deployment --replicas<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment scaled
</code></pre><p>クラスター内で<a href=/ja/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>水平Podオートスケーラー</a>が有効になっていると仮定します。ここでDeploymentのオートスケーラーを設定し、稼働しているPodのCPU使用量に基づいて、稼働させたいPodのレプリカ数の最小値と最大値を設定できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment.v1.apps/nginx-deployment --min<span style=color:#666>=</span><span style=color:#666>10</span> --max<span style=color:#666>=</span><span style=color:#666>15</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>80</span>
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment scaled
</code></pre><h3 id=比例スケーリング>比例スケーリング</h3><p>Deploymentのローリングアップデートは、同時に複数のバージョンのアプリケーションの稼働をサポートします。ユーザーやオートスケーラーがローリングアップデートをロールアウト中(更新中もしくは一時停止中)のDeploymentに対して行うと、Deploymentコントローラーはリスクを削減するために既存のアクティブなReplicaSetのレプリカのバランシングを行います。これを<em>比例スケーリング</em> と呼びます。</p><p>レプリカ数が10、<a href=#max-surge>maxSurge</a>=3、<a href=#max-unavailable>maxUnavailable</a>=2であるDeploymentが稼働している例です。</p><ul><li><p>Deployment内で10のレプリカが稼働していることを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment     10        10        10           10          50s
</code></pre></li><li><p>クラスター内で、解決できない新しいイメージに更新します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:sometag
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre></li><li><p>イメージの更新は新しいReplicaSet nginx-deployment-1989198191へのロールアウトを開始させます。しかしロールアウトは、上述した<code>maxUnavailable</code>の要求によりブロックされます。ここでロールアウトのステータスを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY     AGE
nginx-deployment-1989198191   5         5         0         9s
nginx-deployment-618515232    8         8         8         1m
</code></pre></li><li><p>次にDeploymentのスケーリングをするための新しい要求が発生します。オートスケーラーはDeploymentのレプリカ数を15に増やします。Deploymentコントローラーは新しい5つのレプリカをどこに追加するか決める必要がでてきます。比例スケーリングを使用していない場合、5つのレプリカは全て新しいReplicaSetに追加されます。比例スケーリングでは、追加されるレプリカは全てのReplicaSetに分散されます。比例割合が大きいものはレプリカ数の大きいReplicaSetとなり、比例割合が低いときはレプリカ数の小さいReplicaSetとなります。残っているレプリカはもっとも大きいレプリカ数を持つReplicaSetに追加されます。レプリカ数が0のReplicaSetはスケールアップされません。</p></li></ul><p>上記の例では、3つのレプリカが古いReplicaSetに追加され、2つのレプリカが新しいReplicaSetに追加されました。ロールアウトの処理では、新しいレプリカ数のPodが正常になったと仮定すると、最終的に新しいReplicaSetに全てのレプリカを移動させます。これを確認するためには以下のコマンドを実行して下さい。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                 DESIRED   CURRENT   UP-TO-DATE  AVAILABLE   AGE
nginx-deployment     15        18        7           8           7m
</code></pre><p>ロールアウトのステータスでレプリカがどのように各ReplicaSetに追加されるか確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT  READY     AGE
nginx-deployment-1989198191   7         7        0         7m
nginx-deployment-618515232    11        11       11        7m
</code></pre><h2 id=pausing-and-resuming-a-deployment>Deployment更新の一時停止と再開</h2><p>ユーザーは1つ以上の更新処理をトリガーする前に更新の一時停止と再開ができます。これにより、不必要なロールアウトを実行することなく一時停止と再開を行う間に複数の修正を反映できます。</p><ul><li><p>例えば、作成直後のDeploymentを考えます。
Deploymentの詳細情報を確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx     3         3         3            3           1m
</code></pre><p>ロールアウトのステータスを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         1m
</code></pre></li><li><p>以下のコマンドを実行して更新処理の一時停止を行います。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout pause deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment paused
</code></pre></li><li><p>次にDeploymentのイメージを更新します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre></li><li><p>新しいロールアウトが開始されていないことを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployments &#34;nginx&#34;
REVISION  CHANGE-CAUSE
1   &lt;none&gt;
</code></pre></li><li><p>Deploymentの更新に成功したことを確認するためにロールアウトのステータスを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         2m
</code></pre></li><li><p>更新は何度でも実行できます。例えば、Deploymentが使用するリソースを更新します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> resources deployment.v1.apps/nginx-deployment -c<span style=color:#666>=</span>nginx --limits<span style=color:#666>=</span><span style=color:#b8860b>cpu</span><span style=color:#666>=</span>200m,memory<span style=color:#666>=</span>512Mi
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment resource requirements updated
</code></pre><p>一時停止する前の初期状態では更新処理は機能しますが、Deploymentが一時停止されている間は新しい更新処理は反映されません。</p></li><li><p>最後に、Deploymentの稼働を再開させ、新しいReplicaSetが更新内容を全て反映させているのを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout resume deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment resumed
</code></pre></li><li><p>更新処理が完了するまでロールアウトのステータスを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs -w
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   2         2         2         2m
nginx-3926361531   2         2         0         6s
nginx-3926361531   2         2         1         18s
nginx-2142116321   1         2         2         2m
nginx-2142116321   1         2         2         2m
nginx-3926361531   3         2         1         18s
nginx-3926361531   3         2         1         18s
nginx-2142116321   1         1         1         2m
nginx-3926361531   3         3         1         18s
nginx-3926361531   3         3         2         19s
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         20s
</code></pre></li><li><p>最新のロールアウトのステータスを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         28s
</code></pre></li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentの稼働を再開させない限り、一時停止したDeploymentをロールバックすることはできません。</div><h2 id=deployment-status>Deploymentのステータス</h2><p>Deploymentは、そのライフサイクルの間に様々な状態に遷移します。新しいReplicaSetへのロールアウト中は<a href=#progressing-deployment>進行中</a>になり、その後は<a href=#complete-deployment>完了</a>し、また<a href=#failed-deployment>失敗</a>にもなります。</p><h3 id=progressing-deployment>Deploymentの更新処理</h3><p>以下のタスクが実行中のとき、KubernetesはDeploymentの状態を <em>進行中</em> にします。</p><ul><li>Deploymentが新しいReplicaSetを作成します。</li><li>Deploymentが新しいReplicaSetをスケールアップさせています。</li><li>Deploymentが古いReplicaSetをスケールダウンさせています。</li><li>新しいPodが準備中もしくは利用可能な状態になります(少なくとも<a href=#min-ready-seconds>MinReadySeconds</a>の間は準備中になります)。</li></ul><p><code>kubectl rollout status</code>を実行すると、Deploymentの進行状態を確認できます。</p><h3 id=complete-deployment>Deploymentの更新処理の完了</h3><p>Deploymentが以下の状態になったとき、KubernetesはDeploymentのステータスを <em>完了</em> にします。</p><ul><li>Deploymentの全てのレプリカが、指定された最新のバージョンに更新されます。これは指定した更新処理が完了したことを意味します。</li><li>Deploymentの全てのレプリカが利用可能になります。</li><li>Deploymentの古いレプリカが1つも稼働していません。</li></ul><p><code>kubectl rollout status</code>を実行して、Deploymentの更新が完了したことを確認できます。ロールアウトが正常に完了すると<code>kubectl rollout status</code>の終了コードが0で返されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Waiting for rollout to finish: 2 of 3 updated replicas are available...
deployment &#34;nginx-deployment&#34; successfully rolled out
</code></pre><p>そして<code>kubectl rollout</code>の終了ステータスが0となります（成功です）:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$?</span>
</span></span></code></pre></div><pre tabindex=0><code>0
</code></pre><h3 id=failed-deployment>Deploymentの更新処理の失敗</h3><p>新しいReplicaSetのデプロイが完了せず、更新処理が止まる場合があります。これは主に以下の要因によるものです。</p><ul><li>不十分なリソースの割り当て</li><li>ReadinessProbeの失敗</li><li>コンテナイメージの取得ができない</li><li>不十分なパーミッション</li><li>リソースリミットのレンジ</li><li>アプリケーションランタイムの設定の不備</li></ul><p>このような状況を検知する1つの方法として、Deploymentのリソース定義でデッドラインのパラメータを指定します(<a href=#progress-deadline-seconds><code>.spec.progressDeadlineSeconds</code></a>)。<code>.spec.progressDeadlineSeconds</code>はDeploymentの更新が停止したことを示す前にDeploymentコントローラーが待つ秒数を示します。</p><p>以下の<code>kubectl</code>コマンドでリソース定義に<code>progressDeadlineSeconds</code>を設定します。これはDeploymentの更新が止まってから10分後に、コントローラーが失敗を通知させるためです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch deployment.v1.apps/nginx-deployment -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;progressDeadlineSeconds&#34;:600}}&#39;</span>
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>deployment.apps/nginx-deployment patched
</code></pre><p>一度デッドラインを超過すると、DeploymentコントローラーはDeploymentの<code>.status.conditions</code>に以下のDeploymentConditionを追加します。</p><ul><li>Type=Progressing</li><li>Status=False</li><li>Reason=ProgressDeadlineExceeded</li></ul><p>ステータスの状態に関するさらなる情報は<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties>Kubernetes APIの規則</a>を参照してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Kubernetesは停止状態のDeploymentに対して、ステータス状態を報告する以外のアクションを実行しません。高レベルのオーケストレーターはこれを利用して、状態に応じて行動できます。例えば、前のバージョンへのDeploymentのロールバックが挙げられます。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentを停止すると、Kubernetesは指定したデッドラインを超えたかどうかチェックしません。
ロールアウトの途中でもDeploymentを安全に一時停止でき、デッドラインを超えたイベントをトリガーすることなく再開できます。</div><p>設定したタイムアウトの秒数が小さかったり、一時的なエラーとして扱える他の種類のエラーが原因となり、Deploymentで一時的なエラーが出る場合があります。例えば、リソースの割り当てが不十分な場合を考えます。Deploymentの詳細情報を確認すると、以下のセクションが表示されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>&lt;...&gt;
Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     True    ReplicaSetUpdated
  ReplicaFailure  True    FailedCreate
&lt;...&gt;
</code></pre><p><code>kubectl get deployment nginx-deployment -o yaml</code>を実行すると、Deploymentのステータスは以下のようになります。</p><pre tabindex=0><code>status:
  availableReplicas: 2
  conditions:
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: Replica set &#34;nginx-deployment-4262182780&#34; is progressing.
    reason: ReplicaSetUpdated
    status: &#34;True&#34;
    type: Progressing
  - lastTransitionTime: 2016-10-04T12:25:42Z
    lastUpdateTime: 2016-10-04T12:25:42Z
    message: Deployment has minimum availability.
    reason: MinimumReplicasAvailable
    status: &#34;True&#34;
    type: Available
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: &#39;Error creating: pods &#34;nginx-deployment-4262182780-&#34; is forbidden: exceeded quota:
      object-counts, requested: pods=1, used: pods=3, limited: pods=2&#39;
    reason: FailedCreate
    status: &#34;True&#34;
    type: ReplicaFailure
  observedGeneration: 3
  replicas: 2
  unavailableReplicas: 2
</code></pre><p>最後に、一度Deploymentの更新処理のデッドラインを越えると、KubernetesはDeploymentのステータスと進行中の状態を更新します。</p><pre tabindex=0><code>Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     False   ProgressDeadlineExceeded
  ReplicaFailure  True    FailedCreate
</code></pre><p>Deploymentか他のリソースコントローラーのスケールダウンを行うか、使用している名前空間内でリソースの割り当てを増やすことで、リソースの割り当て不足の問題に対処できます。割り当て条件を満たすと、DeploymentコントローラーはDeploymentのロールアウトを完了させ、Deploymentのステータスが成功状態になるのを確認できます(<code>Status=True</code>と<code>Reason=NewReplicaSetAvailable</code>)。</p><pre tabindex=0><code>Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
</code></pre><p><code>Status=True</code>の<code>Type=Available</code>は、Deploymentが最小可用性の状態であることを意味します。最小可用性は、Deploymentの更新戦略において指定されているパラメータにより決定されます。<code>Status=True</code>の<code>Type=Progressing</code>は、Deploymentのロールアウトの途中で、更新処理が進行中であるか、更新処理が完了し、必要な最小数のレプリカが利用可能であることを意味します(各TypeのReason項目を確認してください。このケースでは、<code>Reason=NewReplicaSetAvailable</code>はDeploymentの更新が完了したことを意味します)。</p><p><code>kubectl rollout status</code>を実行してDeploymentが更新に失敗したかどうかを確認できます。<code>kubectl rollout status</code>はDeploymentが更新処理のデッドラインを超えたときに0以外の終了コードを返します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>実行結果は以下のとおりです。</p><pre tabindex=0><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
error: deployment &#34;nginx&#34; exceeded its progress deadline
</code></pre><p>そして<code>kubectl rollout</code>の終了ステータスが1となります(エラーを示しています):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$?</span>
</span></span></code></pre></div><pre tabindex=0><code>1
</code></pre><h3 id=失敗したdeploymentの操作>失敗したDeploymentの操作</h3><p>更新完了したDeploymentに適用した全てのアクションは、更新失敗したDeploymentに対しても適用されます。スケールアップ、スケールダウンができ、前のリビジョンへのロールバックや、Deploymentのテンプレートに複数の更新を適用させる必要があるときは一時停止もできます。</p><h2 id=clean-up-policy>古いリビジョンのクリーンアップポリシー</h2><p>Deploymentが管理する古いReplicaSetをいくつ保持するかを指定するために、<code>.spec.revisionHistoryLimit</code>フィールドを設定できます。この値を超えた古いReplicaSetはバックグラウンドでガーベージコレクションの対象となって削除されます。デフォルトではこの値は10です。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> このフィールドを明示的に0に設定すると、Deploymentの全ての履歴を削除します。従って、Deploymentはロールバックできません。</div><h2 id=カナリアパターンによるデプロイ>カナリアパターンによるデプロイ</h2><p>Deploymentを使って一部のユーザーやサーバーに対してリリースのロールアウトをしたい場合、<a href=/ja/docs/concepts/cluster-administration/manage-deployment/#canary-deployments-%E3%82%AB%E3%83%8A%E3%83%AA%E3%82%A2%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4>リソースの管理</a>に記載されているカナリアパターンに従って、リリース毎に1つずつ、複数のDeploymentを作成できます。</p><h2 id=deployment-specの記述>Deployment Specの記述</h2><p>他の全てのKubernetesの設定と同様に、Deploymentは<code>.apiVersion</code>、<code>.kind</code>や<code>.metadata</code>フィールドを必要とします。
設定ファイルの利用に関する情報は<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>アプリケーションのデプロイ</a>を参照してください。コンテナーの設定に関しては<a href=/ja/docs/concepts/overview/working-with-objects/object-management/>リソースを管理するためのkubectlの使用</a>を参照してください。
Deploymentオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>でなければなりません。
Deploymentは<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code>セクション</a>も必要とします。</p><h3 id=podテンプレート>Podテンプレート</h3><p><code>.spec.template</code>と<code>.spec.selector</code>は<code>.spec</code>における必須のフィールドです。</p><p><code>.spec.template</code>は<a href=/docs/concepts/workloads/pods/#pod-templates>Podテンプレート</a>です。これは.spec内でネストされていないことと、<code>apiVersion</code>や<code>kind</code>を持たないことを除いては<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>と同じスキーマとなります。</p><p>Podの必須フィールドに加えて、Deployment内のPodテンプレートでは適切なラベルと再起動ポリシーを設定しなくてはなりません。ラベルは他のコントローラーと重複しないようにしてください。ラベルについては、<a href=#selector>セレクター</a>を参照してください。</p><p><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>.spec.template.spec.restartPolicy</code></a>が<code>Always</code>に等しいときのみ許可されます。これはテンプレートで指定されていない場合のデフォルト値です。</p><h3 id=レプリカ数>レプリカ数</h3><p><code>.spec.replias</code>は理想的なPodの数を指定するオプションのフィールドです。デフォルトは1です。</p><h3 id=selector>セレクター</h3><p><code>.spec.selector</code>は必須フィールドで、Deploymentによって対象とされるPodの<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルセレクター</a>を指定します。</p><p><code>.spec.selector</code>は<code>.spec.template.metadata.labels</code>と一致している必要があり、一致しない場合はAPIによって拒否されます。</p><p><code>apps/v1</code>バージョンにおいて、<code>.spec.selector</code>と<code>.metadata.labels</code>が指定されていない場合、<code>.spec.template.metadata.labels</code>の値に初期化されません。そのため<code>.spec.selector</code>と<code>.metadata.labels</code>を明示的に指定する必要があります。また<code>apps/v1</code>のDeploymentにおいて<code>.spec.selector</code>は作成後に不変になります。</p><p>Deploymentのテンプレートが<code>.spec.template</code>と異なる場合や、<code>.spec.replicas</code>の値を超えてPodが稼働している場合、Deploymentはセレクターに一致するラベルを持つPodを削除します。Podの数が理想状態より少ない場合Deploymentは<code>.spec.template</code>をもとに新しいPodを作成します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Deploymentのセレクターに一致するラベルを持つPodを直接作成したり、他のDeploymentやReplicaSetやReplicationControllerによって作成するべきではありません。作成してしまうと、最初のDeploymentがラベルに一致する新しいPodを作成したとみなされます。こうなったとしても、Kubernetesは処理を止めません。</div><p>セレクターが重複する複数のコントローラーを持つとき、そのコントローラーは互いに競合状態となり、正しくふるまいません。</p><h3 id=更新戦略>更新戦略</h3><p><code>.spec.strategy</code>は古いPodから新しいPodに置き換える際の更新戦略を指定します。<code>.spec.strategy.type</code>は"Recreate"もしくは"RollingUpdate"を指定できます。デフォルトは"RollingUpdate"です。</p><h4 id=deploymentの再作成>Deploymentの再作成</h4><p><code>.spec.strategy.type==Recreate</code>と指定されているとき、既存の全てのPodは新しいPodが作成される前に削除されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> これは更新のための作成の前にPodを停止する事を保証するだけです。Deploymentを更新する場合、古いリビジョンのPodは全てすぐに停止されます。削除に成功するまでは、新しいリビジョンのPodは作成されません。手動でPodを削除すると、ライフサイクルがReplicaSetに制御されているのですぐに置き換えが実施されます（たとえ古いPodがまだ停止中のステータスでも）。Podに"高々この程度の"保証を求めるならば<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>の使用を検討してください。</div><h4 id=deploymentのローリングアップデート>Deploymentのローリングアップデート</h4><p><code>.spec.strategy.type==RollingUpdate</code>と指定されているとき、DeploymentはローリングアップデートによりPodを更新します。ローリングアップデートの処理をコントロールするために<code>maxUnavailable</code>と<code>maxSurge</code>を指定できます。</p><h5 id=max-unavailable>Max Unavailable</h5><p><code>.spec.strategy.rollingUpdate.maxUnavailable</code>はオプションのフィールドで、更新処理において利用不可となる最大のPod数を指定します。値は絶対値(例: 5)を指定するか、理想状態のPodのパーセンテージを指定します(例: 10%)。パーセンテージを指定した場合、絶対値は小数切り捨てされて計算されます。<code>.spec.strategy.rollingUpdate.maxSurge</code>が0に指定されている場合、この値を0にできません。デフォルトでは25%です。</p><p>例えば、この値が30%と指定されているとき、ローリングアップデートが開始すると古いReplicaSetはすぐに理想状態の70%にスケールダウンされます。一度新しいPodが稼働できる状態になると、古いReplicaSetはさらにスケールダウンされ、続いて新しいReplicaSetがスケールアップされます。この間、利用可能なPodの総数は理想状態のPodの少なくとも70%以上になるように保証されます。</p><h5 id=max-surge>Max Surge</h5><p><code>.spec.strategy.rollingUpdate.maxSurge</code>はオプションのフィールドで、理想状態のPod数を超えて作成できる最大のPod数を指定します。値は絶対値(例: 5)を指定するか、理想状態のPodのパーセンテージを指定します(例: 10%)。パーセンテージを指定した場合、絶対値は小数切り上げで計算されます。<code>MaxUnavailable</code>が0に指定されている場合、この値を0にできません。デフォルトでは25%です。</p><p>例えば、この値が30%と指定されているとき、ローリングアップデートが開始すると新しいReplicaSetはすぐに更新されます。このとき古いPodと新しいPodの総数は理想状態の130%を超えないように更新されます。一度古いPodが削除されると、新しいReplicaSetはさらにスケールアップされます。この間、利用可能なPodの総数は理想状態のPodに対して最大130%になるように保証されます。</p><h3 id=progress-deadline-seconds>Progress Deadline Seconds</h3><p><code>.spec.progressDeadlineSeconds</code>はオプションのフィールドで、システムがDeploymentの<a href=#failed-deployment>更新に失敗</a>したと判断するまでに待つ秒数を指定します。更新に失敗したと判断されたとき、リソースのステータスは<code>Type=Progressing</code>、<code>Status=False</code>かつ<code>Reason=ProgressDeadlineExceeded</code>となるのを確認できます。DeploymentコントローラーはDeploymentの更新のリトライし続けます。デフォルト値は600です。今後、自動的なロールバックが実装されたとき、更新失敗状態になるとすぐにDeploymentコントローラーがロールバックを行うようになります。</p><p>この値が指定されているとき、<code>.spec.minReadySeconds</code>より大きい値を指定する必要があります。</p><h3 id=min-ready-seconds>Min Ready Seconds</h3><p><code>.spec.minReadySeconds</code>はオプションのフィールドで、新しく作成されたPodが利用可能となるために、最低どれくらいの秒数コンテナーがクラッシュすることなく稼働し続ければよいかを指定するものです。デフォルトでは0です(Podは作成されるとすぐに利用可能と判断されます)。Podが利用可能と判断された場合についてさらに学ぶために<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>Container Probes</a>を参照してください。</p><h3 id=リビジョン履歴の保持上限>リビジョン履歴の保持上限</h3><p>Deploymentのリビジョン履歴は、Deploymentが管理するReplicaSetに保持されています。</p><p><code>.spec.revisionHistoryLimit</code>はオプションのフィールドで、ロールバック可能な古いReplicaSetの数を指定します。この古いReplicaSetは<code>etcd</code>内のリソースを消費し、<code>kubectl get rs</code>の出力結果を見にくくします。Deploymentの各リビジョンの設定はReplicaSetに保持されます。このため一度古いReplicaSetが削除されると、そのリビジョンのDeploymentにロールバックすることができなくなります。デフォルトでは10もの古いReplicaSetが保持されます。しかし、この値の最適値は新しいDeploymentの更新頻度と安定性に依存します。</p><p>さらに詳しく言うと、この値を0にすると、0のレプリカを持つ古い全てのReplicaSetが削除されます。このケースでは、リビジョン履歴が完全に削除されているため新しいDeploymentのロールアウトを元に戻すことができません。</p><h3 id=paused>paused</h3><p><code>.spec.paused</code>はオプションのboolean値で、Deploymentの一時停止と再開のための値です。一時停止されているものと、そうでないものとの違いは、一時停止されているDeploymentはPodTemplateSpecのいかなる変更があってもロールアウトがトリガーされないことです。デフォルトではDeploymentは一時停止していない状態で作成されます。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d459b930218774655fa7fd1620625539>2.2 - ReplicaSet</h1><p>ReplicaSetの目的は、どのような時でも安定したレプリカPodのセットを維持することです。これは、理想的なレプリカ数のPodが利用可能であることを保証するものとして使用されます。</p><h2 id=how-a-replicaset-works>ReplicaSetがどのように動くか</h2><p>ReplicaSetは、ReplicaSetが対象とするPodをどう特定するかを示すためのセレクターや、稼働させたいPodのレプリカ数、Podテンプレート(理想のレプリカ数の条件を満たすために作成される新しいPodのデータを指定するために用意されるもの)といったフィールドとともに定義されます。ReplicaSetは、指定された理想のレプリカ数にするためにPodの作成と削除を行うことにより、その目的を達成します。ReplicaSetが新しいPodを作成するとき、ReplicaSetはそのPodテンプレートを使用します。</p><p>ReplicaSetがそのPod群と連携するためのリンクは、Podの<a href=/ja/docs/concepts/architecture/garbage-collection/#owners-dependents>metadata.ownerReferences</a>というフィールド(現在のオブジェクトが所有されているリソースを指定する)を介して作成されます。ReplicaSetによって所持された全てのPodは、それらの<code>ownerReferences</code>フィールドにReplicaSetを特定する情報を保持します。このリンクを通じて、ReplicaSetは管理しているPodの状態を把握したり、その後の実行計画を立てます。</p><p>ReplicaSetは、そのセレクターを使用することにより、所有するための新しいPodを特定します。もし<code>ownerReference</code>フィールドの値を持たないPodか、<code>ownerReference</code>フィールドの値が <a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>でないPodで、そのPodがReplicaSetのセレクターとマッチした場合に、そのPodは即座にそのReplicaSetによって所有されます。</p><h2 id=replicasetを使うとき>ReplicaSetを使うとき</h2><p>ReplicaSetはどんな時でも指定された数のPodのレプリカが稼働することを保証します。しかし、DeploymentはReplicaSetを管理する、より上位レベルの概念で、Deploymentはその他の多くの有益な機能と共に、宣言的なPodのアップデート機能を提供します。それゆえ、我々はユーザーが独自のアップデートオーケストレーションを必要としたり、アップデートを全く必要としないような場合を除いて、ReplicaSetを直接使うよりも代わりにDeploymentを使うことを推奨します。</p><p>これは、ユーザーがReplicaSetのオブジェクトを操作する必要が全く無いことを意味します。
代わりにDeploymentを使用して、<code>spec</code>セクションにユーザーのアプリケーションを定義してください。</p><h2 id=replicasetの使用例>ReplicaSetの使用例</h2><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/frontend.yaml download=controllers/frontend.yaml><code>controllers/frontend.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-frontend-yaml")' title="Copy controllers/frontend.yaml to clipboard"></img></div><div class=includecode id=controllers-frontend-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ケースに応じてレプリカを修正する</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-frontend:v3<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>上記のマニフェストを<code>frontend.yaml</code>ファイルに保存しKubernetesクラスターに適用すると、マニフェストに定義されたReplicaSetとそれが管理するPod群を作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f http://k8s.io/examples/controllers/frontend.yaml
</span></span></code></pre></div><p>ユーザーはデプロイされた現在のReplicaSetの情報も取得できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>そして、ユーザーが作成したfrontendリソースについての情報も取得できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME       DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>frontend   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       6s
</span></span></code></pre></div><p>ユーザーはまたReplicaSetの状態も確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe rs/frontend
</span></span></code></pre></div><p>その結果は以下のようになります。</p><pre tabindex=0><code>Name:		frontend
Namespace:	default
Selector:	tier=frontend
Labels:		app=guestbook
		tier=frontend
Annotations:	kubectl.kubernetes.io/last-applied-configuration:
                {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;ReplicaSet&#34;,&#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;labels&#34;:{&#34;app&#34;:&#34;guestbook&#34;,&#34;tier&#34;:&#34;frontend&#34;},&#34;name&#34;:&#34;frontend&#34;,...
Replicas:	3 current / 3 desired
Pods Status:	3 Running / 0 Waiting / 0 Succeeded / 0 Failed
Pod Template:
  Labels:  tier=frontend
  Containers:
   php-redis:
    Image:        gcr.io/google_samples/gb-frontend:v3
    Port:         &lt;none&gt;
    Host Port:    &lt;none&gt;
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Events:
  Type    Reason            Age   From                   Message
  ----    ------            ----  ----                   -------
  Normal  SuccessfulCreate  117s  replicaset-controller  Created pod: frontend-wtsmm
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-b2zdv
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-vcmts
</code></pre><p>そして最後に、ユーザーはReplicaSetによって作成されたPodもチェックできます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>表示されるPodに関する情報は以下のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME             READY   STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>frontend-b2zdv   1/1     Running   <span style=color:#666>0</span>          6m36s
</span></span><span style=display:flex><span>frontend-vcmts   1/1     Running   <span style=color:#666>0</span>          6m36s
</span></span><span style=display:flex><span>frontend-wtsmm   1/1     Running   <span style=color:#666>0</span>          6m36s
</span></span></code></pre></div><p>ユーザーはまた、それらのPodの<code>ownerReferences</code>が<code>frontend</code>ReplicaSetに設定されていることも確認できます。
これを確認するためには、稼働しているPodの中のどれかのyamlファイルを取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods frontend-b2zdv -o yaml
</span></span></code></pre></div><p>その表示結果は、以下のようになります。その<code>frontend</code>ReplicaSetの情報が<code>metadata</code>の<code>ownerReferences</code>フィールドにセットされています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-12T07:06:16Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>generateName</span>:<span style=color:#bbb> </span>frontend-<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-b2zdv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ownerReferences</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>blockOwnerDeletion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>f391f6db-bb9b-4c09-ae74-6a1f77f3d5cf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=テンプレートなしのpodの所有>テンプレートなしのPodの所有</h2><p>ユーザーが問題なくベアPod(Bare Pod: ここではPodテンプレート無しのPodのこと)を作成しているとき、そのベアPodがユーザーのReplicaSetの中のいずれのセレクターともマッチしないことを確認することを強く推奨します。
この理由として、ReplicaSetは、所有対象のPodがReplicaSetのテンプレートによって指定されたPodのみに限定されていないからです(ReplicaSetは前のセクションで説明した方法によって他のPodも所有できます)。</p><p>前のセクションで取り上げた<code>frontend</code>ReplicaSetと、下記のマニフェストのPodをみてみます。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-rs.yaml download=pods/pod-rs.yaml><code>pods/pod-rs.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-rs-yaml")' title="Copy pods/pod-rs.yaml to clipboard"></img></div><div class=includecode id=pods-pod-rs-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:2.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:1.0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>これらのPodは<code>ownerReferences</code>に何のコントローラー(もしくはオブジェクト)も指定されておらず、そして<code>frontend</code>ReplicaSetにマッチするセレクターをもっており、これらのPodは即座に<code>frontend</code>ReplicaSetによって所有されます。</p><p>この<code>frontend</code>ReplicaSetがデプロイされ、初期のPodレプリカがレプリカ数の要求を満たすためにセットアップされた後で、ユーザーがそのPodを作成することを考えます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f http://k8s.io/examples/pods/pod-rs.yaml
</span></span></code></pre></div><p>新しいPodはそのReplicaSetによって所有され、そのReplicaSetのレプリカ数が、設定された理想のレプリカ数を超えた場合すぐにそれらのPodは削除されます。</p><p>下記のコマンドでPodを取得できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>その表示結果で、新しいPodがすでに削除済みか、削除中のステータスになっているのを確認できます。</p><pre tabindex=0><code>NAME             READY   STATUS        RESTARTS   AGE
frontend-b2zdv   1/1     Running       0          10m
frontend-vcmts   1/1     Running       0          10m
frontend-wtsmm   1/1     Running       0          10m
pod1             0/1     Terminating   0          1s
pod2             0/1     Terminating   0          1s
</code></pre><p>もしユーザーがそのPodを最初に作成する場合</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f http://k8s.io/examples/pods/pod-rs.yaml
</span></span></code></pre></div><p>そしてその後に<code>frontend</code>ReplicaSetを作成すると、</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f http://k8s.io/examples/controllers/frontend.yaml
</span></span></code></pre></div><p>ユーザーはそのReplicaSetが作成したPodを所有し、さらにもともと存在していたPodと今回新たに作成されたPodの数が、理想のレプリカ数になるまでPodを作成するのを確認できます。
ここでまたPodの状態を取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>取得結果は下記のようになります。</p><pre tabindex=0><code>NAME             READY   STATUS    RESTARTS   AGE
frontend-hmmj2   1/1     Running   0          9s
pod1             1/1     Running   0          36s
pod2             1/1     Running   0          36s
</code></pre><p>この方法で、ReplicaSetはテンプレートで指定されたもの以外のPodを所有することができます。</p><h2 id=replicasetのマニフェストを記述する>ReplicaSetのマニフェストを記述する。</h2><p>他の全てのKubernetes APIオブジェクトのように、ReplicaSetは<code>apiVersion</code>、<code>kind</code>と<code>metadata</code>フィールドを必要とします。
ReplicaSetでは、<code>kind</code>フィールドの値は<code>ReplicaSet</code>です。</p><p>ReplicaSetオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><p>また、ReplicaSetは<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> セクション</a>も必須です。</p><h3 id=pod-テンプレート>Pod テンプレート</h3><p><code>.spec.template</code>はラベルを持つことが必要な<a href=/ja/docs/concepts/workloads/pods/#pod-template>Podテンプレート</a> です。先ほど作成した<code>frontend.yaml</code>の例では、<code>tier: frontend</code>というラベルを1つ持っています。
他のコントローラーがこのPodを所有しようとしないためにも、他のコントローラーのセレクターでラベルを上書きしないように注意してください。</p><p>テンプレートの<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy>再起動ポリシー</a>のためのフィールドである<code>.spec.template.spec.restartPolicy</code>は<code>Always</code>のみ許可されていて、そしてそれがデフォルト値です。</p><h3 id=pod-セレクター>Pod セレクター</h3><p><code>.spec.selector</code>フィールドは<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルセレクター</a>です。
<a href=#how-a-replicaset-works>先ほど</a>議論したように、ReplicaSetが所有するPodを指定するためにそのラベルが使用されます。
先ほどの<code>frontend.yaml</code>の例では、そのセレクターは下記のようになっていました</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span></code></pre></div><p>そのReplicaSetにおいて、<code>.spec.template.metadata.labels</code>フィールドの値は<code>spec.selector</code>と一致しなくてはならず、一致しない場合はAPIによって拒否されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 2つのReplicaSetが同じ<code>.spec.selector</code>の値を設定しているが、それぞれ異なる<code>.spec.template.metadata.labels</code>と<code>.spec.template.spec</code>フィールドの値を持っていたとき、それぞれのReplicaSetはもう一方のReplicaSetによって作成されたPodを無視します。</div><h3 id=レプリカ数について>レプリカ数について</h3><p>ユーザーは<code>.spec.replicas</code>フィールドの値を設定することにより、いくつのPodを同時に稼働させるか指定できます。そのときReplicaSetはレプリカ数がこの値に達するまでPodを作成、または削除します。</p><p>もしユーザーが<code>.spec.replicas</code>を指定しない場合、デフォルト値として1がセットされます。</p><h2 id=replicasetを利用する>ReplicaSetを利用する</h2><h3 id=replicasetとpodの削除>ReplicaSetとPodの削除</h3><p>ReplicaSetとそれが所有する全てのPod削除したいときは、<a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>コマンドを使ってください。<br><a href=/ja/docs/concepts/architecture/garbage-collection/>ガベージコレクター</a>がデフォルトで自動的に全ての依存するPodを削除します。</p><p>REST APIもしくは<code>client-go</code>ライブラリーを使用するとき、ユーザーは<code>-d</code>オプションで<code>propagationPolicy</code>を<code>Background</code>か<code>Foreground</code>と指定しなくてはなりません。例えば下記のように実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><h3 id=replicasetのみを削除する>ReplicaSetのみを削除する</h3><p>ユーザーは<a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>コマンドで<code>--cascade=false</code>オプションを付けることにより、所有するPodに影響を与えることなくReplicaSetを削除できます。
REST APIもしくは<code>client-go</code>ライブラリーを使用するとき、ユーザーは<code>-d</code>オプションで<code>propagationPolicy</code>を<code>Orphan</code>と指定しなくてはなりません。
例えば下記のように実行します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>一度元のReplicaSetが削除されると、ユーザーは新しいものに置き換えるため新しいReplicaSetを作ることができます。新旧のReplicaSetの<code>.spec.selector</code>の値が同じである間、新しいReplicaSetは古いReplicaSetで稼働していたPodを取り入れます。
しかし、存在するPodが新しく異なるPodテンプレートとマッチさせようとするとき、この仕組みは機能しません。
ReplicaSetはローリングアップデートを直接サポートしないため、ユーザーのコントロール下においてPodを新しいspecにアップデートしたい場合は、<a href=/ja/docs/concepts/workloads/controllers/deployment/#creating-a-deployment>Deployment</a>を使用してください。</p><h3 id=podをreplicasetから分離させる>PodをReplicaSetから分離させる</h3><p>ユーザーはPodのラベルを変更することにより、ReplicaSetからそのPodを削除できます。この手法はデバッグや、データ修復などのためにサービスからPodを削除したいときに使用できます。
この方法で削除されたPodは自動的に新しいものに置き換えられます。(レプリカ数は変更されないものと仮定します。)</p><h3 id=replicasetのスケーリング>ReplicaSetのスケーリング</h3><p>ReplicaSetは、ただ<code>.spec.replicas</code>フィールドを更新することによって簡単にスケールアップまたはスケールダウンできます。ReplicaSetコントローラーは、ラベルセレクターにマッチするような指定した数のPodが利用可能であり、操作可能であることを保証します。</p><p>スケールダウンする場合、ReplicaSetコントローラーは以下の一般的なアルゴリズムに基づき、利用可能なPodをソートし、スケールダウンするPodの優先順位を付け、削除するPodを選択します:</p><ol><li>保留している(またはスケジュール不可な)Podが先にスケールダウンされます。</li><li><code>controller.kubernetes.io/pod-deletion-cost</code>アノテーションが設定されている場合、値の小さいPodが優先されます。</li><li>レプリカ数の多いノード上のPodが、レプリカ数の少ないノード上のPodより優先されます。</li><li>Podの作成時間が異なる場合、より新しく作成されたPodが古いPodより優先されます(<code>LogarithmicScaleDown</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>が有効の場合、作成時間は整数対数スケールでバケット化されます)。</li></ol><p>上記条件のすべてに該当する場合は、ランダム選択となります。</p><h3 id=pod削除コスト>Pod削除コスト</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code></div><p><a href=/docs/reference/labels-annotations-taints/#pod-deletion-cost><code>controller.kubernetes.io/pod-deletion-cost</code></a>アノテーションを使用すると、ReplicaSetをスケールダウンする際に、どのPodを最初に削除するかについて、ユーザーが優先順位を設定することができます。</p><p>アノテーションはPodに設定する必要があり、範囲は[-2147483647, 2147483647]になります。同じReplicaSetに属する他のPodと比較して、Podを削除する際のコストを表しています。削除コストの低いPodは、削除コストの高いPodより優先的に削除されます。</p><p>このアノテーションを設定しないPodは暗黙的に0と設定され、負の値は許容されます。
無効な値はAPIサーバーによって拒否されます。</p><p>この機能はbeta版で、デフォルトで有効になっています。kube-apiserverとkube-controller-managerで<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a><code>PodDeletionCost</code>を設定することで無効にすることができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><ul><li>これはベストエフォートで実行されているもので、Pod削除の順番を保証するものではありません。</li><li>ユーザーは、メトリック値に基づいてアノテーションを更新するなど、頻繁に更新することは避けるべきです。APIサーバー上で大量のPodの更新操作を発生させることになるためです。</li></ul></div><h4 id=使用事例>使用事例</h4><p>アプリケーションの異なるPodは、異なる使用レベルになる可能性があります。スケールダウンする場合、アプリケーションは使用率の低いPodを削除することを優先しています。Podを頻繁に更新することを避けるため、アプリケーションはスケールダウンする前に一度<code>controller.kubernetes.io/pod-deletion-cost</code>を更新する必要があります(アノテーションをPod使用レベルに比例する値に設定します)。Spark DeploymentのドライバーPodのように、アプリケーション自体がスケールダウンを制御する場合も機能します。</p><h3 id=horizontalpodautoscaler-hpa-のターゲットとしてのreplicaset>HorizontalPodAutoscaler(HPA)のターゲットとしてのReplicaSet</h3><p>ReplicaSetはまた、<a href=/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscalers (HPA)</a>のターゲットにもなることができます。
これはつまりReplicaSetがHPAによってオートスケールされうることを意味します。
ここではHPAが、前の例で作成したReplicaSetをターゲットにする例を示します。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/hpa-rs.yaml download=controllers/hpa-rs.yaml><code>controllers/hpa-rs.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-hpa-rs-yaml")' title="Copy controllers/hpa-rs.yaml to clipboard"></img></div><div class=includecode id=controllers-hpa-rs-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-scaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>このマニフェストを<code>hpa-rs.yaml</code>に保存し、Kubernetesクラスターに適用すると、レプリケートされたPodのCPU使用量にもとづいてターゲットのReplicaSetをオートスケールするHPAを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/hpa-rs.yaml
</span></span></code></pre></div><p>同様のことを行うための代替案として、<code>kubectl autoscale</code>コマンドも使用できます。(こちらの方がより簡単です。)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale rs frontend --max<span style=color:#666>=</span><span style=color:#666>10</span> --min<span style=color:#666>=</span><span style=color:#666>3</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span>
</span></span></code></pre></div><h2 id=replicasetの代替案>ReplicaSetの代替案</h2><h3 id=deployment-推奨>Deployment (推奨)</h3><p><a href=/ja/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>はReplicaSetを所有することのできるオブジェクトで、宣言的なサーバサイドのローリングアップデートを介してReplicaSetとPodをアップデートできます。
ReplicaSetは単独で使用可能ですが、現在では、ReplicaSetは主にPodの作成、削除とアップデートを司るためのメカニズムとしてDeploymentによって使用されています。ユーザーがDeploymentを使用するとき、Deploymentによって作成されるReplicaSetの管理について心配する必要はありません。DeploymentはReplicaSetを所有し、管理します。
このため、もしユーザーがReplicaSetを必要とするとき、Deploymentの使用を推奨します。</p><h3 id=ベアpod-bare-pods>ベアPod(Bare Pods)</h3><p>ユーザーがPodを直接作成するケースとは異なり、ReplicaSetはNodeの故障やカーネルのアップグレードといった破壊的なNodeのメンテナンスなど、どのような理由に限らず削除または停止されたPodを置き換えます。
このため、我々はもしユーザーのアプリケーションが単一のPodのみ必要とする場合でもReplicaSetを使用することを推奨します。プロセスのスーパーバイザーについても同様に考えると、それは単一Node上での独立したプロセスの代わりに複数のNodeにまたがった複数のPodを監視します。
ReplicaSetは、KubeletのようなNode上のいくつかのエージェントに対して、ローカルのコンテナ再起動を移譲します。</p><h3 id=job>Job</h3><p>PodをPodそれ自身で停止させたいような場合(例えば、バッチ用のジョブなど)は、ReplicaSetの代わりに<a href=/ja/docs/concepts/workloads/controllers/job/><code>Job</code></a>を使用してください。</p><h3 id=daemonset>DaemonSet</h3><p>マシンの監視やロギングなど、マシンレベルの機能を提供したい場合は、ReplicaSetの代わりに<a href=/ja/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>を使用してください。
これらのPodはマシン自体のライフタイムに紐づいています: そのPodは他のPodが起動する前に、そのマシン上で稼働される必要があり、マシンが再起動またはシャットダウンされるときには、安全に停止されます。</p><h3 id=replicationcontroller>ReplicationController</h3><p>ReplicaSetは<a href=/docs/concepts/workloads/controllers/replicationcontroller/><em>ReplicationControllers</em></a>の後継となるものです。
この2つは、ReplicationControllerが<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルについてのユーザーガイド</a>に書かれているように、集合ベース(set-based)のセレクター要求をサポートしていないことを除いては、同じ目的を果たし、同じようにふるまいます。<br>このように、ReplicaSetはReplicationControllerよりも好まれます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/workloads/pods/>Pod</a>について学ぶ。</li><li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>について学ぶ。</li><li>ReplicaSetsに依存した<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>Deploymentを使用してステートレスアプリケーションを実行する</a>。</li><li><code>ReplicaSet</code>はKubernetes REST APIのトップレベルのリソースです。
<a href=/docs/reference/kubernetes-api/workload-resources/replica-set-v1/>ReplicaSet</a>オブジェクトの定義を読み、レプリカセットのAPIを理解する。</li><li><a href=/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>について、またPodDisruptionBudgetで障害発生時のアプリケーションの可用性を管理する方法について読む。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6d72299952c37ca8cc61b416e5bdbcd4>2.3 - StatefulSet</h1><p>StatefulSetはステートフルなアプリケーションを管理するためのワークロードAPIです。</p><p>StatefulSetはDeploymentと<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>のセットのスケーリングを管理し、それらのPodの<em>順序と一意性を保証</em> します。</p><p><a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>のように、StatefulSetは指定したコンテナのspecに基づいてPodを管理します。Deploymentとは異なり、StatefulSetは各Podにおいて管理が大変な同一性を維持します。これらのPodは同一のspecから作成されますが、それらは交換可能ではなく、リスケジュール処理をまたいで維持される永続的な識別子を持ちます。</p><p>ワークロードに永続性を持たせるためにストレージボリュームを使いたい場合は、解決策の1つとしてStatefulSetが利用できます。StatefulSet内の個々のPodは障害の影響を受けやすいですが、永続化したPodの識別子は既存のボリュームと障害によって置換された新しいPodの紐付けを簡単にします。</p><h2 id=statefulsetの使用>StatefulSetの使用</h2><p>StatefulSetは下記の1つ以上の項目を要求するアプリケーションにおいて最適です。</p><ul><li>安定した一意のネットワーク識別子</li><li>安定した永続ストレージ</li><li>規則的で安全なデプロイとスケーリング</li><li>規則的で自動化されたローリングアップデート</li></ul><p>上記において安定とは、Podのスケジュール(または再スケジュール)をまたいでも永続的であることと同義です。
もしアプリケーションが安定したネットワーク識別子と規則的なデプロイや削除、スケーリングを全く要求しない場合、ユーザーはステートレスなレプリカのセットを提供するワークロードを使ってアプリケーションをデプロイするべきです。
<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>や<a href=/ja/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>のようなコントローラーはこのようなステートレスな要求に対して最適です。</p><h2 id=制限事項>制限事項</h2><ul><li>提供されたPodのストレージは、要求された<code>storage class</code>にもとづいて<a href=https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/README.md>PersistentVolume Provisioner</a>によってプロビジョンされるか、管理者によって事前にプロビジョンされなくてはなりません。</li><li>StatefulSetの削除もしくはスケールダウンをすることにより、StatefulSetに関連したボリュームは削除<em>されません</em> 。 これはデータ安全性のためで、関連するStatefulSetのリソース全てを自動的に削除するよりもたいてい有効です。</li><li>StatefulSetは現在、Podのネットワークアイデンティティーに責務をもつために<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless Service</a>を要求します。ユーザーはこのServiceを作成する責任があります。</li><li>StatefulSetは、StatefulSetが削除されたときにPodの停止を行うことを保証していません。StatefulSetにおいて、規則的で安全なPodの停止を行う場合、削除のために事前にそのStatefulSetの数を0にスケールダウンさせることが可能です。</li><li>デフォルト設定の<a href=#pod-management-policies>Pod管理ポリシー</a> (<code>OrderedReady</code>)によって<a href=#rolling-updates>ローリングアップデート</a>を行う場合、<a href=#forced-rollback>修復のための手動介入</a>を要求するようなブロークンな状態に遷移させることが可能です。</li></ul><h2 id=コンポーネント>コンポーネント</h2><p>下記の例は、StatefulSetのコンポーネントのデモンストレーションとなります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># .spec.template.metadata.labelsの値と一致する必要があります</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginx&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># by default is 1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># .spec.selector.matchLabelsの値と一致する必要があります</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/nginx-slim:0.8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-storage-class&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>上記の例では、</p><ul><li>nginxという名前のHeadlessServiceは、ネットワークドメインをコントロールするために使われます。</li><li>webという名前のStatefulSetは、specで3つのnginxコンテナのレプリカを持ち、そのコンテナはそれぞれ別のPodで稼働するように設定されています。</li><li>volumeClaimTemplatesは、PersistentVolumeプロビジョナーによってプロビジョンされた<a href=/ja/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>を使って安定したストレージを提供します。</li></ul><p>StatefulSetの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>名前</a>である必要があります。</p><h2 id=podセレクター>Podセレクター</h2><p>ユーザーは、StatefulSetの<code>.spec.template.metadata.labels</code>のラベルと一致させるため、StatefulSetの<code>.spec.selector</code>フィールドをセットしなくてはなりません。Kubernetes1.8以前では、<code>.spec.selector</code>フィールドは省略された場合デフォルト値になります。Kubernetes1.8とそれ以降のバージョンでは、ラベルに一致するPodセレクターの指定がない場合はStatefulSetの作成時にバリデーションエラーになります。</p><h2 id=podアイデンティティー>Podアイデンティティー</h2><p>StatefulSetのPodは、順番を示す番号、安定したネットワークアイデンティティー、安定したストレージからなる一意なアイデンティティーを持ちます。
そのアイデンティティーはどのNode上にスケジュール(もしくは再スケジュール)されるかに関わらず、そのPodに紐付きます。</p><h3 id=順序インデックス>順序インデックス</h3><p>N個のレプリカをもったStatefulSetにおいて、StatefulSet内の各Podは、0からはじまりN-1までの整数値を順番に割り当てられ、そのStatefulSetにおいては一意となります。</p><h3 id=安定したネットワークid>安定したネットワークID</h3><p>StatefulSet内の各Podは、そのStatefulSet名とPodの順序番号から派生してホストネームが割り当てられます。
作成されたホストネームの形式は<code>$(StatefulSet名)-$(順序番号)</code>となります。先ほどの上記の例では、<code>web-0,web-1,web-2</code>という3つのPodが作成されます。
StatefulSetは、Podのドメインをコントロールするために<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless Service</a>を使うことができます。
このHeadless Serviceによって管理されたドメインは<code>$(Service名).$(ネームスペース).svc.cluster.local</code>形式となり、"cluster.local"というのはそのクラスターのドメインとなります。
各Podが作成されると、Podは<code>$(Pod名).$(管理するServiceドメイン名)</code>に一致するDNSサブドメインを取得し、管理するServiceはStatefulSetの<code>serviceName</code>で定義されます。</p><p>クラスターでのDNSの設定方法によっては、新たに起動されたPodのDNS名をすぐに検索できない場合があります。
この動作は、クラスター内の他のクライアントが、Podが作成される前にそのPodのホスト名に対するクエリーをすでに送信していた場合に発生する可能性があります。
(DNSでは通常)ネガティブキャッシュは、Podの起動後でも、少なくとも数秒間、以前に失敗したルックアップの結果が記憶され、再利用されることを意味します。</p><p>Podが作成された後、速やかにPodを検出する必要がある場合は、いくつかのオプションがあります。</p><ul><li>DNSルックアップに依存するのではなく、Kubernetes APIに直接(例えばwatchを使って)問い合わせる。</li><li>Kubernetes DNS プロバイダーのキャッシュ時間を短縮する(これは現在30秒キャッシュされるようになっているCoreDNSのConfigMapを編集することを意味しています。)。</li></ul><p><a href=#%E5%88%B6%E9%99%90%E4%BA%8B%E9%A0%85>制限事項</a>セクションで言及したように、ユーザーはPodのネットワークアイデンティティーのために<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless Service</a>を作成する責任があります。</p><p>ここで、クラスタードメイン、Service名、StatefulSet名の選択と、それらがStatefulSetのPodのDNS名にどう影響するかの例をあげます。</p><table><thead><tr><th>Cluster Domain</th><th>Service (ns/name)</th><th>StatefulSet (ns/name)</th><th>StatefulSet Domain</th><th>Pod DNS</th><th>Pod Hostname</th></tr></thead><tbody><tr><td>cluster.local</td><td>default/nginx</td><td>default/web</td><td>nginx.default.svc.cluster.local</td><td>web-{0..N-1}.nginx.default.svc.cluster.local</td><td>web-{0..N-1}</td></tr><tr><td>cluster.local</td><td>foo/nginx</td><td>foo/web</td><td>nginx.foo.svc.cluster.local</td><td>web-{0..N-1}.nginx.foo.svc.cluster.local</td><td>web-{0..N-1}</td></tr><tr><td>kube.local</td><td>foo/nginx</td><td>foo/web</td><td>nginx.foo.svc.kube.local</td><td>web-{0..N-1}.nginx.foo.svc.kube.local</td><td>web-{0..N-1}</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>備考:</strong> クラスタードメインは<a href=/ja/docs/concepts/services-networking/dns-pod-service/>その他の設定</a>がされない限り、<code>cluster.local</code>にセットされます。</div><h3 id=安定したストレージ>安定したストレージ</h3><p>Kubernetesは各VolumeClaimTemplateに対して、1つの<a href=/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>を作成します。上記のnginxの例において、各Podは<code>my-storage-class</code>というStorageClassをもち、1Gibのストレージ容量を持った単一のPersistentVolumeを受け取ります。もしStorageClassが指定されていない場合、デフォルトのStorageClassが使用されます。PodがNode上にスケジュール(もしくは再スケジュール)されたとき、その<code>volumeMounts</code>はPersistentVolume Claimに関連したPersistentVolumeをマウントします。
注意点として、PodのPersistentVolume Claimと関連したPersistentVolumeは、PodやStatefulSetが削除されたときに削除されません。
削除する場合は手動で行わなければなりません。</p><h3 id=podのネームラベル>Podのネームラベル</h3><p>StatefulSet <a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a> がPodを作成したとき、Podの名前として、<code>statefulset.kubernetes.io/pod-name</code>にラベルを追加します。このラベルによってユーザーはServiceにStatefulSet内の指定したPodを割り当てることができます。</p><h2 id=デプロイとスケーリングの保証>デプロイとスケーリングの保証</h2><ul><li>N個のレプリカをもつStatefulSetにおいて、Podがデプロイされるとき、それらのPodは{0..N-1}の番号で順番に作成されます。</li><li>Podが削除されるとき、それらのPodは{N-1..0}の番号で降順に削除されます。</li><li>Podに対してスケーリングオプションが適用される前に、そのPodの前の順番の全てのPodがRunningかつReady状態になっていなくてはなりません。</li><li>Podが停止される前に、そのPodの番号より大きい番号を持つの全てのPodは完全にシャットダウンされていなくてはなりません。</li></ul><p>StatefulSetは<code>pod.Spec.TerminationGracePeriodSeconds</code>を0に指定すべきではありません。これは不安全で、やらないことを強く推奨します。さらなる説明としては、<a href=/ja/docs/tasks/run-application/force-delete-stateful-set-pod/>StatefulSetのPodの強制削除</a>を参照してください。</p><p>上記の例のnginxが作成されたとき、3つのPodは<code>web-0</code>、<code>web-1</code>、<code>web-2</code>の順番でデプロイされます。<code>web-1</code>は<code>web-0</code>が<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>RunningかつReady状態</a>になるまでは決してデプロイされないのと、同様に<code>web-2</code>は<code>web-1</code>がRunningかつReady状態にならないとデプロイされません。もし<code>web-0</code>が<code>web-1</code>がRunningかつReady状態になった後だが、<code>web-2</code>が起動する前に失敗した場合、<code>web-2</code>は<code>web-0</code>の再起動が成功し、RunningかつReady状態にならないと再起動されません。</p><p>もしユーザーが<code>replicas=1</code>といったようにStatefulSetにパッチをあてることにより、デプロイされたものをスケールすることになった場合、<code>web-2</code>は最初に停止されます。<code>web-1</code>は<code>web-2</code>が完全にシャットダウンされ削除されるまでは、停止されません。もし<code>web-0</code>が、<code>web-2</code>が完全に停止され削除された後だが、<code>web-1</code>の停止の前に失敗した場合、<code>web-1</code>は<code>web-0</code>がRunningかつReady状態になるまでは停止されません。</p><h3 id=podの管理ポリシー>Podの管理ポリシー</h3><p>Kubernetes1.7とそれ以降のバージョンでは、StatefulSetは<code>.spec.podManagementPolicy</code>フィールドを介して、Podの一意性とアイデンティティーを保証します。</p><h4 id=orderedreadyなpod管理>OrderedReadyなPod管理</h4><p><code>OrderedReady</code>なPod管理はStatefulSetにおいてデフォルトです。これは<a href=#deployment-and-scaling-guarantees>デプロイとスケーリングの保証</a>に記載されている項目の振る舞いを実装します。</p><h4 id=並行なpod管理>並行なPod管理</h4><p><code>Parallel</code>なPod管理は、StatefulSetコントローラーに対して、他のPodが起動や停止される前にそのPodが完全に起動し準備完了になるか停止するのを待つことなく、Podが並行に起動もしくは停止するように指示します。</p><h2 id=アップデートストラテジー>アップデートストラテジー</h2><p>Kubernetes1.7とそれ以降のバージョンにおいて、StatefulSetの<code>.spec.updateStrategy</code>フィールドで、コンテナの自動のローリングアップデートの設定やラベル、リソースのリクエストとリミットや、StatefulSet内のPodのアノテーションを指定できます。</p><h3 id=ondelete>OnDelete</h3><p><code>OnDelete</code>というアップデートストラテジーは、レガシーな(Kubernetes1.6以前)振る舞いとなります。StatefulSetの<code>.spec.updateStrategy.type</code>が<code>OnDelete</code>にセットされていたとき、そのStatefulSetコントローラーはStatefulSet内でPodを自動的に更新しません。StatefulSetの<code>.spec.template</code>項目の修正を反映した新しいPodの作成をコントローラーに支持するためには、ユーザーは手動でPodを削除しなければなりません。</p><h3 id=rollingupdate>RollingUpdate</h3><p><code>RollingUpdate</code>というアップデートストラテジーは、StatefulSet内のPodに対する自動化されたローリングアップデートの機能を実装します。これは<code>.spec.updateStrategy</code>フィールドが未指定の場合のデフォルトのストラテジーです。StatefulSetの<code>.spec.updateStrategy.type</code>が<code>RollingUpdate</code>にセットされたとき、そのStatefulSetコントローラーは、StatefulSet内のPodを削除し、再作成します。これはPodの停止(Podの番号の降順)と同じ順番で、一度に1つのPodを更新します。コントローラーは、その前のPodの状態がRunningかつReady状態になるまで次のPodの更新を待ちます。</p><h4 id=パーティション>パーティション</h4><p><code>RollingUpdate</code>というアップデートストラテジーは、<code>.spec.updateStrategy.rollingUpdate.partition</code>を指定することにより、パーティションに分けることができます。もしパーティションが指定されていたとき、そのパーティションの値と等しいか、大きい番号を持つPodが更新されます。パーティションの値より小さい番号を持つPodは更新されず、たとえそれらのPodが削除されたとしても、それらのPodは以前のバージョンで再作成されます。もしStatefulSetの<code>.spec.updateStrategy.rollingUpdate.partition</code>が、<code>.spec.replicas</code>より大きい場合、<code>.spec.template</code>への更新はPodに反映されません。
多くのケースの場合、ユーザーはパーティションを使う必要はありませんが、もし一部の更新を行う場合や、カナリー版のバージョンをロールアウトする場合や、段階的ロールアウトを行う場合に最適です。</p><h4 id=強制ロールバック>強制ロールバック</h4><p>デフォルトの<a href=#pod-management-policies>Pod管理ポリシー</a>(<code>OrderedReady</code>)による<a href=#rolling-updates>ローリングアップデート</a>を行う際、修復のために手作業が必要な状態にすることが可能です。</p><p>もしユーザーが、決してRunningかつReady状態にならないような設定になるようにPodテンプレートを更新した場合(例えば、不正なバイナリや、アプリケーションレベルの設定エラーなど)、StatefulSetはロールアウトを停止し、待機します。</p><p>この状態では、Podテンプレートを正常な状態に戻すだけでは不十分です。<a href=https://github.com/kubernetes/kubernetes/issues/67250>既知の問題</a>によって、StatefulSetは元の正常な状態へ戻す前に、壊れたPodがReady状態(決して起こりえない)に戻るのを待ち続けます。</p><p>そのテンプレートを戻したあと、ユーザーはまたStatefulSetが異常状態で稼働しようとしていたPodをすべて削除する必要があります。StatefulSetはその戻されたテンプレートを使ってPodの再作成を始めます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/tutorials/stateful-application/basic-stateful-set/>ステートフルなアプリケーションのデプロイ</a>の例を参考にしてください。</li><li><a href=/ja/docs/tutorials/stateful-application/cassandra/>StatefulSetを使ったCassandraのデプロイ</a>の例を参考にしてください。</li><li><a href=/ja/docs/tasks/run-application/run-replicated-stateful-application/>レプリカを持つステートフルアプリケーションを実行する</a>の例を参考にしてください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-41600eb8b6631c88848156f381e9d588>2.4 - DaemonSet</h1><p><em>DaemonSet</em> は全て(またはいくつか)のNodeが単一のPodのコピーを稼働させることを保証します。Nodeがクラスターに追加されるとき、PodがNode上に追加されます。Nodeがクラスターから削除されたとき、それらのPodはガーベージコレクターにより除去されます。DaemonSetの削除により、DaemonSetが作成したPodもクリーンアップします。</p><p>DaemonSetのいくつかの典型的な使用例は以下の通りです。</p><ul><li>クラスターのストレージデーモンを全てのNode上で稼働させる。</li><li>ログ集計デーモンを全てのNode上で稼働させる。</li><li>Nodeのモニタリングデーモンを全てのNode上で稼働させる。</li></ul><p>シンプルなケースとして、各タイプのデーモンにおいて、全てのNodeをカバーする1つのDaemonSetが使用されるケースがあります。さらに複雑な設定では、単一のタイプのデーモン用ですが、異なるフラグや、異なるハードウェアタイプに対するメモリー、CPUリクエストを要求する複数のDaemonSetを使用するケースもあります。</p><h2 id=daemonset-specの記述>DaemonSet Specの記述</h2><h3 id=daemonsetの作成>DaemonSetの作成</h3><p>ユーザーはYAMLファイル内でDaemonSetの設定を記述することができます。例えば、下記の<code>daemonset.yaml</code>ファイルでは<code>fluentd-elasticsearch</code>というDockerイメージを稼働させるDaemonSetの設定を記述します。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/daemonset.yaml download=controllers/daemonset.yaml><code>controllers/daemonset.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-daemonset-yaml")' title="Copy controllers/daemonset.yaml to clipboard"></img></div><div class=includecode id=controllers-daemonset-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>fluentd-logging<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>quay.io/fluentd_elasticsearch/fluentd:v2.5.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>YAMLファイルに基づいてDaemonSetを作成します。</p><pre tabindex=0><code>kubectl apply -f https://k8s.io/examples/controllers/daemonset.yaml
</code></pre><h3 id=必須のフィールド>必須のフィールド</h3><p>他の全てのKubernetesの設定と同様に、DaemonSetは<code>apiVersion</code>、<code>kind</code>と<code>metadata</code>フィールドが必須となります。設定ファイルの活用法に関する一般的な情報は、<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>ステートレスアプリケーションの稼働</a>、<a href=/ja/docs/tasks/>コンテナの設定</a>、<a href=/ja/docs/concepts/overview/working-with-objects/object-management/>kubectlを用いたオブジェクトの管理</a>といったドキュメントを参照ください。</p><p>DaemonSetオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><p>また、DaemonSetにおいて<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code></a>セクションも必須となります。</p><h3 id=podテンプレート>Podテンプレート</h3><p><code>.spec.template</code>は<code>.spec</code>内での必須のフィールドの1つです。</p><p><code>.spec.template</code>は<a href=/docs/concepts/workloads/pods/#pod-templates>Podテンプレート</a>となります。これはフィールドがネストされていて、<code>apiVersion</code>や<code>kind</code>をもたないことを除いては、<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>のテンプレートと同じスキーマとなります。</p><p>Podに対する必須のフィールドに加えて、DaemonSet内のPodテンプレートは適切なラベルを指定しなくてはなりません(<a href=#pod-selector>Podセレクター</a>の項目を参照ください)。</p><p>DaemonSet内のPodテンプレートでは、<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>RestartPolicy</code></a>フィールドを指定せずにデフォルトの<code>Always</code>を使用するか、明示的に<code>Always</code>を設定するかのどちらかである必要があります。</p><h3 id=podセレクター>Podセレクター</h3><p><code>.spec.selector</code>フィールドはPodセレクターとなります。これは<a href=/docs/concepts/workloads/controllers/job/>Job</a>の<code>.spec.selector</code>と同じものです。</p><p>Kubernetes1.8のように、ユーザーは<code>.spec.template</code>のラベルにマッチするPodセレクターを指定しなくてはいけません。Podセレクターは、値を空のままにしてもデフォルト設定にならなくなりました。セレクターのデフォルト化は<code>kubectl apply</code>と互換性はありません。また、一度DaemonSetが作成されると、その<code>.spec.selector</code>は変更不可能になります。Podセレクターの変更は、意図しないPodの孤立を引き起こし、ユーザーにとってやっかいなものとなります。</p><p><code>.spec.selector</code>は2つのフィールドからなるオブジェクトです。</p><ul><li><code>matchLabels</code> - <a href=/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>の<code>.spec.selector</code>と同じように機能します。</li><li><code>matchExpressions</code> - キーと、値のリストとさらにはそれらのキーとバリューに関連したオペレーターを指定することにより、より洗練された形式のセレクターを構成できます。</li></ul><p>上記の2つが指定された場合は、2つの条件をANDでどちらも満たすものを結果として返します。</p><p>もし<code>spec.selector</code>が指定されたとき、<code>.spec.template.metadata.labels</code>とマッチしなければなりません。この2つの値がマッチしない設定をした場合、APIによってリジェクトされます。</p><h3 id=選択したnode上でpodを稼働させる>選択したNode上でPodを稼働させる</h3><p>もしユーザーが<code>.spec.template.spec.nodeSelector</code>を指定したとき、DaemonSetコントローラーは、その<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>node selector</a>にマッチするNode上にPodを作成します。同様に、もし<code>.spec.template.spec.affinity</code>を指定したとき、DaemonSetコントローラーは<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>node affinity</a>にマッチするNode上にPodを作成します。
もしユーザーがどちらも指定しないとき、DaemonSetコントローラーは全てのNode上にPodを作成します。</p><h2 id=daemon-podがどのようにスケジューリングされるか>Daemon Podがどのようにスケジューリングされるか</h2><h3 id=デフォルトスケジューラーによってスケジューリングされる場合>デフォルトスケジューラーによってスケジューリングされる場合</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.17 [stable]</code></div><p>DaemonSetは全ての利用可能なNodeが単一のPodのコピーを稼働させることを保証します。通常、Podが稼働するNodeはKubernetesスケジューラーによって選択されます。しかし、DaemonSetのPodは代わりにDaemonSetコントローラーによって作成され、スケジューリングされます。<br>下記の問題について説明します:</p><ul><li>矛盾するPodのふるまい: スケジューリングされるのを待っている通常のPodは、作成されているが<code>Pending</code>状態となりますが、DaemonSetのPodは<code>Pending</code>状態で作成されません。これはユーザーにとって困惑するものです。</li><li><a href=/docs/concepts/configuration/pod-priority-preemption/>Podプリエンプション(Pod preemption)</a>はデフォルトスケジューラーによってハンドルされます。もしプリエンプションが有効な場合、そのDaemonSetコントローラーはPodの優先順位とプリエンプションを考慮することなくスケジューリングの判断を行います。</li></ul><p><code>ScheduleDaemonSetPods</code>は、DaemonSetのPodに対して<code>NodeAffinity</code>項目を追加することにより、DaemonSetコントローラーの代わりにデフォルトスケジューラーを使ってDaemonSetのスケジュールを可能にします。その際に、デフォルトスケジューラーはPodをターゲットのホストにバインドします。もしDaemonSetのNodeAffinityが存在するとき、それは新しいものに置き換えられます(ターゲットホストを選択する前に、元のNodeAffinityが考慮されます)。DaemonSetコントローラーはDaemonSetのPodの作成や修正を行うときのみそれらの操作を実施します。そしてDaemonSetの<code>.spec.template</code>フィールドに対しては何も変更が加えられません。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>matchFields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- target-host-name<span style=color:#bbb>
</span></span></span></code></pre></div><p>さらに、<code>node.kubernetes.io/unschedulable:NoSchedule</code>というtolarationがDaemonSetのPodに自動的に追加されます。デフォルトスケジューラーは、DaemonSetのPodのスケジューリングのときに、<code>unschedulable</code>なNodeを無視します。</p><h3 id=taintsとtolerations>TaintsとTolerations</h3><p>DaemonSetのPodは<a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>TaintsとTolerations</a>の設定を尊重します。下記のTolerationsは、関連する機能によって自動的にDaemonSetのPodに追加されます。</p><table><thead><tr><th>Toleration Key</th><th>Effect</th><th>Version</th><th>Description</th></tr></thead><tbody><tr><td><code>node.kubernetes.io/not-ready</code></td><td>NoExecute</td><td>1.13+</td><td>DaemonSetのPodはネットワーク分割のようなNodeの問題が発生したときに除外されません。</td></tr><tr><td><code>node.kubernetes.io/unreachable</code></td><td>NoExecute</td><td>1.13+</td><td>DaemonSetのPodはネットワーク分割のようなNodeの問題が発生したときに除外されません。</td></tr><tr><td><code>node.kubernetes.io/disk-pressure</code></td><td>NoSchedule</td><td>1.8+</td><td></td></tr><tr><td><code>node.kubernetes.io/memory-pressure</code></td><td>NoSchedule</td><td>1.8+</td><td></td></tr><tr><td><code>node.kubernetes.io/unschedulable</code></td><td>NoSchedule</td><td>1.12+</td><td>DaemonSetのPodはデフォルトスケジューラーによってスケジュール不可能な属性を許容(tolerate)します。</td></tr><tr><td><code>node.kubernetes.io/network-unavailable</code></td><td>NoSchedule</td><td>1.12+</td><td>ホストネットワークを使うDaemonSetのPodはデフォルトスケジューラーによってネットワーク利用不可能な属性を許容(tolerate)します。</td></tr></tbody></table><h2 id=daemon-podとのコミュニケーション>Daemon Podとのコミュニケーション</h2><p>DaemonSet内のPodとのコミュニケーションをする際に考えられるパターンは以下の通りです。:</p><ul><li><strong>Push</strong>: DaemonSet内のPodは他のサービスに対して更新情報を送信するように設定されます。</li><li><strong>NodeIPとKnown Port</strong>: PodがNodeIPを介して疎通できるようにするため、DaemonSet内のPodは<code>hostPort</code>を使用できます。慣例により、クライアントはNodeIPのリストとポートを知っています。</li><li><strong>DNS</strong>: 同じPodセレクターを持つ<a href=/ja/docs/concepts/services-networking/service/#headless-service>HeadlessService</a>を作成し、<code>endpoints</code>リソースを使ってDaemonSetを探すか、DNSから複数のAレコードを取得します。</li><li><strong>Service</strong>: 同じPodセレクターを持つServiceを作成し、複数のうちのいずれかのNode上のDaemonに疎通させるためにそのServiceを使います。</li></ul><h2 id=daemonsetの更新>DaemonSetの更新</h2><p>もしNodeラベルが変更されたとき、そのDaemonSetは直ちに新しくマッチしたNodeにPodを追加し、マッチしなくなったNodeからPodを削除します。</p><p>ユーザーはDaemonSetが作成したPodを修正可能です。しかし、Podは全てのフィールドの更新を許可していません。また、DaemonSetコントローラーは次のNode(同じ名前でも)が作成されたときにオリジナルのテンプレートを使ってPodを作成します。</p><p>ユーザーはDaemonSetを削除可能です。<code>kubectl</code>コマンドで<code>--cascade=false</code>を指定するとDaemonSetのPodはNode上に残り続けます。その後、同じセレクターで新しいDaemonSetを作成すると、新しいDaemonSetは既存のPodを再利用します。PodでDaemonSetを置き換える必要がある場合は、<code>updateStrategy</code>に従ってそれらを置き換えます。</p><p>ユーザーはDaemonSet上で<a href=/docs/tasks/manage-daemon/update-daemon-set/>ローリングアップデートの実施</a>が可能です。</p><h2 id=daemonsetの代替案>DaemonSetの代替案</h2><h3 id=initスクリプト>Initスクリプト</h3><p>Node上で直接起動することにより(例: <code>init</code>、<code>upstartd</code>、<code>systemd</code>を使用する)、デーモンプロセスを稼働することが可能です。この方法は非常に良いですが、このようなプロセスをDaemonSetを介して起動することはいくつかの利点があります。</p><ul><li>アプリケーションと同じ方法でデーモンの監視とログの管理ができる。</li><li>デーモンとアプリケーションで同じ設定用の言語とツール(例: Podテンプレート、<code>kubectl</code>)を使える。</li><li>リソースリミットを使ったコンテナ内でデーモンを稼働させることにより、デーモンとアプリケーションコンテナの分離を促進します。しかし、これはPod内でなく、コンテナ内でデーモンを稼働させることにより可能です(Dockerを介して直接起動する)。</li></ul><h3 id=ベアpod>ベアPod</h3><p>特定のNode上で稼働するように指定したPodを直接作成することは可能です。しかし、DaemonSetはNodeの故障やNodeの破壊的なメンテナンスやカーネルのアップグレードなど、どのような理由に限らず、削除されたもしくは停止されたPodを置き換えます。このような理由で、ユーザーはPod単体を作成するよりもむしろDaemonSetを使うべきです。</p><h3 id=静的pod-pods>静的Pod Pods</h3><p>Kubeletによって監視されているディレクトリに対してファイルを書き込むことによって、Podを作成することが可能です。これは<a href=/ja/docs/tasks/configure-pod-container/static-pod/>静的Pod</a>と呼ばれます。DaemonSetと違い、静的Podはkubectlや他のKubernetes APIクライアントで管理できません。静的PodはApiServerに依存しておらず、クラスターの自立起動時に最適です。また、静的Podは将来的には廃止される予定です。</p><h3 id=deployment>Deployment</h3><p>DaemonSetは、Podの作成し、そのPodが停止されることのないプロセスを持つことにおいて<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>と同様です(例: webサーバー、ストレージサーバー)。</p><p>フロントエンドのようなServiceのように、どのホスト上にPodが稼働するか制御するよりも、レプリカ数をスケールアップまたはスケールダウンしたりローリングアップデートする方が重要であるような、状態をもたないServiceに対してDeploymentを使ってください。
Podのコピーが全てまたは特定のホスト上で常に稼働していることが重要な場合や、他のPodの前に起動させる必要があるときにDaemonSetを使ってください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-cc7cc3c4907039d9f863162e20bfbbef>2.5 - Jobs</h1><p>Jobは一つ以上のPodを作成し、指定された数のPodが正常に終了するまで、Podの実行を再試行し続けます。Podが正常に終了すると、Jobは成功したPodの数を追跡します。指定された完了数に達すると、そのタスク(つまりJob)は完了したとみなされます。Jobを削除すると、作成されたPodも一緒に削除されます。Jobを一時停止すると、再開されるまで、稼働しているPodは全部削除されます。</p><p>単純なケースを言うと、確実に一つのPodが正常に完了するまで実行されるよう、一つのJobオブジェクトを作成します。
一つ目のPodに障害が発生したり、(例えばノードのハードウェア障害またノードの再起動が原因で)削除されたりすると、Jobオブジェクトは新しいPodを作成します。</p><p>Jobで複数のPodを並列で実行することもできます。</p><p>スケジュールに沿ってJob(単一のタスクか複数タスク並列のいずれか)を実行したい場合は <a href=/ja/docs/concepts/workloads/controllers/cron-jobs/>CronJob</a>を参照してください。</p><h2 id=running-an-example-job>実行例</h2><p>下記にJobの定義例を記載しています。πを2000桁まで計算して出力するJobで、完了するまで約10秒かかります。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/job.yaml download=controllers/job.yaml><code>controllers/job.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-job-yaml")' title="Copy controllers/job.yaml to clipboard"></img></div><div class=includecode id=controllers-job-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl:5.34.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>backoffLimit</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>このコマンドで実行できます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/controllers/job.yaml
</span></span></code></pre></div><p>実行結果はこのようになります:</p><pre tabindex=0><code>job.batch/pi created
</code></pre><p><code>kubectl</code>でJobの状態を確認できます:</p><ul class="nav nav-tabs" id=check-status-of-job role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#check-status-of-job-0 role=tab aria-controls=check-status-of-job-0 aria-selected=true>kubectl describe job pi</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#check-status-of-job-1 role=tab aria-controls=check-status-of-job-1>kubectl get job pi -o yaml</a></li></ul><div class=tab-content id=check-status-of-job><div id=check-status-of-job-0 class="tab-pane show active" role=tabpanel aria-labelledby=check-status-of-job-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>Name:           pi
</span></span><span style=display:flex><span>Namespace:      default
</span></span><span style=display:flex><span>Selector:       controller-uid<span style=color:#666>=</span>c9948307-e56d-4b5d-8302-ae2d7b7da67c
</span></span><span style=display:flex><span>Labels:         controller-uid<span style=color:#666>=</span>c9948307-e56d-4b5d-8302-ae2d7b7da67c
</span></span><span style=display:flex><span>                job-name<span style=color:#666>=</span>pi
</span></span><span style=display:flex><span>Annotations:    kubectl.kubernetes.io/last-applied-configuration:
</span></span><span style=display:flex><span>                  <span style=color:#666>{</span><span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;batch/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Job&#34;</span>,<span style=color:#b44>&#34;metadata&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;annotations&#34;</span>:<span style=color:#666>{}</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;pi&#34;</span>,<span style=color:#b44>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span><span style=color:#666>}</span>,<span style=color:#b44>&#34;spec&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;backoffLimit&#34;</span>:4,<span style=color:#b44>&#34;template&#34;</span>:...
</span></span><span style=display:flex><span>Parallelism:    <span style=color:#666>1</span>
</span></span><span style=display:flex><span>Completions:    <span style=color:#666>1</span>
</span></span><span style=display:flex><span>Start Time:     Mon, <span style=color:#666>02</span> Dec <span style=color:#666>2019</span> 15:20:11 +0200
</span></span><span style=display:flex><span>Completed At:   Mon, <span style=color:#666>02</span> Dec <span style=color:#666>2019</span> 15:21:16 +0200
</span></span><span style=display:flex><span>Duration:       65s
</span></span><span style=display:flex><span>Pods Statuses:  <span style=color:#666>0</span> Running / <span style=color:#666>1</span> Succeeded / <span style=color:#666>0</span> Failed
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>  Labels:  controller-uid<span style=color:#666>=</span>c9948307-e56d-4b5d-8302-ae2d7b7da67c
</span></span><span style=display:flex><span>           job-name<span style=color:#666>=</span>pi
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   pi:
</span></span><span style=display:flex><span>    Image:      perl:5.34.0
</span></span><span style=display:flex><span>    Port:       &lt;none&gt;
</span></span><span style=display:flex><span>    Host Port:  &lt;none&gt;
</span></span><span style=display:flex><span>    Command:
</span></span><span style=display:flex><span>      perl
</span></span><span style=display:flex><span>      -Mbignum<span style=color:#666>=</span>bpi
</span></span><span style=display:flex><span>      -wle
</span></span><span style=display:flex><span>      print bpi<span style=color:#666>(</span>2000<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    Environment:  &lt;none&gt;
</span></span><span style=display:flex><span>    Mounts:       &lt;none&gt;
</span></span><span style=display:flex><span>  Volumes:        &lt;none&gt;
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type    Reason            Age   From            Message
</span></span><span style=display:flex><span>  ----    ------            ----  ----            -------
</span></span><span style=display:flex><span>  Normal  SuccessfulCreate  14m   job-controller  Created pod: pi-5rwd7
</span></span></code></pre></div></div><div id=check-status-of-job-1 class=tab-pane role=tabpanel aria-labelledby=check-status-of-job-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>apiVersion: batch/v1
</span></span><span style=display:flex><span>kind: Job
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  annotations:
</span></span><span style=display:flex><span>    kubectl.kubernetes.io/last-applied-configuration: |
</span></span><span style=display:flex><span>      <span style=color:#666>{</span><span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;batch/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Job&#34;</span>,<span style=color:#b44>&#34;metadata&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;annotations&#34;</span>:<span style=color:#666>{}</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;pi&#34;</span>,<span style=color:#b44>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span><span style=color:#666>}</span>,<span style=color:#b44>&#34;spec&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;backoffLimit&#34;</span>:4,<span style=color:#b44>&#34;template&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;spec&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;containers&#34;</span>:<span style=color:#666>[{</span><span style=color:#b44>&#34;command&#34;</span>:<span style=color:#666>[</span><span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#b44>&#34;print bpi(2000)&#34;</span><span style=color:#666>]</span>,<span style=color:#b44>&#34;image&#34;</span>:<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;pi&#34;</span><span style=color:#666>}]</span>,<span style=color:#b44>&#34;restartPolicy&#34;</span>:<span style=color:#b44>&#34;Never&#34;</span><span style=color:#666>}}}}</span>
</span></span><span style=display:flex><span>  creationTimestamp: <span style=color:#b44>&#34;2022-06-15T08:40:15Z&#34;</span>
</span></span><span style=display:flex><span>  generation: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    controller-uid: 863452e6-270d-420e-9b94-53a54146c223
</span></span><span style=display:flex><span>    job-name: pi
</span></span><span style=display:flex><span>  name: pi
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>  resourceVersion: <span style=color:#b44>&#34;987&#34;</span>
</span></span><span style=display:flex><span>  uid: 863452e6-270d-420e-9b94-53a54146c223
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  backoffLimit: <span style=color:#666>4</span>
</span></span><span style=display:flex><span>  completionMode: NonIndexed
</span></span><span style=display:flex><span>  completions: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  parallelism: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    matchLabels:
</span></span><span style=display:flex><span>      controller-uid: 863452e6-270d-420e-9b94-53a54146c223
</span></span><span style=display:flex><span>  suspend: <span style=color:#a2f>false</span>
</span></span><span style=display:flex><span>  template:
</span></span><span style=display:flex><span>    metadata:
</span></span><span style=display:flex><span>      creationTimestamp: null
</span></span><span style=display:flex><span>      labels:
</span></span><span style=display:flex><span>        controller-uid: 863452e6-270d-420e-9b94-53a54146c223
</span></span><span style=display:flex><span>        job-name: pi
</span></span><span style=display:flex><span>    spec:
</span></span><span style=display:flex><span>      containers:
</span></span><span style=display:flex><span>      - command:
</span></span><span style=display:flex><span>        - perl
</span></span><span style=display:flex><span>        - -Mbignum<span style=color:#666>=</span>bpi
</span></span><span style=display:flex><span>        - -wle
</span></span><span style=display:flex><span>        - print bpi<span style=color:#666>(</span>2000<span style=color:#666>)</span>
</span></span><span style=display:flex><span>        image: perl:5.34.0
</span></span><span style=display:flex><span>        imagePullPolicy: Always
</span></span><span style=display:flex><span>        name: pi
</span></span><span style=display:flex><span>        resources: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>        terminationMessagePath: /dev/termination-log
</span></span><span style=display:flex><span>        terminationMessagePolicy: File
</span></span><span style=display:flex><span>      dnsPolicy: ClusterFirst
</span></span><span style=display:flex><span>      restartPolicy: Never
</span></span><span style=display:flex><span>      schedulerName: default-scheduler
</span></span><span style=display:flex><span>      securityContext: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>      terminationGracePeriodSeconds: <span style=color:#666>30</span>
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  active: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  ready: <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  startTime: <span style=color:#b44>&#34;2022-06-15T08:40:15Z&#34;</span>
</span></span></code></pre></div></div></div><p>Jobの完了したPodを確認するには、<code>kubectl get pods</code>を使います。</p><p>Jobに属するPodの一覧を機械可読形式で出力するには、下記のコマンドを使います:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span>job-name<span style=color:#666>=</span>pi --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$pods</span>
</span></span></code></pre></div><p>出力結果はこのようになります:</p><pre tabindex=0><code>pi-5rwd7
</code></pre><p>ここのセレクターはJobのセレクターと同じです。<code>--output=jsonpath</code>オプションは、返されたリストからPodのnameフィールドを指定するための表現です。</p><p>その中の一つのPodの標準出力を確認するには:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs <span style=color:#b8860b>$pods</span>
</span></span></code></pre></div><p>出力結果はこのようになります:</p><pre tabindex=0><code>3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275901
</code></pre><h2 id=writing-a-job-spec>Job spec(仕様)の書き方</h2><p>他のKubernetesオブジェクト設定ファイルと同様に、Jobにも<code>apiVersion</code>、<code>kind</code>または<code>metadata</code>フィールドが必要です。
Jobの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><p>Jobには<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code>セクション</a>も必要です。</p><h3 id=pod-template>Podテンプレート</h3><p><code>.spec.template</code>は<code>.spec</code>の唯一の必須フィールドです。</p><p><code>.spec.template</code>は<a href=/ja/docs/concepts/workloads/pods/#pod-template>podテンプレート</a>です。ネストされていることと<code>apiVersion</code>や<code>kind</code>フィールドが不要になったことを除いて、仕様の定義が<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>と全く同じです。</p><p>Podの必須フィールドに加えて、Job定義ファイルにあるPodテンプレートでは、適切なラベル(<a href=#pod-selector>podセレクター</a>を参照)と適切な再起動ポリシーを指定する必要があります。</p><p><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>RestartPolicy</code></a>は<code>Never</code>か<code>OnFailure</code>のみ設定可能です。</p><h3 id=pod-selector>Podセレクター</h3><p><code>.spec.selector</code>フィールドはオプションです。ほとんどの場合はむしろ指定しないほうがよいです。
<a href=#specifying-your-own-pod-selector>独自のPodセレクターを指定</a>セクションを参照してください。</p><h3 id=parallel-jobs>Jobの並列実行</h3><p>Jobで実行するのに適したタスクは主に3種類あります:</p><ol><li>非並列Job<ul><li>通常、Podに障害が発生しない限り、一つのPodのみが起動されます。</li><li>Podが正常に終了すると、Jobはすぐに完了します。</li></ul></li><li><em>固定の完了数</em>を持つ並列Job:<ul><li><code>.spec.completions</code>に0以外の正の値を指定します。</li><li>Jobは全体的なタスクを表し、<code>.spec.completions</code>個のPodが成功すると、Jobの完了となります。</li><li><code>.spec.completionMode="Indexed"</code>を利用する場合、各Podは0から<code>.spec.completions-1</code>までの範囲内のインデックスがアサインされます。</li></ul></li><li><em>ワークキュー</em>を利用した並列Job:<ul><li><code>.spec.completions</code>の指定をしない場合、デフォルトは<code>.spec.parallelism</code>となります。</li><li>Pod間で調整する、または外部サービスを使う方法で、それぞれ何のタスクに着手するかを決めます。例えば、一つのPodはワークキューから最大N個のタスクを一括で取得できます。</li><li>各Podは他のPodがすべて終了したかどうか、つまりJobが完了したかどうかを単独で判断できます。</li><li>Jobに属する <em>任意</em> のPodが正常に終了すると、新しいPodは作成されません。</li><li>一つ以上のPodが正常に終了し、すべてのPodが終了すると、Jobは正常に完了します。</li><li>一つのPodが正常に終了すると、他のPodは同じタスクの作業を行ったり、出力を書き込んだりすることはできません。すべてのPodが終了プロセスに進む必要があります。</li></ul></li></ol><p><em>非並列</em> Jobの場合、<code>.spec.completions</code>と<code>.spec.parallelism</code>の両方を未設定のままにしておくことも可能です。未設定の場合、両方がデフォルトで1になります。</p><p><em>完了数固定</em> Jobの場合、<code>.spec.completions</code>を必要完了数に設定する必要があります。
<code>.spec.parallelism</code>を設定してもいいですし、未設定の場合、デフォルトで1になります。</p><p><em>ワークキュー</em> 並列Jobの場合、<code>.spec.completions</code>を未設定のままにし、<code>.spec.parallelism</code>を非負の整数に設定する必要があります。</p><p>各種類のJobの使用方法の詳細については、<a href=#job-patterns>Jobパターン</a>セクションを参照してください。</p><h4 id=controlling-parallelism>並列処理の制御</h4><p>必要並列数(<code>.spec.parallelism</code>)は任意の非負の値に設定できます。
未設定の場合は、デフォルトで1になります。
0に設定した際には、増加するまでJobは一時停止されます。</p><p>実際の並列数(任意の瞬間に実行されているPod数)は、さまざまな理由により、必要並列数と異なる可能性があります:</p><ul><li><em>完了数固定</em> Jobの場合、実際に並列して実行されるPodの数は、残りの完了数を超えることはありません。 <code>.spec.parallelism</code>の値が高い場合は無視されます。</li><li><em>ワークキュー</em> Jobの場合、任意のPodが成功すると、新しいPodは作成されません。ただし、残りのPodは終了まで実行し続けられます。</li><li>Job<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>の応答する時間がなかった場合。</li><li>Jobコントローラーが何らかの理由で(<code>ResourceQuota</code>の不足、権限の不足など)、Podを作成できない場合、
実際の並列数は必要並列数より少なくなる可能性があります。</li><li>同じJobで過去に発生した過度のPod障害が原因で、Jobコントローラーは新しいPodの作成を抑制することがあります。</li><li>Podがグレースフルシャットダウンされた場合、停止するのに時間がかかります。</li></ul><h3 id=completion-mode>完了モード</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [stable]</code></div><p><em>完了数固定</em> Job、つまり<code>.spec.completions</code>の値がnullではないJobは<code>.spec.completionMode</code>で完了モードを指定できます:</p><ul><li><p><code>NonIndexed</code>(デフォルト): <code>.spec.completions</code>個のPodが成功した場合、Jobの完了となります。言い換えれば、各Podの完了状態は同質です。ここで要注意なのは、<code>.spec.completions</code>の値がnullの場合、暗黙的に<code>NonIndexed</code>として指定されることです。</p></li><li><p><code>Indexed</code>: Jobに属するPodはそれぞれ、0から<code>.spec.completions-1</code>の範囲内の完了インデックスを取得できます。インデックスは下記の三つの方法で取得できます。</p><ul><li>Podアノテーション<code>batch.kubernetes.io/job-completion-index</code>。</li><li>Podホスト名の一部として、<code>$(job-name)-$(index)</code>の形式になっています。
インデックス付きJob(Indexed Job)と<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を一緒に使用すると、Jobに属するPodはお互いにDNSを介して確定的ホスト名で通信できます。</li><li>コンテナ化されたタスクの環境変数<code>JOB_COMPLETION_INDEX</code>。</li></ul><p>インデックスごとに、成功したPodが一つ存在すると、Jobの完了となります。完了モードの使用方法の詳細については、
<a href=/ja/docs/tasks/job/indexed-parallel-processing-static/>静的な処理の割り当てを使用した並列処理のためのインデックス付きJob</a>を参照してください。めったに発生しませんが、同じインデックスを取得して稼働し始めるPodも存在する可能性があります。ただし、完了数にカウントされるのはそのうちの一つだけです。</p></li></ul><h2 id=handling-pod-and-container-failures>Podとコンテナの障害対策</h2><p>Pod内のコンテナは、その中のプロセスが0以外の終了コードで終了した、またはメモリ制限を超えたためにコンテナが強制終了されたなど、様々な理由で失敗することがあります。この場合、もし<code>.spec.template.spec.restartPolicy = "OnFailure"</code>と設定すると、Podはノード上に残りますが、コンテナは再実行されます。そのため、プログラムがローカルで再起動した場合の処理を行うか、<code>.spec.template.spec.restartPolicy = "Never"</code>と指定する必要があります。
<code>restartPolicy</code>の詳細については<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>を参照してください。</p><p>Podがノードからキックされた(ノードがアップグレード、再起動、削除されたなど)、または<code>.spec.template.spec.restartPolicy = "Never"</code>と設定されたときにPodに属するコンテナが失敗したなど、様々な理由でPod全体が故障することもあります。Podに障害が発生すると、Jobコントローラーは新しいPodを起動します。つまりアプリケーションは新しいPodで再起動された場合の処理を行う必要があります。特に、過去に実行した際に生じた一時ファイル、ロック、不完全な出力などを処理する必要があります。</p><p><code>.spec.parallelism = 1</code>、<code>.spec.completions = 1</code>と<code>.spec.template.spec.restartPolicy = "Never"</code>を指定しても、同じプログラムが2回起動されることもありますので注意してください。</p><p><code>.spec.parallelism</code>と<code>.spec.completions</code>を両方とも2以上指定した場合、複数のPodが同時に実行される可能性があります。そのため、Podは並行処理を行えるようにする必要があります。</p><h3 id=pod-backoff-failure-policy>Pod失敗のバックオフポリシー</h3><p>設定の論理エラーなどにより、Jobが数回再試行した後に失敗状態にしたい場合があります。<code>.spec.backoffLimit</code>を設定すると、失敗したと判断するまでの再試行回数を指定できます。バックオフ制限はデフォルトで6に設定されています。Jobに属していて失敗したPodはJobコントローラーにより再作成され、バックオフ遅延は指数関数的に増加し(10秒、20秒、40秒…)、最大6分まで増加します。</p><p>再実行回数の算出方法は以下の2通りです:</p><ul><li><code>.status.phase = "Failed"</code>で設定されたPod数を計算します。</li><li><code>restartPolicy = "OnFailure"</code>と設定された場合、<code>.status.phase</code>が<code>Pending</code>または<code>Running</code>であるPodに属するすべてのコンテナで再試行する回数を計算します。</li></ul><p>どちらかの計算が<code>.spec.backoffLimit</code>に達した場合、Jobは失敗とみなされます。</p><p><a href=#job-tracking-with-finalizers><code>JobTrackingWithFinalizers</code></a>機能が無効な場合、
失敗したPodの数は、API内にまだ存在するPodのみに基づいています。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>restartPolicy = "OnFailure"</code>が設定されたJobはバックオフ制限に達すると、属するPodは全部終了されるので注意してください。これにより、Jobの実行ファイルのデバッグ作業が難しくなる可能性があります。失敗したJobからの出力が不用意に失われないように、Jobのデバッグ作業をする際は<code>restartPolicy = "Never"</code>を設定するか、ロギングシステムを使用することをお勧めします。</div><h2 id=job-termination-and-cleanup>Jobの終了とクリーンアップ</h2><p>Jobが完了すると、それ以上Podは作成されませんが、<a href=#pod-backoff-failure-policy>通常</a>Podが削除されることもありません。
これらを残しておくと、完了したPodのログを確認でき、エラーや警告などの診断出力を確認できます。
またJobオブジェクトはJob完了後も残っているため、状態を確認することができます。古いJobの状態を把握した上で、削除するかどうかはユーザー次第です。Jobを削除するには<code>kubectl</code> (例:<code>kubectl delete jobs/pi</code>または<code>kubectl delete -f ./job.yaml</code>)を使います。<code>kubectl</code>でJobを削除する場合、Jobが作成したPodも全部削除されます。</p><p>デフォルトでは、Jobは中断されることなく実行できますが、Podが失敗した場合(<code>restartPolicy=Never</code>)、またはコンテナがエラーで終了した場合(<code>restartPolicy=OnFailure</code>)のみ、前述の<code>.spec.backoffLimit</code>で決まった回数まで再試行します。<code>.spec.backoffLimit</code>に達すると、Jobが失敗とマークされ、実行中のPodもすべて終了されます。</p><p>Jobを終了させるもう一つの方法は、活動期間を設定することです。
Jobの<code>.spec.activeDeadlineSeconds</code>フィールドに秒数を設定することで、活動期間を設定できます。
Podがいくつ作成されても、<code>activeDeadlineSeconds</code>はJobの存続する時間に適用されます。
Jobが<code>activeDeadlineSeconds</code>に達すると、実行中のすべてのPodは終了され、Jobの状態は<code>type: Failed</code>になり、理由は<code>reason: DeadlineExceeded</code>になります。</p><p>ここで要注意なのは、Jobの<code>.spec.activeDeadlineSeconds</code>は<code>.spec.backoffLimit</code>よりも優先されます。したがって、失敗して再試行しているPodが一つ以上持っているJobは、<code>backoffLimit</code>に達していなくても、<code>activeDeadlineSeconds</code>で指定された設定時間に達すると、追加のPodをデプロイしなくなります。</p><p>例えば:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi-with-timeout<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>backoffLimit</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>activeDeadlineSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl:5.34.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><p>Job仕様と、Jobに属する<a href=/ja/docs/concepts/workloads/pods/init-containers/#detailed-behavior>Podテンプレートの仕様</a>は両方とも<code>activeDeadlineSeconds</code>フィールドを持っているので注意してください。適切なレベルで設定していることを確認してください。</p><p>また<code>restartPolicy</code>はJob自体ではなく、Podに適用されることも注意してください: Jobの状態は<code>type: Failed</code>になると、自動的に再起動されることはありません。
つまり、<code>.spec.activeDeadlineSeconds</code>と<code>.spec.backoffLimit</code>によって引き起こされるJob終了メカニズムは、永久的なJob失敗につながり、手動で介入して解決する必要があります。</p><h2 id=clean-up-finished-jobs-automatically>終了したJobの自動クリーンアップ</h2><p>終了したJobは通常システムに残す必要はありません。残ったままにしておくとAPIサーバーに負担をかけることになります。Jobが上位コントローラーにより直接管理されている場合、例えば<a href=/ja/docs/concepts/workloads/controllers/cron-jobs/>CronJobs</a>の場合、Jobは指定された容量ベースのクリーンアップポリシーに基づき、CronJobによりクリーンアップされます。</p><h3 id=ttl-mechanism-for-finished-jobs>終了したJobのTTLメカニズム</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code></div><p>終了したJob(状態が<code>Complete</code>か<code>Failed</code>になったJob)を自動的にクリーンアップするもう一つの方法は
<a href=/ja/docs/concepts/workloads/controllers/ttlafterfinished/>TTLコントローラー</a>より提供されたTTLメカニズムです。<code>.spec.ttlSecondsAfterFinished</code>フィールドを指定することで、終了したリソースをクリーンアップすることができます。</p><p>TTLコントローラーでJobをクリーンアップする場合、Jobはカスケード的に削除されます。つまりJobを削除する際に、Jobに属しているオブジェクト、例えばPodなども一緒に削除されます。Jobが削除される場合、Finalizerなどの、Jobのライフサイクル保証は守られることに注意してください。</p><p>例えば:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi-with-ttl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ttlSecondsAfterFinished</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl:5.34.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><p>Job <code>pi-with-ttl</code>は終了してからの<code>100</code>秒後に自動的に削除されるようになっています。</p><p>このフィールドに<code>0</code>を設定すると、Jobは終了後すぐに自動削除の対象になります。このフィールドに何も設定しないと、Jobが終了してもTTLコントローラーによるクリーンアップはされません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p><code>ttlSecondsAfterFinished</code>フィールドを設定することが推奨されます。管理されていないJob(CronJobなどの、他のワークロードAPIを経由せずに、直接作成したJob)は<code>orphanDependents</code>というデフォルトの削除ポリシーがあるため、Jobが完全に削除されても、属しているPodが残ってしまうからです。
<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>は最終的に、失敗または完了して削除されたJobに属するPodを<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>ガベージコレクション</a>しますが、Podが残っていると、クラスターのパフォーマンスが低下することがあり、最悪の場合、この低下によりクラスターがオフラインになることがあります。</p><p><a href=/ja/docs/concepts/policy/limit-range/>LimitRanges</a>と<a href=/ja/docs/concepts/policy/resource-quotas/>リソースクォータ</a>で、指定する名前空間が消費できるリソースの量に上限を設定することができます。</p></div><h2 id=job-patterns>Jobパターン</h2><p>Jobオブジェクトは、Podの確実な並列実行をサポートするために使用されます。科学技術計算でよく見られるような、密接に通信を行う並列処理をサポートするようには設計されていません。独立だが関連性のある一連の<em>作業項目</em>の並列処理をサポートします。例えば送信すべき電子メール、レンダリングすべきフレーム、トランスコードすべきファイル、スキャンすべきNoSQLデータベースのキーの範囲、などです。</p><p>複雑なシステムでは、異なる作業項目のセットが複数存在する場合があります。ここでは、ユーザーが一斉に管理したい作業項目のセットが一つだけの場合 — つまり<em>バッチJob</em>だけを考えます。</p><p>並列計算にはいくつかのパターンがあり、それぞれに長所と短所があります。
トレードオフの関係にあるのは:</p><ul><li>各作業項目に1つのJobオブジェクト vs. すべての作業項目に1つのJobオブジェクト。<br>　後者は大量の作業項目を処理する場合に適しています。<br>　前者は大量のJobオブジェクトを管理するため、ユーザーとシステムにオーバーヘッドをかけることになります。</li><li>作成されるPod数が作業項目数と等しい、 vs. 各Podが複数の作業項目を処理する。
　前者は通常、既存のコードやコンテナへの変更が少なくて済みます。
後者は上記と同じ理由で、大量の作業項目を処理する場合に適しています。</li><li>ワークキューを利用するアプローチもいくつかあります。それを使うためには、キューサービスを実行し、既存のプログラムやコンテナにワークキューを利用させるための改造を行う必要があります。
他のアプローチは既存のコンテナ型アプリケーションに適用しやすいです。</li></ul><p>ここでは、上記のトレードオフをまとめてあり、それぞれ2～4列目に対応しています。
またパターン名のところは、例やより詳しい説明が書いてあるページへのリンクになっています。</p><table><thead><tr><th>パターン</th><th style=text-align:center>単一Jobオブジェクト</th><th style=text-align:center>Podが作業項目より少ない？</th><th style=text-align:center>アプリを修正せずに使用できる？</th></tr></thead><tbody><tr><td><a href=/docs/tasks/job/coarse-parallel-processing-work-queue/>作業項目ごとにPodを持つキュー</a></td><td style=text-align:center>✓</td><td style=text-align:center></td><td style=text-align:center>時々</td></tr><tr><td><a href=/docs/tasks/job/fine-parallel-processing-work-queue/>Pod数可変のキュー</a></td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center></td></tr><tr><td><a href=/ja/docs/tasks/job/indexed-parallel-processing-static/>静的な処理の割り当てを使用したインデックス付きJob</a></td><td style=text-align:center>✓</td><td style=text-align:center></td><td style=text-align:center>✓</td></tr><tr><td><a href=/docs/tasks/job/parallel-processing-expansion/>Jobテンプレート拡張</a></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>✓</td></tr></tbody></table><p><code>.spec.completions</code>で完了数を指定する場合、Jobコントローラーより作成された各Podは同一の<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>spec</code></a>を持ちます。これは、このタスクのすべてのPodが同じコマンドライン、同じイメージ、同じボリューム、そして(ほぼ)同じ環境変数を持つことを意味します。これらのパターンは、Podが異なる作業をするためのさまざまな配置方法になります。</p><p>この表は、各パターンで必要な<code>.spec.parallelism</code>と<code>.spec.completions</code>の設定を示しています。
ここで、<code>W</code>は作業項目の数を表しています。</p><table><thead><tr><th>パターン</th><th style=text-align:center><code>.spec.completions</code></th><th style=text-align:center><code>.spec.parallelism</code></th></tr></thead><tbody><tr><td><a href=/docs/tasks/job/coarse-parallel-processing-work-queue/>作業項目ごとにPodを持つキュー</a></td><td style=text-align:center>W</td><td style=text-align:center>任意</td></tr><tr><td><a href=/docs/tasks/job/fine-parallel-processing-work-queue/>Pod数可変のキュー</a></td><td style=text-align:center>null</td><td style=text-align:center>任意</td></tr><tr><td><a href=/ja/docs/tasks/job/indexed-parallel-processing-static/>静的な処理の割り当てを使用したインデックス付きJob</a></td><td style=text-align:center>W</td><td style=text-align:center>任意</td></tr><tr><td><a href=/docs/tasks/job/parallel-processing-expansion/>Jobテンプレート拡張</a></td><td style=text-align:center>1</td><td style=text-align:center>1であるべき</td></tr></tbody></table><h2 id=advanced-usage>高度な使い方</h2><h3 id=suspending-a-job>Jobの一時停止</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [stable]</code></div><p>Jobが作成されると、JobコントローラーはJobの要件を満たすために直ちにPodの作成を開始し、Jobが完了するまで作成し続けます。しかし、Jobの実行を一時的に中断して後で再開したい場合、または一時停止状態のJobを再開し、再開時間は後でカスタムコントローラーに判断させたい場合はあると思います。</p><p>Jobを一時停止するには、Jobの<code>.spec.suspend</code>フィールドをtrueに修正し、後でまた再開したい場合にはfalseに修正すればよいです。
<code>.spec.suspend</code>をtrueに設定してJobを作成すると、一時停止状態のままで作成されます。</p><p>一時停止状態のJobを再開すると、<code>.status.startTime</code>フィールドの値は現在時刻にリセットされます。これはつまり、Jobが一時停止して再開すると、<code>.spec.activeDeadlineSeconds</code>タイマーは停止してリセットされることになります。</p><p>Jobを中断すると、稼働中のPodは全部削除されることを忘れないでください。Jobが中断されると、PodはSIGTERMシグナルを受信して<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>終了されます</a>。Podのグレースフル終了の猶予期間がカウントダウンされ、この期間内に、Podはこのシグナルを処理しなければなりません。場合により、その後のために処理状況を保存したり、変更を元に戻したりする処理が含まれます。この方法で終了したPodは<code>completions</code>数にカウントされません。</p><p>下記は一時停止状態のままで作成されたJobの定義例になります:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get job myjob -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myjob<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>suspend</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>Jobのstatusセクションで、Jobが停止中なのか、過去に停止したことがあるかを判断できます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get jobs/myjob -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># .metadata and .spec omitted</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-02-05T13:14:33Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-02-05T13:14:33Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Suspended<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>startTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-02-05T13:13:48Z&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Jobのcondition.typeが"Suspended"で、statusが"True"になった場合、Jobは一時停止中になります。<code>lastTransitionTime</code>フィールドで、どのぐらい中断されたかを判断できます。statusが"False"になった場合、Jobは一時停止状態でしたが、今は実行されていることになります。conditionが書いていない場合、Jobは一度も停止していないことになります。</p><p>Jobが一時停止して再開した場合、Eventsも作成されます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe jobs/myjob
</span></span></code></pre></div><pre tabindex=0><code>Name:           myjob
...
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  12m   job-controller  Created pod: myjob-hlrpl
  Normal  SuccessfulDelete  11m   job-controller  Deleted pod: myjob-hlrpl
  Normal  Suspended         11m   job-controller  Job suspended
  Normal  SuccessfulCreate  3s    job-controller  Created pod: myjob-jvb44
  Normal  Resumed           3s    job-controller  Job resumed
</code></pre><p>最後の4つのイベント、特に"Suspended"と"Resumed"のイベントは、<code>.spec.suspend</code>フィールドの値を切り替えた直接の結果です。この2つのイベントの間に、Podは作成されていないことがわかりますが、Jobが再開されるとすぐにPodの作成も再開されました。</p><h3 id=mutable-scheduling-directives>可変スケジューリング命令</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> この機能を使うためには、<a href=/docs/reference/command-line-tools-reference/kube-apiserver/>APIサーバー</a>上で<code>JobMutableNodeSchedulingDirectives</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にする必要があります。
デフォルトで有効になっています。</div><p>ほとんどの場合、並列Jobは、すべてのPodが同じゾーン、またはすべてのGPUモデルxかyのいずれかであるが、両方の混在ではない、などの制約付きで実行することが望ましいです。</p><p><a href=#suspending-a-job>suspend</a>フィールドは、これらの機能を実現するための第一歩です。Suspendは、カスタムキューコントローラーがJobをいつ開始すべきかを決定することができます。しかし、Jobの一時停止が解除されると、カスタムキューコントローラーは、Job内のPodの実際の配置場所には影響を与えません。</p><p>この機能により、Jobが開始される前にスケジューリング命令を更新でき、カスタムキューコントローラーがPodの配置に影響を与えることができると同時に、実際のPodとノードの割り当てをkube-schedulerにオフロードすることができます。これは一時停止されたJobの中で、一度も一時停止解除されたことのないJobに対してのみ許可されます。</p><p>JobのPodテンプレートで更新可能なフィールドはnodeAffinity、nodeSelector、tolerations、labelsとannotationsです。</p><h3 id=specifying-your-own-pod-selector>独自のPodセレクターを指定</h3><p>Jobオブジェクトを作成する際には通常、<code>.spec.selector</code>を指定しません。Jobが作成された際に、システムのデフォルトロジックは、他のJobと重ならないようなセレクターの値を選択し、このフィールドに追加します。</p><p>しかし、場合によっては、この自動設定されたセレクターをオーバーライドする必要があります。そのためには、Jobの<code>.spec.selector</code>を指定します。</p><p>その際には十分な注意が必要です。そのJobの他のPodと重なったラベルセレクターを指定し、無関係のPodにマッチした場合、無関係のJobのPodが削除されたり、無関係のPodが完了されてもこのJobの完了数とカウントしたり、片方または両方のJobがPodの作成または完了までの実行を拒否する可能性があります。
一意でないセレクターを選択した場合、他のコントローラー(例えばReplicationController)や属しているPodが予測できない挙動をする可能性があります。Kubernetesは<code>.spec.selector</code>を間違って設定しても止めることはしません。</p><p>下記はこの機能の使用例を紹介しています。</p><p><code>old</code>と名付けたJobがすでに実行されていると仮定します。既存のPodをそのまま実行し続けてほしい一方で、作成する残りのPodには別のテンプレートを使用し、そのJobには新しい名前を付けたいとしましょう。これらのフィールドは更新できないため、Jobを直接更新できません。そのため、<code>kubectl delete jobs/old --cascade=orphan</code>で、<em>属しているPodが実行されたまま</em>、<code>old</code>Jobを削除します。削除する前に、どのセレクターを使用しているかをメモしておきます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get job old -o yaml
</span></span></code></pre></div><p>出力結果はこのようになります:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>old<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-uid</span>:<span style=color:#bbb> </span>a8f3d00d-c6d2-11e5-9f87-42010af00002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>次に、<code>new</code>という名前で新しくJobを作成し、同じセレクターを明示的に指定します。既存のPodも<code>controller-uid=a8f3d00d-c6d2-11e5-9f87-42010af00002</code>ラベルが付いているので、同じく<code>new</code>Jobによってコントロールされます。</p><p>通常システムが自動的に生成するセレクターを使用しないため、新しいJobで <code>manualSelector: true</code>を指定する必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>manualSelector</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-uid</span>:<span style=color:#bbb> </span>a8f3d00d-c6d2-11e5-9f87-42010af00002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>新しいJobは<code>a8f3d00d-c6d2-11e5-9f87-42010af00002</code>ではなく、別のuidを持つことになります。<code>manualSelector: true</code>を設定することで、自分は何をしているかを知っていて、またこのミスマッチを許容することをシステムに伝えます。</p><h3 id=job-tracking-with-finalizers>FinalizerによるJob追跡</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>この機能を使うためには、<a href=/docs/reference/command-line-tools-reference/kube-apiserver/>APIサーバー</a>と<a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>コントローラーマネージャー</a>で<code>JobTrackingWithFinalizers</code>
<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にする必要があります。</p><p>有効にした場合、コントロールプレーンは下記に示す機能で新しいJobを追跡します。この機能が有効になる前に作成されたJobは影響を受けません。ユーザーとして実感できる唯一の違いは、コントロールプレーンのJob完了ステータス追跡がより正確になるということだけです。</p></div><p>この機能が有効でない場合、Job <a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=Controller>Controller</a>はクラスター内に存在するPodを数えてJobステータスを追跡します。つまり<code>succeeded</code>Podと<code>failed</code>Podのカウンターを保持します。
しかし、Podは以下のような理由で削除されることもあります:</p><ul><li>Nodeがダウンしたときに、孤立した(Orphan)Podを削除するガベージコレクター。</li><li>閾値に達すると、(<code>Succeeded</code>または<code>Failed</code>フェーズで)終了したPodを削除するガベージコレクター。</li><li>Jobに属するPodの人為的な削除。</li><li>外部コントローラー(Kubernetesの一部として提供されていない)によるPodの削除や置き換え。</li></ul><p>クラスターで<code>JobTrackingWithFinalizers</code>機能を有効にすると、コントロールプレーンは任意のJobに属するPodを追跡し、そのようなPodがAPIサーバーから削除された場合に通知します。そのために、Jobコントローラーは<code>batch.kubernetes.io/job-tracking</code>Finalizerを持つPodを作成します。コントローラーはPodがJobステータスに計上された後にのみFinalizerを削除し、他のコントローラーやユーザーによるPodの削除を可能にします。</p><p>Jobコントローラーは、新しいJobに対してのみ新しいアルゴリズムを使用します。この機能が有効になる前に作成されたJobは影響を受けません。JobコントローラーがPod FinalizerでJob追跡しているかどうかは、Jobが<code>batch.kubernetes.io/job-tracking</code>というアノテーションを持っているかどうかで判断できます。
このアノテーションを手動で追加または削除しては<strong>いけません</strong>。</p><h2 id=alternatives>代替案</h2><h3 id=bare-pods>単なるPod</h3><p>Podが動作しているノードが再起動または故障した場合、Podは終了し、再起動されません。しかし、終了したPodを置き換えるため、Jobが新しいPodを作成します。このため、たとえアプリケーションが1つのPodしか必要としない場合でも、単なるPodではなくJobを使用することをお勧めします。</p><h3 id=replication-controller>Replication Controller</h3><p>Jobは<a href=/docs/concepts/workloads/controllers/replicationcontroller/>Replication Controllers</a>を補完するものです。
Replication Controllerは、終了することが想定されていないPod(Webサーバーなど)を管理し、Jobは終了することが想定されているPod(バッチタスクなど)を管理します。</p><p><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>で説明したように、<code>Job</code>は<code>RestartPolicy</code>が<code>OnFailure</code>か<code>Never</code>と設定されているPodに<em>のみ</em>適用されます。(注意:<code>RestartPolicy</code>が設定されていない場合、デフォルト値は<code>Always</code>になります)</p><h3 id=single-job-starts-controller-pod>シングルJobによるコントローラーPodの起動</h3><p>もう一つのパターンは、一つのJobが一つPodを作り、そのPodがカスタムコントローラーのような役割を果たし、他のPodを作ります。これは最も柔軟性がありますが、使い始めるにはやや複雑で、Kubernetesとの統合もあまりできません。</p><p>このパターンの一例としては、Sparkマスターコントローラーを起動し、sparkドライバーを実行してクリーンアップするスクリプトを実行するPodをJobで起動する(<a href=https://github.com/kubernetes/examples/tree/master/staging/spark/README.md>sparkの例</a>を参照)が挙げられます。</p><p>この方法のメリットは、全処理過程でJobオブジェクトが完了する保証がありながらも、どのPodを作成し、どのように作業を割り当てるかを完全に制御できることです。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/workloads/pods/>Pods</a>について学ぶ。</li><li>Jobのさまざまな実行方法について学ぶ:<ul><li><a href=/docs/tasks/job/coarse-parallel-processing-work-queue/>ワークキューを用いた粒度の粗い並列処理</a></li><li><a href=/docs/tasks/job/fine-parallel-processing-work-queue/>ワークキューを用いた粒度の細かい並列処理</a></li><li><a href=/ja/docs/tasks/job/indexed-parallel-processing-static/>静的な処理の割り当てを使用した並列処理のためのインデックス付きJob</a> を使う</li><li>テンプレートを元に複数のJobを作成: <a href=/docs/tasks/job/parallel-processing-expansion/>拡張機能を用いた並列処理</a></li></ul></li><li><a href=#clean-up-finished-jobs-automatically>終了したJobの自動クリーンアップ</a>のリンクから、クラスターが完了または失敗したJobをどのようにクリーンアップするかをご確認ください。</li><li><code>Job</code>はKubernetes REST APIの一部です。JobのAPIを理解するために、
<a href=/docs/reference/kubernetes-api/workload-resources/job-v1/>Job</a>オブジェクトの定義をお読みください。</li><li>UNIXツールの<code>cron</code>と同様に、スケジュールに基づいて実行される一連のJobを定義するために使用できる<a href=/ja/docs/concepts/workloads/controllers/cron-jobs/><code>CronJob</code></a>についてお読みください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-9add0d2120634b63073ad08dc8683bd6>2.6 - ガベージコレクション</h1><p>Kubernetesのガベージコレクターの役割は、かつてオーナーがいたが、現時点でもはやオーナーがいないようなオブジェクトの削除を行うことです。</p><h2 id=owners-and-dependents>オーナーとその従属オブジェクト</h2><p>いくつかのKubernetesオブジェクトは他のオブジェクトのオーナーとなります。例えば、ReplicaSetはPodのセットに対するオーナーです。オーナーによって所有されたオブジェクトは、オーナーオブジェクトの<em>従属オブジェクト(Dependents)</em> と呼ばれます。全ての従属オブジェクトは、オーナーオブジェクトを指し示す<code>metadata.ownerReferences</code>というフィールドを持ちます。</p><p>時々、Kubernetesは<code>ownerReference</code>フィールドに値を自動的にセットします。例えば、ユーザーがReplicaSetを作成したとき、KubernetesはReplicaSet内の各Podの<code>ownerReference</code>フィールドに自動的に値をセットします。Kubernetes1.8において、KubernetesはReplicaController、ReplicaSet、StatefulSet、DaemonSet、Deployment、Job、CronJobによって作成され、適用されたオブジェクトの<code>ownerReference</code>フィールドに自動的にその値をセットします。</p><p>ユーザーはまた<code>ownerReference</code>フィールドに手動で値をセットすることにより、オーナーと従属オブジェクト間の関係を指定することができます。</p><p>下記の例は、3つのPodを持つReplicaSetの設定ファイルとなります。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/replicaset.yaml download=controllers/replicaset.yaml><code>controllers/replicaset.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-replicaset-yaml")' title="Copy controllers/replicaset.yaml to clipboard"></img></div><div class=includecode id=controllers-replicaset-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-repset<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pod-is-for</span>:<span style=color:#bbb> </span>garbage-collection-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pod-is-for</span>:<span style=color:#bbb> </span>garbage-collection-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>もしユーザーがReplicaSetを作成し、Podのメタデータを見る時、<code>ownerReference</code>フィールドの値を確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/replicaset.yaml
</span></span><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>その出力結果によると、そのPodのオーナーは<code>my-repset</code>という名前のReplicaSetです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ownerReferences</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>blockOwnerDeletion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-repset<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>d9607e19-f88f-11e6-a518-42010a800195<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>ネームスペースをまたいだownerReferenceは意図的に許可されていません。これは以下のことを意味します。</p><ol><li>ネームスペース内のスコープの従属オブジェクトは、同一のネームスペース内のオーナーと、クラスターのスコープ内のオーナーのみ指定できます。</li><li>クラスターのスコープ内の従属オブジェクトは、クラスターのスコープ内のオーナーオブジェクトのみ指定でき、ネームスペース内のスコープのオーナーオブジェクトは指定できません。</li></ol></div><h2 id=ガベージコレクターがどのように従属オブジェクトの削除をするかを制御する>ガベージコレクターがどのように従属オブジェクトの削除をするかを制御する</h2><p>ユーザーがオブジェクトを削除するとき、それに紐づく従属オブジェクトも自動で削除するか指定できます。従属オブジェクトの自動削除は、<em>カスケード削除(Cascading deletion)</em> と呼ばれます。<em>カスケード削除</em> には2つのモードがあり、<em>バックグラウンド</em> と<em>フォアグラウンド</em> があります。</p><p>もしユーザーが、従属オブジェクトの自動削除なしにあるオブジェクトを削除する場合、その従属オブジェクトは<em>みなしご(orphaned)</em> と呼ばれます。</p><h3 id=フォアグラウンドのカスケード削除>フォアグラウンドのカスケード削除</h3><p><em>フォアグラウンドのカスケード削除</em> において、そのルートオブジェクトは最初に"削除処理中"という状態に遷移します。その<em>削除処理中</em> 状態において、下記の項目は正となります。</p><ul><li>そのオブジェクトはREST APIを介して確認可能です。</li><li>そのオブジェクトの<code>deletionTimestamp</code>がセットされます。</li><li>そのオブジェクトの<code>metadata.finalizers</code>フィールドは、<code>foregroundDeletion</code>という値を含みます。</li></ul><p>一度"削除処理中"状態に遷移すると、そのガベージコレクターはオブジェクトの従属オブジェクトを削除します。一度そのガベージコレクターが全ての”ブロッキングしている”従属オブジェクトを削除すると(<code>ownerReference.blockOwnerDeletion=true</code>という値を持つオブジェクト)、それはオーナーのオブジェクトも削除します。</p><p>注意点として、"フォアグラウンドのカスケード削除"において、<code>ownerReference.blockOwnerDeletion=true</code>フィールドを持つ従属オブジェクトのみ、そのオーナーオブジェクトの削除をブロックします。
Kubernetes1.7では、認証されていない従属オブジェクトがオーナーオブジェクトの削除を遅らせることができないようにするために<a href=/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement>アドミッションコントローラー</a>が追加され、それは、オーナーオブジェクトの削除パーミッションに基づいて<code>blockOwnerDeletion</code>の値がtrueに設定してユーザーアクセスをコントロールします。</p><p>もしオブジェクトの<code>ownerReferences</code>フィールドがコントローラー(DeploymentやReplicaSetなど)によってセットされている場合、<code>blockOwnerDeletion</code>は自動的にセットされ、ユーザーはこのフィールドを手動で修正する必要はありません。</p><h3 id=バックグラウンドのカスケード削除>バックグラウンドのカスケード削除</h3><p><em>バックグラウンドのカスケード削除</em> において、Kubernetesはそのオーナーオブジェクトを即座に削除し、ガベージコレクションはその従属オブジェクトをバックグラウンドで削除します。</p><h3 id=カスケード削除ポリシーの設定>カスケード削除ポリシーの設定</h3><p>カスケード削除ポリシーを制御するためには、オブジェクトをいつ設定するか<code>deleteOptions</code>引数上の<code>propagationPolicy</code>フィールドに設定してください。設定可能な値は<code>Orphan</code>、<code>Foreground</code>、もしくは<code>Background</code>のどれかです。</p><p>下記のコマンドは従属オブジェクトをバックグラウンドで削除する例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Background&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>下記のコマンドは従属オブジェクトをフォアグラウンドで削除する例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>下記のコマンドは従属オブジェクトをみなしご状態になった従属オブジェクトの例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>kubectlもまたカスケード削除をサポートしています。<br>kubectlを使って従属オブジェクトを自動的に削除するためには、<code>--cascade</code>をtrueにセットしてください。
従属オブジェクトを削除せず、みなしご状態にするには<code>--cascade</code>をfalseにセットしてください。
<code>--cascade</code>オプションのデフォルト値はtrueになります。</p><p>下記のコマンドは、ReplicaSetを削除し、その従属オブジェクトをみなしご状態にします。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete replicaset my-repset --cascade<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h3 id=deploymentsに関する追記事項>Deploymentsに関する追記事項</h3><p>Kubernetes1.7以前では、Deploymentに対するカスケード削除において、作成されたReplicaSetだけでなく、それらのPodも削除するためには、ユーザーは<code>propagationPolicy: Foreground</code>と指定<em>しなくてはなりません</em> 。もしこのタイプの<em>propagationPolicy</em>が使われなかった場合、そのReplicaSetは削除されますが、そのPodは削除されずみなしご状態になります。<br>さらなる詳細に関しては<a href=https://github.com/kubernetes/kubeadm/issues/149#issuecomment-284766613>kubeadm/#149</a>を参照してください。</p><h2 id=既知の問題について>既知の問題について</h2><p><a href=https://github.com/kubernetes/kubernetes/issues/26120>#26120</a>にてイシューがトラックされています。</p><h2 id=次の項目>次の項目</h2><p><a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/garbage-collection.md>Design Doc 1</a></p><p><a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/synchronous-garbage-collection.md>Design Doc 2</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-4de50a37ebb6f2340484192126cb7a04>2.7 - 終了したリソースのためのTTLコントローラー(TTL Controller for Finished Resources)</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code></div><p>TTLコントローラーは実行を終えたリソースオブジェクトのライフタイムを制御するためのTTL (time to live) メカニズムを提供します。<br>TTLコントローラーは現在<a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>のみ扱っていて、将来的にPodやカスタムリソースなど、他のリソースの実行終了を扱えるように拡張される予定です。</p><p>α版の免責事項: この機能は現在α版の機能で、kube-apiserverとkube-controller-managerの<a href=/docs/reference/command-line-tools-reference/feature-gates/>Feature Gate</a>の<code>TTLAfterFinished</code>を有効にすることで使用可能です。</p><h2 id=ttlコントローラー>TTLコントローラー</h2><p>TTLコントローラーは現在Jobに対してのみサポートされています。クラスターオペレーターはこの<a href=/ja/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically>例</a>のように、Jobの<code>.spec.ttlSecondsAfterFinished</code>フィールドを指定することにより、終了したJob(<code>完了した</code>もしくは<code>失敗した</code>)を自動的に削除するためにこの機能を使うことができます。<br>TTLコントローラーは、そのリソースが終了したあと指定したTTLの秒数後に削除できるか推定します。言い換えると、そのTTLが期限切れになると、TTLコントローラーがリソースをクリーンアップするときに、そのリソースに紐づく従属オブジェクトも一緒に連続で削除します。注意点として、リソースが削除されるとき、ファイナライザーのようなライフサイクルに関する保証は尊重されます。</p><p>TTL秒はいつでもセット可能です。下記はJobの<code>.spec.ttlSecondsAfterFinished</code>フィールドのセットに関するいくつかの例です。</p><ul><li>Jobがその終了後にいくつか時間がたった後に自動的にクリーンアップできるように、そのリソースマニフェストにこの値を指定します。</li><li>この新しい機能を適用させるために、存在していてすでに終了したリソースに対してこのフィールドをセットします。</li><li>リソース作成時に、このフィールドを動的にセットするために、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>管理webhookの変更</a>をさせます。クラスター管理者は、終了したリソースに対して、このTTLポリシーを強制するために使うことができます。</li><li>リソースが終了した後に、このフィールドを動的にセットしたり、リソースステータスやラベルなどの値に基づいて異なるTTL値を選択するために、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>管理webhookの変更</a>をさせます。</li></ul><h2 id=注意>注意</h2><h3 id=ttl秒の更新>TTL秒の更新</h3><p>注意点として、Jobの<code>.spec.ttlSecondsAfterFinished</code>フィールドといったTTL期間はリソースが作成された後、もしくは終了した後に変更できます。しかし、一度Jobが削除可能(TTLの期限が切れたとき)になると、それがたとえTTLを伸ばすような更新に対してAPIのレスポンスで成功したと返されたとしても、そのシステムはJobが稼働し続けることをもはや保証しません。</p><h3 id=タイムスキュー-time-skew>タイムスキュー(Time Skew)</h3><p>TTLコントローラーが、TTL値が期限切れかそうでないかを決定するためにKubernetesリソース内に保存されたタイムスタンプを使うため、この機能はクラスター内のタイムスキュー(時刻のずれ)に対してセンシティブとなります。タイムスキューは、誤った時間にTTLコントローラーに対してリソースオブジェクトのクリーンアップしてしまうことを引き起こすものです。</p><p>Kubernetesにおいてタイムスキューを避けるために、全てのNode上でNTPの稼働を必須とします(<a href=https://github.com/kubernetes/kubernetes/issues/6159#issuecomment-93844058>#6159</a>を参照してください)。クロックは常に正しいものではありませんが、Node間におけるその差はとても小さいものとなります。TTLに0でない値をセットするときにこのリスクに対して注意してください。</p><h2 id=次の項目>次の項目</h2><ul><li><p><a href=/ja/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically>Jobの自動クリーンアップ</a></p></li><li><p><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-apps/592-ttl-after-finish/README.md>設計ドキュメント</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2e4cec01c525b45eccd6010e21cc76d9>2.8 - CronJob</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.8 [beta]</code></div><p><em>CronJob</em> は繰り返しのスケジュールによって<a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>を作成します。</p><p><em>CronJob</em> オブジェクトとは <em>crontab</em> (cron table)ファイルでみられる一行のようなものです。
<a href=https://ja.wikipedia.org/wiki/Cron>Cron</a>形式で記述された指定のスケジュールの基づき、定期的にジョブが実行されます。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong><p>すべての<strong>CronJob</strong><code>スケジュール</code>: 時刻はジョブが開始された<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>のタイムゾーンに基づいています。</p><p>コントロールプレーンがkube-controller-managerをPodもしくは素のコンテナで実行している場合、CronJobコントローラーのタイムゾーンとして、kube-controller-managerコンテナに設定されたタイムゾーンを使用します。</p></div><p>CronJobリソースのためのマニフェストを作成する場合、その名前が有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>か確認してください。
名前は52文字を超えることはできません。これはCronJobコントローラーが自動的に、与えられたジョブ名に11文字を追加し、ジョブ名の長さは最大で63文字以内という制約があるためです。</p><h2 id=cronjob>CronJob</h2><p>CronJobは、バックアップの実行やメール送信のような定期的であったり頻発するタスクの作成に役立ちます。
CronJobは、クラスターがアイドル状態になりそうなときにJobをスケジューリングするなど、特定の時間に個々のタスクをスケジュールすることもできます。</p><h3 id=例>例</h3><p>このCronJobマニフェスト例は、毎分ごとに現在の時刻とhelloメッセージを表示します。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/job/cronjob.yaml download=application/job/cronjob.yaml><code>application/job/cronjob.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-cronjob-yaml")' title="Copy application/job/cronjob.yaml to clipboard"></img></div><div class=includecode id=application-job-cronjob-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronJob<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * *&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jobTemplate</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- date; echo Hello from the Kubernetes cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>(<a href=/ja/docs/tasks/job/automated-tasks-with-cron-jobs/>Running Automated Tasks with a CronJob</a>ではこの例をより詳しく説明しています。).</p><h2 id=cron-job-limitations>CronJobの制限</h2><p>cronジョブは一度のスケジュール実行につき、 <em>おおよそ</em> 1つのジョブオブジェクトを作成します。ここで <em>おおよそ</em> と言っているのは、ある状況下では2つのジョブが作成される、もしくは1つも作成されない場合があるためです。通常、このようなことが起こらないようになっていますが、完全に防ぐことはできません。したがって、ジョブは <em>冪等</em> であるべきです。</p><p><code>startingDeadlineSeconds</code>が大きな値、もしくは設定されていない(デフォルト)、そして、<code>concurrencyPolicy</code>を<code>Allow</code>に設定している場合には、少なくとも一度、ジョブが実行されることを保証します。</p><p>最後にスケジュールされた時刻から現在までの間に、CronJob<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>はどれだけスケジュールが間に合わなかったのかをCronJobごとにチェックします。もし、100回以上スケジュールが失敗していると、ジョブは開始されずに、ログにエラーが記録されます。</p><pre tabindex=0><code>Cannot determine if job needs to be started. Too many missed start time (&gt; 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.
</code></pre><p><code>startingDeadlineSeconds</code>フィールドが設定されると(<code>nil</code>ではない)、最後に実行された時刻から現在までではなく、<code>startingDeadlineSeconds</code>の値から現在までで、どれだけジョブを逃したのかをコントローラーが数えます。 <code>startingDeadlineSeconds</code>が<code>200</code>の場合、過去200秒間にジョブが失敗した回数を記録します。</p><p>スケジュールされた時間にCronJobが作成できないと、失敗したとみなされます。たとえば、<code>concurrencyPolicy</code>が<code>Forbid</code>に設定されている場合、前回のスケジュールがまだ実行中にCronJobをスケジュールしようとすると、CronJobは作成されません。</p><p>例として、CronJobが<code>08:30:00</code>を開始時刻として1分ごとに新しいJobをスケジュールするように設定され、<code>startingDeadlineSeconds</code>フィールドが設定されていない場合を想定します。CronJobコントローラーが<code>08:29:00</code> から<code>10:21:00</code>の間にダウンしていた場合、スケジューリングを逃したジョブの数が100を超えているため、ジョブは開始されません。</p><p>このコンセプトをさらに掘り下げるために、CronJobが<code>08:30:00</code>から1分ごとに新しいJobを作成し、<code>startingDeadlineSeconds</code>が200秒に設定されている場合を想定します。CronJobコントローラーが前回の例と同じ期間(<code>08:29:00</code> から<code>10:21:00</code>まで)にダウンしている場合でも、10:22:00時点でJobはまだ動作しています。このようなことは、過去200秒間(言い換えると、3回の失敗)に何回スケジュールが間に合わなかったをコントローラーが確認するときに発生します。これは最後にスケジュールされた時間から今までのものではありません。</p><p>CronJobはスケジュールに一致するJobの作成にのみ関与するのに対して、JobはJobが示すPod管理を担います。</p><h2 id=次の項目>次の項目</h2><p><a href=https://en.wikipedia.org/wiki/Cron>Cron表現形式</a>では、CronJobの<code>schedule</code>フィールドのフォーマットを説明しています。</p><p>cronジョブの作成や動作の説明、CronJobマニフェストの例については、<a href=/docs/tasks/job/automated-tasks-with-cron-jobs>Running automated tasks with cron jobs</a>を見てください。</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>