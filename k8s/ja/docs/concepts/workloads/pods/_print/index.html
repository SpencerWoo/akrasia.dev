<!doctype html><html lang=ja class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/workloads/pods/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/workloads/pods/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/workloads/pods/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/workloads/pods/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/workloads/pods/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/workloads/pods/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/workloads/pods/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Pod | Kubernetes</title><meta property="og:title" content="Pod"><meta property="og:description" content="プロダクショングレードのコンテナ管理基盤"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/workloads/pods/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Pod"><meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pod"><meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Podは、Kubernetes内で作成・管理できるコンピューティングの最小のデプロイ可能なユニットです。
Pod(Podという名前は、たとえばクジラの群れ(pod of whales)やえんどう豆のさや(pea pod)などの表現と同じような意味です)は、1つまたは複数のコンテナのグループであり、ストレージやネットワークの共有リソースを持ち、コンテナの実行方法に関する仕様を持っています。同じPodに含まれるリソースは、常に同じ場所で同時にスケジューリングされ、共有されたコンテキストの中で実行されます。Podはアプリケーションに特化した「論理的なホスト」をモデル化します。つまり、1つのPod内には、1つまたは複数の比較的密に結合されたアプリケーションコンテナが含まれます。クラウド外の文脈で説明すると、アプリケーションが同じ物理ホストや同じバーチャルマシンで実行されることが、クラウドアプリケーションの場合には同じ論理ホスト上で実行されることに相当します。
アプリケーションコンテナと同様に、Podでも、Podのスタートアップ時に実行されるinitコンテナを含めることができます。また、クラスターで利用できる場合には、エフェメラルコンテナを注入してデバッグすることもできます。
Podとは何か？ 備考: KubernetesはDockerだけでなく複数のコンテナランタイムをサポートしていますが、Dockerが最も一般的に知られたランタイムであるため、Docker由来の用語を使ってPodを説明するのが理解の助けとなります。 Podの共有コンテキストは、Dockerコンテナを隔離するのに使われているのと同じ、Linuxのnamespaces、cgroups、場合によっては他の隔離技術の集合を用いて作られます。Podのコンテキスト内では、各アプリケーションが追加の準隔離技術を適用することもあります。
Dockerの概念を使って説明すると、Podは共有の名前空間と共有ファイルシステムのボリュームを持つDockerコンテナのグループに似ています。
Podを使用する 以下は、nginx:1.14.2イメージが実行されるコンテナからなるPodの例を記載しています。
pods/simple-pod.yaml apiVersion: v1 kind: Pod metadata: name: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 上記のようなPodを作成するには、以下のコマンドを実行します:
kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml Podは通常、直接作成されず、ワークロードリソースで作成されます。ワークロードリソースでPodを作成する方法の詳細については、Podを利用するを参照してください。
Podを管理するためのワークロードリソース 通常、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、自分でPodを直接作成する必要はありません。その代わりに、DeploymentやJobなどのワークロードリソースを使用してPodを作成します。もしPodが状態を保持する必要がある場合は、StatefulSetリソースを使用することを検討してください。
Kubernetesクラスター内のPodは、主に次の2種類の方法で使われます。
単一のコンテナを稼働させるPod。「1Pod1コンテナ」構成のモデルは、Kubernetesでは最も一般的なユースケースです。このケースでは、ユーザーはPodを単一のコンテナのラッパーとして考えることができます。Kubernetesはコンテナを直接管理するのではなく、Podを管理します。
協調して稼働させる必要がある複数のコンテナを稼働させるPod。単一のPodは、密に結合してリソースを共有する必要があるような、同じ場所で稼働する複数のコンテナからなるアプリケーションをカプセル化することもできます。これらの同じ場所で稼働するコンテナ群は、単一のまとまりのあるサービスのユニットを構成します。たとえば、1つのコンテナが共有ボリュームからファイルをパブリックに配信し、別のサイドカーコンテナがそれらのファイルを更新するという構成が考えられます。Podはこれらの複数のコンテナ、ストレージリソース、一時的なネットワークIDなどを、単一のユニットとしてまとめます。
備考: 複数のコンテナを同じ場所で同時に管理するように単一のPod内にグループ化するのは、比較的高度なユースケースです。このパターンを使用するのは、コンテナが密に結合しているような特定のインスタンス内でのみにするべきです。 各Podは、与えられたアプリケーションの単一のインスタンスを稼働するためのものです。もしユーザーのアプリケーションを水平にスケールさせたい場合(例: 複数インスタンスを稼働させる)、複数のPodを使うべきです。1つのPodは各インスタンスに対応しています。Kubernetesでは、これは一般的にレプリケーションと呼ばれます。レプリケーションされたPodは、通常ワークロードリソースと、それに対応するコントローラーによって、作成・管理されます。
Kubernetesがワークロードリソースとそのコントローラーを活用して、スケーラブルで自動回復するアプリケーションを実装する方法については、詳しくはPodとコントローラーを参照してください。
Podが複数のコンテナを管理する方法 Podは、まとまりの強いサービスのユニットを構成する、複数の協調する(コンテナとして実行される)プロセスをサポートするために設計されました。単一のPod内の複数のコンテナは、クラスター内の同じ物理または仮想マシン上で、自動的に同じ場所に配置・スケジューリングされます。コンテナ間では、リソースや依存関係を共有したり、お互いに通信したり、停止するときにはタイミングや方法を協調して実行できます。
たとえば、あるコンテナが共有ボリューム内のファイルを配信するウェブサーバーとして動作し、別の「サイドカー」コンテナがリモートのリソースからファイルをアップデートするような構成が考えられます。この構成を以下のダイアグラムに示します。
Podによっては、appコンテナに加えてinitコンテナを持っている場合があります。initコンテナはappコンテナが起動する前に実行・完了するコンテナです。
Podは、Podを構成する複数のコンテナに対して、ネットワークとストレージの2種類の共有リソースを提供します。
Podを利用する 通常Kubernetesでは、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、個別のPodを直接作成することはめったにありません。その理由は、Podがある程度一時的で使い捨てできる存在として設計されているためです。Podが作成されると(あなたが直接作成した場合でも、コントローラーが間接的に作成した場合でも)、新しいPodはクラスター内のノード上で実行されるようにスケジューリングされます。Podは、実行が完了するか、Podオブジェクトが削除されるか、リソース不足によって強制退去されるか、ノードが停止するまで、そのノード上にとどまります。
備考: Pod内のコンテナの再起動とPodの再起動を混同しないでください。Podはプロセスではなく、コンテナが実行するための環境です。Podは削除されるまでは残り続けます。 Podオブジェクトのためのマニフェストを作成したときは、指定したPodの名前が有効なDNSサブドメイン名であることを確認してください。
Pod OS FEATURE STATE: Kubernetes v1.25 [stable] .spec.os.nameフィールドでwindowsかlinuxのいずれかを設定し、Podを実行させたいOSを指定する必要があります。Kubernetesは今のところ、この2つのOSだけサポートしています。将来的には増える可能性があります。
Kubernetes v1.25では、このフィールドに設定した値はPodのスケジューリングに影響を与えません。.spec.os.nameを設定することで、Pod OSに権限を認証することができ、バリデーションにも使用されます。kubeletが実行されているノードのOSが、指定されたPod OSと異なる場合、kubeletはPodの実行を拒否します。 Podセキュリティの標準もこのフィールドを使用し、指定したOSと関係ないポリシーの適用を回避しています。"><meta property="og:description" content="Podは、Kubernetes内で作成・管理できるコンピューティングの最小のデプロイ可能なユニットです。
Pod(Podという名前は、たとえばクジラの群れ(pod of whales)やえんどう豆のさや(pea pod)などの表現と同じような意味です)は、1つまたは複数のコンテナのグループであり、ストレージやネットワークの共有リソースを持ち、コンテナの実行方法に関する仕様を持っています。同じPodに含まれるリソースは、常に同じ場所で同時にスケジューリングされ、共有されたコンテキストの中で実行されます。Podはアプリケーションに特化した「論理的なホスト」をモデル化します。つまり、1つのPod内には、1つまたは複数の比較的密に結合されたアプリケーションコンテナが含まれます。クラウド外の文脈で説明すると、アプリケーションが同じ物理ホストや同じバーチャルマシンで実行されることが、クラウドアプリケーションの場合には同じ論理ホスト上で実行されることに相当します。
アプリケーションコンテナと同様に、Podでも、Podのスタートアップ時に実行されるinitコンテナを含めることができます。また、クラスターで利用できる場合には、エフェメラルコンテナを注入してデバッグすることもできます。
Podとは何か？ 備考: KubernetesはDockerだけでなく複数のコンテナランタイムをサポートしていますが、Dockerが最も一般的に知られたランタイムであるため、Docker由来の用語を使ってPodを説明するのが理解の助けとなります。 Podの共有コンテキストは、Dockerコンテナを隔離するのに使われているのと同じ、Linuxのnamespaces、cgroups、場合によっては他の隔離技術の集合を用いて作られます。Podのコンテキスト内では、各アプリケーションが追加の準隔離技術を適用することもあります。
Dockerの概念を使って説明すると、Podは共有の名前空間と共有ファイルシステムのボリュームを持つDockerコンテナのグループに似ています。
Podを使用する 以下は、nginx:1.14.2イメージが実行されるコンテナからなるPodの例を記載しています。
pods/simple-pod.yaml apiVersion: v1 kind: Pod metadata: name: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 上記のようなPodを作成するには、以下のコマンドを実行します:
kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml Podは通常、直接作成されず、ワークロードリソースで作成されます。ワークロードリソースでPodを作成する方法の詳細については、Podを利用するを参照してください。
Podを管理するためのワークロードリソース 通常、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、自分でPodを直接作成する必要はありません。その代わりに、DeploymentやJobなどのワークロードリソースを使用してPodを作成します。もしPodが状態を保持する必要がある場合は、StatefulSetリソースを使用することを検討してください。
Kubernetesクラスター内のPodは、主に次の2種類の方法で使われます。
単一のコンテナを稼働させるPod。「1Pod1コンテナ」構成のモデルは、Kubernetesでは最も一般的なユースケースです。このケースでは、ユーザーはPodを単一のコンテナのラッパーとして考えることができます。Kubernetesはコンテナを直接管理するのではなく、Podを管理します。
協調して稼働させる必要がある複数のコンテナを稼働させるPod。単一のPodは、密に結合してリソースを共有する必要があるような、同じ場所で稼働する複数のコンテナからなるアプリケーションをカプセル化することもできます。これらの同じ場所で稼働するコンテナ群は、単一のまとまりのあるサービスのユニットを構成します。たとえば、1つのコンテナが共有ボリュームからファイルをパブリックに配信し、別のサイドカーコンテナがそれらのファイルを更新するという構成が考えられます。Podはこれらの複数のコンテナ、ストレージリソース、一時的なネットワークIDなどを、単一のユニットとしてまとめます。
備考: 複数のコンテナを同じ場所で同時に管理するように単一のPod内にグループ化するのは、比較的高度なユースケースです。このパターンを使用するのは、コンテナが密に結合しているような特定のインスタンス内でのみにするべきです。 各Podは、与えられたアプリケーションの単一のインスタンスを稼働するためのものです。もしユーザーのアプリケーションを水平にスケールさせたい場合(例: 複数インスタンスを稼働させる)、複数のPodを使うべきです。1つのPodは各インスタンスに対応しています。Kubernetesでは、これは一般的にレプリケーションと呼ばれます。レプリケーションされたPodは、通常ワークロードリソースと、それに対応するコントローラーによって、作成・管理されます。
Kubernetesがワークロードリソースとそのコントローラーを活用して、スケーラブルで自動回復するアプリケーションを実装する方法については、詳しくはPodとコントローラーを参照してください。
Podが複数のコンテナを管理する方法 Podは、まとまりの強いサービスのユニットを構成する、複数の協調する(コンテナとして実行される)プロセスをサポートするために設計されました。単一のPod内の複数のコンテナは、クラスター内の同じ物理または仮想マシン上で、自動的に同じ場所に配置・スケジューリングされます。コンテナ間では、リソースや依存関係を共有したり、お互いに通信したり、停止するときにはタイミングや方法を協調して実行できます。
たとえば、あるコンテナが共有ボリューム内のファイルを配信するウェブサーバーとして動作し、別の「サイドカー」コンテナがリモートのリソースからファイルをアップデートするような構成が考えられます。この構成を以下のダイアグラムに示します。
Podによっては、appコンテナに加えてinitコンテナを持っている場合があります。initコンテナはappコンテナが起動する前に実行・完了するコンテナです。
Podは、Podを構成する複数のコンテナに対して、ネットワークとストレージの2種類の共有リソースを提供します。
Podを利用する 通常Kubernetesでは、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、個別のPodを直接作成することはめったにありません。その理由は、Podがある程度一時的で使い捨てできる存在として設計されているためです。Podが作成されると(あなたが直接作成した場合でも、コントローラーが間接的に作成した場合でも)、新しいPodはクラスター内のノード上で実行されるようにスケジューリングされます。Podは、実行が完了するか、Podオブジェクトが削除されるか、リソース不足によって強制退去されるか、ノードが停止するまで、そのノード上にとどまります。
備考: Pod内のコンテナの再起動とPodの再起動を混同しないでください。Podはプロセスではなく、コンテナが実行するための環境です。Podは削除されるまでは残り続けます。 Podオブジェクトのためのマニフェストを作成したときは、指定したPodの名前が有効なDNSサブドメイン名であることを確認してください。
Pod OS FEATURE STATE: Kubernetes v1.25 [stable] .spec.os.nameフィールドでwindowsかlinuxのいずれかを設定し、Podを実行させたいOSを指定する必要があります。Kubernetesは今のところ、この2つのOSだけサポートしています。将来的には増える可能性があります。
Kubernetes v1.25では、このフィールドに設定した値はPodのスケジューリングに影響を与えません。.spec.os.nameを設定することで、Pod OSに権限を認証することができ、バリデーションにも使用されます。kubeletが実行されているノードのOSが、指定されたPod OSと異なる場合、kubeletはPodの実行を拒否します。 Podセキュリティの標準もこのフィールドを使用し、指定したOSと関係ないポリシーの適用を回避しています。"><meta name=twitter:description content="Podは、Kubernetes内で作成・管理できるコンピューティングの最小のデプロイ可能なユニットです。
Pod(Podという名前は、たとえばクジラの群れ(pod of whales)やえんどう豆のさや(pea pod)などの表現と同じような意味です)は、1つまたは複数のコンテナのグループであり、ストレージやネットワークの共有リソースを持ち、コンテナの実行方法に関する仕様を持っています。同じPodに含まれるリソースは、常に同じ場所で同時にスケジューリングされ、共有されたコンテキストの中で実行されます。Podはアプリケーションに特化した「論理的なホスト」をモデル化します。つまり、1つのPod内には、1つまたは複数の比較的密に結合されたアプリケーションコンテナが含まれます。クラウド外の文脈で説明すると、アプリケーションが同じ物理ホストや同じバーチャルマシンで実行されることが、クラウドアプリケーションの場合には同じ論理ホスト上で実行されることに相当します。
アプリケーションコンテナと同様に、Podでも、Podのスタートアップ時に実行されるinitコンテナを含めることができます。また、クラスターで利用できる場合には、エフェメラルコンテナを注入してデバッグすることもできます。
Podとは何か？ 備考: KubernetesはDockerだけでなく複数のコンテナランタイムをサポートしていますが、Dockerが最も一般的に知られたランタイムであるため、Docker由来の用語を使ってPodを説明するのが理解の助けとなります。 Podの共有コンテキストは、Dockerコンテナを隔離するのに使われているのと同じ、Linuxのnamespaces、cgroups、場合によっては他の隔離技術の集合を用いて作られます。Podのコンテキスト内では、各アプリケーションが追加の準隔離技術を適用することもあります。
Dockerの概念を使って説明すると、Podは共有の名前空間と共有ファイルシステムのボリュームを持つDockerコンテナのグループに似ています。
Podを使用する 以下は、nginx:1.14.2イメージが実行されるコンテナからなるPodの例を記載しています。
pods/simple-pod.yaml apiVersion: v1 kind: Pod metadata: name: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 上記のようなPodを作成するには、以下のコマンドを実行します:
kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml Podは通常、直接作成されず、ワークロードリソースで作成されます。ワークロードリソースでPodを作成する方法の詳細については、Podを利用するを参照してください。
Podを管理するためのワークロードリソース 通常、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、自分でPodを直接作成する必要はありません。その代わりに、DeploymentやJobなどのワークロードリソースを使用してPodを作成します。もしPodが状態を保持する必要がある場合は、StatefulSetリソースを使用することを検討してください。
Kubernetesクラスター内のPodは、主に次の2種類の方法で使われます。
単一のコンテナを稼働させるPod。「1Pod1コンテナ」構成のモデルは、Kubernetesでは最も一般的なユースケースです。このケースでは、ユーザーはPodを単一のコンテナのラッパーとして考えることができます。Kubernetesはコンテナを直接管理するのではなく、Podを管理します。
協調して稼働させる必要がある複数のコンテナを稼働させるPod。単一のPodは、密に結合してリソースを共有する必要があるような、同じ場所で稼働する複数のコンテナからなるアプリケーションをカプセル化することもできます。これらの同じ場所で稼働するコンテナ群は、単一のまとまりのあるサービスのユニットを構成します。たとえば、1つのコンテナが共有ボリュームからファイルをパブリックに配信し、別のサイドカーコンテナがそれらのファイルを更新するという構成が考えられます。Podはこれらの複数のコンテナ、ストレージリソース、一時的なネットワークIDなどを、単一のユニットとしてまとめます。
備考: 複数のコンテナを同じ場所で同時に管理するように単一のPod内にグループ化するのは、比較的高度なユースケースです。このパターンを使用するのは、コンテナが密に結合しているような特定のインスタンス内でのみにするべきです。 各Podは、与えられたアプリケーションの単一のインスタンスを稼働するためのものです。もしユーザーのアプリケーションを水平にスケールさせたい場合(例: 複数インスタンスを稼働させる)、複数のPodを使うべきです。1つのPodは各インスタンスに対応しています。Kubernetesでは、これは一般的にレプリケーションと呼ばれます。レプリケーションされたPodは、通常ワークロードリソースと、それに対応するコントローラーによって、作成・管理されます。
Kubernetesがワークロードリソースとそのコントローラーを活用して、スケーラブルで自動回復するアプリケーションを実装する方法については、詳しくはPodとコントローラーを参照してください。
Podが複数のコンテナを管理する方法 Podは、まとまりの強いサービスのユニットを構成する、複数の協調する(コンテナとして実行される)プロセスをサポートするために設計されました。単一のPod内の複数のコンテナは、クラスター内の同じ物理または仮想マシン上で、自動的に同じ場所に配置・スケジューリングされます。コンテナ間では、リソースや依存関係を共有したり、お互いに通信したり、停止するときにはタイミングや方法を協調して実行できます。
たとえば、あるコンテナが共有ボリューム内のファイルを配信するウェブサーバーとして動作し、別の「サイドカー」コンテナがリモートのリソースからファイルをアップデートするような構成が考えられます。この構成を以下のダイアグラムに示します。
Podによっては、appコンテナに加えてinitコンテナを持っている場合があります。initコンテナはappコンテナが起動する前に実行・完了するコンテナです。
Podは、Podを構成する複数のコンテナに対して、ネットワークとストレージの2種類の共有リソースを提供します。
Podを利用する 通常Kubernetesでは、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、個別のPodを直接作成することはめったにありません。その理由は、Podがある程度一時的で使い捨てできる存在として設計されているためです。Podが作成されると(あなたが直接作成した場合でも、コントローラーが間接的に作成した場合でも)、新しいPodはクラスター内のノード上で実行されるようにスケジューリングされます。Podは、実行が完了するか、Podオブジェクトが削除されるか、リソース不足によって強制退去されるか、ノードが停止するまで、そのノード上にとどまります。
備考: Pod内のコンテナの再起動とPodの再起動を混同しないでください。Podはプロセスではなく、コンテナが実行するための環境です。Podは削除されるまでは残り続けます。 Podオブジェクトのためのマニフェストを作成したときは、指定したPodの名前が有効なDNSサブドメイン名であることを確認してください。
Pod OS FEATURE STATE: Kubernetes v1.25 [stable] .spec.os.nameフィールドでwindowsかlinuxのいずれかを設定し、Podを実行させたいOSを指定する必要があります。Kubernetesは今のところ、この2つのOSだけサポートしています。将来的には増える可能性があります。
Kubernetes v1.25では、このフィールドに設定した値はPodのスケジューリングに影響を与えません。.spec.os.nameを設定することで、Pod OSに権限を認証することができ、バリデーションにも使用されます。kubeletが実行されているノードのOSが、指定されたPod OSと異なる場合、kubeletはPodの実行を拒否します。 Podセキュリティの標準もこのフィールドを使用し、指定したOSと関係ないポリシーの適用を回避しています。"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/workloads/pods/"><meta property="og:title" content="Pod"><meta name=twitter:title content="Pod"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ja/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ja/docs/>ドキュメント</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/blog/>Blogs</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/training/>トレーニング</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/partners/>パートナー</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/community/>コミュニティ</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/case-studies/>ケーススタディ</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>バージョン</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ja/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/workloads/pods/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/workloads/pods/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/workloads/pods/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/concepts/workloads/pods/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ja/docs/concepts/workloads/pods/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語 (Japanese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/workloads/pods/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/workloads/pods/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/workloads/pods/>한국어 (Korean)</a>
<a class=dropdown-item href=/fr/docs/concepts/workloads/pods/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/workloads/pods/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/workloads/pods/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/concepts/workloads/pods/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.</p><p><a href=/ja/docs/concepts/workloads/pods/>このページの通常のビューに戻る</a>.</p></div><h1 class=title>Pod</h1><ul><li>1: <a href=#pg-37afa6c66c74400d1579f10faf55e5b6>Podの概観</a></li><li>2: <a href=#pg-c3c2b9cf30915ec9d46c147201da3332>Podのライフサイクル</a></li><li>3: <a href=#pg-1ccbd4eeded6ab138d98b59175bd557e>Initコンテナ</a></li><li>4: <a href=#pg-4e9b9cbc9776b12e7335c53da377c9c8>Pod Preset</a></li><li>5: <a href=#pg-53a1005011e1bda2ce81819aad7c8b32>エフェメラルコンテナ</a></li></ul><div class=content><p><em>Pod</em>は、Kubernetes内で作成・管理できるコンピューティングの最小のデプロイ可能なユニットです。</p><p><em>Pod</em>(Podという名前は、たとえばクジラの群れ(pod of whales)やえんどう豆のさや(pea pod)などの表現と同じような意味です)は、1つまたは複数の<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>のグループであり、ストレージやネットワークの共有リソースを持ち、コンテナの実行方法に関する仕様を持っています。同じPodに含まれるリソースは、常に同じ場所で同時にスケジューリングされ、共有されたコンテキストの中で実行されます。Podはアプリケーションに特化した「論理的なホスト」をモデル化します。つまり、1つのPod内には、1つまたは複数の比較的密に結合されたアプリケーションコンテナが含まれます。クラウド外の文脈で説明すると、アプリケーションが同じ物理ホストや同じバーチャルマシンで実行されることが、クラウドアプリケーションの場合には同じ論理ホスト上で実行されることに相当します。</p><p>アプリケーションコンテナと同様に、Podでも、Podのスタートアップ時に実行される<a href=/ja/docs/concepts/workloads/pods/init-containers/>initコンテナ</a>を含めることができます。また、クラスターで利用できる場合には、<a href=/ja/docs/concepts/workloads/pods/ephemeral-containers/>エフェメラルコンテナ</a>を注入してデバッグすることもできます。</p><h2 id=podとは何か>Podとは何か？</h2><div class="alert alert-info note callout" role=alert><strong>備考:</strong> KubernetesはDockerだけでなく複数の<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>をサポートしていますが、<a href=https://www.docker.com/>Docker</a>が最も一般的に知られたランタイムであるため、Docker由来の用語を使ってPodを説明するのが理解の助けとなります。</div><p>Podの共有コンテキストは、Dockerコンテナを隔離するのに使われているのと同じ、Linuxのnamespaces、cgroups、場合によっては他の隔離技術の集合を用いて作られます。Podのコンテキスト内では、各アプリケーションが追加の準隔離技術を適用することもあります。</p><p>Dockerの概念を使って説明すると、Podは共有の名前空間と共有ファイルシステムのボリュームを持つDockerコンテナのグループに似ています。</p><h2 id=podを使用する>Podを使用する</h2><p>以下は、<code>nginx:1.14.2</code>イメージが実行されるコンテナからなるPodの例を記載しています。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/simple-pod.yaml download=pods/simple-pod.yaml><code>pods/simple-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-simple-pod-yaml")' title="Copy pods/simple-pod.yaml to clipboard"></img></div><div class=includecode id=pods-simple-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>上記のようなPodを作成するには、以下のコマンドを実行します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml
</span></span></code></pre></div><p>Podは通常、直接作成されず、ワークロードリソースで作成されます。ワークロードリソースでPodを作成する方法の詳細については、<a href=#working-with-pods>Podを利用する</a>を参照してください。</p><h3 id=podを管理するためのワークロードリソース>Podを管理するためのワークロードリソース</h3><p>通常、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、自分でPodを直接作成する必要はありません。その代わりに、<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>や<a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>などのワークロードリソースを使用してPodを作成します。もしPodが状態を保持する必要がある場合は、<a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>リソースを使用することを検討してください。</p><p>Kubernetesクラスター内のPodは、主に次の2種類の方法で使われます。</p><ul><li><p><strong>単一のコンテナを稼働させるPod</strong>。「1Pod1コンテナ」構成のモデルは、Kubernetesでは最も一般的なユースケースです。このケースでは、ユーザーはPodを単一のコンテナのラッパーとして考えることができます。Kubernetesはコンテナを直接管理するのではなく、Podを管理します。</p></li><li><p><strong>協調して稼働させる必要がある複数のコンテナを稼働させるPod</strong>。単一のPodは、密に結合してリソースを共有する必要があるような、同じ場所で稼働する複数のコンテナからなるアプリケーションをカプセル化することもできます。これらの同じ場所で稼働するコンテナ群は、単一のまとまりのあるサービスのユニットを構成します。たとえば、1つのコンテナが共有ボリュームからファイルをパブリックに配信し、別の<em>サイドカー</em>コンテナがそれらのファイルを更新するという構成が考えられます。Podはこれらの複数のコンテナ、ストレージリソース、一時的なネットワークIDなどを、単一のユニットとしてまとめます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 複数のコンテナを同じ場所で同時に管理するように単一のPod内にグループ化するのは、比較的高度なユースケースです。このパターンを使用するのは、コンテナが密に結合しているような特定のインスタンス内でのみにするべきです。</div></li></ul><p>各Podは、与えられたアプリケーションの単一のインスタンスを稼働するためのものです。もしユーザーのアプリケーションを水平にスケールさせたい場合(例: 複数インスタンスを稼働させる)、複数のPodを使うべきです。1つのPodは各インスタンスに対応しています。Kubernetesでは、これは一般的に<em>レプリケーション</em>と呼ばれます。レプリケーションされたPodは、通常ワークロードリソースと、それに対応する<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>によって、作成・管理されます。</p><p>Kubernetesがワークロードリソースとそのコントローラーを活用して、スケーラブルで自動回復するアプリケーションを実装する方法については、詳しくは<a href=#pods-and-controllers>Podとコントローラー</a>を参照してください。</p><h3 id=podが複数のコンテナを管理する方法>Podが複数のコンテナを管理する方法</h3><p>Podは、まとまりの強いサービスのユニットを構成する、複数の協調する(コンテナとして実行される)プロセスをサポートするために設計されました。単一のPod内の複数のコンテナは、クラスター内の同じ物理または仮想マシン上で、自動的に同じ場所に配置・スケジューリングされます。コンテナ間では、リソースや依存関係を共有したり、お互いに通信したり、停止するときにはタイミングや方法を協調して実行できます。</p><p>たとえば、あるコンテナが共有ボリューム内のファイルを配信するウェブサーバーとして動作し、別の「サイドカー」コンテナがリモートのリソースからファイルをアップデートするような構成が考えられます。この構成を以下のダイアグラムに示します。</p><figure class=diagram-medium><img src=/images/docs/pod.svg alt=Pod作成ダイアグラム></figure><p>Podによっては、<a class=glossary-tooltip title='A container used to run part of a workload. Compare with init container.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-app-container' target=_blank aria-label=appコンテナ>appコンテナ</a>に加えて<a class=glossary-tooltip title='One or more initialization containers that must run to completion before any app containers run.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-init-container' target=_blank aria-label=initコンテナ>initコンテナ</a>を持っている場合があります。initコンテナはappコンテナが起動する前に実行・完了するコンテナです。</p><p>Podは、Podを構成する複数のコンテナに対して、<a href=#pod-networking>ネットワーク</a>と<a href=#pod-storage>ストレージ</a>の2種類の共有リソースを提供します。</p><h2 id=working-with-pods>Podを利用する</h2><p>通常Kubernetesでは、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、個別のPodを直接作成することはめったにありません。その理由は、Podがある程度一時的で使い捨てできる存在として設計されているためです。Podが作成されると(あなたが直接作成した場合でも、<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>が間接的に作成した場合でも)、新しいPodはクラスター内の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>上で実行されるようにスケジューリングされます。Podは、実行が完了するか、Podオブジェクトが削除されるか、リソース不足によって<em>強制退去</em>されるか、ノードが停止するまで、そのノード上にとどまります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Pod内のコンテナの再起動とPodの再起動を混同しないでください。Podはプロセスではなく、コンテナが実行するための環境です。Podは削除されるまでは残り続けます。</div><p>Podオブジェクトのためのマニフェストを作成したときは、指定したPodの名前が有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>であることを確認してください。</p><h3 id=pod-os>Pod OS</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [stable]</code></div><p><code>.spec.os.name</code>フィールドで<code>windows</code>か<code>linux</code>のいずれかを設定し、Podを実行させたいOSを指定する必要があります。Kubernetesは今のところ、この2つのOSだけサポートしています。将来的には増える可能性があります。</p><p>Kubernetes v1.25では、このフィールドに設定した値はPodの<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=スケジューリング>スケジューリング</a>に影響を与えません。<code>.spec.os.name</code>を設定することで、Pod OSに権限を認証することができ、バリデーションにも使用されます。kubeletが実行されているノードのOSが、指定されたPod OSと異なる場合、kubeletはPodの実行を拒否します。
<a href=/ja/docs/concepts/security/pod-security-standards/>Podセキュリティの標準</a>もこのフィールドを使用し、指定したOSと関係ないポリシーの適用を回避しています。</p><h3 id=pods-and-controllers>Podとコンテナコントローラー</h3><p>ワークロードリソースは、複数のPodを作成・管理するために利用できます。リソースに対応するコントローラーが、複製やロールアウトを扱い、Podの障害時には自動回復を行います。たとえば、あるノードに障害が発生した場合、コントローラーはそのノードの動作が停止したことを検知し、代わりのPodを作成します。そして、スケジューラーが代わりのPodを健全なノード上に配置します。</p><p>以下に、1つ以上のPodを管理するワークロードリソースの一例をあげます。</p><ul><li><a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a></li><li><a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a></li><li><a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a></li></ul><h3 id=pod-template>Podテンプレート</h3><p><a class=glossary-tooltip title=ワークロードとは、Kubernetes上で実行中のアプリケーションです。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/ target=_blank aria-label=workload>workload</a>リソース向けのコントローラーは、Podを<em>Podテンプレート</em>を元に作成し、あなたの代わりにPodを管理してくれます。</p><p>PodTemplateはPodを作成するための仕様で、<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>、<a href=/ja/docs/concepts/workloads/controllers/job/>Job</a>、<a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>などのワークロードリソースの中に含まれています。</p><p>ワークロードリソースに対応する各コントローラーは、ワークロードオブジェクト内にある<code>PodTemplate</code>を使用して実際のPodを作成します。<code>PodTemplate</code>は、アプリを実行するために使われるワークロードリソースがどんな種類のものであれ、その目的の状態の一部を構成するものです。</p><p>以下は、単純なJobのマニフェストの一例で、1つのコンテナを実行する<code>template</code>があります。Pod内のコンテナはメッセージを出力した後、一時停止します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># これがPodテンプレートです</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo &#34;Hello, Kubernetes!&#34; &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Podテンプレートはここまでです</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Podテンプレートを修正するか新しいPodに切り替えたとしても、すでに存在するPodには直接の影響はありません。ワークロードリソース内のPodテンプレートを変更すると、そのリソースは更新されたテンプレートを使用して代わりとなるPodを作成する必要があります。</p><p>たとえば、StatefulSetコントローラーは、各StatefulSetごとに、実行中のPodが現在のPodテンプレートに一致することを保証します。Podテンプレートを変更するためにStatefulSetを編集すると、StatefulSetは更新されたテンプレートを元にした新しいPodを作成するようになります。最終的に、すべての古いPodが新しいPodで置き換えられ、更新は完了します。</p><p>各ワークロードリソースは、Podテンプレートへの変更を処理するための独自のルールを実装しています。特にStatefulSetについて更に詳しく知りたい場合は、StatefulSetの基本チュートリアル内の<a href=/ja/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets>アップデート戦略</a>を読んでください。</p><p>ノード上では、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>はPodテンプレートに関する詳細について監視や管理を直接行うわけではありません。こうした詳細は抽象化されています。こうした抽象化や関心の分離のおかげでシステムのセマンティクスが単純化され、既存のコードを変更せずにクラスターの動作を容易に拡張できるようになっているのです。</p><h2 id=podの更新と取替>Podの更新と取替</h2><p>前のセクションで述べたように、ワークロードリソースのPodテンプレートが変更されると、コントローラーは既存のPodを更新したりパッチを適用したりするのではなく、更新されたテンプレートに基づいて新しいPodを作成します。</p><p>KubernetesはPodを直接管理することを妨げません。実行中のPodの一部のフィールドをその場で更新することが可能です。しかし、<a href=/docs/reference/generated/kubernetes-api/v1.25/#patch-pod-v1-core><code>patch</code></a>と<a href=/docs/reference/generated/kubernetes-api/v1.25/#replace-pod-v1-core><code>replace</code></a>といった、Podのアップデート操作にはいくつかの制限があります:</p><ul><li><p>Podのメタデータのほとんどは固定されたものです。たとえば<code>namespace</code>、<code>name</code>、<code>uid</code>または<code>creationTimestamp</code>フィールドは変更できません。<code>generation</code>フィールドは特別で、現在の値を増加させる更新のみを受け付けます。</p></li><li><p><code>metadata.deletionTimestamp</code>が設定されている場合、<code>metadata.finalizers</code>リストに新しい項目を追加することはできません。</p></li><li><p>Podの更新では<code>spec.containers[*].image</code>、<code>spec.initContainers[*].image</code>、<code>spec.activeDeadlineSeconds</code>または<code>spec.tolerations</code>以外のフィールドを変更してはなりません。
<code>spec.tolerations</code>については新しい項目のみを追加することができます。</p></li><li><p><code>spec.activeDeadlineSeconds</code>フィールドを更新する場合、2種類の更新が可能です:</p><ol><li>未割り当てのフィールドに正の数を設定する</li><li>現在の値から負の数でない、より小さい数に更新する</li></ol></li></ul><h2 id=リソースの共有と通信>リソースの共有と通信</h2><p>Podは、データの共有と構成するコンテナ間での通信を可能にします。</p><h3 id=pod-storage>Pod内のストレージ</h3><p>Podでは、共有ストレージである<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>の集合を指定できます。Pod内のすべてのコンテナは共有ボリュームにアクセスできるため、それら複数のコンテナでデータを共有できるようになります。また、ボリュームを利用すれば、Pod内のコンテナの1つに再起動が必要になった場合にも、Pod内の永続化データを保持し続けられるようにできます。Kubernetesの共有ストレージの実装方法とPodで利用できるようにする方法に関するさらに詳しい情報は、<a href=/ja/docs/concepts/storage/>ストレージ</a>を読んでください。</p><h3 id=pod-networking>Podネットワーク</h3><p>各Podには、各アドレスファミリーごとにユニークなIPアドレスが割り当てられます。Pod内のすべてのコンテナは、IPアドレスとネットワークポートを含むネットワーク名前空間を共有します。Podの中では(かつその場合に<strong>のみ</strong>)、そのPod内のコンテナは<code>localhost</code>を使用して他のコンテナと通信できます。Podの内部にあるコンテナが<em>Podの外部にある</em>エンティティと通信する場合、(ポートなどの)共有ネットワークリソースの使い方をコンテナ間で調整しなければなりません。Pod内では、コンテナはIPアドレスとポートの空間を共有するため、<code>localhost</code>で他のコンテナにアクセスできます。また、Pod内のコンテナは、SystemVのセマフォやPOSIXの共有メモリなど、標準のプロセス間通信を使って他のコンテナと通信することもできます。異なるPod内のコンテナは異なるIPアドレスを持つため、特別な設定をしない限り、OSレベルIPCで通信することはできません。異なるPod上で実行中のコンテナ間でやり取りをしたい場合は、IPネットワークを使用して通信できます。</p><p>Pod内のコンテナは、システムのhostnameがPodに設定した<code>name</code>と同一であると考えます。ネットワークについての詳しい情報は、<a href=/ja/docs/concepts/cluster-administration/networking/>ネットワーク</a>で説明しています。</p><h2 id=コンテナの特権モード>コンテナの特権モード</h2><p>Linuxでは、Pod内のどんなコンテナも、<code>privileged</code>フラグをコンテナのspecの<a href=/docs/tasks/configure-pod-container/security-context/>security context</a>に設定することで、特権モード(privileged mode)を有効にできます。これは、ネットワークスタックの操作やハードウェアデバイスへのアクセスなど、オペレーティングシステムの管理者の権限が必要なコンテナの場合に役に立ちます。</p><p><code>WindowsHostProcessContainers</code>機能を有効にしたクラスターの場合、Pod仕様のsecurityContextに<code>windowsOptions.hostProcess</code>フラグを設定することで、<a href=/docs/tasks/configure-pod-container/create-hostprocess-pod>Windows HostProcess Pod</a>を作成することが可能です。これらのPod内のすべてのコンテナは、Windows HostProcessコンテナとして実行する必要があります。HostProcess Podはホスト上で直接実行され、Linuxの特権コンテナで行われるような管理作業を行うのにも使用できます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> この設定を有効にするには、<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>が特権コンテナの概念をサポートしていなければなりません。</div><h2 id=static-pod>static Pod</h2><p><em>static Pod</em>は、<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>には管理されない、特定のノード上でkubeletデーモンによって直接管理されるPodのことです。大部分のPodはコントロープレーン(たとえば<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>)によって管理されますが、static Podの場合はkubeletが各static Podを直接管理します(障害時には再起動します)。</p><p>static Podは常に特定のノード上の1つの<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>に紐付けられます。static Podの主な用途は、セルフホストのコントロールプレーンを実行すること、言い換えると、kubeletを使用して個別の<a href=/ja/docs/concepts/overview/components/#control-plane-components>コントロールプレーンコンポーネント</a>を管理することです。</p><p>kubeletは自動的にKubernetes APIサーバー上に各static Podに対応する<a class=glossary-tooltip title='kubelet上のstatic Podを追跡するAPIサーバー内のオブジェクトです。' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-mirror-pod' target=_blank aria-label=ミラーPod>ミラーPod</a>の作成を試みます。つまり、ノード上で実行中のPodはAPIサーバー上でも見えるようになるけれども、APIサーバー上から制御はできないということです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Static Podの<code>spec</code>は他のAPIオブジェクト
(例えば<a class=glossary-tooltip title='Provides an identity for processes that run in a Pod.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=サービスアカウント>サービスアカウント</a>、
<a class=glossary-tooltip title=機密性のないデータをキーと値のペアで保存するために使用されるAPIオブジェクトです。環境変数、コマンドライン引数、またはボリューム内の設定ファイルとして使用できます。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>、
<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>、など)を参照することはできません。</div><h2 id=コンテナのprobe>コンテナのProbe</h2><p><em>Probe</em> はkubeletがコンテナに対して行う定期診断です。診断を実行するために、kubeletはさまざまなアクションを実行できます:</p><ul><li><code>ExecAction</code> (コンテナランタイムの助けを借りて実行)</li><li><code>TCPSocketAction</code> (kubeletにより直接チェック)</li><li><code>HTTPGetAction</code> (kubeletにより直接チェック)</li></ul><p>更に詳しく知りたい場合は、Podのライフサイクルドキュメントにある<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>Probe</a>を読んでください。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>について学ぶ。</li><li><a href=/ja/docs/concepts/containers/runtime-class/>RuntimeClass</a>と、それを用いてPodごとに異なるコンテナランタイム設定する方法について学ぶ。</li><li><a href=/ja/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>と、それを使用してクラスターの停止(disruption)中にアプリケーションの可用性を管理する方法について読む。</li><li>PodはKubernetes REST API内のトップレベルのリソースです。
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/>Pod</a>オブジェクトの定義では、オブジェクトの詳細について記述されています。</li><li><a href=/blog/2015/06/the-distributed-system-toolkit-patterns/>The Distributed System Toolkit: Patterns for Composite Containers</a>では、2つ以上のコンテナを利用する場合の一般的なレイアウトについて説明しています。</li><li><a href=/docs/concepts/scheduling-eviction/topology-spread-constraints/>Podトポロジー分布制約</a>について読む。</li></ul><p>Kubernetesが共通のPod APIを他のリソース内(たとえば<a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>や<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>など)にラッピングしている理由の文脈を理解するためには、Kubernetes以前から存在する以下のような既存技術について読むのが助けになります。</p><ul><li><a href=https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a></li><li><a href=https://research.google.com/pubs/pub43438.html>Borg</a></li><li><a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a></li><li><a href=https://research.google/pubs/pub41684/>Omega</a></li><li><a href=https://engineering.fb.com/data-center-engineering/tupperware/>Tupperware</a></li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-37afa6c66c74400d1579f10faf55e5b6>1 - Podの概観</h1><p>このページでは、Kubernetesのオブジェクトモデルにおいて、デプロイ可能な最小単位のオブジェクトである<code>Pod</code>に関して説明します。</p><h2 id=understanding-pods>Podについて理解する</h2><p><em>Pod</em> は、Kubernetesアプリケーションの基本的な実行単位です。これは、作成またはデプロイするKubernetesオブジェクトモデルの中で最小かつ最も単純な単位です。Podは、<a class=glossary-tooltip title=コンテナ化されたアプリケーションを実行する、ノードと呼ばれるワーカーマシンの集合です。すべてのクラスターには少なくとも1つのワーカーノードがあります。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=クラスター>クラスター</a>で実行されているプロセスを表します。</p><p>Podは、アプリケーションのコンテナ(いくつかの場合においては複数のコンテナ)、ストレージリソース、ユニークなネットワークIP、およびコンテナの実行方法を管理するオプションをカプセル化します。Podはデプロイメントの単位、すなわち<em>Kubernetesのアプリケーションの単一インスタンス</em> で、単一の<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>または密結合なリソースを共有する少数のコンテナで構成される場合があります。</p><p><a href=https://www.docker.com>Docker</a>はKubernetesのPod内で使われる最も一般的なコンテナランタイムですが、Podは他の<a href=/ja/docs/setup/production-environment/container-runtimes/>コンテナランタイム</a>も同様にサポートしています。</p><p>Kubernetesクラスター内でのPodは2つの主な方法で使うことができます。</p><ul><li><strong>単一のコンテナを稼働させるPod</strong> : いわゆる*「1Pod1コンテナ」* 構成のモデルは、最も一般的なKubernetesのユースケースです。
このケースでは、ユーザーはPodを単一のコンテナのラッパーとして考えることができ、Kubernetesはコンテナを直接扱うというよりは、Podを管理することになります。</li><li><strong>協調して稼働させる必要がある複数のコンテナを稼働させるPod</strong> : 単一のPodは、リソースを共有する必要があるような、密接に連携した複数の同じ環境にあるコンテナからなるアプリケーションをカプセル化することもできます。 これらの同じ環境にあるコンテナ群は、サービスの結合力の強いユニットを構成することができます。
-- 1つのコンテナが、共有されたボリュームからファイルをパブリックな場所に送信し、一方では分割された<em>サイドカー</em> コンテナがそれらのファイルを更新します。そのPodはそれらのコンテナとストレージリソースを、単一の管理可能なエンティティとしてまとめます。</li></ul><p><a href=https://kubernetes.io/blog>Kubernetes Blog</a>にて、Podのユースケースに関するいくつかの追加情報を見ることができます。さらなる情報を得たい場合は、下記のページを参照ください。</p><ul><li><a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>The Distributed System Toolkit: Patterns for Composite Containers</a></li><li><a href=https://kubernetes.io/blog/2016/06/container-design-patterns>Container Design Patterns</a></li></ul><p>各Podは、与えられたアプリケーションの単一のインスタンスを稼働するためのものです。もしユーザーのアプリケーションを水平にスケールさせたい場合(例: 複数インスタンスを稼働させる)、複数のPodを使うべきです。1つのPodは各インスタンスに対応しています。
Kubernetesにおいて、これは一般的に <em>レプリケーション</em> と呼ばれます。
レプリケーションされたPodは、通常コントローラーと呼ばれる抽象概念によって単一のグループとして作成、管理されます。
さらなる情報に関しては<a href=#pods-and-controllers>Podとコントローラー</a>を参照して下さい。</p><h3 id=podがどのように複数のコンテナを管理しているか>Podがどのように複数のコンテナを管理しているか</h3><p>Podは凝集性の高いサービスのユニットを構成するような複数の協調プロセス(コンテナ）をサポートするためにデザインされました。
単一のPod内のコンテナ群は、クラスター内において同一の物理マシンもしくは仮想マシン上において自動で同じ環境に配備され、スケジュールされます。コンテナはリソースや依存関係を共有し、お互いにコミュニケートし、それらがいつ、どのように削除されるかを調整できます。</p><p>注意点として、単一のPod内で同じ環境に配備され、同時管理される複数のコンテナをグルーピングするのは、比較的に発展的なユースケースとなります。
ユーザーは、コンテナ群が密接に連携するような、特定のインスタンスにおいてのみこのパターンを使用するべきです。
例えば、ユーザーが共有ボリューム内にあるファイル用のWebサーバとして稼働するコンテナと、下記のダイアグラムにあるような、リモートのソースからファイルを更新するような分離された<em>サイドカー</em> コンテナを持っているような場合です。</p><figure><img src=/images/docs/pod.svg alt=Podのダイアグラム width=50%></figure><p>Podは、Podによって構成されたコンテナ群のために2種類の共有リソースを提供します。 <em>ネットワーキング</em> と<em>ストレージ</em> です。</p><h4 id=ネットワーキング>ネットワーキング</h4><p>各Podは固有のIPアドレスを割り当てられます。単一のPod内の各コンテナは、IPアドレスやネットワークポートを含む、そのネットワークの名前空間を共有します。<em>Pod内の</em> コンテナは<code>localhost</code>を使用してお互いに疎通できます。単一のPod内のコンテナが<em>Pod外</em> のエンティティと疎通する場合、共有されたネットワークリソース(ポートなど）をどのように使うかに関して調整しなければなりません。</p><h4 id=ストレージ>ストレージ</h4><p>単一のPodは共有されたストレージ<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>のセットを指定できます。Pod内の全てのコンテナは、その共有されたボリュームにアクセスでき、コンテナ間でデータを共有することを可能にします。ボリュームもまた、もしPod内のコンテナの1つが再起動が必要になった場合に備えて、データを永続化できます。
単一のPod内での共有ストレージをKubernetesがどう実装しているかについてのさらなる情報については、<a href=/docs/concepts/storage/volumes/>Volumes</a>を参照してください。</p><h2 id=podを利用する>Podを利用する</h2><p>ユーザーはまれに、Kubernetes内で独立したPodを直接作成する場合があります(シングルトンPodなど)。
これはPodが比較的、一時的な使い捨てエンティティとしてデザインされているためです。Podが作成された時(ユーザーによって直接的、またはコントローラーによって間接的に作成された場合)、ユーザーのクラスター内の単一の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>上で稼働するようにスケジューリングされます。そのPodはプロセスが停止されたり、Podオブジェクトが削除されたり、Podがリソースの欠如のために<em>追い出され</em> たり、ノードが故障するまでノード上に残り続けます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 単一のPod内でのコンテナを再起動することと、そのPodを再起動することを混同しないでください。Podはそれ自体は実行されませんが、コンテナが実行される環境であり、削除されるまで存在し続けます。</div><p>Podは、Podそれ自体によって自己修復しません。もし、稼働されていないノード上にPodがスケジュールされた場合や、スケジューリング操作自体が失敗した場合、Podが削除されます。同様に、Podはリソースの欠如や、ノードのメンテナンスによる追い出しがあった場合はそこで停止します。Kubernetesは<em>コントローラー</em> と呼ばれる高レベルの抽象概念を使用し、それは比較的使い捨て可能なPodインスタンスの管理を行います。
このように、Podを直接使うのは可能ですが、コントローラーを使用したPodを管理する方がより一般的です。KubernetesがPodのスケーリングと修復機能を実現するためにコントローラーをどのように使うかに関する情報は<a href=#pods-and-controllers>Podとコントローラー</a>を参照してください。</p><h3 id=podとコントローラー>Podとコントローラー</h3><p>単一のコントローラーは、ユーザーのために複数のPodを作成・管理し、レプリケーションやロールアウト、クラスターのスコープ内で自己修復の機能をハンドリングします。例えば、もしノードが故障した場合、コントローラーは異なるノード上にPodを置き換えるようにスケジューリングすることで、自動的にリプレース可能となります。</p><p>1つまたはそれ以上のPodを含むコントローラーの例は下記の通りです。</p><ul><li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a></li><li><a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li></ul><p>通常は、コントローラーはユーザーが作成したPodテンプレートを使用して、担当するPodを作成します。</p><h2 id=podテンプレート>Podテンプレート</h2><p>Podテンプレートは、<a href=/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>、 <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/>Job</a>や、
<a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>のような他のオブジェクト内で含まれるPodの仕様となります。
コントローラーは実際のPodを作成するためにPodテンプレートを使用します。
下記のサンプルは、メッセージを表示する単一のコンテナを含んだ、シンプルなPodのマニフェストとなります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>myapp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo Hello Kubernetes! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>全てのレプリカの現在の理想的な状態を指定するというよりも、Podテンプレートはクッキーの抜き型のようなものです。一度クッキーがカットされると、そのクッキーは抜き型から離れて関係が無くなります。そこにはいわゆる”量子もつれ”といったものはありません。テンプレートに対するその後の変更や新しいテンプレートへの切り替えは、すでに作成されたPod上には直接的な影響はありません。
同様に、ReplicationControllerによって作成されたPodは、変更後に直接更新されます。これはPodとの意図的な違いとなり、そのPodに属する全てのコンテナの現在の理想的な状態を指定します。このアプローチは根本的にシステムのセマンティクスを単純化し、機能の柔軟性を高めます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/workloads/pods/pod/>Pod</a>についてさらに学びましょう</li><li>Podの振る舞いに関して学ぶには下記を参照してください<ul><li><a href=/ja/docs/concepts/workloads/pods/pod/#termination-of-pods>Podの停止</a></li><li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c3c2b9cf30915ec9d46c147201da3332>2 - Podのライフサイクル</h1><p>このページではPodのライフサイクルについて説明します。Podは定義されたライフサイクルに従い <code>Pending</code><a href=#pod-phase>フェーズ</a>から始まり、少なくとも1つのプライマリーコンテナが正常に開始した場合は<code>Running</code>を経由し、次に失敗により終了したコンテナの有無に応じて、<code>Succeeded</code>または<code>Failed</code>フェーズを経由します。</p><p>Podの実行中、kubeletはコンテナを再起動して、ある種の障害を処理できます。Pod内で、Kubernetesはさまざまなコンテナの<a href=#container-states>ステータス</a>を追跡して、回復させるためのアクションを決定します。</p><p>Kubernetes APIでは、Podには仕様と実際のステータスの両方があります。Podオブジェクトのステータスは、<a href=#pod-conditions>PodのCondition</a>のセットで構成されます。<a href=#pod-readiness-gate>カスタムのReadiness情報</a>をPodのConditionデータに挿入することもできます。</p><p>Podはその生存期間に1回だけ<a href=/docs/concepts/scheduling-eviction/>スケジューリング</a>されます。PodがNodeにスケジュール(割り当て)されると、Podは停止または<a href=#pod-termination>終了</a>するまでそのNode上で実行されます。</p><h2 id=podのライフタイム>Podのライフタイム</h2><p>個々のアプリケーションコンテナと同様に、Podは(永続的ではなく)比較的短期間の存在と捉えられます。Podが作成されると、一意のID(<a href=/ja/docs/concepts/overview/working-with-objects/names/#uids>UID</a>)が割り当てられ、(再起動ポリシーに従って)終了または削除されるまでNodeで実行されるようにスケジュールされます。<br><a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>が停止した場合、そのNodeにスケジュールされたPodは、タイムアウト時間の経過後に<a href=#pod-garbage-collection>削除</a>されます。</p><p>Pod自体は、自己修復しません。Podが<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a>にスケジュールされ、その後に失敗、またはスケジュール操作自体が失敗した場合、Podは削除されます。同様に、リソースの不足またはNodeのメンテナンスによりPodはNodeから立ち退きます。Kubernetesは、比較的使い捨てのPodインスタンスの管理作業を処理する、<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>と呼ばれる上位レベルの抽象化を使用します。</p><p>特定のPod(UIDで定義)は新しいNodeに"再スケジュール"されません。代わりに、必要に応じて同じ名前で、新しいUIDを持つ同一のPodに置き換えることができます。</p><p><a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a>など、Podと同じ存続期間を持つものがあると言われる場合、それは(そのUIDを持つ)Podが存在する限り存在することを意味します。そのPodが何らかの理由で削除された場合、たとえ同じ代替物が作成されたとしても、関連するもの(例えばボリューム)も同様に破壊されて再作成されます。</p><figure><img src=/images/docs/pod.svg width=50%><figcaption><h4>Podの図</h4></figcaption></figure><p><em>file puller(ファイル取得コンテナ)とWebサーバーを含むマルチコンテナのPod。コンテナ間の共有ストレージとして永続ボリュームを使用しています。</em></p><h2 id=pod-phase>Podのフェーズ</h2><p>Podの<code>status</code>項目は<a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a>オブジェクトで、それは<code>phase</code>のフィールドがあります。</p><p>Podのフェーズは、そのPodがライフサイクルのどの状態にあるかを、簡単かつ高レベルにまとめたものです。このフェーズはコンテナやPodの状態を包括的にまとめることを目的としたものではなく、また包括的なステートマシンでもありません。</p><p>Podの各フェーズの値と意味は厳重に守られています。ここに記載されているもの以外に<code>phase</code>の値は存在しないと思ってください。</p><p>これらが<code>phase</code>の取りうる値です。</p><table><thead><tr><th style=text-align:left>値</th><th style=text-align:left>概要</th></tr></thead><tbody><tr><td style=text-align:left><code>Pending</code></td><td style=text-align:left>PodがKubernetesクラスターによって承認されましたが、1つ以上のコンテナがセットアップされて稼働する準備ができていません。これには、スケジュールされるまでの時間と、ネットワーク経由でイメージをダウンロードするための時間などが含まれます。</td></tr><tr><td style=text-align:left><code>Running</code></td><td style=text-align:left>PodがNodeにバインドされ、すべてのコンテナが作成されました。少なくとも1つのコンテナがまだ実行されているか、開始または再起動中です。</td></tr><tr><td style=text-align:left><code>Succeeded</code></td><td style=text-align:left>Pod内のすべてのコンテナが正常に終了し、再起動されません。</td></tr><tr><td style=text-align:left><code>Failed</code></td><td style=text-align:left>Pod内のすべてのコンテナが終了し、少なくとも1つのコンテナが異常終了しました。つまり、コンテナはゼロ以外のステータスで終了したか、システムによって終了されました。</td></tr><tr><td style=text-align:left><code>Unknown</code></td><td style=text-align:left>何らかの理由によりPodの状態を取得できませんでした。このフェーズは通常はPodのホストとの通信エラーにより発生します。</td></tr></tbody></table><p>Nodeが停止するか、クラスタの残りの部分から切断された場合、Kubernetesは失われたNode上のすべてのPodの<code>Phase</code>をFailedに設定するためのポリシーを適用します。</p><h2 id=container-states>コンテナのステータス</h2><p>Pod全体の<a href=#pod-phase>フェーズ</a>と同様に、KubernetesはPod内の各コンテナの状態を追跡します。<a href=/ja/docs/concepts/containers/container-lifecycle-hooks/>container lifecycle hooks</a>を使用して、コンテナのライフサイクルの特定のポイントで実行するイベントをトリガーできます。</p><p>Podが<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=scheduler>scheduler</a>によってNodeに割り当てられると、kubeletは<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label='container runtime'>container runtime</a>を使用してコンテナの作成を開始します。コンテナの状態は<code>Waiting</code>、<code>Running</code>または<code>Terminated</code>の3ついずれかです。</p><p>Podのコンテナの状態を確認するには<code>kubectl describe pod [POD_NAME]</code>のコマンドを使用します。Pod内のコンテナごとにStateの項目として表示されます。</p><p>各状態の意味は次のとおりです。</p><h3 id=container-state-waiting><code>Waiting</code></h3><p>コンテナが<code>Running</code>または<code>Terminated</code>のいずれの状態でもない場合コンテナは<code>Waiting</code>の状態になります。Waiting状態のコンテナは引き続きコンテナイメージレジストリからイメージを取得したり<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>を適用したりするなど必要な操作を実行します。<code>Waiting</code>状態のコンテナを持つPodに対して<code>kubectl</code>コマンドを使用すると、そのコンテナが<code>Waiting</code>の状態である理由の要約が表示されます。</p><h3 id=container-state-running><code>Running</code></h3><p><code>Running</code>状態はコンテナが問題なく実行されていることを示します。<code>postStart</code>フックが構成されていた場合、それはすでに実行が完了しています。<code>Running</code>状態のコンテナを持つPodに対して<code>kubectl</code>コマンドを使用すると、そのコンテナが<code>Running</code>状態になった時刻が表示されます。</p><h3 id=container-state-terminated><code>Terminated</code></h3><p><code>Terminated</code>状態のコンテナは実行されて、完了したときまたは何らかの理由で失敗したことを示します。<code>Terminated</code>状態のコンテナを持つPodに対して<code>kubectl</code>コマンドを使用すると、いずれにせよ理由と終了コード、コンテナの開始時刻と終了時刻が表示されます。</p><p>コンテナがTerminatedに入る前に<code>preStop</code>フックがあれば実行されます。</p><h2 id=restart-policy>コンテナの再起動ポリシー</h2><p>Podの<code>spec</code>には、Always、OnFailure、またはNeverのいずれかの値を持つ<code>restartPolicy</code>フィールドがあります。デフォルト値はAlwaysです。</p><p><code>restartPolicy</code>は、Pod内のすべてのコンテナに適用されます。<code>restartPolicy</code>は、同じNode上のkubeletによるコンテナの再起動のみを参照します。Pod内のコンテナが終了した後、kubeletは5分を上限とする指数バックオフ遅延（10秒、20秒、40秒...）でコンテナを再起動します。コンテナが10分間実行されると、kubeletはコンテナの再起動バックオフタイマーをリセットします。</p><h2 id=pod-conditions>PodのCondition</h2><p>PodにはPodStatusがあります。それはPodが成功したかどうかの情報を持つ<a href=/docs/reference/generated/kubernetes-api/v1.25/#podcondition-v1-core>PodConditions</a>の配列です。</p><ul><li><code>PodScheduled</code>: PodがNodeにスケジュールされました。</li><li><code>ContainersReady</code>: Pod内のすべてのコンテナが準備できた状態です。</li><li><code>Initialized</code>: すべての<a href=/ja/docs/concepts/workloads/pods/init-containers>Initコンテナ</a>が正常に実行されました。</li><li><code>Ready</code>: Podはリクエストを処理でき、一致するすべてのサービスの負荷分散プールに追加されます。</li></ul><table><thead><tr><th style=text-align:left>フィールド名</th><th style=text-align:left>内容</th></tr></thead><tbody><tr><td style=text-align:left><code>type</code></td><td style=text-align:left>このPodの状態の名前です。</td></tr><tr><td style=text-align:left><code>status</code></td><td style=text-align:left>その状態が適用可能かどうか示します。可能な値は"<code>True</code>"と"<code>False</code>"、"<code>Unknown</code>"のうちのいずれかです。</td></tr><tr><td style=text-align:left><code>lastProbeTime</code></td><td style=text-align:left>Pod Conditionが最後に確認されたときのタイムスタンプが表示されます。</td></tr><tr><td style=text-align:left><code>lastTransitionTime</code></td><td style=text-align:left>最後にPodのステータスの遷移があった際のタイムスタンプが表示されます。</td></tr><tr><td style=text-align:left><code>reason</code></td><td style=text-align:left>最後の状態遷移の理由を示す、機械可読のアッパーキャメルケースのテキストです。</td></tr><tr><td style=text-align:left><code>message</code></td><td style=text-align:left>ステータスの遷移に関する詳細を示す人間向けのメッセージです。</td></tr></tbody></table><h2 id=pod-readiness-gate>PodのReadiness</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code></div><p>追加のフィードバックやシグナルをPodStatus:_Pod readiness_に注入できるようにします。これを使用するには、Podの<code>spec</code>で<code>readinessGates</code>を設定して、kubeletがPodのReadinessを評価する追加の状態のリストを指定します。</p><p>ReadinessゲートはPodの<code>status.conditions</code>フィールドの現在の状態によって決まります。Kubernetesが<code>Podのstatus.conditions</code>フィールドでそのような状態を発見できない場合、ステータスはデフォルトで<code>False</code>になります。</p><p>以下はその例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>Kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readinessGates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>conditionType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready <span style=color:#bbb> </span><span style=color:#080;font-style:italic># これはビルトインのPodCondition</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># 追加のPodCondition</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://abcd...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>PodのConditionは、Kubernetesの<a href=/ja/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set>label key format</a>に準拠している必要があります。</p><h3 id=pod-readiness-status>PodのReadinessの状態</h3><p><code>kubectl patch</code>コマンドはオブジェクトステータスのパッチ適用をまだサポートしていません。Podにこれらの<code>status.conditions</code>を設定するには、アプリケーションと<a class=glossary-tooltip title='A specialized controller used to manage a custom resource' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operators>operators</a>は<code>PATCH</code>アクションを使用する必要があります。<a href=/docs/reference/using-api/client-libraries/>Kubernetes client library</a>を使用して、PodのReadinessのためにカスタムのPodのConditionを設定するコードを記述できます。</p><p>カスタムのPodのConditionが導入されるとPodは次の両方の条件に当てはまる場合<strong>のみ</strong>準備できていると評価されます:</p><ul><li>Pod内のすべてのコンテナが準備完了している。</li><li><code>ReadinessGates</code>で指定された条件が全て<code>True</code>である。</li></ul><p>Podのコンテナは準備完了ですが、少なくとも1つのカスタムのConditionが欠落しているか「False」の場合、kubeletはPodの<a href=#pod-condition>Condition</a>を<code>ContainersReady</code>に設定します。</p><h2 id=container-probes>コンテナのProbe</h2><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core>Probe</a> は <a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> により定期的に実行されるコンテナの診断です。診断を行うために、kubeletはコンテナに実装された <a href=/docs/reference/generated/kubernetes-api/v1.25/#handler-v1-core>Handler</a>を呼びます。Handlerには次の3つの種類があります:</p><ul><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#execaction-v1-core>ExecAction</a>:
コンテナ内で特定のコマンドを実行します。コマンドがステータス0で終了した場合に診断を成功と見まします。</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#tcpsocketaction-v1-core>TCPSocketAction</a>:
PodのIPの特定のポートにTCPチェックを行います。
そのポートが空いていれば診断を成功とみなします。</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#httpgetaction-v1-core>HTTPGetAction</a>:
PodのIPの特定のポートとパスに対して、HTTP GETのリクエストを送信します。
レスポンスのステータスコードが200以上400未満の際に診断を成功とみなします。</p></li></ul><p>各Probe 次の3つのうちの一つの結果を持ちます:</p><ul><li><code>Success</code>: コンテナの診断が成功しました。</li><li><code>Failure</code>: コンテナの診断が失敗しました。</li><li><code>Unknown</code>: コンテナの診断が失敗し、取れるアクションがありません。</li></ul><p>Kubeletは3種類のProbeを実行中のコンテナで行い、また反応することができます:</p><ul><li><p><code>livenessProbe</code>: コンテナが動いているかを示します。
livenessProbe に失敗すると、kubeletはコンテナを殺します、そしてコンテナは<a href=#restart-policy>restart policy</a>に従います。
コンテナにlivenessProbeが設定されていない場合、デフォルトの状態は<code>Success</code>です。</p></li><li><p><code>readinessProbe</code>: コンテナがリクエスト応答する準備ができているかを示します。
readinessProbeに失敗すると、エンドポイントコントローラーにより、ServiceからそのPodのIPアドレスが削除されます。
initial delay前のデフォルトのreadinessProbeの初期値は<code>Failure</code>です。
コンテナにreadinessProbeが設定されていない場合、デフォルトの状態は<code>Success</code>です。</p></li><li><p><code>startupProbe</code>: コンテナ内のアプリケーションが起動したかどうかを示します。
startupProbeが設定された場合、完了するまでその他のすべてのProbeは無効になります。
startupProbeに失敗すると、kubeletはコンテナを殺します、そしてコンテナは<a href=#restart-policy>restart policy</a>に従います。
コンテナにstartupProbeが設定されていない場合、デフォルトの状態は<code>Success</code>です。</p></li></ul><p>livenessProbe、readinessProbeまたはstartupProbeを設定する方法の詳細については、<a href=/ja/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>Liveness Probe、Readiness ProbeおよびStartup Probeを使用する</a>を参照してください。</p><h3 id=when-should-you-use-a-liveness-probe>livenessProbeをいつ使うべきか?</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code></div><p>コンテナ自体に問題が発生した場合や状態が悪くなった際にクラッシュすることができればlivenessProbeは不要です.
この場合kubeletが自動でPodの<code>restartPolicy</code>に基づいたアクションを実行します。</p><p>Probeに失敗したときにコンテナを殺したり再起動させたりするには、livenessProbeを設定し<code>restartPolicy</code>をAlwaysまたはOnFailureにします。</p><h3 id=when-should-you-use-a-readiness-probe>readinessProbeをいつ使うべきか?</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code></div><p>Probeが成功したときにのみPodにトラフィックを送信したい場合は、readinessProbeを指定します。
この場合readinessProbeはlivenessProbeと同じになる可能性がありますが、readinessProbeが存在するということは、Podがトラフィックを受けずに開始され、Probe成功が開始した後でトラフィックを受け始めることになります。コンテナが起動時に大きなデータ、構成ファイル、またはマイグレーションを読み込む必要がある場合は、readinessProbeを指定します。</p><p>コンテナがメンテナンスのために停止できるようにするには、livenessProbeとは異なる、特定のエンドポイントを確認するreadinessProbeを指定することができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Podが削除されたときにリクエストを来ないようにするためには必ずしもreadinessProbeが必要というわけではありません。Podの削除時にはreadinessProbeが存在するかどうかに関係なくPodは自動的に自身をunreadyにします。Pod内のコンテナが停止するのを待つ間Podはunreadyのままです。</div><h3 id=when-should-you-use-a-startup-probe>startupProbeをいつ使うべきか?</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>startupProbeは、サービスの開始に時間がかかるコンテナを持つPodに役立ちます。livenessProbeの間隔を長く設定するのではなく、コンテナの起動時に別のProbeを構成して、livenessProbeの間隔よりも長い時間を許可できます。
コンテナの起動時間が、<code>initialDelaySeconds + failureThreshold x periodSeconds</code>よりも長い場合は、livenessProbeと同じエンドポイントをチェックするためにstartupProbeを指定します。<code>periodSeconds</code>のデフォルトは30秒です。次に、<code>failureThreshold</code>をlivenessProbeのデフォルト値を変更せずにコンテナが起動できるように、十分に高い値を設定します。これによりデッドロックを防ぐことができます。</p><h2 id=pod-termination>Podの終了</h2><p>Podは、クラスター内のNodeで実行中のプロセスを表すため、不要になったときにそれらのプロセスを正常に終了できるようにすることが重要です(対照的なケースは、KILLシグナルで強制終了され、クリーンアップする機会がない場合)。</p><p>ユーザーは削除を要求可能であるべきで、プロセスがいつ終了するかを知ることができなければなりませんが、削除が最終的に完了することも保証できるべきです。ユーザーがPodの削除を要求すると、システムはPodが強制終了される前に意図された猶予期間を記録および追跡します。強制削除までの猶予期間がある場合、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>正常な終了を試みます。</p><p>通常、コンテナランタイムは各コンテナのメインプロセスにTERMシグナルを送信します。多くのコンテナランタイムは、コンテナイメージで定義されたSTOPSIGNAL値を尊重し、TERMシグナルの代わりにこれを送信します。猶予期間が終了すると、プロセスにKILLシグナルが送信され、Podは<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API server'>API server</a>から削除されます。プロセスの終了を待っている間にkubeletかコンテナランタイムの管理サービスが再起動されると、クラスターは元の猶予期間を含めて、最初からリトライされます。</p><p>フローの例は下のようになります。</p><ol><li>ユーザーがデフォルトの猶予期間(30秒)でPodを削除するために<code>kubectl</code>コマンドを送信する。</li><li>API server内のPodは、猶予期間を越えるとPodが「死んでいる」と見なされるように更新される。<br>削除中のPodに対して<code>kubectl describe</code>コマンドを使用すると、Podは「終了中」と表示される。<br>Podが実行されているNode上で、Podが終了しているとマークされている(正常な終了期間が設定されている)とkubeletが認識するとすぐに、kubeletはローカルでPodの終了プロセスを開始します。<ol><li>Pod内のコンテナの1つが<code>preStop</code><a href=/ja/docs/concepts/containers/container-lifecycle-hooks/#hook-details>フック</a>を定義している場合は、コンテナの内側で呼び出される。猶予期間が終了した後も <code>preStop</code>フックがまだ実行されている場合は、一度だけ猶予期間を延長される(2秒)。<div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>preStop</code>フックが完了するまでにより長い時間が必要な場合は、<code>terminationGracePeriodSeconds</code>を変更する必要があります。</div></li><li>kubeletはコンテナランタイムをトリガーして、コンテナ内のプロセス番号1にTERMシグナルを送信する。<div class="alert alert-info note callout" role=alert><strong>備考:</strong> Pod内のすべてのコンテナが同時にTERMシグナルを受信するわけではなく、シャットダウンの順序が問題になる場合はそれぞれに<code>preStop</code>フックを使用して同期することを検討する。</div></li></ol></li><li>kubeletが正常な終了を開始すると同時に、コントロールプレーンは、終了中のPodをEndpoints(および有効な場合はEndpointSlice)オブジェクトから削除します。これらのオブジェクトは、<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selector>selector</a>が設定された<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を表します。<a class=glossary-tooltip title=ReplicaSetは、指定された数のPodレプリカが一度に動作するように保証します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSets>ReplicaSets</a>とその他のワークロードリソースは、終了中のPodを有効なサービス中のReplicaSetとして扱いません。ゆっくりと終了するPodは、(サービスプロキシーのような)ロードバランサーが終了猶予期間が_始まる_とエンドポイントからそれらのPodを削除するので、トラフィックを継続して処理できません。</li><li>猶予期間が終了すると、kubeletは強制削除を開始する。コンテナランタイムは、Pod内でまだ実行中のプロセスに<code>SIGKILL</code>を送信する。kubeletは、コンテナランタイムが非表示の<code>pause</code>コンテナを使用している場合、そのコンテナをクリーンアップします。</li><li>kubeletは猶予期間を0(即時削除)に設定することでAPI server上のPodの削除を終了する。</li><li>API serverはPodのAPIオブジェクトを削除し、クライアントからは見えなくなります。</li></ol><h3 id=pod-termination-forced>Podの強制削除</h3><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> 強制削除は、Podによっては潜在的に危険な場合があるため、慎重に実行する必要があります。</div><p>デフォルトでは、すべての削除は30秒以内に正常に行われます。<code>kubectl delete</code> コマンドは、ユーザーがデフォルト値を上書きして独自の値を指定できるようにする <code>--grace-period=&lt;seconds></code> オプションをサポートします。</p><p><code>--grace-period</code>を<code>0</code>に設定した場合、PodはAPI serverから即座に強制的に削除されます。PodがNode上でまだ実行されている場合、その強制削除によりkubeletがトリガーされ、すぐにクリーンアップが開始されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 強制削除を実行するために <code>--grace-period=0</code> と共に <code>--force</code> というフラグを追加で指定する必要があります。</div><p>強制削除が実行されると、API serverは、Podが実行されていたNode上でPodが停止されたというkubeletからの確認を待ちません。API内のPodは直ちに削除されるため、新しいPodを同じ名前で作成できるようになります。Node上では、すぐに終了するように設定されるPodは、強制終了される前にわずかな猶予期間が与えられます。</p><p>StatefulSetのPodについては、<a href=/ja/docs/tasks/run-application/force-delete-stateful-set-pod/>StatefulSetからPodを削除するためのタスクのドキュメント</a>を参照してください。</p><h3 id=pod-garbage-collection>終了したPodのガベージコレクション</h3><p>失敗したPodは人間または<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>が明示的に削除するまで存在します。</p><p>コントロールプレーンは終了状態のPod(SucceededまたはFailedの<code>phase</code>を持つ)の数が設定された閾値(kube-controller-manager内の<code>terminated-pod-gc-threshold</code>によって定義される)を超えたとき、それらのPodを削除します。これはPodが作成されて時間とともに終了するため、リソースリークを避けます。</p><h2 id=次の項目>次の項目</h2><ul><li><p><a href=/ja/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>attaching handlers to Container lifecycle events</a>のハンズオンをやってみる</p></li><li><p><a href=/ja/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>Configure Liveness, Readiness and Startup Probes</a>のハンズオンをやってみる</p></li><li><p><a href=/ja/docs/concepts/containers/container-lifecycle-hooks/>Container lifecycle hooks</a>についてもっと学ぶ</p></li><li><p>APIのPod/コンテナステータスの詳細情報は<a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a>および<a href=/docs/reference/generated/kubernetes-api/v1.25/#containerstatus-v1-core>ContainerStatus</a>を参照してください</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ccbd4eeded6ab138d98b59175bd557e>3 - Initコンテナ</h1><p>このページでは、Initコンテナについて概観します。Initコンテナとは、<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>内でアプリケーションコンテナの前に実行される特別なコンテナです。
Initコンテナにはアプリケーションコンテナのイメージに存在しないセットアップスクリプトやユーティリティーを含めることができます。</p><p>Initコンテナは、Podの仕様のうち<code>containers</code>という配列(これがアプリケーションコンテナを示します)と並べて指定します。</p><h2 id=understanding-init-containers>Initコンテナを理解する</h2><p>単一の<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>は、Pod内にアプリケーションを実行している複数のコンテナを持つことができますが、同様に、アプリケーションコンテナが起動する前に実行されるInitコンテナも1つ以上持つことができます。</p><p>Initコンテナは下記の項目をのぞいて、通常のコンテナと全く同じものとなります。</p><ul><li>Initコンテナは常に完了するまで稼働します。</li><li>各Initコンテナは、次のInitコンテナが稼働する前に正常に完了しなくてはなりません。</li></ul><p>もしあるPodの単一のInitコンテナが失敗した場合、Kubeletは成功するまで何度もそのInitコンテナを再起動します。しかし、もしそのPodの<code>restartPolicy</code>がNeverで、そのPodの起動時にInitコンテナが失敗した場合、KubernetesはそのPod全体を失敗として扱います。</p><p>PodにInitコンテナを指定するためには、<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec>Podの仕様</a>に<code>initContainers</code>フィールドを<code>container</code>アイテムの配列として追加してください(アプリケーションの<code>containers</code>フィールドとそのコンテンツに似ています)。
詳細については、APIリファレンスの<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>Container</a>を参照してください。</p><p>Initコンテナのステータスは、<code>.status.initContainerStatuses</code>フィールドにコンテナのステータスの配列として返されます(<code>.status.containerStatuses</code>と同様)。</p><h3 id=differences-from-regular-containers>通常のコンテナとの違い</h3><p>Initコンテナは、リソースリミット、ボリューム、セキュリティ設定などのアプリケーションコンテナの全てのフィールドと機能をサポートしています。しかし、Initコンテナに対するリソースリクエストやリソースリミットの扱いは異なります。<a href=#resources>リソース</a>にて説明します。</p><p>また、InitコンテナはそのPodの準備ができる前に完了しなくてはならないため、<code>lifecycle</code>、<code>livenessProbe</code>、<code>readinessProbe</code>および<code>startupProbe</code>をサポートしていません。</p><p>複数のInitコンテナを単一のPodに対して指定した場合、KubeletはそれらのInitコンテナを1つずつ順番に実行します。各Initコンテナは、次のInitコンテナが稼働する前に正常終了しなくてはなりません。全てのInitコンテナの実行が完了すると、KubeletはPodのアプリケーションコンテナを初期化し、通常通り実行します。</p><h2 id=using-init-containers>Initコンテナを使用する</h2><p>Initコンテナはアプリケーションコンテナのイメージとは分離されているため、コンテナの起動に関連したコードにおいていくつかの利点があります。</p><ul><li>Initコンテナはアプリケーションのイメージに存在しないセットアップ用のユーティリティーやカスタムコードを含むことができます。例えば、セットアップ中に<code>sed</code>、<code>awk</code>、<code>python</code>や、<code>dig</code>のようなツールを使うためだけに、別のイメージを元にしてアプリケーションイメージを作る必要がなくなります。</li><li>アプリケーションイメージをビルドする役割とデプロイする役割は、共同で単一のアプリケーションイメージをビルドする必要がないため、それぞれ独立して実施することができます。</li><li>Initコンテナは同一Pod内のアプリケーションコンテナと別のファイルシステムビューで稼働することができます。その結果、アプリケーションコンテナがアクセスできない<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>に対するアクセス権限を得ることができます。</li><li>Initコンテナはアプリケーションコンテナが開始する前に完了するまで実行されるため、Initコンテナを使用することで、特定の前提条件が満たされるまでアプリケーションコンテナの起動をブロックしたり遅らせることができます。前提条件が満たされると、Pod内の全てのアプリケーションコンテナを並行して起動することができます。</li><li>Initコンテナはアプリケーションコンテナイメージの安全性を低下させるようなユーティリティーやカスタムコードを安全に実行することができます。不必要なツールを分離しておくことで、アプリケーションコンテナイメージのアタックサーフィスを制限することができます。</li></ul><h3 id=examples>例</h3><p>Initコンテナを活用する方法について、いくつかのアイデアを次に示します。</p><ul><li><p>シェルコマンドを使って単一の<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>が作成されるのを待機する。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>{</span>1..100<span style=color:#666>}</span>; <span style=color:#a2f;font-weight:700>do</span> sleep 1; <span style=color:#a2f;font-weight:700>if</span> dig myservice; <span style=color:#a2f;font-weight:700>then</span> <span style=color:#a2f>exit</span> 0; <span style=color:#a2f;font-weight:700>fi</span>; <span style=color:#a2f;font-weight:700>done</span>; <span style=color:#a2f>exit</span> <span style=color:#666>1</span>
</span></span></code></pre></div></li><li><p>以下のようなコマンドを使って下位のAPIからPodの情報をリモートサーバに登録する。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X POST http://<span style=color:#b8860b>$MANAGEMENT_SERVICE_HOST</span>:<span style=color:#b8860b>$MANAGEMENT_SERVICE_PORT</span>/register -d <span style=color:#b44>&#39;instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)&#39;</span>
</span></span></code></pre></div></li><li><p>以下のようなコマンドを使ってアプリケーションコンテナの起動を待機する。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sleep <span style=color:#666>60</span>
</span></span></code></pre></div></li><li><p>gitリポジトリを<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a>にクローンする。</p></li><li><p>いくつかの値を設定ファイルに配置し、メインのアプリケーションコンテナのための設定ファイルを動的に生成するためのテンプレートツールを実行する。例えば、そのPodの<code>POD_IP</code>の値を設定ファイルに配置し、Jinjaを使ってメインのアプリケーションコンテナの設定ファイルを生成する。</p></li></ul><h4 id=init-containers-in-use>Initコンテナの具体的な使用方法</h4><p>下記の例は2つのInitコンテナを含むシンプルなPodを定義しています。
1つ目のInitコンテナは<code>myservies</code>の起動を、2つ目のInitコンテナは<code>mydb</code>の起動をそれぞれ待ちます。両方のInitコンテナの実行が完了すると、Podは<code>spec</code>セクションにあるアプリケーションコンテナを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo The app is running! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>次のコマンドを実行して、このPodを開始できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f myapp.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>pod/myapp-pod created
</code></pre><p>そして次のコマンドでステータスを確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m
</code></pre><p>より詳細な情報は次のコマンドで確認します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe -f myapp.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>Name:          myapp-pod
Namespace:     default
[...]
Labels:        app.kubernetes.io/name=MyApp
Status:        Pending
[...]
Init Containers:
  init-myservice:
[...]
    State:         Running
[...]
  init-mydb:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Containers:
  myapp-container:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  ---------    --------    -----    ----                      -------------                           --------      ------        -------
  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container with docker id 5ced34a04634; Security:[seccomp=unconfined]
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container with docker id 5ced34a04634
</code></pre><p>このPod内のInitコンテナのログを確認するためには、次のコマンドを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs myapp-pod -c init-myservice <span style=color:#080;font-style:italic># 1つ目のInitコンテナを調査する</span>
</span></span><span style=display:flex><span>kubectl logs myapp-pod -c init-mydb      <span style=color:#080;font-style:italic># 2つ目のInitコンテナを調査する</span>
</span></span></code></pre></div><p>この時点で、これらのInitコンテナは<code>mydb</code>と<code>myservice</code>という名前のServiceの検出を待機しています。</p><p>これらのServiceを検出させるための構成は以下の通りです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>mydb</code>および<code>myservice</code>というServiceを作成するために、以下のコマンドを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f services.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>service/myservice created
service/mydb created
</code></pre><p>Initコンテナが完了し、<code>myapp-pod</code>というPodがRunning状態に移行したことが確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><p>実行結果は下記のようになります。</p><pre tabindex=0><code>NAME        READY     STATUS    RESTARTS   AGE
myapp-pod   1/1       Running   0          9m
</code></pre><p>このシンプルな例を独自のInitコンテナを作成する際の参考にしてください。<a href=#what-s-next>次の項目</a>にさらに詳細な使用例に関するリンクがあります。</p><h2 id=detailed-behavior>Initコンテナのふるまいに関する詳細</h2><p>Podの起動時に、kubeletはネットワークおよびストレージの準備が整うまで、Initコンテナを実行可能な状態にしません。また、kubeletはPodのspecに定義された順番に従ってPodのInitコンテナを起動します。</p><p>各Initコンテナは次のInitコンテナが起動する前に正常に終了しなくてはなりません。もしあるInitコンテナがランタイムにより起動失敗した場合、もしくはエラーで終了した場合、そのPodの<code>restartPolicy</code>の値に従ってリトライされます。しかし、もしPodの<code>restartPolicy</code>が<code>Always</code>に設定されていた場合、Initコンテナの<code>restartPolicy</code>は<code>OnFailure</code>が適用されます。</p><p>Podは全てのInitコンテナが完了するまで<code>Ready</code>状態となりません。Initコンテナ上のポートはServiceによって集約されません。初期化中のPodのステータスは<code>Pending</code>となりますが、<code>Initialized</code>という値はtrueとなります。</p><p>もしそのPodを<a href=#pod-restart-reasons>再起動</a>するとき、または再起動されたとき、全てのInitコンテナは必ず再度実行されます。</p><p>Initコンテナの仕様の変更は、コンテナイメージのフィールドのみに制限されています。
Initコンテナのイメージフィールド値を変更すると、そのPodは再起動されます。</p><p>Initコンテナは何度も再起動、リトライおよび再実行可能なため、べき等(Idempotent)である必要があります。特に、<code>EmptyDirs</code>にファイルを書き込むコードは、書き込み先のファイルがすでに存在している可能性を考慮に入れる必要があります。</p><p>Initコンテナはアプリケーションコンテナの全てのフィールドを持っています。しかしKubernetesは、Initコンテナが完了と異なる状態を定義できないため<code>readinessProbe</code>が使用されることを禁止しています。これはバリデーションの際に適用されます。</p><p>Initコンテナがずっと失敗し続けたままの状態を防ぐために、Podに<code>activeDeadlineSeconds</code>を設定してください。<code>activeDeadlineSeconds</code>の設定はInitコンテナが実行中の時間にも適用されます。しかし<code>activeDeadlineSeconds</code>はInitコンテナが終了した後でも効果があるため、チームがアプリケーションをJobとしてデプロイする場合にのみ使用することが推奨されています。
すでに正しく動作しているPodは<code>activeDeadlineSeconds</code>を設定すると強制終了されます。</p><p>Pod内の各アプリケーションコンテナとInitコンテナの名前はユニークである必要があります。他のコンテナと同じ名前を共有していた場合、バリデーションエラーが返されます。</p><h3 id=resources>リソース</h3><p>Initコンテナの順序と実行を考えるとき、リソースの使用に関して下記のルールが適用されます。</p><ul><li>全てのInitコンテナの中で定義された最も高いリソースリクエストとリソースリミットが、<em>有効なinitリクエスト／リミット</em> になります。いずれかのリソースでリミットが設定されていない場合、これが最上級のリミットとみなされます。</li><li>Podのリソースの<em>有効なリクエスト／リミット</em> は、下記の2つの中のどちらか高い方となります。<ul><li>リソースに対する全てのアプリケーションコンテナのリクエスト／リミットの合計</li><li>リソースに対する有効なinitリクエスト／リミット</li></ul></li><li>スケジューリングは有効なリクエスト／リミットに基づいて実行されます。つまり、InitコンテナはPodの生存中には使用されない初期化用のリソースを確保することができます。</li><li>Podの<em>有効なQoS(quality of service)ティアー</em> は、Initコンテナとアプリケーションコンテナで同様です。</li></ul><p>クォータとリミットは有効なPodリクエストとリミットに基づいて適用されます。</p><p>Podレベルのコントロールグループ(cgroups)は、スケジューラーと同様に、有効なPodリクエストとリミットに基づいています。</p><h3 id=pod-restart-reasons>Podの再起動の理由</h3><p>以下の理由によりPodは再起動し、Initコンテナの再実行も引き起こす可能性があります。</p><ul><li>そのPodのインフラストラクチャーコンテナが再起動された場合。これはあまり起きるものでなく、Nodeに対するルート権限を持ったユーザーにより行われることがあります。</li><li><code>restartPolicy</code>が<code>Always</code>と設定されているPod内の全てのコンテナが停止され、強制的に再起動が行われたことで、ガベージコレクションによりInitコンテナの完了記録が失われた場合。</li></ul><p>Kubernetes v1.20以降では、initコンテナのイメージが変更されたり、ガベージコレクションによってinitコンテナの完了記録が失われたりした場合でも、Podは再起動されません。以前のバージョンを使用している場合は、対応バージョンのドキュメントを参照してください。</p><h2 id=what-s-next>次の項目</h2><ul><li><a href=/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container>Initコンテナを含むPodの作成</a>方法について学ぶ。</li><li><a href=/ja/docs/tasks/debug-application-cluster/debug-init-containers/>Initコンテナのデバッグ</a>を行う方法について学ぶ。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4e9b9cbc9776b12e7335c53da377c9c8>4 - Pod Preset</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.6 [alpha]</code></div><p>このページではPodPresetについて概観します。PodPresetは、Podの作成時にそのPodに対して、Secret、Volume、VolumeMountや環境変数など、特定の情報を注入するためのオブジェクトです。</p><h2 id=podpresetを理解する>PodPresetを理解する</h2><p><code>PodPreset</code>はPodの作成時に追加のランタイム要求を注入するためのAPIリソースです。ユーザーはPodPresetを適用する対象のPodを指定するために、<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルセレクター</a>を使用します。</p><p>PodPresetの使用により、Podテンプレートの作者はPodにおいて、全ての情報を明示的に指定する必要がなくなります。この方法により、特定のServiceを使っているPodテンプレートの作者は、そのServiceについて全ての詳細を知る必要がなくなります。</p><h2 id=enable-pod-preset>クラスターでPodPresetを有効にする</h2><p>ユーザーのクラスター内でPodPresetを使うためには、クラスター内の以下の項目をご確認ください。</p><ol><li><code>settings.k8s.io/v1alpha1/podpreset</code>というAPIを有効にします。例えば、これはAPI Serverの <code>--runtime-config</code>オプションに<code>settings.k8s.io/v1alpha1=true</code>を含むことで可能になります。Minikubeにおいては、クラスターの起動時に<code>--extra-config=apiserver.runtime-config=settings.k8s.io/v1alpha1=true</code>をつけることで可能です。</li><li><code>PodPreset</code>に対する管理コントローラーを有効にします。これを行うための1つの方法として、API Serverの<code>--enable-admission-plugins</code>オプションの値に<code>PodPreset</code>を含む方法があります。例えば、Minikubeにおいては、クラスターの起動時に</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--extra-config<span style=color:#666>=</span>apiserver.enable-admission-plugins<span style=color:#666>=</span>NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodPreset
</span></span></code></pre></div><p>を追加することで可能になります。</p><h2 id=podpresetはどのように動くか>PodPresetはどのように動くか</h2><p>Kubernetesは<code>PodPreset</code>に対する管理用コントローラーを提供し、これが有効になっている時、コントローラーはリクエストされたPod作成要求に対してPodPresetを適用します。Pod作成要求が発生した時、Kubernetesシステムは下記の処理を行います。</p><ol><li>使用可能な全ての<code>PodPreset</code>を取得する。</li><li>それらの<code>PodPreset</code>のラベルセレクターが、作成されたPod上のラベルと一致するかチェックする。</li><li><code>PodPreset</code>によって定義された様々なリソースを、作成されたPodにマージしようと試みる。</li><li>エラーが起きた時、そのPod上でマージエラーが起きたことを説明するイベントをスローし、<code>PodPreset</code>からリソースを1つも注入されていないPodを作成します。</li><li><code>PodPreset</code>によって修正されたことを示すために、マージ後の修正されたPodにアノテーションをつけます。そのアノテーションは<code>podpreset.admission.kubernetes.io/podpreset-&lt;PodPreset名>: "&lt;リソースのバージョン>"</code>という形式になります。</li></ol><p>各Podは0以上のPodPresetにマッチすることができます。そして各PodPresetは0以上のPodに適用されます。単一のPodPresetが1以上のPodに適用された時、KubernetesはそのPodのSpecを修正します。<code>env</code>、<code>envFrom</code>、<code>volumeMounts</code>への変更があると、KubernetesはそのPod内の全てのコンテナのSpecを修正します。<code>volumes</code>への変更があった場合、KubernetesはそのPodのSpecを修正します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>単一のPodPresetは必要に応じてPodのspec内の以下のフィールドを修正することができます。</p><ul><li><code>.spec.containers</code>フィールド</li><li><code>.spec.initContainers</code>フィールド</li></ul></div><h3 id=特定のpodに対するpodpresetを無効にする>特定のPodに対するPodPresetを無効にする</h3><p>PodPresetによるPodの変更を受け付けたくないようなインスタンスがある場合があります。このようなケースでは、ユーザーはそのPodの<code>.spec</code>内に次のような形式のアノテーションを追加できます。<br><code>podpreset.admission.kubernetes.io/exclude: "true"</code></p><h2 id=次の項目>次の項目</h2><p><a href=/docs/tasks/inject-data-application/podpreset/>PodPresetを使ったPodへのデータの注入</a></p><p>PodPresetの内部についてのさらなる情報は、<a href=https://git.k8s.io/community/contributors/design-proposals/service-catalog/pod-preset.md>PodPresetのデザインプロポーザル</a>を参照してください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-53a1005011e1bda2ce81819aad7c8b32>5 - エフェメラルコンテナ</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>このページでは、特別な種類のコンテナであるエフェメラルコンテナの概要を説明します。エフェメラルコンテナは、トラブルシューティングなどのユーザーが開始するアクションを実行するために、すでに存在する<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>内で一時的に実行するコンテナです。エフェメラルコンテナは、アプリケーションの構築ではなく、serviceの調査のために利用します。</p><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> エフェメラルコンテナは初期のアルファ状態であり、本番クラスタには適しません。<a href=/docs/reference/using-api/deprecation-policy/>Kubernetesの非推奨ポリシー</a>に従って、このアルファ機能は、将来大きく変更されたり、完全に削除される可能性があります。</div><h2 id=エフェメラルコンテナを理解する>エフェメラルコンテナを理解する</h2><p><a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>は、Kubernetesのアプリケーションの基本的なビルディングブロックです。Podは破棄可能かつ置き換え可能であることが想定されているため、一度Podが作成されると新しいコンテナを追加することはできません。その代わりに、通常は<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>を使用してPodを削除して置き換えます。</p><p>たとえば、再現困難なバグのトラブルシューティングなどのために、すでに存在するPodの状態を調査する必要が出てくることがあります。このような場合、既存のPod内でエフェメラルコンテナを実行することで、Podの状態を調査したり、任意のコマンドを実行したりできます。</p><h3 id=エフェメラルコンテナとは何か>エフェメラルコンテナとは何か？</h3><p>エフェメラルコンテナは、他のコンテナと異なり、リソースや実行が保証されず、自動的に再起動されることも決してないため、アプリケーションを構築する目的には適しません。エフェメラルコンテナは、通常のコンテナと同じ<code>ContainerSpec</code>で記述されますが、多くのフィールドに互換性がなかったり、使用できなくなっています。</p><ul><li>エフェメラルコンテナはポートを持つことができないため、<code>ports</code>、<code>livenessProbe</code>、<code>readinessProbe</code>などは使えなくなっています。</li><li>Podリソースの割り当てはイミュータブルであるため、<code>resources</code>の設定が禁止されています。</li><li>利用が許可されているフィールドの一覧については、<a href=/docs/reference/generated/kubernetes-api/v1.25/#ephemeralcontainer-v1-core>EphemeralContainerのリファレンスドキュメント</a>を参照してください。</li></ul><p>エフェメラルコンテナは、直接<code>pod.spec</code>に追加するのではなく、API内の特別な<code>ephemeralcontainers</code>ハンドラを使用して作成します。そのため、エフェメラルコンテナを<code>kubectl edit</code>を使用して追加することはできません。</p><p>エフェメラルコンテナをPodに追加した後は、通常のコンテナのようにエフェメラルコンテナを変更または削除することはできません。</p><h2 id=エフェメラルコンテナの用途>エフェメラルコンテナの用途</h2><p>エフェメラルコンテナは、コンテナがクラッシュしてしまったり、コンテナイメージにデバッグ用ユーティリティが同梱されていない場合など、<code>kubectl exec</code>では不十分なときにインタラクティブなトラブルシューティングを行うために役立ちます。</p><p>特に、<a href=https://github.com/GoogleContainerTools/distroless>distrolessイメージ</a>を利用すると、攻撃対象領域を減らし、バグや脆弱性を露出する可能性を減らせる最小のコンテナイメージをデプロイできるようになります。distrolessイメージにはシェルもデバッグ用のユーティリティも含まれないため、<code>kubectl exec</code>のみを使用してdistrolessイメージのトラブルシューティングを行うのは困難です。</p><p>エフェメラルコンテナを利用する場合には、他のコンテナ内のプロセスにアクセスできるように、<a href=/ja/docs/tasks/configure-pod-container/share-process-namespace/>プロセス名前空間の共有</a>を有効にすると便利です。</p><p>エフェメラルコンテナを利用してトラブルシューティングを行う例については、<a href=/docs/tasks/debug/debug-application/debug-running-pod/#ephemeral-container>デバッグ用のエフェメラルコンテナを使用してデバッグする</a>を参照してください。</p><h2 id=ephemeral-containers-api>Ephemeral containers API</h2><div class="alert alert-info note callout" role=alert><strong>備考:</strong> このセクションの例を実行するには、<code>EphemeralContainers</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にして、Kubernetesクライアントとサーバーのバージョンをv1.16以上にする必要があります。</div><p>このセクションの例では、API内でエフェメラルコンテナを表示する方法を示します。通常は、APIを直接呼び出すのではなく、<code>kubectl alpha debug</code>やその他の<code>kubectl</code><a href=/docs/tasks/extend-kubectl/kubectl-plugins/>プラグイン</a>を使用して、これらのステップを自動化します。</p><p>エフェメラルコンテナは、Podの<code>ephemeralcontainers</code>サブリソースを使用して作成されます。このサブリソースは、<code>kubectl --raw</code>を使用して確認できます。まずはじめに、以下に<code>EphemeralContainers</code>リストとして追加するためのエフェメラルコンテナを示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example-pod&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>: [{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;command&#34;</span>: [
</span></span><span style=display:flex><span>            <span style=color:#b44>&#34;sh&#34;</span>
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>: <span style=color:#b44>&#34;IfNotPresent&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;debugger&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;stdin&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;tty&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>: <span style=color:#b44>&#34;File&#34;</span>
</span></span><span style=display:flex><span>    }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>すでに実行中の<code>example-pod</code>のエフェメラルコンテナを更新するには、次のコマンドを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace --raw /api/v1/namespaces/default/pods/example-pod/ephemeralcontainers -f ec.json
</span></span></code></pre></div><p>このコマンドを実行すると、新しいエフェメラルコンテナのリストが返されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;example-pod&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;selfLink&#34;</span>:<span style=color:#b44>&#34;/api/v1/namespaces/default/pods/example-pod/ephemeralcontainers&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;uid&#34;</span>:<span style=color:#b44>&#34;a14a6d9b-62f2-4119-9d8e-e2ed6bc3a47c&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>:<span style=color:#b44>&#34;15886&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>:<span style=color:#b44>&#34;2019-08-29T06:41:42Z&#34;</span>
</span></span><span style=display:flex><span>   },
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>:[
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;debugger&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;busybox&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;command&#34;</span>:[
</span></span><span style=display:flex><span>            <span style=color:#b44>&#34;sh&#34;</span>
</span></span><span style=display:flex><span>         ],
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;resources&#34;</span>:{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         },
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>:<span style=color:#b44>&#34;File&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>:<span style=color:#b44>&#34;IfNotPresent&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;stdin&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;tty&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>新しく作成されたエフェメラルコンテナの状態を確認するには、<code>kubectl describe</code>を使用します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod example-pod
</span></span></code></pre></div><pre tabindex=0><code>...
Ephemeral Containers:
  debugger:
    Container ID:  docker://cf81908f149e7e9213d3c3644eda55c72efaff67652a2685c1146f0ce151e80f
    Image:         busybox
    Image ID:      docker-pullable://busybox@sha256:9f1003c480699be56815db0f8146ad2e22efea85129b5b5983d0e0fb52d9ab70
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Command:
      sh
    State:          Running
      Started:      Thu, 29 Aug 2019 06:42:21 +0000
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:         &lt;none&gt;
...
</code></pre><p>新しいエフェメラルコンテナとやりとりをするには、他のコンテナと同じように、<code>kubectl attach</code>、<code>kubectl exec</code>、<code>kubectl logs</code>などのコマンドが利用できます。例えば、次のようなコマンドが実行できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it example-pod -c debugger
</span></span></code></pre></div></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script>
<script async src=/js/sweetalert-2.1.2.min.js></script>
<script type=text/javascript>function copyCode(e){if(document.getElementById(e)){var t,n,s="_hiddenCopyText_";t=document.getElementById(s),t||(t=document.createElement("textarea"),t.style.position="absolute",t.style.left="-9999px",t.style.top="0",t.id=s,document.body.appendChild(t)),t.value=document.getElementById(e).innerText,t.select();try{n=document.execCommand("copy")}catch{swal("Oh, no…","Sorry, your browser doesn't support copying this example to your clipboard."),n=!1}return n?(swal("Copied to clipboard: ",e),n):(swal("Oops!",e+" not found when trying to copy code"),!1)}}</script></body></html>