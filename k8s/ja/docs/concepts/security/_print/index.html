<!doctype html><html lang=ja class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/security/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/security/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/security/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/security/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/security/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/security/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/security/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/security/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>セキュリティ | Kubernetes</title><meta property="og:title" content="セキュリティ"><meta property="og:description" content="クラウドネイティブなワークロードをセキュアに維持するための概念
"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/security/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="セキュリティ"><meta itemprop=description content="クラウドネイティブなワークロードをセキュアに維持するための概念
"><meta name=twitter:card content="summary"><meta name=twitter:title content="セキュリティ"><meta name=twitter:description content="クラウドネイティブなワークロードをセキュアに維持するための概念
"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="クラウドネイティブなワークロードをセキュアに維持するための概念
"><meta property="og:description" content="クラウドネイティブなワークロードをセキュアに維持するための概念
"><meta name=twitter:description content="クラウドネイティブなワークロードをセキュアに維持するための概念
"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/security/"><meta property="og:title" content="セキュリティ"><meta name=twitter:title content="セキュリティ"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ja/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ja/docs/>ドキュメント</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/blog/>Blogs</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/training/>トレーニング</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/partners/>パートナー</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/community/>コミュニティ</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/case-studies/>ケーススタディ</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>バージョン</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ja/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/security/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/security/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/security/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/concepts/security/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ja/docs/concepts/security/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語 (Japanese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/security/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/security/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/security/>한국어 (Korean)</a>
<a class=dropdown-item href=/fr/docs/concepts/security/>Français (French)</a>
<a class=dropdown-item href=/es/docs/concepts/security/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/security/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/security/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.</p><p><a href=/ja/docs/concepts/security/>このページの通常のビューに戻る</a>.</p></div><h1 class=title>セキュリティ</h1><div class=lead>クラウドネイティブなワークロードをセキュアに維持するための概念</div><ul><li>1: <a href=#pg-1fb24c1dd155f43849da490a74c4b8c5>Podセキュリティの標準</a></li><li>2: <a href=#pg-04eeb110d75afc8acb2cf7a3db743985>クラウドネイティブセキュリティの概要</a></li><li>3: <a href=#pg-bc9934fccfeaf880eec6ea79025c0381>Podのセキュリティアドミッション</a></li><li>4: <a href=#pg-4d77d1ae4c06aa14f54b385191627881>Kubernetes APIへのアクセスコントロール</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-1fb24c1dd155f43849da490a74c4b8c5>1 - Podセキュリティの標準</h1><p>Podに対するセキュリティの設定は通常<a href=/docs/tasks/configure-pod-container/security-context/>Security Context</a>を使用して適用されます。Security ContextはPod単位での特権やアクセスコントロールの定義を実現します。</p><p>クラスターにおけるSecurity Contextの強制やポリシーベースの定義は<a href=/docs/concepts/policy/pod-security-policy/>Pod Security Policy</a>によって実現されてきました。
<em>Pod Security Policy</em> はクラスターレベルのリソースで、Pod定義のセキュリティに関する設定を制御します。</p><p>しかし、PodSecurityPolicyを拡張したり代替する、ポリシーを強制するための多くの方法が生まれてきました。
このページの意図は、推奨されるPodのセキュリティプロファイルを特定の実装から切り離して詳しく説明することです。</p><h2 id=ポリシーの種別>ポリシーの種別</h2><p>まず、幅広いセキュリティの範囲をカバーできる、基礎となるポリシーの定義が必要です。
それらは強く制限をかけるものから自由度の高いものまでをカバーすべきです。</p><ul><li><strong><em>特権</em></strong> - 制限のかかっていないポリシーで、可能な限り幅広い権限を提供します。このポリシーは既知の特権昇格を認めます。</li><li><strong><em>ベースライン、デフォルト</em></strong> - 制限は最小限にされたポリシーですが、既知の特権昇格を防止します。デフォルト（最小の指定）のPod設定を許容します。</li><li><strong><em>制限</em></strong> - 厳しく制限されたポリシーで、Podを強化するための現在のベストプラクティスに沿っています。</li></ul><h2 id=ポリシー>ポリシー</h2><h3 id=特権>特権</h3><p>特権ポリシーは意図的に開放されていて、完全に制限がかけられていません。この種のポリシーは通常、特権ユーザーまたは信頼されたユーザーが管理する、システムまたはインフラレベルのワークロードに対して適用されることを意図しています。</p><p>特権ポリシーは制限がないことと定義されます。gatekeeperのようにデフォルトで許可される仕組みでは、特権プロファイルはポリシーを設定せず、何も制限を適用しないことにあたります。
一方で、Pod Security Policyのようにデフォルトで拒否される仕組みでは、特権ポリシーでは全ての制限を無効化してコントロールできるようにする必要があります。</p><h3 id=ベースライン-デフォルト>ベースライン、デフォルト</h3><p>ベースライン、デフォルトのプロファイルは一般的なコンテナ化されたランタイムに適用しやすく、かつ既知の特権昇格を防ぐことを意図しています。
このポリシーはクリティカルではないアプリケーションの運用者または開発者を対象にしています。
次の項目は強制、または無効化すべきです。</p><table><caption style=display:none>ベースラインポリシーの定義</caption><tbody><tr><td><strong>項目</strong></td><td><strong>ポリシー</strong></td></tr><tr><td>ホストのプロセス</td><td><p>Windows Podは、Windowsノードへの特権的なアクセスを可能にする<a href=/docs/tasks/configure-pod-container/create-hostprocess-pod>HostProcess</a>コンテナ</a>を実行する機能を提供します。ベースラインポリシーでは、ホストへの特権的なアクセスは禁止されています。HostProcess Podは、Kubernetes v1.22時点ではアルファ版の機能です。
ホストのネームスペースの共有は無効化すべきです。</p><p><strong>制限されるフィールド</strong></p><ul><li><code>spec.securityContext.windowsOptions.hostProcess</code></li><li><code>spec.containers[*].securityContext.windowsOptions.hostProcess</code></li><li><code>spec.initContainers[*].securityContext.windowsOptions.hostProcess</code></li><li><code>spec.ephemeralContainers[*].securityContext.windowsOptions.hostProcess</code></li></ul><p><strong>認められる値</strong></p><ul><li>Undefined/nil</li><li><code>false</code></li></ul></td></tr><tr><td>ホストのネームスペース</td><td>ホストのネームスペースの共有は無効化すべきです。<br><br><b>制限されるフィールド:</b><br>spec.hostNetwork<br>spec.hostPID<br>spec.hostIPC<br><br><b>認められる値:</b> false, Undefined/nil<br></td></tr><tr><td>特権コンテナ</td><td>特権を持つPodはほとんどのセキュリティ機構を無効化できるので、禁止すべきです。<br><br><b>制限されるフィールド:</b><br>spec.containers[*].securityContext.privileged<br>spec.initContainers[*].securityContext.privileged<br>spec.ephemeralContainers[*].securityContext.privileged<br><br><b>認められる値:</b> false, undefined/nil<br></td></tr><tr><td>ケーパビリティー</td><td><a href=https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities>デフォルト</a>よりも多くのケーパビリティーを与えることは禁止すべきです。<br><br><b>制限されるフィールド:</b><br>spec.containers[*].securityContext.capabilities.add<br>spec.initContainers[*].securityContext.capabilities.add<br>spec.ephemeralContainers[*].securityContext.capabilities.add<br><br><b>認められる値:</b>
Undefined/nil<br>AUDIT_WRITE<br>CHOWN<br>DAC_OVERRIDE<br>FOWNER<br>FSETID<br>KILL<br>MKNOD<br>NET_BIND_SERVICE<br>SETFCAP<br>SETGID<br>SETPCAP<br>SETUID<br>SYS_CHROOT<br></td></tr><tr><td>HostPathボリューム</td><td>HostPathボリュームは禁止すべきです。<br><br><b>制限されるフィールド:</b><br>spec.volumes[*].hostPath<br><br><b>認められる値:</b> undefined/nil<br></td></tr><tr><td>ホストのポート</td><td>HostPortは禁止するか、最小限の既知のリストに限定すべきです。<br><br><b>制限されるフィールド:</b><br>spec.containers[*].ports[*].hostPort<br>spec.initContainers[*].ports[*].hostPort<br>spec.ephemeralContainers[*].ports[*].hostPort<br><br><b>認められる値:</b> 0, undefined (または既知のリストに限定)<br></td></tr><tr><td>AppArmor<em>(任意)</em></td><td>サポートされるホストでは、AppArmorの'runtime/default'プロファイルがデフォルトで適用されます。デフォルトのポリシーはポリシーの上書きや無効化を防ぎ、許可されたポリシーのセットを上書きできないよう制限すべきです。<br><br><b>制限されるフィールド:</b><br>metadata.annotations['container.apparmor.security.beta.kubernetes.io/*']<br><br><b>認められる値:</b> 'runtime/default', undefined, localhost/*<br></td></tr><tr><td>SELinux <em>(任意)</em></td><td>SELinuxのオプションをカスタムで設定することは禁止すべきです。<br><br><b>制限されるフィールド:</b><br>spec.securityContext.seLinuxOptions<br>spec.containers[*].securityContext.seLinuxOptions<br>spec.initContainers[*].securityContext.seLinuxOptions<br>spec.ephemeralContainers[*].securityContext.seLinuxOptions.type<br><br><b>認められる値:</b>undefined/nil<br>Undefined/""<br>container_t<br>container_init_t<br>container_kvm_t<br><hr><br><b>制限されるフィールド:</b><br>spec.securityContext.seLinuxOptions.user<br>spec.containers[*].securityContext.seLinuxOptions.user<br>spec.initContainers[*].securityContext.seLinuxOptions.user<br>spec.ephemeralContainers[*].securityContext.seLinuxOptions.user<br>spec.securityContext.seLinuxOptions.role<br>spec.containers[*].securityContext.seLinuxOptions.role<br>spec.initContainers[*].securityContext.seLinuxOptions.role<br>spec.ephemeralContainers[*].securityContext.seLinuxOptions.role<br><br><b>認められる値:</b>undefined/nil<br>Undefined/""</td></tr><tr><td>/procマウントタイプ</td><td>攻撃対象を縮小するため/procのマスクを設定し、必須とすべきです。<br><br><b>制限されるフィールド:</b><br>spec.containers[*].securityContext.procMount<br>spec.initContainers[*].securityContext.procMount<br>spec.ephemeralContainers[*].securityContext.procMount<br><br><b>認められる値:</b>undefined/nil, 'Default'<br></td></tr><tr><td>Seccomp</td><td><p>Seccompプロファイルを明示的に<code>Unconfined</code>に設定することはできません。</p><p><strong>Restricted Fields</strong></p><ul><li><code>spec.securityContext.seccompProfile.type</code></li><li><code>spec.containers[*].securityContext.seccompProfile.type</code></li><li><code>spec.initContainers[*].securityContext.seccompProfile.type</code></li><li><code>spec.ephemeralContainers[*].securityContext.seccompProfile.type</code></li></ul><p><strong>Allowed Values</strong></p><ul><li>Undefined/nil</li><li><code>RuntimeDefault</code></li><li><code>Localhost</code></li></ul></td></tr><tr><td>Sysctl</td><td>Sysctlはセキュリティ機構を無効化したり、ホストの全てのコンテナに影響を与えたりすることが可能なので、「安全」なサブネットを除いては禁止すべきです。
コンテナまたはPodの中にsysctlがありネームスペースが分離されていて、同じノードの別のPodやプロセスから分離されている場合はsysctlは安全だと考えられます。<br><br><b>制限されるフィールド:</b><br>spec.securityContext.sysctls<br><br><b>認められる値:</b><br>kernel.shm_rmid_forced<br>net.ipv4.ip_local_port_range<br>net.ipv4.tcp_syncookies<br>net.ipv4.ping_group_range<br>undefined/空文字列<br></td></tr></tbody></table><h3 id=制限>制限</h3><p>制限ポリシーはいくらかの互換性を犠牲にして、Podを強化するためのベストプラクティスを強制することを意図しています。
セキュリティ上クリティカルなアプリケーションの運用者や開発者、また信頼度の低いユーザーも対象にしています。
下記の項目を強制、無効化すべきです。</p><table><caption style=display:none>制限ポリシーの定義</caption><tbody><tr><td><strong>項目</strong></td><td><strong>ポリシー</strong></td></tr><tr><td colspan=2><em>デフォルトプロファイルにある項目全て</em></td></tr><tr><td>Volumeタイプ</td><td>HostPathボリュームの制限に加え、制限プロファイルではコアでない種類のボリュームの利用をPersistentVolumeにより定義されたものに限定します。<br><br><b>制限されるフィールド:</b><br>spec.volumes[*].hostPath<br>spec.volumes[*].gcePersistentDisk<br>spec.volumes[*].awsElasticBlockStore<br>spec.volumes[*].gitRepo<br>spec.volumes[*].nfs<br>spec.volumes[*].iscsi<br>spec.volumes[*].glusterfs<br>spec.volumes[*].rbd<br>spec.volumes[*].flexVolume<br>spec.volumes[*].cinder<br>spec.volumes[*].cephfs<br>spec.volumes[*].flocker<br>spec.volumes[*].fc<br>spec.volumes[*].azureFile<br>spec.volumes[*].vsphereVolume<br>spec.volumes[*].quobyte<br>spec.volumes[*].azureDisk<br>spec.volumes[*].portworxVolume<br>spec.volumes[*].scaleIO<br>spec.volumes[*].storageos<br>spec.volumes[*].photonPersistentDisk<br><br><b>認められる値:</b> undefined/nil<br></td></tr><tr><td>特権昇格</td><td>特権昇格(ファイルモードのset-user-IDまたはset-group-IDのような方法による)は禁止すべきです。<br><br><b>制限されるフィールド:</b><br>spec.containers[*].securityContext.allowPrivilegeEscalation<br>spec.initContainers[*].securityContext.allowPrivilegeEscalation<br>spec.ephemeralContainers[*].securityContext.allowPrivilegeEscalation<br><br><b>認められる値:</b> false<br></td></tr><tr><td>root以外での実行</td><td>コンテナはroot以外のユーザーで実行する必要があります。<br><br><b>制限されるフィールド:</b><br>spec.securityContext.runAsNonRoot<br>spec.containers[*].securityContext.runAsNonRoot<br>spec.initContainers[*].securityContext.runAsNonRoot<br>spec.ephemeralContainers[*].securityContext.runAsNonRoot<br><br><b>認められる値:</b> true<br></td></tr><tr><td>root以外のグループ <em>(任意)</em></td><td>コンテナをrootのプライマリまたは補助GIDで実行することを禁止すべきです。<br><br><b>制限されるフィールド:</b><br>spec.securityContext.runAsGroup<br>spec.securityContext.supplementalGroups[*]<br>spec.securityContext.fsGroup<br>spec.containers[*].securityContext.runAsGroup<br>spec.initContainers[*].securityContext.runAsGroup<br><br><b>認められる値:</b><br>0以外<br>undefined / nil (`*.runAsGroup`を除く)<br></td></tr><tr><td>Seccomp</td><td>SeccompのRuntimeDefaultを必須とする、または特定の追加プロファイルを許可することが必要です。<br><br><b>制限されるフィールド:</b><br>spec.securityContext.seccompProfile.type<br>spec.containers[*].securityContext.seccompProfile<br>spec.initContainers[*].securityContext.seccompProfile<br><br><b>認められる値:</b><br>'runtime/default'<br>undefined / nil<br></td></tr><tr><td style=white-space:nowrap>Capabilities (v1.22+)</td><td><p>コンテナはすべてのケイパビリティを削除する必要があり、<code>NET_BIND_SERVICE</code>ケイパビリティを追加することだけが許可されています。</p><p><strong>Restricted Fields</strong></p><ul><li><code>spec.containers[*].securityContext.capabilities.drop</code></li><li><code>spec.initContainers[*].securityContext.capabilities.drop</code></li><li><code>spec.ephemeralContainers[*].securityContext.capabilities.drop</code></li></ul><p><strong>Allowed Values</strong></p><ul><li>Any list of capabilities that includes <code>ALL</code></li></ul><hr><p><strong>Restricted Fields</strong></p><ul><li><code>spec.containers[*].securityContext.capabilities.add</code></li><li><code>spec.initContainers[*].securityContext.capabilities.add</code></li><li><code>spec.ephemeralContainers[*].securityContext.capabilities.add</code></li></ul><p><strong>Allowed Values</strong></p><ul><li>Undefined/nil</li><li><code>NET_BIND_SERVICE</code></li></ul></td></tr></tbody></table><h2 id=ポリシーの実例>ポリシーの実例</h2><p>ポリシーの定義とポリシーの実装を切り離すことによって、ポリシーを強制する機構とは独立して、汎用的な理解や複数のクラスターにわたる共通言語とすることができます。</p><p>機構が成熟してきたら、ポリシーごとに下記に定義されます。それぞれのポリシーを強制する方法についてはここでは定義しません。</p><p><a href=/docs/concepts/policy/pod-security-policy/><strong>PodSecurityPolicy</strong></a></p><ul><li><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/privileged-psp.yaml>特権</a></li><li><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/baseline-psp.yaml>ベースライン</a></li><li><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml>制限</a></li></ul><h2 id=faq>FAQ</h2><h3 id=特権とデフォルトの間のプロファイルがないのはどうしてですか>特権とデフォルトの間のプロファイルがないのはどうしてですか?</h3><p>ここで定義されている3つのプロファイルは最も安全(制限)から最も安全ではない(特権)まで、直線的に段階が設定されており、幅広いワークロードをカバーしています。
ベースラインを超える特権が必要な場合、その多くはアプリケーションに特化しているため、その限られた要求に対して標準的なプロファイルを提供することはできません。
これは、このような場合に必ず特権プロファイルを使用すべきだという意味ではなく、場合に応じてポリシーを定義する必要があります。</p><p>将来、他のプロファイルの必要性が明らかになった場合、SIG Authはこの方針について再考する可能性があります。</p><h3 id=セキュリティポリシーとセキュリティコンテキストの違いは何ですか>セキュリティポリシーとセキュリティコンテキストの違いは何ですか?</h3><p><a href=/docs/tasks/configure-pod-container/security-context/>Security Context</a>は実行時のコンテナやPodを設定するものです。
Security ContextはPodのマニフェストの中でPodやコンテナの仕様の一部として定義され、コンテナランタイムへ渡されるパラメータを示します。</p><p>セキュリティポリシーはコントロールプレーンの機構で、Security Contextとそれ以外も含め、特定の設定を強制するものです。
2020年2月時点では、ネイティブにサポートされているポリシー強制の機構は<a href=/docs/concepts/policy/pod-security-policy/>Pod Security
Policy</a>です。これはクラスター全体にわたってセキュリティポリシーを中央集権的に強制するものです。
セキュリティポリシーを強制する他の手段もKubernetesのエコシステムでは開発が進められています。例えば<a href=https://github.com/open-policy-agent/gatekeeper>OPA
Gatekeeper</a>があります。</p><h3 id=windowsのpodにはどのプロファイルを適用すればよいですか>WindowsのPodにはどのプロファイルを適用すればよいですか?</h3><p>Kubernetesでは、Linuxベースのワークロードと比べてWindowsの使用は制限や差異があります。
特に、PodのSecurityContextフィールドは<a href=/ja/docs/setup/production-environment/windows/intro-windows-in-kubernetes/#v1-podsecuritycontext>Windows環境では効果がありません</a>。
したがって、現段階では標準化されたセキュリティポリシーは存在しません。</p><p>Windows Podに制限付きプロファイルを適用すると、実行時にPodに影響が出る場合があります。
制限付きプロファイルでは、Linux固有の制限(seccompプロファイルや特権昇格の不許可など)を適用する必要があります。
kubeletおよび/またはそのコンテナランタイムがこれらのLinux固有の値を無視した場合、Windows Podは制限付きプロファイル内で正常に動作します。
ただし、強制力がないため、Windows コンテナを使用するPodについては、ベースラインプロファイルと比較して追加の制限はありません。</p><p>HostProcess Podを作成するためのHostProcessフラグの使用は、特権的なポリシーに沿ってのみ行われるべきです。
Windows HostProcess Podの作成は、ベースラインおよび制限されたポリシーの下でブロックされているため、いかなるHostProcess Podも特権的であるとみなされるべきです。</p><h3 id=サンドボックス化されたpodはどのように扱えばよいでしょうか>サンドボックス化されたPodはどのように扱えばよいでしょうか?</h3><p>現在のところ、Podがサンドボックス化されていると見なされるかどうかを制御できるAPI標準はありません。
サンドボックス化されたPodはサンドボックス化されたランタイム（例えばgVisorやKata Containers）の使用により特定することは可能ですが、サンドボックス化されたランタイムの標準的な定義は存在しません。</p><p>サンドボックス化されたランタイムに対して必要な保護は、それ以外に対するものとは異なります。
例えば、ワークロードがその基になるカーネルと分離されている場合、特権を制限する必要性は小さくなります。
これにより、強い権限を必要とするワークロードが隔離された状態を維持できます。</p><p>加えて、サンドボックス化されたワークロードの保護はサンドボックス化の実装に強く依存します。
したがって、全てのサンドボックス化されたワークロードに推奨される単一のポリシーは存在しません。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-04eeb110d75afc8acb2cf7a3db743985>2 - クラウドネイティブセキュリティの概要</h1><p>この概要では、クラウドネイティブセキュリティにおけるKubernetesのセキュリティを考えるためのモデルを定義します。</p><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> コンテナセキュリティモデルは、実証済の情報セキュリティポリシーではなく提案を提供します。</div><h2 id=クラウドネイティブセキュリティの４c>クラウドネイティブセキュリティの４C</h2><p>セキュリティは階層で考えることができます。クラウドネイティブの4Cは、クラウド、クラスター、コンテナ、そしてコードです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 階層化されたアプローチは、セキュリティに対する<a href=https://en.wikipedia.org/wiki/Defense_in_depth_(computing)>多層防御</a>のアプローチを強化します。これはソフトウェアシステムを保護するベストプラクティスとして幅広く認知されています。</div><figure><img src=/images/docs/4c.png><figcaption><h4>クラウドネイティブセキュリティの４C</h4></figcaption></figure><p>クラウドネイティブセキュリティモデルの各レイヤーは次の最も外側のレイヤー上に構築します。コードレイヤーは、強固な基盤(クラウド、クラスター、コンテナ)セキュリティレイヤーから恩恵を受けます。コードレベルのセキュリティに対応しても基盤レイヤーが低い水準のセキュリティでは守ることができません。</p><h2 id=クラウド>クラウド</h2><p>いろいろな意味でも、クラウド(または同じ場所に設置されたサーバー、企業のデータセンター)はKubernetesクラスターの<a href=https://en.wikipedia.org/wiki/Trusted_computing_base>トラステッド・コンピューティング・ベース</a>です。クラウドレイヤーが脆弱な(または脆弱な方法で構成されている)場合、この基盤の上に構築されたコンポーネントが安全であるという保証はありません。各クラウドプロバイダーは、それぞれの環境でワークロードを安全に実行させるためのセキュリティの推奨事項を作成しています。</p><h3 id=クラウドプロバイダーのセキュリティ>クラウドプロバイダーのセキュリティ</h3><p>Kubernetesクラスターを所有しているハードウェアや様々なクラウドプロバイダー上で実行している場合、セキュリティのベストプラクティスに関するドキュメントを参考にしてください。ここでは人気のあるクラウドプロバイダーのセキュリティドキュメントの一部のリンクを紹介します。</p><table><caption style=display:none>Cloud provider security</caption><thead><tr><th>IaaSプロバイダー</th><th>リンク</th></tr></thead><tbody><tr><td>Alibaba Cloud</td><td><a href=https://www.alibabacloud.com/trust-center>https://www.alibabacloud.com/trust-center</a></td></tr><tr><td>Amazon Web Services</td><td><a href=https://aws.amazon.com/security/>https://aws.amazon.com/security/</a></td></tr><tr><td>Google Cloud Platform</td><td><a href=https://cloud.google.com/security/>https://cloud.google.com/security/</a></td></tr><tr><td>IBM Cloud</td><td><a href=https://www.ibm.com/cloud/security>https://www.ibm.com/cloud/security</a></td></tr><tr><td>Microsoft Azure</td><td><a href=https://docs.microsoft.com/en-us/azure/security/azure-security>https://docs.microsoft.com/en-us/azure/security/azure-security</a></td></tr><tr><td>Oracle Cloud Infrastructure</td><td><a href=https://www.oracle.com/security/>https://www.oracle.com/security/</a></td></tr><tr><td>VMWare VSphere</td><td><a href=https://www.vmware.com/security/hardening-guides.html>https://www.vmware.com/security/hardening-guides.html</a></td></tr></tbody></table><h3 id=infrastructure-security>インフラのセキュリティ</h3><p>Kubernetesクラスターのインフラを保護するための提案です。</p><table><caption style=display:none>Infrastructure security</caption><thead><tr><th>Kubernetesインフラに関する懸念事項</th><th>推奨事項</th></tr></thead><tbody><tr><td>API Server(コントロールプレーン)へのネットワークアクセス</td><td>Kubernetesコントロールプレーンへのすべてのアクセスは、インターネット上での一般公開は許されず、クラスター管理に必要なIPアドレスに制限するネットワークアクセス制御リストによって制御されます。</td></tr><tr><td>Nodeへのネットワークアクセス</td><td>Nodeはコントロールプレーンの特定ポート <em>のみ</em> 接続(ネットワークアクセス制御リストを介して)を受け入れるよう設定し、NodePortとLoadBalancerタイプのKubernetesのServiceに関する接続を受け入れるよう設定する必要があります。可能であれば、それらのNodeはパブリックなインターネットに完全公開しないでください。</td></tr><tr><td>KubernetesからのクラウドプロバイダーAPIへのアクセス</td><td>各クラウドプロバイダーはKubernetesコントロールプレーンとNodeに異なる権限を与える必要があります。<a href=https://en.wikipedia.org/wiki/Principle_of_least_privilege>最小権限の原則</a>に従い、管理に必要なリソースに対してクラウドプロバイダーへのアクセスをクラスターに提供するのが最善です。<a href=https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles>Kopsドキュメント</a>にはIAMのポリシーとロールについての情報が記載されています。</td></tr><tr><td>etcdへのアクセス</td><td>etcd(Kubernetesのデータストア)へのアクセスはコントロールプレーンのみに制限すべきです。設定によっては、TLS経由でetcdを利用する必要があります。詳細な情報は<a href=https://github.com/etcd-io/etcd/tree/master/Documentation>etcdドキュメント</a>を参照してください。</td></tr><tr><td>etcdの暗号化</td><td>可能な限り、保存時に全ドライブを暗号化することは良いプラクティスですが、etcdはクラスター全体(Secretを含む)の状態を保持しているため、そのディスクは特に暗号化する必要があります。</td></tr></tbody></table><h2 id=クラスター>クラスター</h2><p>Kubernetesを保護する為には２つの懸念事項があります。</p><ul><li>設定可能なクラスターコンポーネントの保護</li><li>クラスターで実行されるアプリケーションの保護</li></ul><h3 id=cluster-components>クラスターのコンポーネント</h3><p>想定外または悪意のあるアクセスからクラスターを保護して適切なプラクティスを採用したい場合、<a href=/docs/tasks/administer-cluster/securing-a-cluster/>クラスターの保護</a>に関するアドバイスを読み従ってください。</p><h3 id=cluster-applications>クラスター内のコンポーネント(アプリケーション)</h3><p>アプリケーションを対象にした攻撃に応じて、セキュリティの特定側面に焦点をあてたい場合があります。例:他のリソースとの連携で重要なサービス(サービスA)と、リソース枯渇攻撃に対して脆弱な別のワークロード(サービスB)が実行されている場合、サービスBのリソースを制限していないとサービスAが危険にさらされるリスクが高くなります。次の表はセキュリティの懸念事項とKubernetesで実行されるワークロードを保護するための推奨事項を示しています。</p><table><thead><tr><th>ワークロードセキュリティに関する懸念事項</th><th>推奨事項</th></tr></thead><tbody><tr><td>RBAC認可(Kubernetes APIへのアクセス)</td><td><a href=https://kubernetes.io/ja/docs/reference/access-authn-authz/rbac/>https://kubernetes.io/ja/docs/reference/access-authn-authz/rbac/</a></td></tr><tr><td>認証</td><td><a href=https://kubernetes.io/docs/concepts/security/controlling-access/>https://kubernetes.io/docs/concepts/security/controlling-access/</a></td></tr><tr><td>アプリケーションのSecret管理(およびetcdへの保存時に暗号化)</td><td><a href=https://kubernetes.io/ja/docs/concepts/configuration/secret/>https://kubernetes.io/ja/docs/concepts/configuration/secret/</a><br><a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/>https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/</a></td></tr><tr><td>PodSecurityPolicy</td><td><a href=https://kubernetes.io/docs/concepts/policy/pod-security-policy/>https://kubernetes.io/docs/concepts/policy/pod-security-policy/</a></td></tr><tr><td>Quality of Service (およびクラスターリソース管理)</td><td><a href=https://kubernetes.io/ja/docs/tasks/configure-pod-container/quality-service-pod/>https://kubernetes.io/ja/docs/tasks/configure-pod-container/quality-service-pod/</a></td></tr><tr><td>NetworkPolicy</td><td><a href=https://kubernetes.io/ja/docs/concepts/services-networking/network-policies/>https://kubernetes.io/ja/docs/concepts/services-networking/network-policies/</a></td></tr><tr><td>Kubernetes IngressのTLS</td><td><a href=https://kubernetes.io/ja/docs/concepts/services-networking/ingress/#tls>https://kubernetes.io/ja/docs/concepts/services-networking/ingress/#tls</a></td></tr></tbody></table><h2 id=コンテナ>コンテナ</h2><p>コンテナセキュリティは本ガイドの範囲外になります。このトピックを検索するために一般的な推奨事項とリンクを以下に示します。</p><table><thead><tr><th>コンテナに関する懸念事項</th><th>推奨事項</th></tr></thead><tbody><tr><td>コンテナの脆弱性スキャンとOS依存のセキュリティ</td><td>イメージをビルドする手順の一部として、既知の脆弱性がないかコンテナをスキャンする必要があります。</td></tr><tr><td>イメージの署名と実施</td><td>コンテナイメージを署名し、コンテナの中身に関する信頼性を維持します。</td></tr><tr><td>特権ユーザーを許可しない</td><td>コンテナの構成時に、コンテナの目的を実行するために必要最低限なOS特権を持ったユーザーをコンテナ内部に作成する方法のドキュメントを参考にしてください。</td></tr></tbody></table><h2 id=コード>コード</h2><p>アプリケーションコードは、あなたが最も制御できる主要な攻撃対象のひとつです。アプリケーションコードを保護することはKubernetesのセキュリティトピックの範囲外ですが、アプリケーションコードを保護するための推奨事項を以下に示します。</p><h3 id=コードセキュリティ>コードセキュリティ</h3><table><caption style=display:none>Code security</caption><thead><tr><th>コードに関する懸念事項</th><th>推奨事項</th></tr></thead><tbody><tr><td>TLS経由のアクセスのみ</td><td>コードがTCP通信を必要とする場合は、事前にクライアントとのTLSハンドシェイクを実行してください。 いくつかの例外を除いて、全ての通信を暗号化してください。さらに一歩すすめて、サービス間のネットワークトラフィックを暗号化することはよい考えです。これは、サービスを特定した2つの証明書で通信の両端を検証する相互認証、または<a href=https://en.wikipedia.org/wiki/Mutual_authentication>mTLS</a>して知られているプロセスを通じて実行できます。</td></tr><tr><td>通信ポートの範囲制限</td><td>この推奨事項は一目瞭然かもしれませんが、可能なかぎり、通信とメトリクス収集に必要不可欠なサービスのポートのみを公開します。</td></tr><tr><td>サードパティに依存するセキュリティ</td><td>既知の脆弱性についてアプリケーションのサードパーティ製ライブラリーを定期的にスキャンすることを推奨します。それぞれの言語は自動でこのチェックを実行するツールを持っています。</td></tr><tr><td>静的コード解析</td><td>ほとんどの言語ではコードのスニペットを解析して、安全でない可能性のあるコーディングを分析する方法が提供しています。可能な限り、コードベースでスキャンして、よく起こるセキュリティエラーを検出できる自動ツールを使用してチェックを実行すべきです。一部のツールはここで紹介されています。 <a href=https://owasp.org/www-community/Source_Code_Analysis_Tools>https://owasp.org/www-community/Source_Code_Analysis_Tools</a></td></tr><tr><td>動的プロービング攻撃</td><td>よく知られているいくつかのサービス攻撃をサービスに対して試すことができる自動ツールがいくつかあります。これにはSQLインジェクション、CSRF、そしてXSSが含まれます。よく知られている動的解析ツールは<a href=https://owasp.org/www-project-zap/>OWASP Zed Attack proxy</a>toolです。</td></tr></tbody></table><h2 id=次の項目>次の項目</h2><p>関連するKubernetesセキュリティについて学びます。</p><ul><li><a href=/ja/docs/concepts/security/pod-security-standards/>Podセキュリティの標準</a></li><li><a href=/ja/docs/concepts/services-networking/network-policies/>Podのネットワークポリシー</a></li><li><a href=/docs/concepts/security/controlling-access>Kubernetes APIへのアクセスを制御する</a></li><li><a href=/docs/tasks/administer-cluster/securing-a-cluster/>クラスターの保護</a></li><li>コントロールプレーンとの<a href=/docs/tasks/tls/managing-tls-in-a-cluster/>通信時のデータ暗号化</a></li><li><a href=/docs/tasks/administer-cluster/encrypt-data/>保存時のデータ暗号化</a></li><li><a href=/ja/docs/concepts/configuration/secret/>Kubernetes Secret</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bc9934fccfeaf880eec6ea79025c0381>3 - Podのセキュリティアドミッション</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [beta]</code></div><p>Kubernetesの<a href=/ja/docs/concepts/security/pod-security-standards/>Podセキュリティの標準</a>はPodに対して異なる分離レベルを定義します。
これらの標準によって、Podの動作をどのように制限したいかを、明確かつ一貫した方法で定義することができます。</p><p>ベータ版機能として、Kubernetesは<a href=/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>の後継である組み込みの <em>Pod Security</em> <a class=glossary-tooltip title='A piece of code that intercepts requests to the Kubernetes API server prior to persistence of the object.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/admission-controllers/ target=_blank aria-label=アドミッションコントローラー>アドミッションコントローラー</a>を提供しています。
Podセキュリティの制限は、Pod作成時に<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=名前空間>名前空間</a>レベルで適用されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> PodSecurityPolicy APIは非推奨であり、v1.25でKubernetesから<a href=/docs/reference/using-api/deprecation-guide/#v1-25>削除</a>される予定です。</div><h2 id=enabling-the-podsecurity-admission-plugin><code>PodSecurity</code>アドミッションプラグインの有効化</h2><p>v1.23において、<code>PodSecurity</code>の<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>はベータ版の機能で、デフォルトで有効化されています。
v1.22において、<code>PodSecurity</code>の<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>はアルファ版の機能で、組み込みのアドミッションプラグインを使用するには、<code>kube-apiserver</code>で有効にする必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--feature-gates<span style=color:#666>=</span><span style=color:#b44>&#34;...,PodSecurity=true&#34;</span>
</span></span></code></pre></div><h2 id=webhook>代替案:<code>PodSecurity</code>アドミッションwebhookのインストール</h2><p>クラスターがv1.22より古い、あるいは<code>PodSecurity</code>機能を有効にできないなどの理由で、ビルトインの<code>PodSecurity</code>アドミッションプラグインが使えない環境では、<code>PodSecurity</code>はアドミッションロジックはベータ版の<a href=https://git.k8s.io/pod-security-admission/webhook>validating admission webhook</a>としても提供されています。</p><p>ビルド前のコンテナイメージ、証明書生成スクリプト、マニフェストの例は、<a href=https://git.k8s.io/pod-security-admission/webhook>https://git.k8s.io/pod-security-admission/webhook</a>で入手可能です。</p><p>インストール方法:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>git clone git@github.com:kubernetes/pod-security-admission.git
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> pod-security-admission/webhook
</span></span><span style=display:flex><span>make certs
</span></span><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 生成された証明書の有効期限は2年間です。有効期限が切れる前に、証明書を再生成するか、内蔵のアドミッションプラグインを使用してWebhookを削除してください。</div><h2 id=pod-security-levels>Podのセキュリティレベル</h2><p>Podのセキュリティアドミッションは、Podの<a href=/docs/tasks/configure-pod-container/security-context/>Security Context</a>とその他の関連フィールドに、<a href=/ja/docs/concepts/security/pod-security-standards>Podセキュリティの標準</a>で定義された3つのレベル、<code>privileged</code>、<code>baseline</code>、<code>restricted</code>に従って要件を設定するものです。
これらの要件の詳細については、<a href=/ja/docs/concepts/security/pod-security-standards>Podセキュリティの標準</a>のページを参照してください。</p><h2 id=pod-security-admission-labels-for-namespaces>Podの名前空間に対するセキュリティアドミッションラベル</h2><p>この機能を有効にするか、Webhookをインストールすると、名前空間を設定して、各名前空間でPodセキュリティに使用したいadmission controlモードを定義できます。
Kubernetesは、名前空間に使用したい定義済みのPodセキュリティの標準レベルのいずれかを適用するために設定できる<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>のセットを用意しています。
選択したラベルは、以下のように違反の可能性が検出された場合に<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>が取るアクションを定義します。</p><table><caption style=display:none>Podのセキュリティアドミッションのモード</caption><thead><tr><th style=text-align:left>モード</th><th style=text-align:left>説明</th></tr></thead><tbody><tr><td style=text-align:left><strong>enforce</strong></td><td style=text-align:left>ポリシーに違反した場合、Podは拒否されます。</td></tr><tr><td style=text-align:left><strong>audit</strong></td><td style=text-align:left>ポリシー違反は、<a href=/ja/docs/tasks/debug-application-cluster/audit/>監査ログ</a>に記録されるイベントに監査アノテーションを追加するトリガーとなりますが、それ以外は許可されます。</td></tr><tr><td style=text-align:left><strong>warn</strong></td><td style=text-align:left>ポリシーに違反した場合は、ユーザーへの警告がトリガーされますが、それ以外は許可されます。</td></tr></tbody></table><p>名前空間は、任意のまたはすべてのモードを設定することができ、異なるモードに対して異なるレベルを設定することもできます。</p><p>各モードには、使用するポリシーを決定する2つのラベルがあります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># モードごとのレベルラベルは、そのモードに適用するポリシーレベルを示す。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># MODEは`enforce`、`audit`、`warn`のいずれかでなければならない。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># LEVELは`privileged`、`baseline`、`restricted`のいずれかでなければならない。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>pod-security.kubernetes.io/&lt;MODE&gt;</span>:<span style=color:#bbb> </span>&lt;LEVEL&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># オプション: モードごとのバージョンラベルは、Kubernetesのマイナーバージョンに同梱される</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># バージョンにポリシーを固定するために使用できる（例えばv1.25など）。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># MODEは`enforce`、`audit`、`warn`のいずれかでなければならない。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># VERSIONは有効なKubernetesのマイナーバージョンか`latest`でなければならない。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>pod-security.kubernetes.io/&lt;MODE&gt;-version</span>:<span style=color:#bbb> </span>&lt;VERSION&gt;<span style=color:#bbb>
</span></span></span></code></pre></div><p><a href=/docs/tasks/configure-pod-container/enforce-standards-namespace-labels>名前空間ラベルでのPodセキュリティの標準の適用</a>で使用例を確認できます。</p><h2 id=workload-resources-and-pod-templates>WorkloadのリソースとPodテンプレート</h2><p>Podは、<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>や<a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>のような<a href=/ja/docs/concepts/workloads/controllers/>ワークロードオブジェクト</a>を作成することによって、しばしば間接的に生成されます。
ワークロードオブジェクトは_Pod template_を定義し、ワークロードリソースの<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>はそのテンプレートに基づきPodを作成します。
違反の早期発見を支援するために、auditモードとwarningモードは、ワークロードリソースに適用されます。
ただし、enforceモードはワークロードリソースには<strong>適用されず</strong>、結果としてのPodオブジェクトにのみ適用されます。</p><h2 id=exemptions>適用除外(Exemption)</h2><p>Podセキュリティの施行から <em>exemptions</em> を定義することで、特定の名前空間に関連するポリシーのために禁止されていたPodの作成を許可することができます。
Exemptionは<a href=/docs/tasks/configure-pod-container/enforce-standards-admission-controller/#configure-the-admission-controller>アドミッションコントローラーの設定</a>で静的に設定することができます。</p><p>Exemptionは明示的に列挙する必要があります。
Exemptionを満たしたリクエストは、アドミッションコントローラーによって <em>無視</em> されます(<code>enforce</code>、<code>audit</code>、<code>warn</code>のすべての動作がスキップされます)。Exemptionの次元は以下の通りです。</p><ul><li><strong>Usernames:</strong> 認証されていない(あるいは偽装された)ユーザー名を持つユーザーからの要求は無視されます。</li><li><strong>RuntimeClassNames:</strong> Podと<a href=#workload-resources-and-pod-templates>ワークロードリソース</a>で指定された除外ランタイムクラス名は、無視されます。</li><li><strong>Namespaces:</strong> 除外された名前空間のPodと<a href=#workload-resources-and-pod-templates>ワークロードリソース</a>は、無視されます。</li></ul><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> ほとんどのPodは、<a href=#workload-resources-and-pod-templates>ワークロードリソース</a>に対応してコントローラーが作成します。つまり、エンドユーザーを適用除外にするのはPodを直接作成する場合のみで、ワークロードリソースを作成する場合は適用除外になりません。
コントローラーサービスアカウント(<code>system:serviceaccount:kube-system:replicaset-controller</code>など)は通常、除外してはいけません。そうした場合、対応するワークロードリソースを作成できるすべてのユーザーを暗黙的に除外してしまうためです。</div><p>以下のPodフィールドに対する更新は、ポリシーチェックの対象外となります。つまり、Podの更新要求がこれらのフィールドを変更するだけであれば、Podが現在のポリシーレベルに違反していても拒否されることはありません。</p><ul><li>すべてのメタデータの更新(seccompまたはAppArmorアノテーションへの変更を<strong>除く</strong>)<ul><li><code>seccomp.security.alpha.kubernetes.io/pod</code>(非推奨)</li><li><code>container.seccomp.security.alpha.kubernetes.io/*</code>(非推奨)</li><li><code>container.apparmor.security.beta.kubernetes.io/*</code></li></ul></li><li><code>.spec.activeDeadlineSeconds</code>に対する有効な更新</li><li><code>.spec.tolerations</code>に対する有効な更新</li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/security/pod-security-standards>Podセキュリティの標準</a></li><li><a href=/docs/setup/best-practices/enforcing-pod-security-standards>Podセキュリティの標準の適用</a></li><li><a href=/docs/tasks/configure-pod-container/enforce-standards-admission-controller>ビルトインのアドミッションコントローラーの設定によるPodセキュリティの標準の適用</a></li><li><a href=/docs/tasks/configure-pod-container/enforce-standards-namespace-labels>名前空間ラベルでのPodセキュリティの標準の適用</a></li><li><a href=/docs/tasks/configure-pod-container/migrate-from-psp>PodSecurityPolicyからビルトインのPodSecurityアドミッションコントローラーへの移行</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4d77d1ae4c06aa14f54b385191627881>4 - Kubernetes APIへのアクセスコントロール</h1><p>このページではKubernetes APIへのアクセスコントロールの概要を説明します。</p><p><a href=/ja/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>には<code>kubectl</code>やクライアントライブラリ、あるいはRESTリクエストを用いてアクセスします。
APIアクセスには、人間のユーザーと<a href=/docs/tasks/configure-pod-container/configure-service-account/>Kubernetesサービスアカウント</a>の両方が認証可能です。
リクエストがAPIに到達すると、次の図のようにいくつかの段階を経ます。</p><p><img src=/images/docs/admin/access-control-overview.svg alt="Kubernetes APIリクエストの処理手順図"></p><h2 id=transport-security>トランスポート層のセキュリティ</h2><p>一般的なKubernetesクラスターでは、APIはTLSで保護された443番ポートで提供されます。
APIサーバーは証明書を提示します。
この証明書は、プライベート認証局(CA)を用いて署名することも、一般に認知されているCAと連携した公開鍵基盤に基づき署名することも可能です。</p><p>クラスターがプライベート認証局を使用している場合、接続を信頼し、傍受されていないと確信できるように、クライアント上の<code>~/.kube/config</code>に設定されたそのCA証明書のコピーが必要です。</p><p>クライアントは、この段階でTLSクライアント証明書を提示することができます。</p><h2 id=authentication>認証</h2><p>TLSが確立されると、HTTPリクエストは認証のステップに移行します。
これは図中のステップ<strong>1</strong>に該当します。
クラスター作成スクリプトまたはクラスター管理者は、1つまたは複数のAuthenticatorモジュールを実行するようにAPIサーバーを設定します。
Authenticatorについては、<a href=/ja/docs/reference/access-authn-authz/authentication/>認証</a>で詳しく説明されています。</p><p>認証ステップへの入力はHTTPリクエスト全体ですが、通常はヘッダとクライアント証明書の両方、またはどちらかを調べます。</p><p>認証モジュールには、クライアント証明書、パスワード、プレーントークン、ブートストラップトークン、JSON Web Tokens(サービスアカウントに使用)などがあります。</p><p>複数の認証モジュールを指定することができ、その場合、1つの認証モジュールが成功するまで、それぞれを順番に試行します。</p><p>認証できない場合、HTTPステータスコード401で拒否されます。
そうでなければ、ユーザーは特定の<code>username</code>として認証され、そのユーザー名は後続のステップでの判断に使用できるようになります。
また、ユーザーのグループメンバーシップを提供する認証機関と、提供しない認証機関があります。</p><p>Kubernetesはアクセスコントロールの決定やリクエストログにユーザー名を使用しますが、<code>User</code>オブジェクトを持たず、ユーザー名やその他のユーザーに関する情報をAPIはに保存しません。</p><h2 id=authorization>認可</h2><p>リクエストが特定のユーザーからのものであると認証された後、そのリクエストは認可される必要があります。
これは図のステップ<strong>2</strong>に該当します。</p><p>リクエストには、リクエスト者のユーザー名、リクエストされたアクション、そのアクションによって影響を受けるオブジェクトを含める必要があります。
既存のポリシーで、ユーザーが要求されたアクションを完了するための権限を持っていると宣言されている場合、リクエストは承認されます。</p><p>例えば、Bobが以下のようなポリシーを持っている場合、彼は名前空間<code>projectCaribou</code>内のPodのみを読むことができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;bob&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;projectCaribou&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Bobが次のようなリクエストをした場合、Bobは名前空間<code>projectCaribou</code>のオブジェクトを読むことが許可されているので、このリクエストは認可されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;resourceAttributes&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;projectCaribou&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;get&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;unicorn.example.org&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Bobが名前空間<code>projectCaribou</code>のオブジェクトに書き込み(<code>create</code>または<code>update</code>)のリクエストをした場合、承認は拒否されます。
また、もしBobが<code>projectFish</code>のような別の名前空間にあるオブジェクトを読み込む(<code>get</code>)リクエストをした場合も、承認は拒否されます。</p><p>Kubernetesの認可では、組織全体またはクラウドプロバイダー全体の既存のアクセスコントロールシステムと対話するために、共通のREST属性を使用する必要があります。
これらのコントロールシステムは、Kubernetes API以外のAPIとやり取りする可能性があるため、REST形式を使用することが重要です。</p><p>Kubernetesは、ABACモード、RBACモード、Webhookモードなど、複数の認可モジュールをサポートしています。
管理者はクラスターを作成する際に、APIサーバーで使用する認証モジュールを設定します。
複数の認可モジュールが設定されている場合、Kubernetesは各モジュールをチェックし、いずれかのモジュールがリクエストを認可した場合、リクエストを続行することができます。
すべてのモジュールがリクエストを拒否した場合、リクエストは拒否されます(HTTPステータスコード403)。</p><p>サポートされている認可モジュールを使用したポリシー作成の詳細を含む、Kubernetesの認可については、<a href=/docs/reference/access-authn-authz/authorization/>認可</a>を参照してください。</p><h2 id=admission-control>アドミッションコントロール</h2><p>アドミッションコントロールモジュールは、リクエストを変更したり拒否したりすることができるソフトウェアモジュールです。
認可モジュールが利用できる属性に加えて、アドミッションコントロールモジュールは、作成または修正されるオブジェクトのコンテンツにアクセスすることができます。</p><p>アドミッションコントローラーは、オブジェクトの作成、変更、削除、または接続(プロキシ)を行うリクエストに対して動作します。
アドミッションコントローラーは、単にオブジェクトを読み取るだけのリクエストには動作しません。
複数のアドミッションコントローラーが設定されている場合は、順番に呼び出されます。</p><p>これは図中のステップ<strong>3</strong>に該当します。</p><p>認証・認可モジュールとは異なり、いずれかのアドミッションコントローラーモジュールが拒否した場合、リクエストは即座に拒否されます。</p><p>オブジェクトを拒否するだけでなく、アドミッションコントローラーは、フィールドに複雑なデフォルトを設定することもできます。</p><p>利用可能なアドミッションコントロールモジュールは、<a href=/docs/reference/access-authn-authz/admission-controllers/>アドミッションコントローラー</a>に記載されています。</p><p>リクエストがすべてのアドミッションコントローラーを通過すると、対応するAPIオブジェクトの検証ルーチンを使って検証され、オブジェクトストアに書き込まれます(図のステップ<strong>4</strong>に該当します)。</p><h2 id=auditing>監査</h2><p>Kubernetesの監査は、クラスター内の一連のアクションを文書化した、セキュリティに関連する時系列の記録を提供します。
クラスターは、ユーザー、Kubernetes APIを使用するアプリケーション、およびコントロールプレーン自身によって生成されるアクティビティを監査します。</p><p>詳しくは<a href=/ja/docs/tasks/debug-application-cluster/audit/>監査</a>をご覧ください。</p><h2 id=api-server-ports-and-ips>APIサーバーのIPとポート</h2><p>これまでの説明は、APIサーバーのセキュアポートに送信されるリクエストに適用されます(典型的なケース)。
APIサーバーは、実際には2つのポートでサービスを提供することができます。</p><p>デフォルトでは、Kubernetes APIサーバーは2つのポートでHTTPを提供します。</p><ol><li><p><code>localhost</code>ポート:</p><ul><li>テストとブートストラップ用で、マスターノードの他のコンポーネント(スケジューラー、コントローラーマネージャー)がAPIと通信するためのものです。</li><li>TLSは使用しません。</li><li>デフォルトポートは8080です。</li><li>デフォルトのIPはlocalhostですが、<code>--insecure-bind-address</code>フラグで変更することができます。</li><li>リクエストは認証と認可のモジュールを<strong>バイパス</strong>します。</li><li>リクエストは、アドミッションコントロールモジュールによって処理されます。</li><li>ホストにアクセスする必要があるため、保護されています。</li></ul></li><li><p>“セキュアポート”:</p><ul><li>可能な限りこちらを使用してください。</li><li>TLSを使用します。証明書は<code>--tls-cert-file</code>フラグで、鍵は<code>--tls-private-key-file</code>フラグで設定します。</li><li>デフォルトポートは6443です。<code>--secure-port</code>フラグで変更することができます。</li><li>デフォルトのIPは、最初の非localhostのネットワークインターフェースです。<code>--bind-address</code>フラグで変更することができます。</li><li>リクエストは、認証・認可モジュールによって処理されます。</li><li>リクエストは、アドミッションコントロールモジュールによって処理されます。</li><li>認証・認可モジュールが実行されます。</li></ul></li></ol><h2 id=次の項目>次の項目</h2><p>認証、認可、APIアクセスコントロールに関する詳しいドキュメントはこちらをご覧ください。</p><ul><li><a href=/ja/docs/reference/access-authn-authz/authentication/>認証</a><ul><li><a href=/docs/reference/access-authn-authz/bootstrap-tokens/>ブートストラップトークンでの認証</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/admission-controllers/>アドミッションコントローラー</a><ul><li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>動的アドミッションコントロール</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/authorization/>認可</a><ul><li><a href=/ja/docs/reference/access-authn-authz/rbac/>ロールに基づいたアクセスコントロール</a></li><li><a href=/docs/reference/access-authn-authz/abac/>属性に基づいたアクセスコントロール</a></li><li><a href=/docs/reference/access-authn-authz/node/>Nodeの認可</a></li><li><a href=/docs/reference/access-authn-authz/webhook/>Webhookの認可</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/>証明書の署名要求</a><ul><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection>CSRの承認</a>と<a href=/docs/reference/access-authn-authz/certificate-signing-requests/#signing>証明書の署名</a>を含む</li></ul></li><li>サービスアカウント<ul><li><a href=/docs/tasks/configure-pod-container/configure-service-account/>Developer guide</a></li><li><a href=/docs/reference/access-authn-authz/service-accounts-admin/>Administration</a></li></ul></li></ul><p>以下についても知ることができます。</p><ul><li>PodがAPIクレデンシャルを取得するために<a href=/ja/docs/concepts/configuration/secret/#service-accounts-automatically-create-and-attach-secrets-with-api-credentials>Secrets</a>を使用する方法について。</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>