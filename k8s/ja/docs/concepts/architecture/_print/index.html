<!doctype html><html lang=ja class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/architecture/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/architecture/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/architecture/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/architecture/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/architecture/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/architecture/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/architecture/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/architecture/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/architecture/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/architecture/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/architecture/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/architecture/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>クラスターのアーキテクチャ | Kubernetes</title><meta property="og:title" content="クラスターのアーキテクチャ"><meta property="og:description" content="プロダクショングレードのコンテナ管理基盤"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/architecture/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="クラスターのアーキテクチャ"><meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary"><meta name=twitter:title content="クラスターのアーキテクチャ"><meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/architecture/"><meta property="og:title" content="クラスターのアーキテクチャ"><meta name=twitter:title content="クラスターのアーキテクチャ"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ja/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ja/docs/>ドキュメント</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/blog/>Blogs</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/training/>トレーニング</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/partners/>パートナー</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/community/>コミュニティ</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/case-studies/>ケーススタディ</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>バージョン</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ja/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/architecture/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/architecture/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/architecture/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/concepts/architecture/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ja/docs/concepts/architecture/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語 (Japanese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/architecture/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/architecture/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/architecture/>한국어 (Korean)</a>
<a class=dropdown-item href=/fr/docs/concepts/architecture/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/architecture/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/architecture/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/architecture/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/architecture/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/architecture/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/architecture/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/concepts/architecture/>Русский (Russian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.</p><p><a href=/ja/docs/concepts/architecture/>このページの通常のビューに戻る</a>.</p></div><h1 class=title>クラスターのアーキテクチャ</h1><ul><li>1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>ノード</a></li><li>2: <a href=#pg-c0251def6da29b30afebfb04549f1703>ノードとコントロールプレーン間の通信</a></li><li>3: <a href=#pg-ca8819042a505291540e831283da66df>コントローラー</a></li><li>4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>クラウドコントローラーマネージャー</a></li><li>5: <a href=#pg-44a2e2e592af0846101e970aff9243e5>ガベージコレクション</a></li><li>6: <a href=#pg-c0ea5310f52e22c5de34dc84d9ab5e0d>コンテナランタイムインターフェイス(CRI)</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>1 - ノード</h1><p>Kubernetesはコンテナを <em>Node</em> 上で実行されるPodに配置することで、ワークロードを実行します。
ノードはクラスターによりますが、1つのVMまたは物理的なマシンです。
各ノードは<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>やそれを制御する<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>を実行するのに必要なサービスを含んでいます。</p><p>通常、1つのクラスターで複数のノードを持ちます。学習用途やリソースの制限がある環境では、1ノードかもしれません。</p><p>1つのノード上の<a href=/ja/docs/concepts/overview/components/#node-components>コンポーネント</a>には、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>、<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>、<a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>が含まれます。</p><h2 id=management>管理</h2><p>ノードを<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>に加えるには2つの方法があります:</p><ol><li>ノード上のkubeletが、コントロールプレーンに自己登録する。</li><li>あなた、もしくは他のユーザーが手動でNodeオブジェクトを追加する。</li></ol><p>Nodeオブジェクトの作成、もしくはノード上のkubeletによる自己登録の後、コントロールプレーンはNodeオブジェクトが有効かチェックします。例えば、下記のjsonマニフェストでノードを作成してみましょう:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kubernetesは内部的にNodeオブジェクトを作成します。 APIサーバーに登録したkubeletがノードの<code>metadata.name</code>フィールドが一致しているか検証します。ノードが有効な場合、つまり必要なサービスがすべて実行されている場合は、Podを実行する資格があります。それ以外の場合、該当ノードが有効になるまではいかなるクラスターの活動に対しても無視されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>Kubernetesは無効なNodeのオブジェクトを保持し、それが有効になるまで検証を続けます。</p><p>ヘルスチェックを止めるためには、あなた、もしくは<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>が明示的にNodeを削除する必要があります。</p></div><p>Nodeオブジェクトの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><h3 id=self-registration-of-nodes>ノードの自己登録</h3><p>kubeletのフラグ <code>--register-node</code>がtrue（デフォルト）のとき、kubeletは自分自身をAPIサーバーに登録しようとします。これはほとんどのディストリビューションで使用されている推奨パターンです。</p><p>自己登録については、kubeletは以下のオプションを伴って起動されます:</p><ul><li><code>--kubeconfig</code> - 自分自身をAPIサーバーに対して認証するための資格情報へのパス</li><li><code>--cloud-provider</code> - 自身に関するメタデータを読むために<a class=glossary-tooltip title='An organization that offers a cloud computing platform.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-cloud-provider' target=_blank aria-label=クラウドプロバイダー>クラウドプロバイダー</a>と会話する方法</li><li><code>--register-node</code> - 自身をAPIサーバーに自動的に登録</li><li><code>--register-with-taints</code> - 与えられた<a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taint>taint</a>のリストでノードを登録します (カンマ区切りの <code>&lt;key>=&lt;value>:&lt;effect></code>)。</li></ul><p><code>register-node</code>がfalseの場合、このオプションは機能しません</p><ul><li><code>--node-ip</code> - ノードのIPアドレス</li><li><code>--node-labels</code> - ノードをクラスターに登録するときに追加する<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=Label>Label</a>（<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction許可プラグイン</a>によって適用されるラベルの制限を参照）</li><li><code>--node-status-update-frequency</code> - kubeletがノードのステータスをマスターにPOSTする頻度の指定</li></ul><p><a href=/docs/reference/access-authn-authz/node/>ノード認証モード</a>および<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction許可プラグイン</a>が有効になっている場合、kubeletは自分自身のノードリソースを作成/変更することのみ許可されています。</p><h3 id=manual-node-administration>手動によるノード管理</h3><p>クラスター管理者は<a class=glossary-tooltip title='A command line tool for communicating with a Kubernetes cluster.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>を使用してNodeオブジェクトを作成および変更できます。</p><p>管理者が手動でNodeオブジェクトを作成したい場合は、kubeletフラグ <code>--register-node = false</code>を設定してください。</p><p>管理者は<code>--register-node</code>の設定に関係なくNodeオブジェクトを変更することができます。
例えば、ノードにラベルを設定し、それをunschedulableとしてマークすることが含まれます。</p><p>ノード上のラベルは、スケジューリングを制御するためにPod上のノードセレクターと組み合わせて使用できます。
例えば、Podをノードのサブセットでのみ実行する資格があるように制限します。</p><p>ノードをunschedulableとしてマークすると、新しいPodがそのノードにスケジュールされるのを防ぎますが、ノード上の既存のPodには影響しません。
これは、ノードの再起動などの前の準備ステップとして役立ちます。</p><p>ノードにスケジュール不可能のマークを付けるには、次のコマンドを実行します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon $ノード名
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>によって作成されたPodはノード上のunschedulable属性を考慮しません。
これは、再起動の準備中にアプリケーションからアプリケーションが削除されている場合でも、DaemonSetがマシンに属していることを前提としているためです。</div><h2 id=ノードのステータス>ノードのステータス</h2><p>ノードのステータスは以下の情報を含みます:</p><ul><li><a href=#addresses>Addresses</a></li><li><a href=#condition>Conditions</a></li><li><a href=#capacity>CapacityとAllocatable</a></li><li><a href=#info>Info</a></li></ul><p><code>kubectl</code>を使用し、ノードのステータスや詳細を確認できます:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe node &lt;ノード名をここに挿入&gt;
</span></span></code></pre></div><p>出力情報の各箇所について、以下で説明します。</p><h3 id=addresses>Addresses</h3><p>これらのフィールドの使い方は、お使いのクラウドプロバイダーやベアメタルの設定内容によって異なります。</p><ul><li>HostName: ノードのカーネルによって伝えられたホスト名です。kubeletの<code>--hostname-override</code>パラメーターによって上書きすることができます。</li><li>ExternalIP: 通常は、外部にルーティング可能(クラスターの外からアクセス可能)なノードのIPアドレスです。</li><li>InternalIP: 通常は、クラスター内でのみルーティング可能なノードのIPアドレスです。</li></ul><h3 id=condition>Conditions</h3><p><code>conditions</code>フィールドは全ての<code>Running</code>なノードのステータスを表します。例として、以下のような状態を含みます:</p><table><caption style=display:none>ノードのConditionと、各condition適用時の概要</caption><thead><tr><th>ノードのCondition</th><th>概要</th></tr></thead><tbody><tr><td><code>Ready</code></td><td>ノードの状態が有効でPodを配置可能な場合に<code>True</code>になります。ノードの状態に問題があり、Podが配置できない場合に<code>False</code>になります。ノードコントローラーが、<code>node-monitor-grace-period</code>で設定された時間内(デフォルトでは40秒)に該当ノードと疎通できない場合、<code>Unknown</code>になります。</td></tr><tr><td><code>DiskPressure</code></td><td>ノードのディスク容量が圧迫されているときに<code>True</code>になります。圧迫とは、ディスクの空き容量が少ないことを指します。それ以外のときは<code>False</code>です。</td></tr><tr><td><code>MemoryPressure</code></td><td>ノードのメモリが圧迫されているときに<code>True</code>になります。圧迫とは、メモリの空き容量が少ないことを指します。それ以外のときは<code>False</code>です。</td></tr><tr><td><code>PIDPressure</code></td><td>プロセスが圧迫されているときに<code>True</code>になります。圧迫とは、プロセス数が多すぎることを指します。それ以外のときは<code>False</code>です。</td></tr><tr><td><code>NetworkUnavailable</code></td><td>ノードのネットワークが適切に設定されていない場合に<code>True</code>になります。それ以外のときは<code>False</code>です。</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>備考:</strong> コマンドラインを使用してcordonされたNodeを表示する場合、Conditionは<code>SchedulingDisabled</code>を含みます。
<code>SchedulingDisabled</code>はKubernetesのAPIにおけるConditionではありません;その代わり、cordonされたノードはUnschedulableとしてマークされます。</div><p>Nodeの状態は、Nodeリソースの<code>.status</code>の一部として表現されます。例えば、正常なノードの場合は以下のようなjson構造が表示されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Ready conditionが<code>pod-eviction-timeout</code>(<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>に渡された引数)に設定された時間を超えても<code>Unknown</code>や<code>False</code>のままになっている場合、該当ノード上にあるPodはノードコントローラーによって削除がスケジュールされます。デフォルトの退役のタイムアウトの時間は<strong>5分</strong>です。ノードが到達不能ないくつかの場合においては、APIサーバーが該当ノードのkubeletと疎通できない状態になっています。その場合、APIサーバーがkubeletと再び通信を確立するまでの間、Podの削除を行うことはできません。削除がスケジュールされるまでの間、削除対象のPodは切り離されたノードの上で稼働を続けることになります。</p><p>ノードコントローラーはクラスター内でPodが停止するのを確認するまでは強制的に削除しないようになりました。到達不能なノード上で動いているPodは<code>Terminating</code>または<code>Unknown</code>のステータスになります。Kubernetesが基盤となるインフラストラクチャーを推定できない場合、クラスター管理者は手動でNodeオブジェクトを削除する必要があります。KubernetesからNodeオブジェクトを削除すると、そのノードで実行されているすべてのPodオブジェクトがAPIサーバーから削除され、それらの名前が解放されます。</p><p>ノードのライフサイクルコントローラーがconditionを表した<a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>taint</a>を自動的に生成します。
スケジューラーがPodをノードに割り当てる際、ノードのtaintを考慮します。Podが許容するtaintは例外です。</p><p>詳細は<a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-nodes-by-condition>条件によるtaintの付与</a>を参照してください。</p><h3 id=capacity>CapacityとAllocatable</h3><p>ノードで利用可能なリソース（CPU、メモリ、およびノードでスケジュールできる最大Pod数）について説明します。</p><p>capacityブロック内のフィールドは、ノードが持っているリソースの合計量を示します。
allocatableブロックは、通常のPodによって消費されるノード上のリソースの量を示します。</p><p>CapacityとAllocatableについて深く知りたい場合は、ノード上でどのように<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>コンピュートリソースが予約されるか</a>を読みながら学ぶことができます。</p><h3 id=info>Info</h3><p>カーネルのバージョン、Kubernetesのバージョン（kubeletおよびkube-proxyのバージョン）、（使用されている場合）Dockerのバージョン、OS名など、ノードに関する一般的な情報です。
この情報はノードからkubeletを通じて取得され、Kubernetes APIに公開されます。</p><h2 id=ハートビート>ハートビート</h2><p>ハートビートは、Kubernetesノードから送信され、ノードが利用可能か判断するのに役立ちます。
以下の２つのハートビートがあります：</p><ul><li>Nodeの<code>.status</code>の更新</li><li><a href=/docs/reference/generated/kubernetes-api/v1.25#lease-v1-coordination-k8s-io>Lease object</a>です。
各ノードは<code>kube-node-lease</code>という<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>に関連したLeaseオブジェクトを持ちます。
Leaseは軽量なリソースで、クラスターのスケールに応じてノードのハートビートにおけるパフォーマンスを改善します。</li></ul><p>kubeletが<code>NodeStatus</code>とLeaseオブジェクトの作成および更新を担当します。</p><ul><li>kubeletは、ステータスに変化があったり、設定した間隔の間に更新がない時に<code>NodeStatus</code>を更新します。<code>NodeStatus</code>更新のデフォルト間隔は５分です。(到達不能の場合のデフォルトタイムアウトである40秒よりもはるかに長いです)</li><li>kubeletは10秒間隔(デフォルトの更新間隔)でLeaseオブジェクトの生成と更新を実施します。Leaseの更新は<code>NodeStatus</code>の更新とは独立されて行われます。Leaseの更新が失敗した場合、kubeletは200ミリ秒から始まり7秒を上限とした指数バックオフでリトライします。</li></ul><h2 id=ノードコントローラー>ノードコントローラー</h2><p>ノード<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>は、ノードのさまざまな側面を管理するKubernetesのコントロールプレーンコンポーネントです。</p><p>ノードコントローラーは、ノードの存続期間中に複数の役割を果たします。1つ目は、ノードが登録されたときにCIDRブロックをノードに割り当てることです（CIDR割り当てがオンになっている場合）。</p><p>2つ目は、ノードコントローラーの内部ノードリストをクラウドの利用可能なマシンのリストと一致させることです。
クラウド環境で実行している場合、ノードに異常があると、ノードコントローラーはクラウドプロバイダーにそのNodeのVMがまだ使用可能かどうかを問い合わせます。
使用可能でない場合、ノードコントローラーはノードのリストから該当ノードを削除します。</p><p>3つ目は、ノードの状態を監視することです。
ノードが到達不能(例えば、ノードがダウンしているなどので理由で、ノードコントローラーがハートビートの受信を停止した場合)になると、ノードコントローラーは、NodeStatusのNodeReady conditionをConditionUnknownに変更する役割があります。その後も該当ノードが到達不能のままであった場合、Graceful Terminationを使って全てのPodを退役させます。デフォルトのタイムアウトは、ConditionUnknownの報告を開始するまで40秒、その後Podの追い出しを開始するまで5分に設定されています。
ノードコントローラーは、<code>--node-monitor-period</code>に設定された秒数ごとに各ノードの状態をチェックします。</p><h4 id=信頼性>信頼性</h4><p>ほとんどの場合、排除の速度は1秒あたり<code>--node-eviction-rate</code>に設定された数値（デフォルトは秒間0.1）です。つまり、10秒間に1つ以上のPodをノードから追い出すことはありません。</p><p>特定のアベイラビリティーゾーン内のノードのステータスが異常になると、ノード排除の挙動が変わります。ノードコントローラーは、ゾーン内のノードの何%が異常（NodeReady条件がConditionUnknownまたはConditionFalseである）であるかを同時に確認します。
異常なノードの割合が少なくとも <code>--healthy-zone-threshold</code>に設定した値を下回る場合（デフォルトは0.55）であれば、退役率は低下します。クラスターが小さい場合（すなわち、 <code>--large-cluster-size-threshold</code>の設定値よりもノード数が少ない場合。デフォルトは50）、退役は停止し、そうでない場合、退役率は秒間で<code>--secondary-node-eviction-rate</code>の設定値（デフォルトは0.01）に減少します。
これらのポリシーがアベイラビリティーゾーンごとに実装されているのは、1つのアベイラビリティーゾーンがマスターから分割される一方、他のアベイラビリティーゾーンは接続されたままになる可能性があるためです。
クラスターが複数のクラウドプロバイダーのアベイラビリティーゾーンにまたがっていない場合、アベイラビリティーゾーンは1つだけです（クラスター全体）。</p><p>ノードを複数のアベイラビリティゾーンに分散させる主な理由は、1つのゾーン全体が停止したときにワークロードを正常なゾーンに移動できることです。
したがって、ゾーン内のすべてのノードが異常である場合、ノードコントローラーは通常のレート <code>--node-eviction-rate</code>で退役します。
コーナーケースは、すべてのゾーンが完全にUnhealthyである（すなわち、クラスタ内にHealthyなノードがない）場合です。
このような場合、ノードコントローラーはマスター接続に問題があると見なし、接続が回復するまですべての退役を停止します。</p><p>ノードコントローラーは、Podがtaintを許容しない場合、 <code>NoExecute</code>のtaintを持つノード上で実行されているPodを排除する責務もあります。
さらに、ノードコントローラーはノードに到達できない、または準備ができていないなどのノードの問題に対応する<a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taint>taint</a>を追加する責務があります。これはスケジューラーが、問題のあるノードにPodを配置しない事を意味しています。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> <code>kubectl cordon</code>はノードに'unschedulable'としてマークします。それはロードバランサーのターゲットリストからノードを削除するという
サービスコントローラーの副次的な効果をもたらします。これにより、ロードバランサトラフィックの流入をcordonされたノードから効率的に除去する事ができます。</div><h3 id=ノードのキャパシティ>ノードのキャパシティ</h3><p>Nodeオブジェクトはノードのリソースキャパシティ（CPUの数とメモリの量）を監視します。
<a href=#self-registration-of-nodes>自己登録</a>したノードは、Nodeオブジェクトを作成するときにキャパシティを報告します。
<a href=#manual-node-administration>手動によるノード管理</a>を実行している場合は、ノードを追加するときにキャパシティを設定する必要があります。</p><p>Kubernetes<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=スケジューラー>スケジューラー</a>は、ノード上のすべてのPodに十分なリソースがあることを確認します。スケジューラーは、ノード上のコンテナが要求するリソースの合計がノードキャパシティ以下であることを確認します。
これは、kubeletによって管理されたすべてのコンテナを含みますが、コンテナランタイムによって直接開始されたコンテナやkubeletの制御外で実行されているプロセスは含みません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Pod以外のプロセス用にリソースを明示的に予約したい場合は、<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>Systemデーモン用にリソースを予約</a>を参照してください。</div><h2 id=ノードのトポロジー>ノードのトポロジー</h2><p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><code>TopologyManager</code>の<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にすると、
kubeletはリソースの割当を決定する際にトポロジーのヒントを利用できます。
詳細は、<a href=/ja/docs/tasks/administer-cluster/topology-manager/>ノードのトポロジー管理ポリシーを制御する</a>を参照してください。</p><h2 id=graceful-node-shutdown>ノードの正常終了</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code></div><p>kubeletは、ノードのシステムシャットダウンを検出すると、ノード上で動作しているPodを終了させます。</p><p>Kubelet は、ノードのシャットダウン時に、ポッドが通常の<a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>通常のポッド終了プロセス</a>に従うようにします。</p><p>Graceful Node Shutdownはsystemdに依存しているため、<a href=https://www.freedesktop.org/wiki/Software/systemd/inhibit/>systemd inhibitor locks</a>を
利用してノードのシャットダウンを一定時間遅らせることができます。</p><p>Graceful Node Shutdownは、v1.21でデフォルトで有効になっている<code>GracefulNodeShutdown</code> <a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>で制御されます。</p><p>なお、デフォルトでは、後述の設定オプション<code>ShutdownGracePeriod</code>および<code>ShutdownGracePeriodCriticalPods</code>の両方がゼロに設定されているため、Graceful node shutdownは有効になりません。この機能を有効にするには、この2つのkubeletの設定を適切に設定し、ゼロ以外の値を設定する必要があります。</p><p>Graceful shutdownでは、kubeletは以下の2段階でPodを終了させます。</p><ol><li>そのノード上で動作している通常のPodを終了させます。</li><li>そのノード上で動作している<a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>を終了させます。</li></ol><p>Graceful Node Shutdownには、2つの<a href=/docs/tasks/administer-cluster/kubelet-config-file/><code>KubeletConfiguration</code></a>オプションを設定します。:</p><ul><li><code>ShutdownGracePeriod</code>:<ul><li>ノードがシャットダウンを遅らせるべき合計期間を指定します。これは、通常のPodと<a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>の両方のPod終了の合計猶予期間です。</li></ul></li><li><code>ShutdownGracePeriodCriticalPods</code>:<ul><li>ノードのシャットダウン時に<a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>critical pods</a>を終了させるために使用する期間を指定します。この値は、ShutdownGracePeriodよりも小さくする必要があります。</li></ul></li></ul><p>例えば、<code>ShutdownGracePeriod=30s</code>、<code>ShutdownGracePeriodCriticalPods=10s</code>とすると、
kubeletはノードのシャットダウンを30秒遅らせます。シャットダウンの間、最初の20(30-10)秒は通常のポッドを優雅に終了させるために確保され、
残りの10秒は重要なポッドを終了させるために確保されることになります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>Graceful Node Shutdown中にPodが退避された場合、それらのPodの<code>.status</code>は<code>Failed</code>になります。
<code>kubectl get pods</code>を実行すると、退避させられたPodのステータスが <code>Shutdown</code> と表示されます。
また、<code>kubectl describe pod</code>を実行すると、ノードのシャットダウンのためにPodが退避されたことがわかります。</p><pre tabindex=0><code>Status:         Failed
Reason:         Shutdown
Message:        Node is shutting, evicting pods
</code></pre><p>失敗したポッドオブジェクトは、明示的に削除されるか、<a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>GCによってクリーンアップ</a>されるまで保存されます。
これは、ノードが突然終了した場合とは異なった振る舞いです。</p></div><h2 id=swap-memory>スワップメモリの管理</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code></div><p>Kubernetes 1.22以前では、ノードはスワップメモリの使用をサポートしておらず、ノード上でスワップが検出された場合、
kubeletはデフォルトで起動に失敗していました。1.22以降では、スワップメモリのサポートをノードごとに有効にすることができます。</p><p>ノードでスワップを有効にするには、kubeletの <code>NodeSwap</code> <a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にし、
<code>--fail-swap-on</code>コマンドラインフラグまたは<code>failSwapOn</code><a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a>を false に設定する必要があります。</p><p>ユーザーはオプションで、ノードがスワップメモリをどのように使用するかを指定するために、<code>memorySwap.swapBehavior</code>を設定することもできます。ノードがスワップメモリをどのように使用するかを指定します。例えば、以下のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>memorySwap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>swapBehavior</span>:<span style=color:#bbb> </span>LimitedSwap<span style=color:#bbb>
</span></span></span></code></pre></div><p>swapBehaviorで使用できる設定オプションは以下の通りです。:</p><ul><li><code>LimitedSwap</code>: Kubernetesのワークロードが、使用できるスワップ量に制限を設けます。Kubernetesが管理していないノード上のワークロードは、依然としてスワップを使用できます。</li><li><code>UnlimitedSwap</code>: Kubernetesのワークロードが使用できるスワップ量に制限を設けません。システムの限界まで、要求されただけのスワップメモリを使用することができます。</li></ul><p><code>memorySwap</code>の設定が指定されておらず、<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>が有効な場合、デフォルトのkubeletは<code>LimitedSwap</code>の設定と同じ動作を適用します。</p><p><code>LimitedSwap</code>設定の動作は、ノードがコントロールグループ(「cgroups」とも呼ばれる)のv1とv2のどちらで動作しているかによって異なります。</p><p>Kubernetesのワークロードでは、メモリとスワップを組み合わせて使用することができ、ポッドのメモリ制限が設定されている場合はその制限まで使用できます。</p><ul><li><strong>cgroupsv1:</strong> Kubernetesのワークロードは、メモリとスワップを組み合わせて使用することができ、ポッドのメモリ制限が設定されている場合はその制限まで使用できます。</li><li><strong>cgroupsv2:</strong> Kubernetesのワークロードは、スワップメモリを使用できません。</li></ul><p>詳しくは、<a href=https://github.com/kubernetes/enhancements/issues/2400>KEP-2400</a>と
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2400-node-swap/README.md>design proposal</a>をご覧いただき、テストにご協力、ご意見をお聞かせください。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/overview/components/#node-components>ノードコンポーネント</a>について学習する。</li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#node-v1-core>Node APIオブジェクト</a>について読む。</li><li>アーキテクチャ設計文書の<a href=https://git.k8s.io/design-proposals-archive/architecture/architecture.md#the-kubernetes-node>Node</a>という章を読む。</li><li><a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>TaintとToleration</a>について読む。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0251def6da29b30afebfb04549f1703>2 - ノードとコントロールプレーン間の通信</h1><p>本ドキュメントは、APIサーバーとKubernetesクラスター間の通信経路をまとめたものです。
その目的は、信頼できないネットワーク上(またはクラウドプロバイダー上の完全なパブリックIP)でクラスターが実行できるよう、ユーザーがインストールをカスタマイズしてネットワーク構成を強固にできるようにすることです。</p><h2 id=node-to-control-plane>ノードからコントロールプレーンへの通信</h2><p>Kubernetesには「ハブアンドスポーク」というAPIパターンがあります。ノード(またはノードが実行するPod)からのすべてのAPIの使用は、APIサーバーで終了します。他のコントロールプレーンコンポーネントは、どれもリモートサービスを公開するようには設計されていません。APIサーバーは、1つ以上の形式のクライアント<a href=/ja/docs/reference/access-authn-authz/authentication/>認証</a>が有効になっている状態で、セキュアなHTTPSポート(通常は443)でリモート接続をリッスンするように設定されています。
特に<a href=/ja/docs/reference/access-authn-authz/authentication/#anonymous-requests>匿名リクエスト</a>や<a href=/ja/docs/reference/access-authn-authz/authentication/#service-account-token>サービスアカウントトークン</a>が許可されている場合は、1つ以上の<a href=/docs/reference/access-authn-authz/authorization/>認可</a>形式を有効にする必要があります。</p><p>ノードは、有効なクライアント認証情報とともに、APIサーバーに安全に接続できるように、クラスターのパブリックルート証明書でプロビジョニングされる必要があります。適切なやり方は、kubeletに提供されるクライアント認証情報が、クライアント証明書の形式であることです。kubeletクライアント証明書の自動プロビジョニングについては、<a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLSブートストラップ</a>を参照してください。</p><p>APIサーバーに接続したいPodは、サービスアカウントを利用することで、安全に接続することができます。これにより、Podのインスタンス化時に、Kubernetesはパブリックルート証明書と有効なBearerトークンを自動的にPodに挿入します。
<code>kubernetes</code>サービス(<code>デフォルト</code>の名前空間)は、APIサーバー上のHTTPSエンドポイントに(<code>kube-proxy</code>経由で)リダイレクトされる仮想IPアドレスで構成されます。</p><p>また、コントロールプレーンのコンポーネントは、セキュアなポートを介してAPIサーバーとも通信します。</p><p>その結果、ノードやノード上で動作するPodからコントロールプレーンへの接続は、デフォルトでセキュアであり、信頼されていないネットワークやパブリックネットワークを介して実行することができます。</p><h2 id=control-plane-to-node>コントロールプレーンからノードへの通信</h2><p>コントロールプレーン(APIサーバー)からノードへの主要な通信経路は2つあります。
1つ目は、APIサーバーからクラスター内の各ノードで実行されるkubeletプロセスへの通信経路です。
2つ目は、APIサーバーの <em>プロキシー</em> 機能を介した、APIサーバーから任意のノード、Pod、またはサービスへの通信経路です。</p><h3 id=api-server-to-kubelet>APIサーバーからkubeletへの通信</h3><p>APIサーバーからkubeletへの接続は、以下の目的で使用されます:</p><ul><li>Podのログの取得。</li><li>実行中のPodへのアタッチ(通常は<code>kubectl</code>を使用)。</li><li>kubeletのポート転送機能の提供。</li></ul><p>これらの接続は、kubeletのHTTPSエンドポイントで終了します。デフォルトでは、APIサーバーはkubeletのサービング証明書を検証しないため、接続は中間者攻撃の対象となり、信頼されていないネットワークやパブリックネットワークを介して実行するのは<strong>安全ではありません</strong>。</p><p>この接続を検証するには、<code>--kubelet-certificate-authority</code>フラグを使用して、kubeletのサービング証明書を検証するために使用するルート証明書バンドルを、APIサーバーに提供します。</p><p>それができない場合は、信頼できないネットワークやパブリックネットワークを介した接続を回避するため、必要に応じてAPIサーバーとkubeletの間で<a href=#ssh-tunnels>SSHトンネル</a>を使用します。</p><p>最後に、kubelet APIを保護するために、<a href=/docs/reference/access-authn-authz/kubelet-authn-authz/>Kubelet認証/認可</a>を有効にする必要があります。</p><h3 id=api-server-to-nodes-pods-and-services>APIサーバーからノード、Pod、サービスへの通信</h3><p>APIサーバーからノード、Pod、またはサービスへの接続は、デフォルトで平文のHTTP接続になるため、認証も暗号化もされません。API URL内のノード、Pod、サービス名に<code>https:</code>を付けることで、セキュアなHTTPS接続を介して実行できますが、HTTPSエンドポイントから提供された証明書を検証したり、クライアント認証情報を提供したりすることはありません。そのため、接続の暗号化はされますが、完全性の保証はありません。これらの接続を、信頼されていないネットワークやパブリックネットワークを介して実行するのは、<strong>現在のところ安全ではありません</strong>。</p><h3 id=ssh-tunnels>SSHトンネル</h3><p>Kubernetesは、コントロールプレーンからノードへの通信経路を保護するために、SSHトンネルをサポートしています。この構成では、APIサーバーがクラスター内の各ノードへのSSHトンネルを開始(ポート22でリッスンしているSSHサーバーに接続)し、kubelet、ノード、Pod、またはサービス宛てのすべてのトラフィックをトンネル経由で渡します。
このトンネルにより、ノードが稼働するネットワークの外部にトラフィックが公開されないようになります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> SSHトンネルは現在非推奨であるため、自分が何をしているのか理解していないのであれば、使用すべきではありません。この通信経路の代替となるものとして、<a href=#konnectivity-service>Konnectivityサービス</a>があります。</div><h3 id=konnectivity-service>Konnectivityサービス</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>SSHトンネルの代替として、Konnectivityサービスは、コントロールプレーンからクラスターへの通信に、TCPレベルのプロキシーを提供します。Konnectivityサービスは、コントロールプレーンネットワークのKonnectivityサーバーと、ノードネットワークのKonnectivityエージェントの、2つの部分で構成されています。
Konnectivityエージェントは、Konnectivityサーバーへの接続を開始し、ネットワーク接続を維持します。
Konnectivityサービスを有効にすると、コントロールプレーンからノードへのトラフィックは、すべてこの接続を経由するようになります。</p><p><a href=/docs/tasks/extend-kubernetes/setup-konnectivity/>Konnectivityサービスのセットアップ</a>に従って、クラスターにKonnectivityサービスをセットアップしてください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>3 - コントローラー</h1><p>ロボット工学やオートメーションの分野において、 <em>制御ループ</em> とは、あるシステムの状態を制御する終了状態のないループのことです。</p><p>ここでは、制御ループの一例として、部屋の中にあるサーモスタットを挙げます。</p><p>あなたが温度を設定すると、それはサーモスタットに <em>目的の状態(desired state)</em> を伝えることになります。実際の部屋の温度は <em>現在の状態</em> です。サーモスタットは、装置をオンまたはオフにすることによって、現在の状態を目的の状態に近づけるように動作します。</p>Kubernetesにおいて、コントローラーは<a class=glossary-tooltip title=コンテナ化されたアプリケーションを実行する、ノードと呼ばれるワーカーマシンの集合です。すべてのクラスターには少なくとも1つのワーカーノードがあります。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=クラスター>クラスター</a>の状態を監視し、必要に応じて変更を加えたり要求したりする制御ループです。それぞれのコントローラーは現在のクラスターの状態を望ましい状態に近づけるように動作します。<h2 id=コントローラーパターン>コントローラーパターン</h2><p>コントローラーは少なくとも1種類のKubernetesのリソースを監視します。これらの<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>オブジェクト</a>には目的の状態を表すspecフィールドがあります。リソースのコントローラーは、現在の状態を目的の状態に近づける責務を持ちます。</p><p>コントローラーは自分自身でアクションを実行する場合もありますが、Kubernetesではコントローラーが<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>に意味のある副作用を持つメッセージを送信することが一般的です。以下では、このような例を見ていきます。</p><h3 id=apiサーバー経由でコントロールする>APIサーバー経由でコントロールする</h3><p><a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>コントローラーはKubernetesのビルトインのコントローラーの一例です。ビルトインのコントローラーは、クラスターのAPIサーバーとやりとりをして状態を管理します。</p><p>Jobは、1つ以上の<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>を起動して、タスクを実行した後に停止する、Kubernetesのリソースです。</p><p>(1度<a href=/ja/docs/concepts/scheduling-eviction/>スケジュール</a>されると、Podオブジェクトはkubeletに対する目的の状態の一部になります。)</p><p>Jobコントローラーが新しいタスクを見つけると、その処理が完了するように、クラスター上のどこかで、一連のNode上のkubeletが正しい数のPodを実行することを保証します。ただし、Jobコントローラーは、自分自身でPodやコンテナを実行することはありません。代わりに、APIサーバーに対してPodの作成や削除を依頼します。<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>上の他のコンポーネントが(スケジュールして実行するべき新しいPodが存在するという)新しい情報を基に動作することによって、最終的に目的の処理が完了します。</p><p>新しいJobが作成されたとき、目的の状態は、そのJobが完了することです。JobコントローラーはそのJobに対する現在の状態を目的の状態に近づけるようにします。つまり、そのJobが行ってほしい処理を実行するPodを作成し、Jobが完了に近づくようにします。</p><p>コントローラーは、コントローラーを設定するオブジェクトも更新します。たとえば、あるJobが完了した場合、Jobコントローラーは、Jobオブジェクトに<code>Finished</code>というマークを付けます。</p><p>(これは、部屋が設定温度になったことを示すために、サーモスタットがランプを消灯するのに少し似ています。)</p><h3 id=直接的なコントロール>直接的なコントロール</h3><p>Jobとは対照的に、クラスターの外部に変更を加える必要があるコントローラーもあります。</p><p>たとえば、クラスターに十分な数の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>が存在することを保証する制御ループの場合、そのコントローラーは、必要に応じて新しいNodeをセットアップするために、現在のクラスターの外部とやりとりをする必要があります。</p><p>外部の状態とやりとりをするコントローラーは、目的の状態をAPIサーバーから取得した後、外部のシステムと直接通信し、現在の状態を目的の状態に近づけます。</p><p>(クラスター内のノードを水平にスケールさせる<a href=https://github.com/kubernetes/autoscaler/>コントローラー</a>が実際に存在します。)</p><p>ここで重要な点は、コントローラーが目的の状態を実現するために変更を加えてから、現在の状態をクラスターのAPIサーバーに報告することです。他の制御ループは、その報告されたデータを監視し、独自のアクションを実行できます。</p><p>サーモスタットの例では、部屋が非常に寒い場合、別のコントローラーが霜防止ヒーターをオンにすることもあります。Kubernetesクラスターを使用すると、コントロールプレーンは、<a href=/ja/docs/concepts/extend-kubernetes/>Kubernetesを拡張して</a>実装することにより、IPアドレス管理ツールやストレージサービス、クラウドプロバイダーAPI、およびその他のサービスと間接的に連携します。</p><h2 id=desired-vs-current>目的の状態 vs 現在の状態</h2><p>Kubernetesはシステムに対してクラウドネイティブな見方をするため、常に変化し続けるような状態を扱えるように設計されています。</p><p>処理を実行したり、制御ループが故障を自動的に修正したりしているどの時点でも、クラスターは変化中である可能性があります。つまり、クラスターは決して安定した状態にならない可能性があるということです。</p><p>コントローラーがクラスターのために実行されていて、有用な変更が行われるのであれば、全体的な状態が安定しているかどうかは問題にはなりません。</p><h2 id=設計>設計</h2><p>設計理念として、Kubernetesは多数のコントローラーを使用しており、各コントローラーはクラスターの状態の特定の側面をそれぞれ管理しています。最もよくあるパターンは、特定の制御ループ(コントローラー)が目的の状態として1種類のリソースを使用し、目的の状態を実現することを管理するために別の種類のリソースを用意するというものです。たとえば、Jobのコントローラーは、Jobオブジェクト(新しい処理を見つけるため)およびPodオブジェクト(Jobを実行し、処理が完了したか確認するため)を監視します。この場合、なにか別のものがJobを作成し、JobコントローラーはPodを作成します。</p><p>相互にリンクされた単一のモノリシックな制御ループよりは、複数の単純なコントローラーが存在する方が役に立ちます。コントローラーは故障することがあるため、Kubernetesは故障を許容するように設計されています。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>同じ種類のオブジェクトを作成または更新するコントローラーが、複数存在する場合があります。実際には、Kubernetesコントローラーは、自分が制御するリソースに関連するリソースにのみ注意を払うように作られています。</p><p>たとえば、DeploymentとJobがありますが、これらは両方ともPodを作成するものです。しかし、JobコントローラーはDeploymentが作成したPodを削除することはありません。各コントローラーが2つのPodを区別できる情報(<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>)が存在するためです。</p></div><h2 id=running-controllers>コントローラーを実行する方法</h2><p>Kubernetesには、<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>内部で動作する一組のビルトインのコントローラーが用意されています。これらビルトインのコントローラーは、コアとなる重要な振る舞いを提供します。</p><p>DeploymentコントローラーとJobコントローラーは、Kubernetes自体の一部として同梱されているコントローラーの例です(それゆえ「ビルトイン」のコントローラーと呼ばれます)。Kubernetesは回復性のあるコントロールプレーンを実行できるようにしているため、ビルトインのコントローラーの一部が故障しても、コントロールプレーンの別の部分が作業を引き継いでくれます。</p><p>Kubernetesを拡張するためにコントロールプレーンの外で動作するコントローラーもあります。もし望むなら、新しいコントローラーを自分で書くこともできます。自作のコントローラーをPodセットとして動作させたり、Kubernetesの外部で動作させることもできます。どのような動作方法が最も適しているかは、そのコントローラーがどのようなことを行うのかに依存します。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/#kubernetes-control-plane>Kubernetesコントロールプレーン</a>について読む</li><li>基本的な<a href=/ja/docs/concepts/#kubernetes-objects>Kubernetesオブジェクト</a>について学ぶ</li><li><a href=/ja/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>について学ぶ</li><li>自分でコントローラーを書きたい場合は、「Kubernetesを拡張する」の<a href=/ja/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>エクステンションパターン</a>を読んでください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>4 - クラウドコントローラーマネージャー</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>クラウドインフラストラクチャー技術により、パブリック、プライベート、ハイブリッドクラウド上でKubernetesを動かすことができます。Kubernetesは、コンポーネント間の密なつながりが不要な自動化されたAPI駆動インフラストラクチャーを信条としています。</p><p><p>cloud-controller-managerは クラウド特有の制御ロジックを組み込むKubernetesの<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>コンポーネントです。クラウドコントロールマネージャーは、クラスターをクラウドプロバイダーAPIをリンクし、クラスタのみで相互作用するコンポーネントからクラウドプラットフォームで相互作用するコンポーネントを分離します。</p></p><p>Kubernetesと下のクラウドインフラストラクチャー間の相互運用ロジックを分離することで、cloud-controller-managerコンポーネントはクラウドプロバイダを主なKubernetesプロジェクトと比較し異なるペースで機能をリリース可能にします。</p><p>cloud-controller-managerは、プラグイン機構を用い、異なるクラウドプロバイダーに対してそれぞれのプラットフォームとKubernetesの結合を可能にする構成になっています。</p><h2 id=設計>設計</h2><p><img src=/images/docs/components-of-kubernetes.svg alt=Kubernetesのコンポーネント></p><p>クラウドコントローラーマネージャーは、複製されたプロセスの集合としてコントロールプレーンで実行されます。（通常、Pod内のコンテナとなります）各cloud-controller-managerは、シングルプロセスで複数の<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a>を実装します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> コントロールプレーンの一部ではなく、Kubernetesの<a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=addon>addon</a>としてクラウドコントローラーマネージャーを実行することもできます。</div><h2 id=functions-of-the-ccm>クラウドコントローラーマネージャーの機能</h2><p>クラウドコントローラーマネージャーのコントローラーは以下を含んでいます。</p><h4 id=ノードコントローラー>ノードコントローラー</h4><p>ノードコントローラーは、クラウドインフラストラクチャーで新しいサーバーが作成された際に、<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>オブジェクトを作成する責務を持ちます。ノードコントローラーは、クラウドプロバイダーのテナント内で動作しているホストの情報を取得します。ノードコントローラーは下記に示す機能を実行します:</p><ol><li>Nodeオブジェクトを、コントローラーがクラウドプロバイダーAPIを通じて見つけた各サーバーで初期化する</li><li>Nodeオブジェクトに、ノードがデプロイされているリージョンや利用可能なリソース（CPU、メモリなど）のようなクラウド特有な情報を注釈付けやラベル付けをする</li><li>ノードのホスト名とネットワークアドレスを取得する</li><li>ノードの正常性を検証する。ノードが応答しなくなった場合、クラウドプロバイダーのAPIを利用しサーバーがdeactivated / deleted / terminatedであるかを確認する。クラウドからノードが削除されていた場合、KubernetesクラスターからNodeオブジェクトを削除する</li></ol><p>いくつかのクラウドプロバイダーは、これをノードコントローラーと個別のノードライフサイクルコントローラーに分けて実装しています。</p><h4 id=ルートコントローラー>ルートコントローラー</h4><p>ルートコントローラーは、クラスタ内の異なるノード上で稼働しているコンテナが相互に通信できるように、クラウド内のルートを適切に設定する責務を持ちます。</p><p>クラウドプロバイダーによっては、ルートコントローラーはPodネットワークのIPアドレスのブロックを割り当てることもあります。</p><h4 id=サービスコントローラー>サービスコントローラー</h4><p><a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Services>Services</a>は、マネージドロードバランサー、IPアドレスネットワークパケットフィルタや対象のヘルスチェックのようなクラウドインフラストラクチャーコンポーネントのインテグレーションを行います。サービスコントローラーは、ロードバランサーや他のインフラストラクチャーコンポーネントを必要とするServiceリソースを宣言する際にそれらのコンポーネントを設定するため、クラウドプロバイダーのAPIと対話します。</p><h2 id=認可>認可</h2><p>このセクションでは、クラウドコントローラーマネージャーが操作を行うために様々なAPIオブジェクトに必要な権限を分類します。</p><h3 id=authorization-node-controller>ノードコントローラー</h3><p>ノードコントローラーはNodeオブジェクトのみに対して働きます。Nodeオブジェクトに対して、readとmodifyの全権限が必要です。</p><p><code>v1/Node</code>:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=authorization-route-controller>ルートコントローラー</h3><p>ルートコントローラーは、Nodeオブジェクトの作成を待ち受け、ルートを適切に設定します。Nodeオブジェクトについて、get権限が必要です。</p><p><code>v1/Node</code>:</p><ul><li>Get</li></ul><h3 id=authorization-service-controller>サービスコントローラー</h3><p>サービスコントローラーは、Serviceオブジェクトの作成、更新、削除イベントを待ち受け、その後、サービスのEndpointを適切に設定します。</p><p>サービスにアクセスするため、list、watchの権限が必要です。サービスを更新するため、patch、updateの権限が必要です。</p><p>サービスのEndpointリソースを設定するため、create、list、get、watchそしてupdateの権限が必要です。</p><p><code>v1/Service</code>:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=authorization-miscellaneous>その他</h3><p>クラウドコントローラーマネージャーのコア機能の実装は、Eventオブジェクトのcreate権限と、セキュアな処理を保証するため、ServiceAccountのcreate権限が必要です。</p><p><code>v1/Event</code>:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p><code>v1/ServiceAccount</code>:</p><ul><li>Create</li></ul><p>クラウドコントローラーマネージャーの<a class=glossary-tooltip title='Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a> ClusterRoleはこのようになります:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=次の項目>次の項目</h2><p><a href=/ja/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>Cloud Controller Manager Administration</a>
はクラウドコントラーマネージャーの実行と管理を説明しています。</p><p>どのようにあなた自身のクラウドコントローラーマネージャーが実装されるのか、もしくは既存プロジェクトの拡張について知りたいですか？</p><p>クラウドコントローラーマネージャーは、いかなるクラウドからもプラグインとしての実装を許可するためにGoインターフェースを使います。具体的には、<a href=https://github.com/kubernetes/cloud-provider>kubernetes/cloud-provider</a>の <a href=https://github.com/kubernetes/cloud-provider/blob/release-1.21/cloud.go#L42-L69><code>cloud.go</code></a>で定義されている<code>CloudProvider</code>を使います。</p><p>本ドキュメントでハイライトした共有コントローラー（Node、Route、Service）の実装と共有クラウドプロバイダーインターフェースに沿ったいくつかの足場は、Kubernetesコアの一部です。クラウドプロバイダに特化した実装は、Kubernetesのコアの外部として、また<code>CloudProvider</code>インターフェースを実装します。</p><p>プラグイン開発ついての詳細な情報は、<a href=/ja/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Developing Cloud Controller Manager</a>を見てください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-44a2e2e592af0846101e970aff9243e5>5 - ガベージコレクション</h1><p>ガベージコレクションは、Kubernetesがクラスターリソースをクリーンアップするために使用するさまざまなメカニズムの総称です。これにより、次のようなリソースのクリーンアップが可能になります:</p><ul><li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>終了したPod</a></li><li><a href=/ja/docs/concepts/workloads/controllers/ttlafterfinished/>完了したJob</a></li><li><a href=#owners-dependents>owner referenceのないオブジェクト</a></li><li><a href=#containers-images>未使用のコンテナとコンテナイメージ</a></li><li><a href=/ja/docs/concepts/storage/persistent-volumes/#delete>StorageClassの再利用ポリシーがDeleteである動的にプロビジョニングされたPersistentVolume</a></li><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process>失効または期限切れのCertificateSigningRequests (CSRs)</a></li><li>次のシナリオで削除された<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>:<ul><li>クラウド上でクラスターが<a href=/ja/docs/concepts/architecture/cloud-controller/>クラウドコントローラーマネージャー</a>を使用する場合</li><li>オンプレミスでクラスターがクラウドコントローラーマネージャーと同様のアドオンを使用する場合</li></ul></li><li><a href=/ja/docs/concepts/architecture/nodes/#heartbeats>Node Leaseオブジェクト</a></li></ul><h2 id=owners-dependents>オーナーの依存関係</h2><p>Kubernetesの多くのオブジェクトは、<a href=/docs/concepts/overview/working-with-objects/owners-dependents/><em>owner reference</em></a>を介して相互にリンクしています。
owner referenceは、どのオブジェクトが他のオブジェクトに依存しているかをコントロールプレーンに通知します。
Kubernetesは、owner referenceを使用して、コントロールプレーンやその他のAPIクライアントに、オブジェクトを削除する前に関連するリソースをクリーンアップする機会を提供します。
ほとんどの場合、Kubernetesはowner referenceを自動的に管理します。</p><p>Ownershipは、一部のリソースでも使用される<a href=/docs/concepts/overview/working-with-objects/labels/>ラベルおよびセレクター</a>メカニズムとは異なります。
たとえば、<code>EndpointSlice</code>オブジェクトを作成する<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を考えます。
Serviceは<em>ラベル</em>を使用して、コントロールプレーンがServiceに使用されている<code>EndpointSlice</code>オブジェクトを判別できるようにします。
ラベルに加えて、Serviceに代わって管理される各<code>EndpointSlice</code>には、owner referenceがあります。
owner referenceは、Kubernetesのさまざまな部分が制御していないオブジェクトへの干渉を回避するのに役立ちます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>namespace間のowner referenceは、設計上許可されていません。
namespaceの依存関係は、クラスタースコープまたはnamespaceのオーナーを指定できます。
namespaceのオーナーは、依存関係と同じnamespaceに<strong>存在する必要があります</strong>。
そうでない場合、owner referenceは不在として扱われ、すべてのオーナーが不在であることが確認されると、依存関係は削除される可能性があります。</p><p>クラスタースコープの依存関係は、クラスタースコープのオーナーのみを指定できます。
v1.20以降では、クラスタースコープの依存関係がnamespaceを持つkindをオーナーとして指定している場合、それは解決できないowner referenceを持つものとして扱われ、ガベージコレクションを行うことはできません。</p><p>V1.20以降では、ガベージコレクタは無効な名前空間間の<code>ownerReference</code>、またはnamespaceのkindを参照する<code>ownerReference</code>をもつクラスター・スコープの依存関係を検出した場合、無効な依存関係の<code>OwnerRefInvalidNamespace</code>と<code>involvedObject</code>を理由とする警告イベントが報告されます。
以下のコマンドを実行すると、そのようなイベントを確認できます。
<code>kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace</code></p></div><h2 id=cascading-deletion>カスケード削除</h2><p>Kubernetesは、ReplicaSetを削除したときに残されたPodなど、owner referenceがなくなったオブジェクトをチェックして削除します。
オブジェクトを削除する場合、カスケード削除と呼ばれるプロセスで、Kubernetesがオブジェクトの依存関係を自動的に削除するかどうかを制御できます。
カスケード削除には、次の2つのタイプがあります。</p><ul><li>フォアグラウンドカスケード削除</li><li>バックグラウンドカスケード削除</li></ul><p>また、Kubernetes <a class=glossary-tooltip title='A namespaced key that tells Kubernetes to wait until specific conditions are met before it fully deletes an object marked for deletion.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=finalizer>finalizer</a>を使用して、ガベージコレクションがowner referenceを持つリソースを削除する方法とタイミングを制御することもできます。</p><h3 id=foreground-deletion>フォアグラウンドカスケード削除</h3><p>フォアグラウンドカスケード削除では、削除するオーナーオブジェクトは最初に<em>削除進行中</em>の状態になります。
この状態では、オーナーオブジェクトに次のことが起こります。</p><ul><li>Kubernetes APIサーバーは、オブジェクトの<code>metadata.deletionTimestamp</code>フィールドを、オブジェクトに削除のマークが付けられた時刻に設定します。</li><li>Kubernetes APIサーバーは、<code>metadata.finalizers</code>フィールドを<code>foregroundDeletion</code>に設定します。</li><li>オブジェクトは、削除プロセスが完了するまで、KubernetesAPIを介して表示されたままになります。</li></ul><p>オーナーオブジェクトが削除進行中の状態に入ると、コントローラーは依存関係を削除します。
すべての依存関係オブジェクトを削除した後、コントローラーはオーナーオブジェクトを削除します。
この時点で、オブジェクトはKubernetesAPIに表示されなくなります。</p><p>フォアグラウンドカスケード削除中に、オーナーの削除をブロックする依存関係は、<code>ownerReference.blockOwnerDeletion=true</code>フィールドを持つ依存関係のみです。
詳細については、<a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-foreground-cascading-deletion>フォアグラウンドカスケード削除の使用</a>を参照してください。</p><h3 id=background-deletion>バックグラウンドカスケード削除</h3><p>バックグラウンドカスケード削除では、Kubernetes APIサーバーがオーナーオブジェクトをすぐに削除し、コントローラーがバックグラウンドで依存オブジェクトをクリーンアップします。
デフォルトでは、フォアグラウンド削除を手動で使用するか、依存オブジェクトを孤立させることを選択しない限り、Kubernetesはバックグラウンドカスケード削除を使用します。</p><p>詳細については、<a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-background-cascading-deletion>バックグラウンドカスケード削除の使用</a>を参照してください。</p><h3 id=孤立した依存関係>孤立した依存関係</h3><p>Kubernetesがオーナーオブジェクトを削除すると、残された依存関係は<em>orphan</em>オブジェクトと呼ばれます。
デフォルトでは、Kubernetesは依存関係オブジェクトを削除します。この動作をオーバーライドする方法については、<a href=/docs/tasks/administer-cluster/use-cascading-deletion/#set-orphan-deletion-policy>オーナーオブジェクトと孤立した依存関係の削除</a>を参照してください。</p><h2 id=containers-images>未使用のコンテナとイメージのガベージコレクション</h2><p><a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>は未使用のイメージに対して5分ごとに、未使用のコンテナーに対して1分ごとにガベージコレクションを実行します。
外部のガベージコレクションツールは、kubeletの動作を壊し、存在するはずのコンテナを削除する可能性があるため、使用しないでください。</p><p>未使用のコンテナーとイメージのガベージコレクションのオプションを設定するには、<a href=/docs/tasks/administer-cluster/kubelet-config-file/>設定ファイル</a>を使用してkubeletを調整し、<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration><code>KubeletConfiguration</code></a>リソースタイプを使用してガベージコレクションに関連するパラメーターを変更します。</p><h3 id=コンテナイメージのライフサイクル>コンテナイメージのライフサイクル</h3><p>Kubernetesは、kubeletの一部である<em>イメージマネージャー</em>を通じて、<a class=glossary-tooltip title='Tool that provides understanding of the resource usage and performance characteristics for containers' data-toggle=tooltip data-placement=top href=https://github.com/google/cadvisor/ target=_blank aria-label=cadvisor>cadvisor</a>の協力を得て、すべてのイメージのライフサイクルを管理します。kubeletは、ガベージコレクションを決定する際に、次のディスク使用制限を考慮します。</p><ul><li><code>HighThresholdPercent</code></li><li><code>LowThresholdPercent</code></li></ul><p>設定された<code>HighThresholdPercent</code>値を超えるディスク使用量はガベージコレクションをトリガーします。
ガベージコレクションは、最後に使用された時間に基づいて、最も古いものから順にイメージを削除します。
kubeletは、ディスク使用量が<code>LowThresholdPercent</code>値に達するまでイメージを削除します。</p><h3 id=container-image-garbage-collection>コンテナのガベージコレクション</h3><p>kubeletは、次の変数に基づいて未使用のコンテナをガベージコレクションします。</p><ul><li><code>MinAge</code>: kubeletがガベージコレクションできるコンテナの最低期間。<code>0</code>を設定すると無効化されます。</li><li><code>MaxPerPodContainer</code>: 各Podのペアが持つことができるデッドコンテナの最大数。<code>0</code>未満に設定すると無効化されます。</li><li><code>MaxContainers</code>: クラスターが持つことができるデッドコンテナーの最大数。<code>0</code>未満に設定すると無効化されます。</li></ul><p>これらの変数に加えて、kubeletは、通常、最も古いものから順に、定義されていない削除されたコンテナをガベージコレクションします。</p><p><code>MaxPerPodContainer</code>と<code>MaxContainers</code>は、Podごとのコンテナーの最大数(<code>MaxPerPodContainer</code>)を保持すると、グローバルなデッドコンテナの許容合計(<code>MaxContainers</code>)を超える状況で、互いに競合する可能性があります。
この状況では、kubeletは<code>MaxPerPodContainer</code>を調整して競合に対処します。最悪のシナリオは、<code>MaxPerPodContainer</code>を1にダウングレードし、最も古いコンテナーを削除することです。
さらに、削除されたPodが所有するコンテナは、<code>MinAge</code>より古くなると削除されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> kubeletがガベージコレクションするのは、自分が管理するコンテナのみです。</div><h2 id=configuring-gc>ガベージコレクションの設定</h2><p>これらのリソースを管理するコントローラーに固有のオプションを設定することにより、リソースのガベージコレクションを調整できます。次のページは、ガベージコレクションを設定する方法を示しています。</p><ul><li><a href=/docs/tasks/administer-cluster/use-cascading-deletion/>Kubernetesオブジェクトのカスケード削除の設定</a></li><li><a href=/ja/docs/concepts/workloads/controllers/ttlafterfinished/>完了したジョブのクリーンアップの設定</a></li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/concepts/overview/working-with-objects/owners-dependents/>Kubernetes オブジェクトの所有権</a>を学びます。</li><li>Kubernetes <a href=/docs/concepts/overview/working-with-objects/finalizers/>finalizer</a>を学びます。</li><li>完了したジョブをクリーンアップする<a href=/ja/docs/concepts/workloads/controllers/ttlafterfinished/>TTL controller</a>(beta)について学びます。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0ea5310f52e22c5de34dc84d9ab5e0d>6 - コンテナランタイムインターフェイス(CRI)</h1><p>CRIは、クラスターコンポーネントを再コンパイルすることなく、kubeletがさまざまなコンテナランタイムを使用できるようにするプラグインインターフェイスです。</p><p><a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>が<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>とそのコンテナを起動できるように、クラスター内の各ノードで動作する<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label='container runtime'>container runtime</a>が必要です。</p><p>kubeletとContainerRuntime間の通信のメインプロトコルです。</p><p>Kubernetes Container Runtime Interface(CRI)は、<a href=/ja/docs/concepts/overview/components/#node-components>クラスターコンポーネント</a><a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>と<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label='container runtime'>container runtime</a>間の通信用のメイン<a href=/ja/docs/concepts/overview/components/#node-components>gRPC</a>プロトコルを定義します。</p><h2 id=api>API</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [stable]</code></div><p>kubeletは、gRPCを介してコンテナランタイムに接続するときにクライアントとして機能します。ランタイムおよびイメージサービスエンドポイントは、コンテナランタイムで使用可能である必要があります。コンテナランタイムは、<code>--image-service-endpoint</code>および<code>--container-runtime-endpoint</code><a href=/ja/docs/reference/command-line-tools-reference/kubelet>コマンドラインフラグ</a>を使用して、kubelet内で個別に設定できます。</p><p>Kubernetes v1.25の場合、kubeletはCRI <code>v1</code>の使用を優先します。
コンテナランタイムがCRIの<code>v1</code>をサポートしていない場合、kubeletはサポートされている古いバージョンのネゴシエーションを試みます。
kubelet v1.25はCRI <code>v1alpha2</code>をネゴシエートすることもできますが、このバージョンは非推奨と見なされます。
kubeletがサポートされているCRIバージョンをネゴシエートできない場合、kubeletはあきらめて、ノードとして登録されません。</p><h2 id=アップグレード>アップグレード</h2><p>Kubernetesをアップグレードする場合、kubeletはコンポーネントの再起動時に最新のCRIバージョンを自動的に選択しようとします。
それが失敗した場合、フォールバックは上記のように行われます。
コンテナランタイムがアップグレードされたためにgRPCリダイヤルが必要な場合は、コンテナランタイムも最初に選択されたバージョンをサポートする必要があります。
そうでない場合、リダイヤルは失敗することが予想されます。これには、kubeletの再起動が必要です。</p><h2 id=次の項目>次の項目</h2><ul><li>CRI<a href=https://github.com/kubernetes/cri-api/blob/c75ef5b/pkg/apis/runtime/v1/api.proto>プロトコル定義</a>の詳細を学ぶ。</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>