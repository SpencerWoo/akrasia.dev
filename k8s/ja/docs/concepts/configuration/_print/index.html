<!doctype html><html lang=ja class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/configuration/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/configuration/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/configuration/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/configuration/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/configuration/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/configuration/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/configuration/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/configuration/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/configuration/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/configuration/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/configuration/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>設定 | Kubernetes</title><meta property="og:title" content="設定"><meta property="og:description" content="プロダクショングレードのコンテナ管理基盤"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/configuration/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="設定"><meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary"><meta name=twitter:title content="設定"><meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/configuration/"><meta property="og:title" content="設定"><meta name=twitter:title content="設定"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ja/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ja/docs/>ドキュメント</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/blog/>Blogs</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/training/>トレーニング</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/partners/>パートナー</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/community/>コミュニティ</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/case-studies/>ケーススタディ</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>バージョン</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ja/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/configuration/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/configuration/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/configuration/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/concepts/configuration/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ja/docs/concepts/configuration/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語 (Japanese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/configuration/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/configuration/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/configuration/>한국어 (Korean)</a>
<a class=dropdown-item href=/fr/docs/concepts/configuration/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/configuration/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/configuration/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/configuration/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/configuration/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/configuration/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/configuration/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.</p><p><a href=/ja/docs/concepts/configuration/>このページの通常のビューに戻る</a>.</p></div><h1 class=title>設定</h1><ul><li>1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>設定のベストプラクティス</a></li><li>2: <a href=#pg-6b5ccadd699df0904e8e9917c5450c4b>ConfigMap</a></li><li>3: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>Secret</a></li><li>4: <a href=#pg-436057b96151ecb8a4a9a9f456b5d0fc>コンテナのリソース管理</a></li><li>5: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>kubeconfigファイルを使用してクラスターアクセスを組織する</a></li><li>6: <a href=#pg-ed4ae5e4344d619bc6df6e1278efae74>Podの優先度とプリエンプション</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>1 - 設定のベストプラクティス</h1><p>このドキュメントでは、ユーザーガイド、入門マニュアル、および例を通して紹介されている設定のベストプラクティスを中心に説明します。</p><p>このドキュメントは生ものです。このリストには載っていないが他の人に役立つかもしれない何かについて考えている場合、IssueまたはPRを遠慮なく作成してください。</p><h2 id=一般的な設定のtips>一般的な設定のTips</h2><ul><li><p>構成を定義する際には、最新の安定したAPIバージョンを指定してください。</p></li><li><p>設定ファイルは、クラスターに反映される前にバージョン管理システムに保存されるべきです。これによって、必要に応じて設定変更を迅速にロールバックできます。また、クラスターの再作成や復元時にも役立ちます。</p></li><li><p>JSONではなくYAMLを使って設定ファイルを書いてください。これらのフォーマットはほとんどすべてのシナリオで互換的に使用できますが、YAMLはよりユーザーフレンドリーになる傾向があります。</p></li><li><p>意味がある場合は常に、関連オブジェクトを単一ファイルにグループ化します。多くの場合、1つのファイルの方が管理が簡単です。例として<a href=https://github.com/kubernetes/examples/tree/master/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a>ファイルを参照してください。</p></li><li><p>多くの<code>kubectl</code>コマンドがディレクトリに対しても呼び出せることも覚えておきましょう。たとえば、設定ファイルのディレクトリで <code>kubectl apply</code>を呼び出すことができます。</p></li><li><p>不必要にデフォルト値を指定しないでください。シンプルかつ最小限の設定のほうがエラーが発生しにくくなります。</p></li><li><p>よりよいイントロスペクションのために、オブジェクトの説明をアノテーションに入れましょう。</p></li></ul><h2 id=naked-pods-vs-replicasets-deployments-and-jobs>"真っ裸"のPod に対する ReplicaSet、Deployment、およびJob</h2><ul><li><p>可能な限り、"真っ裸"のPod(<a href=/ja/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>や<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>にバインドされていないPod)は使わないでください。Nodeに障害が発生した場合、これらのPodは再スケジュールされません。</p><p>明示的に<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>restartPolicy: Never</code></a>を使いたいシーンを除いて、DeploymentはPodを直接作成するよりもほとんど常に望ましい方法です。Deploymentには、希望する数のPodが常に使用可能であることを確認するためにReplicaSetを作成したり、Podを置き換えるための戦略(RollingUpdateなど)を指定したりできます。<a href=/docs/concepts/workloads/controllers/job/>Job</a>のほうが適切な場合もあるかもしれません。</p></li></ul><h2 id=service>Service</h2><ul><li><p>対応するバックエンドワークロード（DeploymentまたはReplicaSet）の前、およびそれにアクセスする必要があるワークロードの前に<a href=/ja/docs/concepts/services-networking/service/>Service</a>を作成します。Kubernetesがコンテナを起動すると、コンテナ起動時に実行されていたすべてのServiceを指す環境変数が提供されます。たとえば、fooという名前のServiceが存在する場合、すべてのコンテナは初期環境で次の変数を取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;the host the Service is running on&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;the port the Service is running on&gt;
</span></span></code></pre></div><p><em>これは順序付けの必要性を意味します</em> - <code>Pod</code>がアクセスしたい<code>Service</code>は<code>Pod</code>自身の前に作らなければならず、そうしないと環境変数は注入されません。DNSにはこの制限はありません。</p></li><li><p>（強くお勧めしますが）<a href=/ja/docs/concepts/cluster-administration/addons/>クラスターアドオン</a>の1つの選択肢はDNSサーバーです。DNSサーバーは、新しい<code>Service</code>についてKubernetes APIを監視し、それぞれに対して一連のDNSレコードを作成します。クラスタ全体でDNSが有効になっている場合は、すべての<code>Pod</code>が自動的に<code>Services</code>の名前解決を行えるはずです。</p></li><li><p>どうしても必要な場合以外は、Podに<code>hostPort</code>を指定しないでください。Podを<code>hostPort</code>にバインドすると、Podがスケジュールできる場所の数を制限します、それぞれの&lt;<code>hostIP</code>、 <code>hostPort</code>、<code>protocol</code>>の組み合わせはユニークでなければならないからです。<code>hostIP</code>と<code>protocol</code>を明示的に指定しないと、Kubernetesはデフォルトの<code>hostIP</code>として<code>0.0.0.0</code>を、デフォルトの <code>protocol</code>として<code>TCP</code>を使います。</p><p>デバッグ目的でのみポートにアクセスする必要がある場合は、<a href=/docs/tasks/access-application-cluster/access-cluster/#manually-constructing-apiserver-proxy-urls>apiserver proxy</a>または<a href=/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>を使用できます。</p><p>ノード上でPodのポートを明示的に公開する必要がある場合は、hostPortに頼る前に<a href=/ja/docs/concepts/services-networking/service/#nodeport>NodePort</a>の使用を検討してください。</p></li><li><p><code>hostPort</code>の理由と同じくして、<code>hostNetwork</code>の使用はできるだけ避けてください。</p></li><li><p><code>kube-proxy</code>のロードバランシングが不要な場合は、<a href=/ja/docs/concepts/services-networking/service/#headless-service>headless Service</a>（<code>ClusterIP</code>が<code>None</code>）を使用してServiceを簡単に検出できます。</p></li></ul><h2 id=ラベルの使用>ラベルの使用</h2><ul><li><code>{ app: myapp, tier: frontend, phase: test, deployment: v3 }</code>のように、アプリケーションまたはデプロイメントの <strong>セマンティック属性</strong> を識別する<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>を定義して使いましょう。これらのラベルを使用して、他のリソースに適切なPodを選択できます。例えば、すべての<code>tier：frontend</code>を持つPodを選択するServiceや、<code>app：myapp</code>に属するすべての<code>phase：test</code>コンポーネント、などです。このアプローチの例を知るには、<a href=https://github.com/kubernetes/examples/tree/master/guestbook/>ゲストブック</a>アプリも合わせてご覧ください。</li></ul><p>セレクターからリリース固有のラベルを省略することで、Serviceを複数のDeploymentにまたがるように作成できます。 <a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>により、ダウンタイムなしで実行中のサービスを簡単に更新できます。</p><p>オブジェクトの望ましい状態はDeploymentによって記述され、その仕様への変更が <em>適用</em> されると、Deploymentコントローラは制御された速度で実際の状態を望ましい状態に変更します。</p><ul><li>デバッグ用にラベルを操作できます。Kubernetesコントローラー（ReplicaSetなど）とServiceはセレクターラベルを使用してPodとマッチするため、Podから関連ラベルを削除すると、コントローラーによって考慮されたり、Serviceによってトラフィックを処理されたりすることがなくなります。既存のPodのラベルを削除すると、そのコントローラーはその代わりに新しいPodを作成します。これは、「隔離」環境で以前の「ライブ」Podをデバッグするのに便利な方法です。対話的にラベルを削除または追加するには、<a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>を使います。</li></ul><h2 id=コンテナイメージ>コンテナイメージ</h2><p><a href=/ja/docs/concepts/containers/images/#updating-images>imagePullPolicy</a>とイメージのタグは、<a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>が特定のイメージをpullしようとしたときに作用します。</p><ul><li><p><code>imagePullPolicy: IfNotPresent</code>: ローカルでイメージが見つからない場合にのみイメージをpullします。</p></li><li><p><code>imagePullPolicy: Always</code>: kubeletがコンテナを起動する度に、kubeletはコンテナイメージレジストリに問い合わせて、イメージのダイジェストの名前解決を行います。もし、kubeletが同じダイジェストのコンテナイメージをローカルにキャッシュしていたら、kubeletはそのキャッシュされたイメージを利用します。そうでなければ、kubeletは解決されたダイジェストのイメージをダウンロードし、そのイメージを利用してコンテナを起動します。</p></li><li><p><code>imagePullPolicy</code> のタグが省略されていて、利用してるイメージのタグが<code>:latest</code>の場合や省略されている場合、<code>Always</code>が適用されます。</p></li><li><p><code>imagePullPolicy</code> のタグが省略されていて、利用してるイメージのタグはあるが<code>:latest</code>でない場合、<code>IfNotPresent</code>が適用されます。</p></li><li><p><code>imagePullPolicy: Never</code>: 常にローカルでイメージを探そうとします。ない場合にもイメージはpullしません。</p></li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong> コンテナが常に同じバージョンのイメージを使用するようにするためには、そのコンテナイメージの<a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>ダイジェスト</a>を指定することができます。<code>&lt;image-name>:&lt;tag></code>を<code>&lt;image-name>@&lt;digest></code>で置き換えます(例:<code>image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>)。このダイジェストはイメージの特定のバージョンを一意に識別するため、ダイジェスト値を変更しない限り、Kubernetesによって更新されることはありません。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> どのバージョンのイメージが実行されているのかを追跡するのが難しく、適切にロールバックするのが難しいため、本番環境でコンテナをデプロイするときは <code>：latest</code>タグを使用しないでください。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ベースイメージのプロバイダーのキャッシュセマンティクスにより、<code>imagePullPolicy：Always</code>もより効率的になります。たとえば、Dockerでは、イメージがすでに存在する場合すべてのイメージレイヤーがキャッシュされ、イメージのダウンロードが不要であるため、pullが高速になります。</div><h2 id=kubectlの使い方>kubectlの使い方</h2><ul><li><p><code>kubectl apply -f &lt;directory></code>を使いましょう。これを使うと、ディレクトリ内のすべての<code>.yaml</code>、<code>.yml</code>、および<code>.json</code>ファイルが<code>apply</code>に渡されます。</p></li><li><p><code>get</code>や<code>delete</code>を行う際は、特定のオブジェクト名を指定するのではなくラベルセレクターを使いましょう。<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルセレクター</a>と<a href=/ja/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>ラベルの効果的な使い方</a>のセクションを参照してください。</p></li><li><p>単一コンテナのDeploymentやServiceを素早く作成するなら、<code>kubectl create deployment</code>や<code>kubectl expose</code>を使いましょう。一例として、<a href=/ja/docs/tasks/access-application-cluster/service-access-application-cluster/>Serviceを利用したクラスター内のアプリケーションへのアクセス</a>を参照してください。</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6b5ccadd699df0904e8e9917c5450c4b>2 - ConfigMap</h1><p><p>ConfigMapは、 機密性のないデータをキーと値のペアで保存するために使用されるAPIオブジェクトです。<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>は、環境変数、コマンドライン引数、または<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>内の設定ファイルとしてConfigMapを使用できます。</p></p><p>ConfigMapを使用すると、環境固有の設定を<a class=glossary-tooltip title=アプリケーションの実行に必要なソフトウェアのセットを持つ、保存されたコンテナの実体です。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-image' target=_blank aria-label=コンテナイメージ>コンテナイメージ</a>から分離できるため、アプリケーションを簡単に移植できるようになります。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> ConfigMapは機密性や暗号化を提供しません。保存したいデータが機密情報である場合は、ConfigMapの代わりに<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>を使用するか、追加の(サードパーティー)ツールを使用してデータが非公開になるようにしてください。</div><h2 id=動機>動機</h2><p>アプリケーションのコードとは別に設定データを設定するには、ConfigMapを使用します。</p><p>たとえば、アプリケーションを開発していて、(開発用時には)自分のコンピューター上と、(実際のトラフィックをハンドルするときは)クラウド上とで実行することを想像してみてください。あなたは、<code>DATABASE_HOST</code>という名前の環境変数を使用するコードを書きます。ローカルでは、この変数を<code>localhost</code>に設定します。クラウド上では、データベースコンポーネントをクラスター内に公開するKubernetesの<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を指すように設定します。</p><p>こうすることで、必要であればクラウド上で実行しているコンテナイメージを取得することで、ローカルでも完全に同じコードを使ってデバッグができるようになります。</p><p>ConfigMapは、大量のデータを保持するようには設計されていません。ConfigMapに保存されるデータは1MiBを超えることはできません。この制限を超える設定を保存する必要がある場合は、ボリュームのマウントを検討するか、別のデータベースまたはファイルサービスを使用することを検討してください。</p><h2 id=configmapオブジェクト>ConfigMapオブジェクト</h2><p>ConfigMapは、他のオブジェクトが使うための設定を保存できるAPI<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/>オブジェクト</a>です。ほとんどのKubernetesオブジェクトに<code>spec</code>セクションがあるのとは違い、ConfigMapには<code>data</code>および<code>binaryData</code>フィールドがあります。これらのフィールドは、キーとバリューのペアを値として受け入れます。<code>data</code>フィールドと<code>binaryData</code>フィールドはどちらもオプションです。<code>data</code>フィールドはUTF-8バイトシーケンスを含むように設計されていますが、<code>binaryData</code>フィールドはバイナリデータを含むように設計されています。</p><p>ConfigMapの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSのサブドメイン名</a>でなければなりません。</p><p><code>data</code>または<code>binaryData</code>フィールドの各キーは、英数字、<code>-</code>、<code>_</code>、または<code>.</code>で構成されている必要があります。<code>data</code>に格納されているキーは、<code>binaryData</code>フィールドのキーと重複することはできません。</p><p>v1.19以降、ConfigMapの定義に<code>immutable</code>フィールドを追加して、<a href=#configmap-immutable>イミュータブルなConfigMap</a>を作成できます。</p><h2 id=configmapとpod>ConfigMapとPod</h2><p>ConfigMapを参照して、ConfigMap内のデータを元にしてPod内のコンテナの設定をするPodの<code>spec</code>を書くことができます。このとき、PodとConfigMapは同じ<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=名前空間>名前空間</a>内に存在する必要があります。</p><p>以下に、ConfigMapの例を示します。単一の値を持つキーと、Configuration形式のデータ片のような値を持つキーがあります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># プロパティーに似たキー。各キーは単純な値にマッピングされている</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>player_initial_lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui_properties_file_name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ファイルに似たキー</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemy.types=aliens,monsters
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    player.maximum-lives=5</span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user-interface.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.good=purple
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    allow.textmode=true</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>ConfigMapを利用してPod内のコンテナを設定する方法には、次の4種類があります。</p><ol><li>コンテナ内のコマンドと引数</li><li>環境変数をコンテナに渡す</li><li>読み取り専用のボリューム内にファイルを追加し、アプリケーションがそのファイルを読み取る</li><li>Kubernetes APIを使用してConfigMapを読み込むコードを書き、そのコードをPod内で実行する</li></ol><p>これらのさまざまな方法は、利用するデータをモデル化するのに役立ちます。最初の3つの方法では、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>がPodのコンテナを起動する時にConfigMapのデータを使用します。</p><p>4番目の方法では、ConfigMapとそのデータを読み込むためのコードを自分自身で書く必要があります。しかし、Kubernetes APIを直接使用するため、アプリケーションはConfigMapがいつ変更されても更新イベントを受信でき、変更が発生したときにすぐに反応できます。この手法では、Kubernetes APIに直接アクセスすることで、別の名前空間にあるConfigMapにもアクセスできます。</p><p>以下に、Podを設定するために<code>game-demo</code>から値を使用するPodの例を示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-demo-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>alpine<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;3600&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 環境変数を定義します。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PLAYER_INITIAL_LIVES<span style=color:#bbb> </span><span style=color:#080;font-style:italic># ここではConfigMap内のキーの名前とは違い</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                                     </span><span style=color:#080;font-style:italic># 大文字が使われていることに着目してください。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo          <span style=color:#bbb> </span><span style=color:#080;font-style:italic># この値を取得するConfigMap。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>player_initial_lives<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 取得するキー。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>UI_PROPERTIES_FILE_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ui_properties_file_name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/config&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Podレベルでボリュームを設定し、Pod内のコンテナにマウントします。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># マウントしたいConfigMapの名前を指定します。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ファイルとして作成するConfigMapのキーの配列</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>ConfigMapは1行のプロパティの値と複数行のファイルに似た形式の値を区別しません。問題となるのは、Podや他のオブジェクトによる値の使用方法です。</p><p>この例では、ボリュームを定義して、<code>demo</code>コンテナの内部で<code>/config</code>にマウントしています。これにより、ConfigMap内には4つのキーがあるにもかかわらず、2つのファイル<code>/config/game.properties</code>および<code>/config/user-interface.properties</code>だけが作成されます。</p><p>これは、Podの定義が<code>volumes</code>セクションで<code>items</code>という配列を指定しているためです。もし<code>items</code>の配列を完全に省略すれば、ConfigMap内の各キーがキーと同じ名前のファイルになり、4つのファイルが作成されます。</p><h2 id=configmapを使う>ConfigMapを使う</h2><p>ConfigMapは、データボリュームとしてマウントできます。ConfigMapは、Podへ直接公開せずにシステムの他の部品として使うこともできます。たとえば、ConfigMapには、システムの他の一部が設定のために使用するデータを保存できます。</p><p>ConfigMapの最も一般的な使い方では、同じ名前空間にあるPod内で実行されているコンテナに設定を構成します。ConfigMapを独立して使用することもできます。</p><p>たとえば、ConfigMapに基づいて動作を調整する<a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=アドオン>アドオン</a>や<a class=glossary-tooltip title='A specialized controller used to manage a custom resource' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=オペレーター>オペレーター</a>を見かけることがあるかもしれません。</p><h3 id=configmapをpodからファイルとして使う>ConfigMapをPodからファイルとして使う</h3><p>ConfigMapをPod内のボリュームで使用するには、次のようにします。</p><ol><li>ConfigMapを作成するか、既存のConfigMapを使用します。複数のPodから同じConfigMapを参照することもできます。</li><li>Podの定義を修正して、<code>.spec.volumes[]</code>以下にボリュームを追加します。ボリュームに任意の名前を付け、<code>.spec.volumes[].configMap.name</code>フィールドにConfigMapオブジェクトへの参照を設定します。</li><li>ConfigMapが必要な各コンテナに<code>.spec.containers[].volumeMounts[]</code>を追加します。<code>.spec.containers[].volumeMounts[].readOnly = true</code>を指定して、<code>.spec.containers[].volumeMounts[].mountPath</code>には、ConfigMapのデータを表示したい未使用のディレクトリ名を指定します。</li><li>イメージまたはコマンドラインを修正して、プログラムがそのディレクトリ内のファイルを読み込むように設定します。ConfigMapの<code>data</code>マップ内の各キーが、<code>mountPath</code>以下のファイル名になります。</li></ol><p>以下は、ボリューム内にConfigMapをマウントするPodの例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></span></span></code></pre></div><p>使用したいそれぞれのConfigMapごとに、<code>.spec.volumes</code>内で参照する必要があります。</p><p>Pod内に複数のコンテナが存在する場合、各コンテナにそれぞれ別の<code>volumeMounts</code>のブロックが必要ですが、<code>.spec.volumes</code>はConfigMapごとに1つしか必要ありません。</p><h4 id=マウントしたconfigmapの自動的な更新>マウントしたConfigMapの自動的な更新</h4><p>ボリューム内で現在使用中のConfigMapが更新されると、射影されたキーも最終的に(eventually)更新されます。kubeletは定期的な同期のたびにマウントされたConfigMapが新しいかどうか確認します。しかし、kubeletが現在のConfigMapの値を取得するときにはローカルキャッシュを使用します。キャッシュの種類は、<a href=https://github.com/kubernetes/kubernetes/blob/main/staging/src/k8s.io/kubelet/config/v1beta1/types.go>KubeletConfiguration構造体</a>の中の<code>ConfigMapAndSecretChangeDetectionStrategy</code>フィールドで設定可能です。ConfigMapは、監視(デフォルト)、ttlベース、またはすべてのリクエストを直接APIサーバーへ単純にリダイレクトする方法のいずれかによって伝搬されます。その結果、ConfigMapが更新された瞬間から、新しいキーがPodに射影されるまでの遅延の合計は、最長でkubeletの同期期間+キャッシュの伝搬遅延になります。ここで、キャッシュの伝搬遅延は選択したキャッシュの種類に依存します(監視の伝搬遅延、キャッシュのttl、または0に等しくなります)。</p><p>環境変数として使用されるConfigMapは自動的に更新されないため、ポッドを再起動する必要があります。</p><h2 id=configmap-immutable>イミュータブルなConfigMap</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p>Kubernetesのベータ版の機能である <em>イミュータブルなSecretおよびConfigMap</em> は、個別のSecretやConfigMapをイミュータブルに設定するオプションを提供します。ConfigMapを広範に使用している(少なくとも数万のConfigMapがPodにマウントされている)クラスターでは、データの変更を防ぐことにより、以下のような利点が得られます。</p><ul><li>アプリケーションの停止を引き起こす可能性のある予想外の(または望まない)変更を防ぐことができる</li><li>ConfigMapをイミュータブルにマークして監視を停止することにより、kube-apiserverへの負荷を大幅に削減し、クラスターの性能が向上する</li></ul><p>この機能は、<code>ImmutableEmphemeralVolumes</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>によって管理されます。<code>immutable</code>フィールドを<code>true</code>に設定することで、イミュータブルなConfigMapを作成できます。次に例を示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>一度ConfigMapがイミュータブルに設定されると、この変更を元に戻したり、<code>data</code>または<code>binaryData</code>フィールドのコンテンツを変更することは<em>できません</em>。ConfigMapの削除と再作成のみ可能です。既存のPodは削除されたConfigMapのマウントポイントを保持するため、こうしたPodは再作成することをおすすめします。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/configuration/secret/>Secret</a>について読む。</li><li><a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>Podを構成してConfigMapを使用する</a>を読む。</li><li>コードを設定から分離する動機を理解するために<a href=https://12factor.net/ja/>The Twelve-Factor App</a>を読む。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e511ed821ada65d0053341dbd8ad2bb5>3 - Secret</h1><p>Secretとは、パスワードやトークン、キーなどの少量の機密データを含むオブジェクトのことです。
このような情報は、Secretを用いないと<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>の定義や<a class=glossary-tooltip title=アプリケーションの実行に必要なソフトウェアのセットを持つ、保存されたコンテナの実体です。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-image' target=_blank aria-label=コンテナイメージ>コンテナイメージ</a>に直接記載することになってしまうかもしれません。
Secretを使用すれば、アプリケーションコードに機密データを含める必要がなくなります。</p><p>なぜなら、Secretは、それを使用するPodとは独立して作成することができ、
Podの作成、閲覧、編集といったワークフローの中でSecret(およびそのデータ)が漏洩する危険性が低くなるためです。
また、Kubernetesやクラスター内で動作するアプリケーションは、不揮発性ストレージに機密データを書き込まないようにするなど、Secretで追加の予防措置を取ることができます。</p><p>Secretsは、<a class=glossary-tooltip title=機密性のないデータをキーと値のペアで保存するために使用されるAPIオブジェクトです。環境変数、コマンドライン引数、またはボリューム内の設定ファイルとして使用できます。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/configmap/ target=_blank aria-label=ConfigMaps>ConfigMaps</a>に似ていますが、機密データを保持するために用います。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong><p>KubernetesのSecretは、デフォルトでは、APIサーバーの基礎となるデータストア(etcd)に暗号化されずに保存されます。APIにアクセスできる人は誰でもSecretを取得または変更でき、etcdにアクセスできる人も同様です。
さらに、名前空間でPodを作成する権限を持つ人は、そのアクセスを使用して、その名前空間のあらゆるSecretを読むことができます。これには、Deploymentを作成する能力などの間接的なアクセスも含まれます。</p><p>Secretsを安全に使用するには、以下の手順を推奨します。</p><ol><li>Secretsを<a href=/docs/tasks/administer-cluster/encrypt-data/>安全に暗号化する</a></li><li>Secretsのデータの読み取りを制限する<a href=/docs/reference/access-authn-authz/authorization/>RBACルール</a>の有効化または設定</li><li>適切な場合には、RBACなどのメカニズムを使用して、どの原則が新しいSecretの作成や既存のSecretの置き換えを許可されるかを制限します。</li></ol></div><h2 id=secretの概要>Secretの概要</h2><p>Secretを使うには、PodはSecretを参照することが必要です。
PodがSecretを使う方法は3種類あります。</p><ul><li><a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>内の<a href=#using-secrets-as-files-from-a-pod>ファイル</a>として、Podの単一または複数のコンテナにマウントする</li><li><a href=#using-secrets-as-environment-variables>コンテナの環境変数</a>として利用する</li><li>Podを生成するために<a href=#using-imagepullsecrets>kubeletがイメージをpullする</a>ときに使用する</li></ul><p>KubernetesのコントロールプレーンでもSecretsは使われています。例えば、<a href=#bootstrap-token-secrets>bootstrap token Secrets</a>は、ノード登録を自動化するための仕組みです。</p><p>Secretオブジェクトの名称は正当な<a href=/ja/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。
シークレットの構成ファイルを作成するときに、<code>data</code>および/または<code>stringData</code>フィールドを指定できます。<code>data</code>フィールドと<code>stringData</code>フィールドはオプションです。
<code>data</code>フィールドのすべてのキーの値は、base64でエンコードされた文字列である必要があります。
base64文字列への変換が望ましくない場合は、代わりに<code>stringData</code>フィールドを指定することを選択できます。これは任意の文字列を値として受け入れます。</p><p><code>data</code>と<code>stringData</code>のキーは、英数字、<code>-</code>、<code>_</code>、または<code>.</code>で構成されている必要があります。
<code>stringData</code>フィールドのすべてのキーと値のペアは、内部で<code>data</code>フィールドにマージされます。
キーが<code>data</code>フィールドと<code>stringData</code>フィールドの両方に表示される場合、<code>stringData</code>フィールドで指定された値が優先されます。</p><h2 id=secret-types>Secretの種類</h2><p>Secretを作成するときは、<a href=/docs/reference/generated/kubernetes-api/v1.25/#secret-v1-core><code>Secret</code></a>の<code>type</code>フィールド、または特定の同等の<code>kubectl</code>コマンドラインフラグ（使用可能な場合）を使用して、その型を指定できます。
Secret型は、Secret dataのプログラムによる処理を容易にするために使用されます。</p><p>Kubernetesは、いくつかの一般的な使用シナリオに対応するいくつかの組み込み型を提供します。
これらの型は、実行される検証とKubernetesが課す制約の点で異なります。</p><table><thead><tr><th>Builtin Type</th><th>Usage</th></tr></thead><tbody><tr><td><code>Opaque</code></td><td>arbitrary user-defined data</td></tr><tr><td><code>kubernetes.io/service-account-token</code></td><td>service account token</td></tr><tr><td><code>kubernetes.io/dockercfg</code></td><td>serialized <code>~/.dockercfg</code> file</td></tr><tr><td><code>kubernetes.io/dockerconfigjson</code></td><td>serialized <code>~/.docker/config.json</code> file</td></tr><tr><td><code>kubernetes.io/basic-auth</code></td><td>credentials for basic authentication</td></tr><tr><td><code>kubernetes.io/ssh-auth</code></td><td>credentials for SSH authentication</td></tr><tr><td><code>kubernetes.io/tls</code></td><td>data for a TLS client or server</td></tr><tr><td><code>bootstrap.kubernetes.io/token</code></td><td>bootstrap token data</td></tr></tbody></table><p>Secretオブジェクトの<code>type</code>値として空でない文字列を割り当てることにより、独自のSecret型を定義して使用できます。空の文字列は<code>Opaque</code>型として扱われます。Kubernetesは型名に制約を課しません。ただし、組み込み型の1つを使用している場合は、その型に定義されているすべての要件を満たす必要があります。</p><h3 id=opaque-secrets>Opaque secrets</h3><p><code>Opaque</code>は、Secret構成ファイルから省略された場合のデフォルトのSecret型です。
<code>kubectl</code>を使用してSecretを作成する場合、<code>generic</code>サブコマンドを使用して<code>Opaque</code>Secret型を示します。 たとえば、次のコマンドは、<code>Opaque</code>型の空のSecretを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic empty-secret
</span></span><span style=display:flex><span>kubectl get secret empty-secret
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6s
</code></pre><p><code>DATA</code>列には、Secretに保存されているデータ項目の数が表示されます。
この場合、<code>0</code>は空のSecretを作成したことを意味します。</p><h3 id=service-account-token-secrets>Service account token Secrets</h3><p><code>kubernetes.io/service-account-token</code>型のSecretは、サービスアカウントを識別するトークンを格納するために使用されます。 このSecret型を使用する場合は、<code>kubernetes.io/service-account.name</code>アノテーションが既存のサービスアカウント名に設定されていることを確認する必要があります。Kubernetesコントローラーは、<code>kubernetes.io/service-account.uid</code>アノテーションや実際のトークンコンテンツに設定された<code>data</code>フィールドの<code>token</code>キーなど、他のいくつかのフィールドに入力します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-sa-sample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-account.name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sa-name&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># You can include additional key value pairs as you do with Opaque Secrets</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb> </span>YmFyCg==<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>Pod</code>を作成すると、Kubernetesはservice account Secretを自動的に作成し、このSecretを使用するようにPodを自動的に変更します。service account token Secretには、APIにアクセスするための資格情報が含まれています。</p><p>API証明の自動作成と使用は、必要に応じて無効にするか、上書きすることができます。 ただし、API Serverに安全にアクセスするだけの場合は、これが推奨されるワークフローです。</p><p>ServiceAccountの動作の詳細については、<a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>のドキュメントを参照してください。
PodからServiceAccountを参照する方法については、<a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core><code>Pod</code></a>の<code>automountServiceAccountToken</code>フィールドと<code>serviceAccountName</code>フィールドを確認することもできます。</p><h3 id=docker-config-secrets>Docker config Secrets</h3><p>次の<code>type</code>値のいずれかを使用して、イメージのDockerレジストリにアクセスするための資格情報を格納するSecretを作成できます。</p><ul><li><code>kubernetes.io/dockercfg</code></li><li><code>kubernetes.io/dockerconfigjson</code></li></ul><p><code>kubernetes.io/dockercfg</code>型は、Dockerコマンドラインを構成するためのレガシー形式であるシリアル化された<code>~/.dockercfg</code>を保存するために予約されています。
このSecret型を使用する場合は、Secretの<code>data</code>フィールドに<code>.dockercfg</code>キーが含まれていることを確認する必要があります。このキーの値は、base64形式でエンコードされた<code>~/.dockercfg</code>ファイルの内容です。</p><p><code>kubernetes.io/dockerconfigjson</code>型は、<code>~/.dockercfg</code>の新しいフォーマットである<code>~/.docker/config.json</code>ファイルと同じフォーマットルールに従うシリアル化されたJSONを保存するために設計されています。
このSecret型を使用する場合、Secretオブジェクトの<code>data</code>フィールドには<code>.dockerconfigjson</code>キーが含まれている必要があります。このキーでは、<code>~/.docker/config.json</code>ファイルのコンテンツがbase64でエンコードされた文字列として提供されます。</p><p>以下は、<code>kubernetes.io/dockercfg</code>型のSecretの例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dockercfg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockercfg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockercfg</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span><span style=color:#b44>&#34;&lt;base64 encoded ~/.dockercfg file&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> base64エンコーディングを実行したくない場合は、代わりに<code>stringData</code>フィールドを使用することを選択できます。</div><p>マニフェストを使用してこれらの型のSecretを作成すると、APIserverは期待されるキーが<code>data</code>フィールドに存在するかどうかを確認し、提供された値を有効なJSONとして解析できるかどうかを確認します。APIサーバーは、JSONが実際にDocker configファイルであるかどうかを検証しません。</p><p>Docker configファイルがない場合、または<code>kubectl</code>を使用してDockerレジストリSecretを作成する場合は、次の操作を実行できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry secret-tiger-docker <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-username<span style=color:#666>=</span>tiger <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-password<span style=color:#666>=</span>pass113 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-email<span style=color:#666>=</span>tiger@acme.com <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-server<span style=color:#666>=</span>my-registry.example:5000
</span></span></code></pre></div><p>このコマンドは、<code>kubernetes.io/dockerconfigjson</code>型のSecretを作成します。
<code>data</code>フィールドから<code>.dockerconfigjson</code>コンテンツをダンプすると、その場で作成された有効なDocker configである次のJSONコンテンツを取得します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;data&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;.dockerconfigjson&#34;</span>: <span style=color:#b44>&#34;eyJhdXRocyI6eyJteS1yZWdpc3RyeTo1MDAwIjp7InVzZXJuYW1lIjoidGlnZXIiLCJwYXNzd29yZCI6InBhc3MxMTMiLCJlbWFpbCI6InRpZ2VyQGFjbWUuY29tIiwiYXV0aCI6ImRHbG5aWEk2Y0dGemN6RXhNdz09In19fQ==&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Secret&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>: <span style=color:#b44>&#34;2021-07-01T07:30:59Z&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;secret-tiger-docker&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>: <span style=color:#b44>&#34;566718&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;e15c1d7b-9071-4100-8681-f3a7a2ce89ca&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;kubernetes.io/dockerconfigjson&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=basic-authentication-secret>Basic authentication Secret</h3><p><code>kubernetes.io/basic-auth</code>型は、Basic認証に必要な認証を保存するために提供されています。このSecret型を使用する場合、Secretの<code>data</code>フィールドには次の2つのキーが含まれている必要があります。</p><ul><li><code>username</code>: 認証のためのユーザー名</li><li><code>password</code>: 認証のためのパスワードかトークン</li></ul><p>上記の2つのキーの両方の値は、base64でエンコードされた文字列です。もちろん、Secretの作成に<code>stringData</code>を使用してクリアテキストコンテンツを提供することもできます。</p><p>次のYAMLは、Basic authentication Secretの設定例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-basic-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/basic-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>admin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>t0p-Secret<span style=color:#bbb>
</span></span></span></code></pre></div><p>Basic認証Secret型は、ユーザーの便宜のためにのみ提供されています。Basic認証に使用される資格情報の<code>Opaque</code>を作成できます。
ただし、組み込みのSecret型を使用すると、認証の形式を統一するのに役立ち、APIserverは必要なキーがSecret configurationで提供されているかどうかを確認します。</p><h3 id=ssh-authentication-secrets>SSH authentication secrets</h3><p>組み込みのタイプ<code>kubernetes.io/ssh-auth</code>は、SSH認証で使用されるデータを保存するために提供されています。このSecret型を使用する場合、使用するSSH認証として<code>data</code>（または<code>stringData</code>）フィールドに<code>ssh-privatekey</code>キーと値のペアを指定する必要があります。</p><p>次のYAMLはSSH authentication Secretの設定例です：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-ssh-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/ssh-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># the data is abbreviated in this example</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ssh-privatekey</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>     </span><span style=color:#bbb>     </span>MIIEpQIBAAKCAQEAulqb/Y ...<span style=color:#bbb>
</span></span></span></code></pre></div><p>SSH authentication Secret型は、ユーザーの便宜のためにのみ提供されています。
SSH認証に使用される資格情報の<code>Opaque</code>を作成できます。
ただし、組み込みのSecret型を使用すると、認証の形式を統一するのに役立ち、APIserverは必要なキーがSecret configurationで提供されているかどうかを確認します。</p><h3 id=tls-secrets>TLS secrets</h3><p>Kubernetesは、TLSに通常使用される証明書とそれに関連付けられたキーを保存するための組み込みのSecret型<code>kubernetes.io/tls</code>を提供します。このデータは、主にIngressリソースのTLS terminationで使用されますが、他のリソースで使用されることも、ワークロードによって直接使用されることもあります。
このSecret型を使用する場合、APIサーバーは各キーの値を実際には検証しませんが、<code>tls.key</code>および<code>tls.crt</code>キーをSecret configurationの<code>data</code>（または<code>stringData</code>）フィールドに指定する必要があります。</p><p>次のYAMLはTLS Secretの設定例です：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># the data is abbreviated in this example</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIC2DCCAcCgAwIBAgIBATANBgkqh ...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...<span style=color:#bbb>
</span></span></span></code></pre></div><p>TLS Secret型は、ユーザーの便宜のために提供されています。 TLSサーバーやクライアントに使用される資格情報の<code>Opaque</code>を作成できます。ただし、組み込みのSecret型を使用すると、プロジェクトでSecret形式の一貫性を確保できます。APIserverは、必要なキーがSecret configurationで提供されているかどうかを確認します。</p><p><code>kubectl</code>を使用してTLS Secretを作成する場合、次の例に示すように<code>tls</code>サブコマンドを使用できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls my-tls-secret <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --cert<span style=color:#666>=</span>path/to/cert/file <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --key<span style=color:#666>=</span>path/to/key/file
</span></span></code></pre></div><p>公開鍵と秘密鍵のペアは、事前に存在している必要があります。<code>--cert</code>の公開鍵証明書は.PEMエンコード（Base64エンコードDER形式）であり、<code>--key</code>の指定された秘密鍵と一致する必要があります。
秘密鍵は、一般にPEM秘密鍵形式と呼ばれる暗号化されていない形式である必要があります。どちらの場合も、PEMの最初と最後の行（たとえば、<code>-------- BEGIN CERTIFICATE -----</code>と<code>------- END CERTIFICATE ----</code>）は含まれて<em>いません</em>。</p><h3 id=bootstrap-token-secrets>Bootstrap token Secrets</h3><p>Bootstrap token Secretは、Secretの<code>type</code>を<code>bootstrap.kubernetes.io/token</code>に明示的に指定することで作成できます。このタイプのSecretは、ノードのブートストラッププロセス中に使用されるトークン用に設計されています。よく知られているConfigMapに署名するために使用されるトークンを格納します。</p><p>Bootstrap token Secretは通常、<code>kube-system</code>namespaceで作成され<code>bootstrap-token-&lt;token-id></code>の形式で名前が付けられます。ここで<code>&lt;token-id></code>はトークンIDの6文字の文字列です。</p><p>Kubernetesマニフェストとして、Bootstrap token Secretは次のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>c3lzdGVtOmJvb3RzdHJhcHBlcnM6a3ViZWFkbTpkZWZhdWx0LW5vZGUtdG9rZW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>MjAyMC0wOS0xM1QwNDozOToxMFo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>NWVtaXRq<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>a3E0Z2lodnN6emduMXAwcg==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></span></span></code></pre></div><p>Bootstrap type Secretには、<code>data</code>で指定された次のキーがあります。</p><ul><li><code>token_id</code>：トークン識別子としてのランダムな6文字の文字列。必須。</li><li><code>token-secret</code>：実際のtoken secretとしてのランダムな16文字の文字列。必須。</li><li><code>description</code>：トークンの使用目的を説明する人間が読める文字列。オプション。</li><li><code>expiration</code>：トークンの有効期限を指定するRFC3339を使用した絶対UTC時間。オプション。</li><li><code>usage-bootstrap-&lt;usage></code>：Bootstrap tokenの追加の使用法を示すブールフラグ。</li><li><code>auth-extra-groups</code>：<code>system：bootstrappers</code>グループに加えて認証されるグループ名のコンマ区切りのリスト。</li></ul><p>上記のYAMLは、値がすべてbase64でエンコードされた文字列であるため、分かりづらく見えるかもしれません。実際には、次のYAMLを使用して同一のSecretを作成できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Note how the Secret is named</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># A bootstrap token Secret usually resides in the kube-system namespace</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;system:bootstrappers:kubeadm:default-node-token&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-09-13T04:39:10Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># This token ID is used in the name</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5emitj&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kq4gihvszzgn1p0r&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># This token can be used for authentication</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># and it can be used for signing</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=secretの作成>Secretの作成</h2><p>Secretを作成するには、いくつかのオプションがあります。</p><ul><li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-kubectl/>create Secret using <code>kubectl</code> command</a></li><li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-config-file/>create Secret from config file</a></li><li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-kustomize/>create Secret using kustomize</a></li></ul><h2 id=secretの編集>Secretの編集</h2><p>既存のSecretは次のコマンドで編集することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit secrets mysecret
</span></span></code></pre></div><p>デフォルトに設定されたエディターが開かれ、<code>data</code>フィールドのBase64でエンコードされたSecretの値を編集することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># Please edit the object below. Lines beginning with a &#39;#&#39; will be ignored,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># and an empty file will abort the edit. If an error occurs while saving this file will be</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># reopened with the relevant failures.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>{<span style=color:#bbb> </span>... }<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-01-22T18:41:56Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;164619&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>cfee02d6-c137-11e5-8d73-42010af00002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=secretの使用>Secretの使用</h2><p>Podの中のコンテナがSecretを使うために、データボリュームとしてマウントしたり、<a class=glossary-tooltip title='Container environment variables are name=value pairs that provide useful information into containers running in a Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment/ target=_blank aria-label=環境変数>環境変数</a>として値を参照できるようにできます。
Secretは直接Podが参照できるようにはされず、システムの別の部分に使われることもあります。
例えば、Secretはあなたに代わってシステムの他の部分が外部のシステムとやりとりするために使う機密情報を保持することもあります。</p><h3 id=secretをファイルとしてpodから利用する>SecretをファイルとしてPodから利用する</h3><p>PodのボリュームとしてSecretを使うには、</p><ol><li>Secretを作成するか既存のものを使用します。複数のPodが同一のSecretを参照することができます。</li><li>ボリュームを追加するため、Podの定義の<code>.spec.volumes[]</code>以下を書き換えます。ボリュームに命名し、<code>.spec.volumes[].secret.secretName</code>フィールドはSecretオブジェクトの名称と同一にします。</li><li>Secretを必要とするそれぞれのコンテナに<code>.spec.containers[].volumeMounts[]</code>を追加します。<code>.spec.containers[].volumeMounts[].readOnly = true</code>を指定して<code>.spec.containers[].volumeMounts[].mountPath</code>をSecretをマウントする未使用のディレクトリ名にします。</li><li>イメージやコマンドラインを変更し、プログラムがそのディレクトリを参照するようにします。連想配列<code>data</code>のキーは<code>mountPath</code>以下のファイル名になります。</li></ol><p>これはSecretをボリュームとしてマウントするPodの例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span></code></pre></div><p>使用したいSecretはそれぞれ<code>.spec.volumes</code>の中で参照されている必要があります。</p><p>Podに複数のコンテナがある場合、それぞれのコンテナが<code>volumeMounts</code>ブロックを必要としますが、<code>.spec.volumes</code>はSecret1つあたり1つで十分です。</p><p>多くのファイルを一つのSecretにまとめることも、多くのSecretを使うことも、便利な方を採ることができます。</p><h4 id=secretのキーの特定のパスへの割り当て>Secretのキーの特定のパスへの割り当て</h4><p>Secretのキーが割り当てられるパスを制御することができます。
それぞれのキーがターゲットとするパスは<code>.spec.volumes[].secret.items</code>フィールドによって指定できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span></code></pre></div><p>次のような挙動をします。</p><ul><li><code>username</code>は<code>/etc/foo/username</code>の代わりに<code>/etc/foo/my-group/my-username</code>の元に格納されます。</li><li><code>password</code>は現れません。</li></ul><p><code>.spec.volumes[].secret.items</code>が使われるときは、<code>items</code>の中で指定されたキーのみが現れます。
Secretの中の全てのキーを使用したい場合は、<code>items</code>フィールドに全て列挙する必要があります。
列挙されたキーは対応するSecretに存在する必要があり、そうでなければボリュームは生成されません。</p><h4 id=secretファイルのパーミッション>Secretファイルのパーミッション</h4><p>単一のSecretキーに対して、ファイルアクセスパーミッションビットを指定することができます。
パーミッションを指定しない場合、デフォルトで<code>0644</code>が使われます。
Secretボリューム全体のデフォルトモードを指定し、必要に応じてキー単位で上書きすることもできます。</p><p>例えば、次のようにしてデフォルトモードを指定できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>0400</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Secretは<code>/etc/foo</code>にマウントされ、Secretボリュームが生成する全てのファイルはパーミッション<code>0400</code>に設定されます。</p><p>JSONの仕様は8進数の記述に対応していないため、パーミッション0400を示す値として256を使用することに注意が必要です。
Podの定義にJSONではなくYAMLを使う場合は、パーミッションを指定するためにより自然な8進表記を使うことができます。</p><p><code>kubectl exec</code>を使ってPodに入るときは、期待したファイルモードを知るためにシンボリックリンクを辿る必要があることに注意してください。</p><p>例として、PodのSecretのファイルモードを確認します。</p><pre tabindex=0><code>kubectl exec mypod -it sh

cd /etc/foo
ls -l
</code></pre><p>出力は次のようになります。</p><pre tabindex=0><code>total 0
lrwxrwxrwx 1 root root 15 May 18 00:18 password -&gt; ..data/password
lrwxrwxrwx 1 root root 15 May 18 00:18 username -&gt; ..data/username
</code></pre><p>正しいファイルモードを知るためにシンボリックリンクを辿ります。</p><pre tabindex=0><code>cd /etc/foo/..data
ls -l
</code></pre><p>出力は次のようになります。</p><pre tabindex=0><code>total 8
-r-------- 1 root root 12 May 18 00:18 password
-r-------- 1 root root  5 May 18 00:18 username
</code></pre><p>前の例のようにマッピングを使い、ファイルごとに異なるパーミッションを指定することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>0777</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>この例では、ファイル<code>/etc/foo/my-group/my-username</code>のパーミッションは<code>0777</code>になります。
JSONを使う場合は、JSONの制約により10進表記の<code>511</code>と記述する必要があります。</p><p>後で参照する場合、このパーミッションの値は10進表記で表示されることがあることに注意してください。</p><h4 id=secretの値のボリュームによる利用>Secretの値のボリュームによる利用</h4><p>Secretのボリュームがマウントされたコンテナからは、Secretのキーはファイル名として、Secretの値はBase64デコードされ、それらのファイルに格納されます。
上記の例のコンテナの中でコマンドを実行した結果を示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls /etc/foo/
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>username
password
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/username
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/password
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><p>コンテナ内のプログラムはファイルからSecretの内容を読み取る責務を持ちます。</p><h4 id=マウントされたsecretの自動更新>マウントされたSecretの自動更新</h4><p>ボリュームとして使用されているSecretが更新されると、やがて割り当てられたキーも同様に更新されます。
kubeletは定期的な同期のたびにマウントされたSecretが新しいかどうかを確認します。
しかしながら、kubeletはSecretの現在の値の取得にローカルキャッシュを使用します。
このキャッシュは<a href=https://github.com/kubernetes/kubernetes/blob/main/staging/src/k8s.io/kubelet/config/v1beta1/types.go>KubeletConfiguration struct</a>内の<code>ConfigMapAndSecretChangeDetectionStrategy</code>フィールドによって設定可能です。
Secretはwatch（デフォルト）、TTLベース、単に全てのリクエストをAPIサーバーへリダイレクトすることのいずれかによって伝搬します。
結果として、Secretが更新された時点からPodに新しいキーが反映されるまでの遅延時間の合計は、kubeletの同期間隔 + キャッシュの伝搬遅延となります。
キャッシュの遅延は、キャッシュの種別により、それぞれwatchの伝搬遅延、キャッシュのTTL、0になります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Secretを<a href=/docs/concepts/storage/volumes#using-subpath>subPath</a>を指定してボリュームにマウントしているコンテナには、Secretの更新が反映されません。</div><h3 id=using-secrets-as-environment-variables>Secretを環境変数として使用する</h3><p>SecretをPodの<a class=glossary-tooltip title='Container environment variables are name=value pairs that provide useful information into containers running in a Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment/ target=_blank aria-label=環境変数>環境変数</a>として使用するには、</p><ol><li>Secretを作成するか既存のものを使います。複数のPodが同一のSecretを参照することができます。</li><li>Podの定義を変更し、Secretを使用したいコンテナごとにSecretのキーと割り当てたい環境変数を指定します。Secretキーを利用する環境変数は<code>env[].valueFrom.secretKeyRef</code>にSecretの名前とキーを指定すべきです。</li><li>イメージまたはコマンドライン（もしくはその両方）を変更し、プログラムが指定した環境変数を参照するようにします。</li></ol><p>Secretを環境変数で参照するPodの例を示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-env-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mycontainer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=環境変数からのsecretの値の利用>環境変数からのSecretの値の利用</h4><p>Secretを環境変数として利用するコンテナの内部では、Secretのキーは一般の環境変数名として現れ、値はBase64デコードされた状態で保持されます。</p><p>上記の例のコンテナの内部でコマンドを実行した結果の例を示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_USERNAME</span>
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_PASSWORD</span>
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><h2 id=secret-immutable>Immutable Secrets</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p>Kubernetesベータ機能<em>ImmutableSecrets and ConfigMaps</em>は、個々のSecretsとConfigMapsをimutableとして設定するオプションを提供します。Secret（少なくとも数万の、SecretからPodへの一意のマウント）を広範囲に使用するクラスターの場合、データの変更を防ぐことには次の利点があります。</p><ul><li>アプリケーションの停止を引き起こす可能性のある偶発的な（または不要な）更新からユーザーを保護します</li><li>imutableとしてマークされたSecretのウォッチを閉じることで、kube-apiserverの負荷を大幅に削減することができ、クラスターのパフォーマンスを向上させます。</li></ul><p>この機能は、<code>ImmutableEphemeralVolumes</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>によって制御されます。これは、v1.19以降デフォルトで有効になっています。<code>immutable</code>フィールドを<code>true</code>に設定することで、imutableのSecretを作成できます。例えば、</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> SecretまたはConfigMapがimutableとしてマークされると、この変更を元に戻したり、<code>data</code>フィールドの内容を変更したりすることは<em>できません</em>。Secretを削除して再作成することしかできません。
既存のPodは、削除されたSecretへのマウントポイントを維持します。これらのPodを再作成することをお勧めします。</div><h3 id=using-imagepullsecrets>imagePullSecretsを使用する</h3><p><code>imagePullSecrets</code>フィールドは同一のネームスペース内のSecretの参照のリストです。
kubeletにDockerやその他のイメージレジストリのパスワードを渡すために、<code>imagePullSecrets</code>にそれを含むSecretを指定することができます。
kubeletはこの情報をPodのためにプライベートイメージをpullするために使います。
<code>imagePullSecrets</code>の詳細は<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec API</a>を参照してください。</p><h4 id=imagepullsecretを手動で指定する>imagePullSecretを手動で指定する</h4><p><code>ImagePullSecrets</code>の指定の方法は<a href=/ja/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>コンテナイメージのドキュメント</a>に記載されています。</p><h3 id=imagepullsecretsが自動的にアタッチされるようにする>imagePullSecretsが自動的にアタッチされるようにする</h3><p><code>imagePullSecrets</code>を手動で作成し、サービスアカウントから参照することができます。
サービスアカウントが指定されるまたはデフォルトでサービスアカウントが設定されたPodは、サービスアカウントが持つ<code>imagePullSecrets</code>フィールドを得ます。
詳細な手順の説明は<a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>サービスアカウントへのImagePullSecretsの追加</a>を参照してください。</p><h3 id=手動で作成されたsecretの自動的なマウント>手動で作成されたSecretの自動的なマウント</h3><p>手動で作成されたSecret（例えばGitHubアカウントへのアクセスに使うトークンを含む）はサービスアカウントを基に自動的にアタッチすることができます。
詳細な説明は<a href=/docs/tasks/inject-data-application/podpreset/>PodPresetを使ったPodへの情報の注入</a>を参照してください。</p><h2 id=詳細>詳細</h2><h3 id=制限事項>制限事項</h3><p>Secretボリュームは指定されたオブジェクト参照が実際に存在するSecretオブジェクトを指していることを保証するため検証されます。
そのため、Secretはそれを必要とするPodよりも先に作成する必要があります。</p><p>Secretリソースは<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>に属します。
Secretは同一のnamespaceに属するPodからのみ参照することができます。</p><p>各Secretは1MiBの容量制限があります。
これはAPIサーバーやkubeletのメモリーを枯渇するような非常に大きなSecretを作成することを避けるためです。
しかしながら、小さなSecretを多数作成することも同様にメモリーを枯渇させます。
Secretに起因するメモリー使用量をより網羅的に制限することは、将来計画されています。</p><p>kubeletがPodに対してSecretを使用するとき、APIサーバーから取得されたSecretのみをサポートします。
これには<code>kubectl</code>を利用して、またはレプリケーションコントローラーによって間接的に作成されたPodが含まれます。
kubeletの<code>--manifest-url</code>フラグ、<code>--config</code>フラグ、またはREST APIにより生成されたPodは含まれません
（これらはPodを生成するための一般的な方法ではありません）。</p><p>環境変数として使われるSecretは任意と指定されていない限り、それを使用するPodよりも先に作成される必要があります。
存在しないSecretへの参照はPodの起動を妨げます。</p><p>Secretに存在しないキーへの参照（<code>secretKeyRef</code>フィールド）はPodの起動を妨げます。</p><p>Secretを<code>envFrom</code>フィールドによって環境変数へ設定する場合、環境変数の名称として不適切なキーは飛ばされます。
Podは起動することを認められます。
このとき、reasonが<code>InvalidVariableNames</code>であるイベントが発生し、メッセージに飛ばされたキーのリストが含まれます。
この例では、Podは2つの不適切なキー<code>1badkey</code>と<code>2alsobad</code>を含むdefault/mysecretを参照しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names.
</code></pre><h3 id=secretとpodの相互作用>SecretとPodの相互作用</h3><p>Kubernetes APIがコールされてPodが生成されるとき、参照するSecretの存在は確認されません。
Podがスケジューリングされると、kubeletはSecretの値を取得しようとします。
Secretが存在しない、または一時的にAPIサーバーへの接続が途絶えたことにより取得できない場合、kubeletは定期的にリトライします。
kubeletはPodがまだ起動できない理由に関するイベントを報告します。
Secretが取得されると、kubeletはそのボリュームを作成しマウントします。
Podのボリュームが全てマウントされるまでは、Podのコンテナは起動することはありません。</p><h2 id=ユースケース>ユースケース</h2><h3 id=ユースケース-コンテナの環境変数として>ユースケース: コンテナの環境変数として</h3><p>Secretの作成</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>USER_NAME</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>PASSWORD</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f mysecret.yaml
</span></span></code></pre></div><p><code>envFrom</code>を使ってSecretの全てのデータをコンテナの環境変数として定義します。
SecretのキーはPod内の環境変数の名称になります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=ユースケース-ssh鍵を持つpod>ユースケース: SSH鍵を持つPod</h3><p>SSH鍵を含むSecretを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic ssh-key-secret --from-file<span style=color:#666>=</span>ssh-privatekey<span style=color:#666>=</span>/path/to/.ssh/id_rsa --from-file<span style=color:#666>=</span>ssh-publickey<span style=color:#666>=</span>/path/to/.ssh/id_rsa.pub
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>secret &#34;ssh-key-secret&#34; created
</code></pre><p>SSH鍵を含む<code>secretGenerator</code>フィールドを持つ<code>kustomization.yaml</code>を作成することもできます。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> 自身のSSH鍵を送る前に慎重に検討してください。クラスターの他のユーザーがSecretにアクセスできる可能性があります。
Kubernetesクラスターを共有しているユーザー全員がアクセスできるようにサービスアカウントを使用し、ユーザーが安全でない状態になったらアカウントを無効化することができます。</div><p>SSH鍵のSecretを参照し、ボリュームとして使用するPodを作成することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>ssh-key-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ssh-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mySshImage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>コンテナのコマンドを実行するときは、下記のパスにて鍵が利用可能です。</p><pre tabindex=0><code>/etc/secret-volume/ssh-publickey
/etc/secret-volume/ssh-privatekey
</code></pre><p>コンテナーはSecretのデータをSSH接続を確立するために使用することができます。</p><h3 id=ユースケース-本番-テスト用の認証情報を持つpod>ユースケース: 本番、テスト用の認証情報を持つPod</h3><p>あるPodは本番の認証情報のSecretを使用し、別のPodはテスト環境の認証情報のSecretを使用する例を示します。</p><p><code>secretGenerator</code>フィールドを持つ<code>kustomization.yaml</code>を作成するか、<code>kubectl create secret</code>を実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic prod-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>produser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>Y4nys7f11
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>secret &#34;prod-db-secret&#34; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic test-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>testuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>iluvtests
</span></span></code></pre></div><p>出力は次のようになります。</p><pre tabindex=0><code>secret &#34;test-db-secret&#34; created
</code></pre><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p><code>$</code>、<code>\</code>、<code>*</code>、<code>=</code>、<code>!</code>のような特殊文字は<a href=https://ja.wikipedia.org/wiki/%E3%82%B7%E3%82%A7%E3%83%AB>シェル</a>に解釈されるので、エスケープする必要があります。
ほとんどのシェルではパスワードをエスケープする最も簡単な方法はシングルクォート(<code>'</code>)で囲むことです。
例えば、実際のパスワードが<code>S!B\*d$zDsb=</code>だとすると、実行すべきコマンドは下記のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic dev-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</span></span></code></pre></div><p><code>--from-file</code>によってファイルを指定する場合は、そのパスワードに含まれる特殊文字をエスケープする必要はありません。</p></div><p>Podを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: List
</span></span></span><span style=display:flex><span><span style=color:#b44>items:
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: prod-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: prod-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: prod-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: test-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: test-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: test-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>同じkustomization.yamlにPodを追記します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>下記のコマンドを実行して、APIサーバーにこれらのオブジェクト群を適用します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><p>両方のコンテナはそれぞれのファイルシステムに下記に示すファイルを持ちます。ファイルの値はそれぞれのコンテナの環境ごとに異なります。</p><pre tabindex=0><code>/etc/secret-volume/username
/etc/secret-volume/password
</code></pre><p>2つのPodの仕様の差分は1つのフィールドのみである点に留意してください。
これは共通のPodテンプレートから異なる能力を持つPodを作成することを容易にします。</p><p>2つのサービスアカウントを使用すると、ベースのPod仕様をさらに単純にすることができます。</p><ol><li><code>prod-user</code>と<code>prod-db-secret</code></li><li><code>test-user</code>と<code>test-db-secret</code></li></ol><p>簡略化されたPod仕様は次のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myClientImage<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=ユースケース-secretボリューム内のdotfile>ユースケース: Secretボリューム内のdotfile</h3><p>キーをドットから始めることで、データを「隠す」ことができます。
このキーはdotfileまたは「隠し」ファイルを示します。例えば、次のSecretは<code>secret-volume</code>ボリュームにマウントされます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.secret-file</span>:<span style=color:#bbb> </span>dmFsdWUtMg0KDQo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dotfiles-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-l&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>このボリュームは<code>.secret-file</code>という単一のファイルを含み、<code>dotfile-test-container</code>はこのファイルを<code>/etc/secret-volume/.secret-file</code>のパスに持ちます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ドットから始まるファイルは<code>ls -l</code>の出力では隠されるため、ディレクトリの内容を参照するときには<code>ls -la</code>を使わなければなりません。</div><h3 id=ユースケース-podの中の単一コンテナのみが参照できるsecret>ユースケース: Podの中の単一コンテナのみが参照できるSecret</h3><p>HTTPリクエストを扱い、複雑なビジネスロジックを処理し、メッセージにHMACによる認証コードを付与する必要のあるプログラムを考えます。
複雑なアプリケーションロジックを持つため、サーバーにリモートのファイルを読み出せる未知の脆弱性がある可能性があり、この脆弱性は攻撃者に秘密鍵を晒してしまいます。</p><p>このプログラムは2つのコンテナに含まれる2つのプロセスへと分割することができます。
フロントエンドのコンテナはユーザーとのやりとりやビジネスロジックを扱い、秘密鍵を参照することはできません。
署名コンテナは秘密鍵を参照することができて、単にフロントエンドからの署名リクエストに応答します。例えば、localhostの通信によって行います。</p><p>この分割する手法によって、攻撃者はアプリケーションサーバーを騙して任意の処理を実行させる必要があるため、ファイルの内容を読み出すより困難になります。</p><h2 id=ベストプラクティス>ベストプラクティス</h2><h3 id=secret-apiを使用するクライアント>Secret APIを使用するクライアント</h3><p>Secret APIとやりとりするアプリケーションをデプロイするときには、<a href=/ja/docs/reference/access-authn-authz/rbac/>RBAC</a>のような<a href=/docs/reference/access-authn-authz/authorization/>認可ポリシー</a>を使用して、アクセスを制限すべきです。
Secretは様々な種類の重要な値を保持することが多く、サービスアカウントのトークンのようにKubernetes内部や、外部のシステムで昇格できるものも多くあります。個々のアプリケーションが、Secretの能力について推論することができたとしても、同じネームスペースの別のアプリケーションがその推定を覆すこともあります。</p><p>これらの理由により、ネームスペース内のSecretに対する<code>watch</code>や<code>list</code>リクエストはかなり強力な能力であり、避けるべきです。Secretのリストを取得することはクライアントにネームスペース内の全てのSecretの値を調べさせることを認めるからです。クラスター内の全てのSecretに対する<code>watch</code>、<code>list</code>権限は最も特権的な、システムレベルのコンポーネントに限って認めるべきです。</p><p>Secret APIへのアクセスが必要なアプリケーションは、必要なSecretに対する<code>get</code>リクエストを発行すべきです。管理者は全てのSecretに対するアクセスは制限しつつ、アプリケーションが必要とする<a href=/docs/reference/access-authn-authz/rbac/#referring-to-resources>個々のインスタンスに対するアクセス許可</a>を与えることができます。</p><p><code>get</code>リクエストの繰り返しに対するパフォーマンスを向上するために、クライアントはSecretを参照するリソースを設計し、それを<code>watch</code>して、参照が変更されたときにSecretを再度リクエストすることができます。加えて、個々のリソースを<code>watch</code>することのできる<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/bulk_watch.md>"bulk watch" API</a>が提案されており、将来のKubernetesリリースにて利用可能になる可能性があります。</p><h2 id=セキュリティ特性>セキュリティ特性</h2><h3 id=保護>保護</h3><p>Secretはそれを使用するPodとは独立に作成されるので、Podを作ったり、参照したり、編集したりするワークフローにおいてSecretが晒されるリスクは軽減されています。
システムは、可能であればSecretの内容をディスクに書き込まないような、Secretについて追加の考慮も行っています。</p><p>Secretはノード上のPodが必要とした場合のみ送られます。
kubeletはSecretがディスクストレージに書き込まれないよう、<code>tmpfs</code>に保存します。
Secretを必要とするPodが削除されると、kubeletはSecretのローカルコピーも同様に削除します。</p><p>同一のノードにいくつかのPodに対する複数のSecretが存在することもあります。
しかし、コンテナから参照できるのはPodが要求したSecretのみです。
そのため、あるPodが他のPodのためのSecretにアクセスすることはできません。</p><p>Podに複数のコンテナが含まれることもあります。しかし、Podの各コンテナはコンテナ内からSecretを参照するために<code>volumeMounts</code>によってSecretボリュームを要求する必要があります。
これは<a href=#use-case-secret-visible-to-one-container-in-a-pod>Podレベルでのセキュリティ分離</a>を実装するのに便利です。</p><p>ほとんどのKubernetesディストリビューションにおいては、ユーザーとAPIサーバー間やAPIサーバーからkubelet間の通信はSSL/TLSで保護されています。
そのような経路で伝送される場合、Secretは保護されています。</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.13 [beta]</code></div><p><a href=/docs/tasks/administer-cluster/encrypt-data/>保存データの暗号化</a>を有効にして、Secretが<a class=glossary-tooltip title=一貫性、高可用性を持ったキーバリューストアで、Kubernetesの全てのクラスター情報の保存場所として利用されています。 data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>に平文で保存されないようにすることができます。</p><h3 id=リスク>リスク</h3><ul><li>APIサーバーでは、機密情報は<a class=glossary-tooltip title=一貫性、高可用性を持ったキーバリューストアで、Kubernetesの全てのクラスター情報の保存場所として利用されています。 data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>に保存されます。
そのため、<ul><li>管理者はクラスターデータの保存データの暗号化を有効にすべきです（v1.13以降が必要）。</li><li>管理者はetcdへのアクセスを管理ユーザに限定すべきです。</li><li>管理者はetcdで使用していたディスクを使用しなくなったときにはそれをワイプするか完全消去したくなるでしょう。</li><li>クラスターの中でetcdが動いている場合、管理者はetcdのピアツーピア通信がSSL/TLSを利用していることを確認すべきです。</li></ul></li><li>Secretをマニフェストファイル（JSONまたはYAML）を介して設定する場合、それはBase64エンコードされた機密情報を含んでいるので、ファイルを共有したりソースリポジトリに入れることは秘密が侵害されることを意味します。Base64エンコーディングは暗号化手段では <em>なく</em> 、平文と同様であると判断すべきです。</li><li>アプリケーションはボリュームからSecretの値を読み取った後も、その値を保護する必要があります。例えば意図せずログに出力する、信用できない相手に送信するようなことがないようにです。</li><li>Secretを利用するPodを作成できるユーザーはSecretの値を見ることができます。たとえAPIサーバーのポリシーがユーザーにSecretの読み取りを許可していなくても、ユーザーはSecretを晒すPodを実行することができます。</li><li>現在、任意のノードでルート権限を持つ人は誰でも、kubeletに偽装することで <em>任意の</em> SecretをAPIサーバーから読み取ることができます。
単一のノードのルート権限を不正に取得された場合の影響を抑えるため、実際に必要としているノードに対してのみSecretを送る機能が計画されています。</li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/tasks/configmap-secret/managing-secret-using-kubectl/><code>kubectl</code>を使用してSecretを管理する</a>方法を学ぶ</li><li><a href=/docs/tasks/configmap-secret/managing-secret-using-config-file/>config fileを使用してSecretを管理する</a>方法を学ぶ</li><li><a href=/docs/tasks/configmap-secret/managing-secret-using-kustomize/>kustomizeを使用してSecretを管理する</a>方法を学ぶ</li><li><a href=/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/>SecretのAPIリファレンス</a>を読む</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-436057b96151ecb8a4a9a9f456b5d0fc>4 - コンテナのリソース管理</h1><p><a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>を指定する際に、<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>が必要とする各リソースの量をオプションで指定することができます。
指定する最も一般的なリソースはCPUとメモリ(RAM)ですが、他にもあります。</p><p>Pod内のコンテナのリソース<em>要求</em>を指定すると、スケジューラはこの情報を使用して、どのNodeにPodを配置するかを決定します。コンテナに<em>制限</em>ソースを指定すると、kubeletはその制限を適用し、実行中のコンテナが設定した制限を超えてリソースを使用することができないようにします。また、kubeletは、少なくともそのシステムリソースのうち、<em>要求</em>の量を、そのコンテナが使用するために特別に確保します。</p><h2 id=requests-and-limits>要求と制限</h2><p>Podが動作しているNodeに利用可能なリソースが十分にある場合、そのリソースの<code>要求</code>が指定するよりも多くのリソースをコンテナが使用することが許可されます
ただし、コンテナはそのリソースの<code>制限</code>を超えて使用することはできません。</p><p>たとえば、コンテナに256MiBの<code>メモリー</code>要求を設定し、そのコンテナが8GiBのメモリーを持つNodeにスケジュールされたPod内に存在し、他のPodが存在しない場合、コンテナはより多くのRAMを使用しようとする可能性があります。</p><p>そのコンテナに4GiBの<code>メモリー</code>制限を設定すると、kubelet(および<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>) が制限を適用します。ランタイムは、コンテナーが設定済みのリソース制限を超えて使用するのを防ぎます。例えば、コンテナ内のプロセスが、許容量を超えるメモリを消費しようとすると、システムカーネルは、メモリ不足(OOM)エラーで、割り当てを試みたプロセスを終了します。</p><p>制限は、違反が検出されるとシステムが介入するように事後的に、またはコンテナーが制限を超えないようにシステムが防ぐように強制的に、実装できます。
異なるランタイムは、同じ制限を実装するために異なる方法をとることができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> コンテナが自身のメモリー制限を指定しているが、メモリー要求を指定していない場合、Kubernetesは制限に一致するメモリー要求を自動的に割り当てます。同様に、コンテナが自身のCPU制限を指定しているが、CPU要求を指定していない場合、Kubernetesは制限に一致するCPU要求を自動的に割り当てます。</div><h2 id=resource-types>リソースタイプ</h2><p><em>CPU</em>と<em>メモリー</em>はいずれも<em>リソースタイプ</em>です。リソースタイプには基本単位があります。
CPUは計算処理を表し、<a href=#meaning-of-cpu>Kubernetes CPUs</a>の単位で指定されます。
メモリはバイト単位で指定されます。
Kubernetes v1.14以降を使用している場合は、<em>huge page</em>リソースを指定することができます。
Huge PageはLinux固有の機能であり、Nodeのカーネルはデフォルトのページサイズよりもはるかに大きいメモリブロックを割り当てます。</p><p>たとえば、デフォルトのページサイズが4KiBのシステムでは、<code>hugepages-2Mi: 80Mi</code>という制限を指定できます。
コンテナが40を超える2MiBの巨大ページ(合計80 MiB)を割り当てようとすると、その割り当ては失敗します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>hugepages-*</code>リソースをオーバーコミットすることはできません。
これは<code>memory</code>や<code>cpu</code>リソースとは異なります。</div><p>CPUとメモリーは、まとめて<em>コンピュートリソース</em>または単に<em>リソース</em>と呼ばれます。
コンピューティングリソースは、要求され、割り当てられ、消費され得る測定可能な量です。
それらは<a href=/ja/docs/concepts/overview/kubernetes-api/>API resources</a>とは異なります。
Podや<a href=/ja/docs/concepts/services-networking/service/>Services</a>などのAPIリソースは、Kubernetes APIサーバーを介して読み取りおよび変更できるオブジェクトです。</p><h2 id=resource-requests-and-limits-of-pod-and-container>Podとコンテナのリソース要求と制限</h2><p>Podの各コンテナは、次の1つ以上を指定できます。</p><ul><li><code>spec.containers[].resources.limits.cpu</code></li><li><code>spec.containers[].resources.limits.memory</code></li><li><code>spec.containers[].resources.limits.hugepages-&lt;size></code></li><li><code>spec.containers[].resources.requests.cpu</code></li><li><code>spec.containers[].resources.requests.memory</code></li><li><code>spec.containers[].resources.requests.hugepages-&lt;size></code></li></ul><p>要求と制限はそれぞれのコンテナでのみ指定できますが、このPodリソースの要求と制限の関係性について理解すると便利です。
特定のリソースタイプの<em>Podリソース要求/制限</em>は、Pod内の各コンテナに対するそのタイプのリソース要求/制限の合計です。</p><h2 id=resource-units-in-kubernetes>Kubernetesにおけるリソースの単位</h2><h3 id=meaning-of-cpu>CPUの意味</h3><p>CPUリソースの制限と要求は、<em>cpu</em>単位で測定されます。
Kuberenetesにおける1つのCPUは、クラウドプロバイダーの<strong>1 vCPU/コア</strong>およびベアメタルのインテルプロセッサーの<strong>1 ハイパースレッド</strong>に相当します。</p><p>要求を少数で指定することもできます。
<code>spec.containers[].resources.requests.cpu</code>が<code>0.5</code>のコンテナは、1CPUを要求するコンテナの半分のCPUが保証されます。
<code>0.1</code>という表現は<code>100m</code>という表現と同等であり、<code>100ミリCPU</code>と読み替えることができます。
<code>100ミリコア</code>という表現も、同じことを意味しています。
<code>0.1</code>のような小数点のある要求はAPIによって<code>100m</code>に変換され、<code>1m</code>より細かい精度は許可されません。
このため、<code>100m</code>の形式が推奨されます。</p><p>CPUは常に相対量としてではなく、絶対量として要求されます。
0.1は、シングルコア、デュアルコア、あるいは48コアマシンのどのCPUに対してでも、同一の量を要求します。</p><h3 id=meaning-of-memory>メモリーの意味</h3><p><code>メモリー</code>の制限と要求はバイト単位で測定されます。
E、P、T、G、M、Kのいずれかのサフィックスを使用して、メモリーを整数または固定小数点数として表すことができます。
また、Ei、Pi、Ti、Gi、Mi、Kiのような2の累乗の値を使用することもできます。
たとえば、以下はほぼ同じ値を表しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>128974848, 129e6, 129M, 123Mi
</span></span></code></pre></div><p>例を見てみましょう。
次のPodには2つのコンテナがあります。
各コンテナには、0.25cpuおよび64MiB(2<sup>26</sup>バイト)のメモリー要求と、0.5cpuおよび128MiBのメモリー制限があります
Podには0.5cpuと128MiBのメモリー要求があり、1cpuと256MiBのメモリ制限があると言えます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=how-pods-with-resource-requests-are-scheduled>リソース要求を含むPodがどのようにスケジュールされるか</h2><p>Podを作成すると、KubernetesスケジューラーはPodを実行するNodeを選択します。
各Nodeには、リソースタイプごとに最大容量があります。それは、Podに提供できるCPUとメモリの量です。
スケジューラーは、リソースタイプごとに、スケジュールされたコンテナのリソース要求の合計がNodeの容量より少ないことを確認します。
Node上の実際のメモリーまたはCPUリソースの使用率は非常に低いですが、容量チェックが失敗した場合、スケジューラーはNodeにPodを配置しないことに注意してください。
これにより、例えば日々のリソース要求のピーク時など、リソース利用が増加したときに、Nodeのリソース不足から保護されます。</p><h2 id=how-pods-with-resource-limits-are-run>リソース制限のあるPodがどのように実行されるか</h2><p>kubeletがPodのコンテナを開始すると、CPUとメモリーの制限がコンテナランタイムに渡されます。</p><p>Dockerを使用する場合:</p><ul><li><p><code>spec.containers[].resources.requests.cpu</code>は、潜在的に小数であるコア値に変換され、1024倍されます。
<code>docker run</code>コマンドの<a href=https://docs.docker.com/engine/reference/run/#cpu-share-constraint><code>--cpu-shares</code></a>フラグの値は、この数値と2のいずれか大きい方が用いられます。</p></li><li><p><code>spec.containers[].resources.limits.cpu</code>はミリコアの値に変換され、100倍されます。
結果の値は、コンテナが100ミリ秒ごとに使用できるCPU時間の合計です。
コンテナは、この間隔の間、CPU時間の占有率を超えて使用することはできません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> デフォルトのクォータ期間は100ミリ秒です。
CPUクォータの最小分解能は1ミリ秒です。</div></li><li><p><code>spec.containers[].resources.limits.memory</code>は整数に変換され、<code>docker run</code>コマンドの<a href=https://docs.docker.com/engine/reference/run/#/user-memory-constraints><code>--memory</code></a>フラグの値として使用されます。</p></li></ul><p>コンテナがメモリー制限を超過すると、終了する場合があります。
コンテナが再起動可能である場合、kubeletは他のタイプのランタイム障害と同様にコンテナを再起動します。</p><p>コンテナがメモリー要求を超過すると、Nodeのメモリーが不足するたびにそのPodが排出される可能性があります。</p><p>コンテナは、長時間にわたってCPU制限を超えることが許可される場合と許可されない場合があります。
ただし、CPUの使用量が多すぎるために、コンテナが強制終了されることはありません。</p><p>コンテナをスケジュールできないか、リソース制限が原因で強制終了されているかどうかを確認するには、<a href=#troubleshooting>トラブルシューティング</a>のセクションを参照してください。</p><h3 id=monitoring-compute-memory-resource-usage>コンピュートリソースとメモリーリソースの使用量を監視する</h3><p>Podのリソース使用量は、Podのステータスの一部として報告されます。</p><p>オプションの<a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>監視ツール</a>がクラスターにおいて利用可能な場合、Podのリソース使用量は<a href=/docs/tasks/debug-application-cluster/resource-metrics-pipeline/#the-metrics-api>メトリクスAPI</a>から直接、もしくは監視ツールから取得できます。</p><h2 id=local-ephemeral-storage>ローカルのエフェメラルストレージ</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code></div><p>Nodeには、ローカルに接続された書き込み可能なデバイス、または場合によってはRAMによってサポートされるローカルのエフェメラルストレージがあります。
"エフェメラル"とは、耐久性について長期的な保証がないことを意味します。</p><p>Podは、スクラッチ領域、キャッシュ、ログ用にエフェメラルなローカルストレージを使用しています。
kubeletは、ローカルのエフェメラルストレージを使用して、Podにスクラッチ領域を提供し、<a href=https://kubernetes.io/docs/concepts/storage/volumes/#emptydir><code>emptyDir</code></a> <a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>をコンテナにマウントできます。</p><p>また、kubeletはこの種類のストレージを使用して、<a href=/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>Nodeレベルのコンテナログ</a>、コンテナイメージ、実行中のコンテナの書き込み可能なレイヤーを保持します。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> Nodeに障害が発生すると、そのエフェメラルストレージ内のデータが失われる可能性があります。
アプリケーションは、ローカルのエフェメラルストレージにパフォーマンスのサービス品質保証(ディスクのIOPSなど)を期待することはできません。</div><p>ベータ版の機能として、Kubernetesでは、Podが消費するローカルのエフェメラルストレージの量を追跡、予約、制限することができます。</p><h3 id=configurations-for-local-ephemeral-storage>ローカルエフェメラルストレージの設定</h3><p>Kubernetesは、Node上のローカルエフェメラルストレージを構成する2つの方法をサポートしています。<ul class="nav nav-tabs" id=local-storage-configurations role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#local-storage-configurations-0 role=tab aria-controls=local-storage-configurations-0 aria-selected=true>シングルファイルシステム</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#local-storage-configurations-1 role=tab aria-controls=local-storage-configurations-1>2ファイルシステム</a></li></ul><div class=tab-content id=local-storage-configurations><div id=local-storage-configurations-0 class="tab-pane show active" role=tabpanel aria-labelledby=local-storage-configurations-0><p><p>この構成では、さまざまな種類のローカルのエフェメラルデータ(<code>emptyDir</code>ボリュームや、書き込み可能なレイヤー、コンテナイメージ、ログなど)をすべて1つのファイルシステムに配置します。
kubeletを構成する最も効果的な方法は、このファイルシステムをKubernetes(kubelet)データ専用にすることです。</p><p>kubeletは<a href=/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>Nodeレベルのコンテナログ</a>も書き込み、これらをエフェメラルなローカルストレージと同様に扱います。</p><p>kubeletは、設定されたログディレクトリ(デフォルトでは<code>/var/log</code>)内のファイルにログを書き出し、ローカルに保存された他のデータのベースディレクトリ(デフォルトでは<code>/var/lib/kubelet</code>)を持ちます。</p><p>通常、<code>/var/lib/kubelet</code>と<code>/var/log</code>はどちらもシステムルートファイルシステムにあり、kubeletはそのレイアウトを考慮して設計されています。</p><p>Nodeには、Kubernetesに使用されていない他のファイルシステムを好きなだけ持つことができます。</p></div><div id=local-storage-configurations-1 class=tab-pane role=tabpanel aria-labelledby=local-storage-configurations-1><p><p>Node上にファイルシステムがありますが、このファイルシステムは、ログや<code>emptyDir</code>ボリュームなど、実行中のPodの一時的なデータに使用されます。
このファイルシステムは、例えばKubernetesに関連しないシステムログなどの他のデータに使用することができ、ルートファイルシステムとすることさえ可能です。</p><p>また、kubeletは<a href=/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>ノードレベルのコンテナログ</a>を最初のファイルシステムに書き込み、これらをエフェメラルなローカルストレージと同様に扱います。</p><p>また、別の論理ストレージデバイスでバックアップされた別のファイルシステムを使用することもできます。
この設定では、コンテナイメージレイヤーと書き込み可能なレイヤーを配置するようにkubeletに指示するディレクトリは、この2番目のファイルシステム上にあります。</p><p>最初のファイルシステムは、コンテナイメージレイヤーや書き込み可能なレイヤーを保持していません。</p><p>Nodeには、Kubernetesに使用されていない他のファイルシステムを好きなだけ持つことができます。</p></div></div></p><p>kubeletは、ローカルストレージの使用量を測定できます。
これは、以下の条件で提供されます。</p><ul><li><code>LocalStorageCapacityIsolation</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>が有効になっています。(デフォルトでオンになっています。)</li><li>そして、ローカルのエフェメラルストレージ用にサポートされている構成の1つを使用してNodeをセットアップします。</li></ul><p>別の構成を使用している場合、kubeletはローカルのエフェメラルストレージにリソース制限を適用しません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> kubeletは、<code>tmpfs</code>のemptyDirボリュームをローカルのエフェメラルストレージとしてではなく、コンテナメモリーとして追跡します。</div><h3 id=setting-requests-and-limits-for-local-ephemeral-storage>ローカルのエフェメラルストレージの要求と制限設定</h3><p>ローカルのエフェメラルストレージを管理するためには <em>ephemeral-storage</em> パラメーターを利用することができます。
Podの各コンテナは、次の1つ以上を指定できます。</p><ul><li><code>spec.containers[].resources.limits.ephemeral-storage</code></li><li><code>spec.containers[].resources.requests.ephemeral-storage</code></li></ul><p><code>ephemeral-storage</code>の制限と要求はバイト単位で記します。
ストレージは、次のいずれかの接尾辞を使用して、通常の整数または固定小数点数として表すことができます。
E、P、T、G、M、K。Ei、Pi、Ti、Gi、Mi、Kiの2のべき乗を使用することもできます。
たとえば、以下はほぼ同じ値を表しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>128974848, 129e6, 129M, 123Mi
</span></span></code></pre></div><p>次の例では、Podに2つのコンテナがあります。
各コンテナには、2GiBのローカルのエフェメラルストレージ要求があります。
各コンテナには、4GiBのローカルのエフェメラルストレージ制限があります。
したがって、Podには4GiBのローカルのエフェメラルストレージの要求と、8GiBのローカルのエフェメラルストレージ制限があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=how-pods-with-ephemeral-storage-requests-are-scheduled>エフェメラルストレージを要求するPodのスケジュール方法</h3><p>Podを作成すると、KubernetesスケジューラーはPodを実行するNodeを選択します。
各Nodeには、Podに提供できるローカルのエフェメラルストレージの上限があります。
詳細については、<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>Node割り当て可能</a>を参照してください。</p><p>スケジューラーは、スケジュールされたコンテナのリソース要求の合計がNodeの容量より少なくなるようにします。</p><h3 id=resource-emphemeralstorage-consumption>エフェメラルストレージの消費管理</h3><p>kubeletがローカルのエフェメラルストレージをリソースとして管理している場合、kubeletはストレージの使用量を測定します</p><ul><li><em>tmpfs</em><code>emptyDir</code>ボリュームを除く<code>emptyDir</code>ボリューム</li><li>Nodeレベルのログを保持するディレクトリ</li><li>書き込み可能なコンテナレイヤー</li></ul><p>Podが許可するよりも多くのエフェメラルストレージを使用している場合、kubeletはPodの排出をトリガーするシグナルを設定します。</p><p>コンテナレベルの分離の場合、コンテナの書き込み可能なレイヤーとログ使用量がストレージの制限を超えると、kubeletはPodに排出のマークを付けます。</p><p>Podレベルの分離の場合、kubeletはPod内のコンテナの制限を合計し、Podの全体的なストレージ制限を計算します。
このケースでは、すべてのコンテナからのローカルのエフェメラルストレージの使用量とPodの<code>emptyDir</code>ボリュームの合計がPod全体のストレージ制限を超過する場合、
kubeletはPodをまた排出対象としてマークします。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong><p>kubeletがローカルのエフェメラルストレージを測定していない場合、ローカルストレージの制限を超えるPodは、ローカルストレージのリソース制限に違反しても排出されません。</p><p>ただし、書き込み可能なコンテナレイヤー、Nodeレベルのログ、または<code>emptyDir</code>ボリュームのファイルシステムスペースが少なくなると、Nodeはローカルストレージが不足していると汚染<a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taints>taints</a>し、この汚染は、汚染を特に許容しないPodの排出をトリガーします。</p><p>ローカルのエフェメラルストレージについては、サポートされている<a href=%EF%BC%83configurations-for-local-ephemeral-storage>設定</a>をご覧ください。</p></div><p>kubeletはPodストレージの使用状況を測定するさまざまな方法をサポートしています</p><ul class="nav nav-tabs" id=resource-emphemeralstorage-measurement role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#resource-emphemeralstorage-measurement-0 role=tab aria-controls=resource-emphemeralstorage-measurement-0 aria-selected=true>定期スキャン</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#resource-emphemeralstorage-measurement-1 role=tab aria-controls=resource-emphemeralstorage-measurement-1>ファイルシステムプロジェクトクォータ</a></li></ul><div class=tab-content id=resource-emphemeralstorage-measurement><div id=resource-emphemeralstorage-measurement-0 class="tab-pane show active" role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-0><p><p>kubeletは、<code>emptyDir</code>ボリューム、コンテナログディレクトリ、書き込み可能なコンテナレイヤーをスキャンする定期的なスケジュールチェックを実行します。</p><p>スキャンは、使用されているスペースの量を測定します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>このモードでは、kubeletは削除されたファイルのために、開いているファイルディスクリプタを追跡しません。</p><p>あなた(またはコンテナ)が<code>emptyDir</code>ボリューム内にファイルを作成した後、何かがそのファイルを開き、そのファイルが開かれたままの状態でファイルを削除した場合、削除されたファイルのinodeはそのファイルを閉じるまで残りますが、kubeletはそのスペースを使用中として分類しません。</p></div></div><div id=resource-emphemeralstorage-measurement-1 class=tab-pane role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-1><p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [alpha]</code></div><p>プロジェクトクォータは、ファイルシステム上のストレージ使用量を管理するためのオペレーティングシステムレベルの機能です。
Kubernetesでは、プロジェクトクォータを有効にしてストレージの使用状況を監視することができます。
ノード上の<code>emptyDir</code>ボリュームをバックアップしているファイルシステムがプロジェクトクォータをサポートしていることを確認してください。
例えば、XFSやext4fsはプロジェクトクォータを提供しています。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> プロジェクトクォータはストレージの使用状況を監視しますが、制限を強制するものではありません。</div><p>Kubernetesでは、<code>1048576</code>から始まるプロジェクトIDを使用します。
使用するプロジェクトIDは<code>/etc/projects</code>と<code>/etc/projid</code>に登録されます。
この範囲のプロジェクトIDをシステム上で別の目的で使用する場合は、それらのプロジェクトIDを<code>/etc/projects</code>と<code>/etc/projid</code>に登録し、
Kubernetesが使用しないようにする必要があります。</p><p>クォータはディレクトリスキャンよりも高速で正確です。
ディレクトリがプロジェクトに割り当てられると、ディレクトリ配下に作成されたファイルはすべてそのプロジェクト内に作成され、カーネルはそのプロジェクト内のファイルによって使用されているブロックの数を追跡するだけです。
ファイルが作成されて削除されても、開いているファイルディスクリプタがあれば、スペースを消費し続けます。
クォータトラッキングはそのスペースを正確に記録しますが、ディレクトリスキャンは削除されたファイルが使用するストレージを見落としてしまいます。</p><p>プロジェクトクォータを使用する場合は、次のことを行う必要があります。</p><ul><li><p>kubelet設定で、<code>LocalocalStorpactionCapactionIsolationFSQuotaMonitoring=true</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gate/>フィーチャーゲート</a>を有効にします。</p></li><li><p>ルートファイルシステム(またはオプションのランタイムファイルシステム))がプロジェクトクォータを有効にしていることを確認してください。
すべてのXFSファイルシステムはプロジェクトクォータをサポートしています。
ext4ファイルシステムでは、ファイルシステムがマウントされていない間は、プロジェクトクォータ追跡機能を有効にする必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># ext4の場合、/dev/block-deviceがマウントされていません</span>
</span></span><span style=display:flex><span>sudo tune2fs -O project -Q prjquota /dev/block-device
</span></span></code></pre></div></li><li><p>ルートファイルシステム(またはオプションのランタイムファイルシステム)がプロジェクトクォータを有効にしてマウントされていることを確認してください。
XFSとext4fsの両方で、マウントオプションは<code>prjquota</code>という名前になっています。</p></li></ul></div></div><h2 id=extended-resources>拡張リソース</h2><p>拡張リソースは<code>kubernetes.io</code>ドメインの外で完全に修飾されたリソース名です。
これにより、クラスタオペレータはKubernetesに組み込まれていないリソースをアドバタイズし、ユーザはそれを利用することができるようになります。</p><p>拡張リソースを使用するためには、2つのステップが必要です。
第一に、クラスタオペレーターは拡張リソースをアドバタイズする必要があります。
第二に、ユーザーはPodで拡張リソースを要求する必要があります。</p><h3 id=managing-extended-resources>拡張リソースの管理</h3><h4 id=node-level-extended-resources>Nodeレベルの拡張リソース</h4><p>Nodeレベルの拡張リソースはNodeに関連付けられています。</p><h5 id=device-plugin-managed-resources>デバイスプラグイン管理のリソース</h5><p>各Nodeにデバイスプラグインで管理されているリソースをアドバタイズする方法については、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a>を参照してください。</p><h5 id=other-resources>その他のリソース</h5><p>新しいNodeレベルの拡張リソースをアドバタイズするには、クラスタオペレータはAPIサーバに<code>PATCH</code>HTTPリクエストを送信し、クラスタ内のNodeの<code>status.capacity</code>に利用可能な量を指定します。
この操作の後、ノードの<code>status.capacity</code>には新しいリソースが含まれます。
<code>status.allocatable</code>フィールドは、kubeletによって非同期的に新しいリソースで自動的に更新されます。
スケジューラはPodの適合性を評価する際にNodeの<code>status.allocatable</code>値を使用するため、Nodeの容量に新しいリソースを追加してから、そのNodeでリソースのスケジューリングを要求する最初のPodが現れるまでには、短い遅延が生じる可能性があることに注意してください。</p><p><strong>例:</strong></p><p>以下は、<code>curl</code>を使用して、Masterが<code>k8s-master</code>であるNode<code>k8s-node-1</code>で5つの<code>example.com/foo</code>リソースを示すHTTPリクエストを作成する方法を示す例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1foo&#34;, &#34;value&#34;: &#34;5&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>http://k8s-master:8080/api/v1/nodes/k8s-node-1/status
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 上記のリクエストでは、<code>~1</code>はパッチパス内の文字<code>/</code>のエンコーディングです。
JSON-Patchの操作パス値は、JSON-Pointerとして解釈されます。
詳細については、<a href=https://tools.ietf.org/html/rfc6901#section-3>IETF RFC 6901, section 3</a>を参照してください。</div><h4 id=cluster-level-extended-resources>クラスターレベルの拡張リソース</h4><p>クラスターレベルの拡張リソースはノードに関連付けられていません。
これらは通常、リソース消費とリソースクォータを処理するスケジューラー拡張機能によって管理されます。</p><p><a href=https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/scheduler/api/v1/types.go#L31>スケジューラーポリシー構成</a>では。スケジューラー拡張機能によって扱われる拡張リソースを指定できます。</p><p><strong>例:</strong></p><p>次のスケジューラーポリシーの構成は、クラスターレベルの拡張リソース"example.com/foo"がスケジューラー拡張機能によって処理されることを示しています。</p><ul><li>スケジューラーは、Podが"example.com/foo"を要求した場合にのみ、Podをスケジューラー拡張機能に送信します。</li><li><code>ignoredByScheduler</code>フィールドは、スケジューラがその<code>PodFitsResources</code>述語で"example.com/foo"リソースをチェックしないことを指定します。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;extenders&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;urlPrefix&#34;</span>:<span style=color:#b44>&#34;&lt;extender-endpoint&gt;&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;bindVerb&#34;</span>: <span style=color:#b44>&#34;bind&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;managedResources&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example.com/foo&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;ignoredByScheduler&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=consuming-extended-resources>拡張リソースの消費</h3><p>ユーザーは、CPUやメモリのようにPodのスペックで拡張されたリソースを消費できます。
利用可能な量以上のリソースが同時にPodに割り当てられないように、スケジューラーがリソースアカウンティングを行います。</p><p>APIサーバーは、拡張リソースの量を整数の値で制限します。
有効な数量の例は、<code>3</code>、<code>3000m</code>、<code>3Ki</code>です。
無効な数量の例は、<code>0.5</code>、<code>1500m</code>です。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 拡張リソースは不透明な整数リソースを置き換えます。
ユーザーは、予約済みの<code>kubernetes.io</code>以外のドメイン名プレフィックスを使用できます。</div><p>Podで拡張リソースを消費するには、コンテナ名の<code>spec.containers[].resources.limits</code>マップにキーとしてリソース名を含めます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 拡張リソースはオーバーコミットできないので、コンテナスペックに要求と制限の両方が存在する場合は等しくなければなりません。</div><p>Podは、CPU、メモリ、拡張リソースを含むすべてのリソース要求が満たされた場合にのみスケジュールされます。
リソース要求が満たされない限り、Podは<code>PENDING</code>状態のままです。</p><p><strong>例:</strong></p><p>下のPodはCPUを2つ、"example.com/foo"(拡張リソース)を1つ要求しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myimage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=troubleshooting>トラブルシューティング</h2><h3 id=my-pods-are-pending-with-event-message-failedscheduling>failedSchedulingイベントメッセージが表示され、Podが保留中になる</h3><p>スケジューラーがPodが収容されるNodeを見つけられない場合、場所が見つかるまでPodはスケジュールされないままになります。
スケジューラーがPodの場所を見つけられないたびに、次のようなイベントが生成されます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod frontend | grep -A <span style=color:#666>3</span> Events
</span></span></code></pre></div><pre tabindex=0><code>Events:
  FirstSeen LastSeen   Count  From          Subobject   PathReason      Message
  36s   5s     6      {scheduler }              FailedScheduling  Failed for reason PodExceedsFreeCPU and possibly others
</code></pre><p>前述の例では、"frontend"という名前のPodは、Node上のCPUリソースが不足しているためにスケジューリングに失敗しています。
同様のエラーメッセージは、メモリー不足による失敗を示唆することもあります(PodExceedsFreeMemory)。
一般的に、このタイプのメッセージでPodが保留されている場合は、いくつか試すべきことがあります。</p><ul><li>クラスタにNodeを追加します。</li><li>不要なポッドを終了して、保留中のPodのためのスペースを空けます。</li><li>PodがすべてのNodeよりも大きくないことを確認してください。
例えば、すべてのNodeが<code>cpu: 1</code>の容量を持っている場合、<code>cpu: 1.1</code>を要求するPodは決してスケジューリングされません。</li></ul><p>Nodeの容量や割り当て量は<code>kubectl describe nodes</code>コマンドで調べることができる。
例えば、以下のようになる。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe nodes e2e-test-node-pool-4lw4
</span></span></code></pre></div><pre tabindex=0><code>Name:            e2e-test-node-pool-4lw4
[ ... lines removed for clarity ...]
Capacity:
 cpu:                               2
 memory:                            7679792Ki
 pods:                              110
Allocatable:
 cpu:                               1800m
 memory:                            7474992Ki
 pods:                              110
[ ... lines removed for clarity ...]
Non-terminated Pods:        (5 in total)
  Namespace    Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits
  ---------    ----                                  ------------  ----------  ---------------  -------------
  kube-system  fluentd-gcp-v1.38-28bv1               100m (5%)     0 (0%)      200Mi (2%)       200Mi (2%)
  kube-system  kube-dns-3297075139-61lj3             260m (13%)    0 (0%)      100Mi (1%)       170Mi (2%)
  kube-system  kube-proxy-e2e-test-...               100m (5%)     0 (0%)      0 (0%)           0 (0%)
  kube-system  monitoring-influxdb-grafana-v4-z1m12  200m (10%)    200m (10%)  600Mi (8%)       600Mi (8%)
  kube-system  node-problem-detector-v0.1-fj7m3      20m (1%)      200m (10%)  20Mi (0%)        100Mi (1%)
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests    CPU Limits    Memory Requests    Memory Limits
  ------------    ----------    ---------------    -------------
  680m (34%)      400m (20%)    920Mi (12%)        1070Mi (14%)
</code></pre><p>前述の出力では、Podが1120m以上のCPUや6.23Gi以上のメモリーを要求した場合、そのPodはNodeに収まらないことがわかります。</p><p><code>Pods</code>セクションを見れば、どのPodがNode上でスペースを占有しているかがわかります。</p><p>システムデーモンが利用可能なリソースの一部を使用しているため、Podに利用可能なリソースの量はNodeの容量よりも少なくなっています。
<code>allocatable</code>フィールド<a href=/docs/reference/generated/kubernetes-api/v1.25/#nodestatus-v1-core>NodeStatus</a>は、Podに利用可能なリソースの量を与えます。
詳細については、<a href=https://git.k8s.io/design-proposals-archive/node/node-allocatable.md>ノード割り当て可能なリソース</a>を参照してください。</p><p><a href=/docs/concepts/policy/resource-quotas/>リソースクォータ</a>機能は、消費できるリソースの総量を制限するように設定することができます。
名前空間と組み合わせて使用すると、1つのチームがすべてのリソースを占有するのを防ぐことができます。</p><h3 id=my-container-is-terminated>コンテナが終了した</h3><p>コンテナはリソース不足のため、終了する可能性があります。
コンテナがリソース制限に達したために強制終了されているかどうかを確認するには、対象のPodで<code>kubectl describe pod</code>を呼び出します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod simmemleak-hra99
</span></span></code></pre></div><pre tabindex=0><code>Name:                           simmemleak-hra99
Namespace:                      default
Image(s):                       saadali/simmemleak
Node:                           kubernetes-node-tf0f/10.240.216.66
Labels:                         name=simmemleak
Status:                         Running
Reason:
Message:
IP:                             10.244.2.75
Replication Controllers:        simmemleak (1/1 replicas created)
Containers:
  simmemleak:
    Image:  saadali/simmemleak
    Limits:
      cpu:                      100m
      memory:                   50Mi
    State:                      Running
      Started:                  Tue, 07 Jul 2015 12:54:41 -0700
    Last Termination State:     Terminated
      Exit Code:                1
      Started:                  Fri, 07 Jul 2015 12:54:30 -0700
      Finished:                 Fri, 07 Jul 2015 12:54:33 -0700
    Ready:                      False
    Restart Count:              5
Conditions:
  Type      Status
  Ready     False
Events:
  FirstSeen                         LastSeen                         Count  From                              SubobjectPath                       Reason      Message
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {scheduler }                                                          scheduled   Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   pulled      Pod container image &#34;k8s.gcr.io/pause:0.8.0&#34; already present on machine
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   created     Created with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   started     Started with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    spec.containers{simmemleak}         created     Created with docker id 87348f12526a
</code></pre><p>上記の例では、<code>Restart Count：5</code>はPodの<code>simmemleak</code>コンテナが終了して、5回再起動したことを示しています。</p><p><code>-o go-template=...</code>オプションを指定して、<code>kubectl get pod</code>を呼び出し、以前に終了したコンテナのステータスを取得できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range.status.containerStatuses}}{{&#34;Container Name: &#34;}}{{.name}}{{&#34;\r\nLastState: &#34;}}{{.lastState}}{{end}}&#39;</span>  simmemleak-hra99
</span></span></code></pre></div><pre tabindex=0><code>Container Name: simmemleak
LastState: map[terminated:map[exitCode:137 reason:OOM Killed startedAt:2015-07-07T20:58:43Z finishedAt:2015-07-07T20:58:43Z containerID:docker://0e4095bba1feccdfe7ef9fb6ebffe972b4b14285d5acdec6f0d3ae8a22fad8b2]]
</code></pre><p><code>reason：OOM Killed</code>が原因でコンテナが終了したことがわかります。<code>OOM</code>はメモリー不足を表します。</p><h2 id=次の項目>次の項目</h2><ul><li><p><a href=/ja/docs/tasks/configure-pod-container/assign-memory-resource/>コンテナとPodへのメモリーリソースの割り当て</a>ハンズオンを行う</p></li><li><p><a href=/ja/docs/tasks/configure-pod-container/assign-cpu-resource/>コンテナとPodへのCPUリソースの割り当て</a>ハンズオンを行う</p></li><li><p>要求と制限の違いの詳細については、<a href=https://git.k8s.io/design-proposals-archive/node/resource-qos.md>リソースQoS</a>を参照する</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>コンテナ</a>APIリファレンスを読む</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#resourcerequirements-v1-core>リソース要求</a>APIリファレンスを読む</p></li><li><p>XFSの<a href=http://xfs.org/docs/xfsdocs-xml-dev/XFS_User_Guide/tmp/en-US/html/xfs-quotas.html>プロジェクトクォータ</a>について読む</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>5 - kubeconfigファイルを使用してクラスターアクセスを組織する</h1><p>kubeconfigを使用すると、クラスターに、ユーザー、名前空間、認証の仕組みに関する情報を組織できます。<code>kubectl</code>コマンドラインツールはkubeconfigファイルを使用してクラスターを選択するために必要な情報を見つけ、クラスターのAPIサーバーと通信します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> クラスターへのアクセスを設定するために使われるファイルは<em>kubeconfigファイル</em>と呼ばれます。これは設定ファイルを指すために使われる一般的な方法です。<code>kubeconfig</code>という名前を持つファイルが存在するという意味ではありません。</div><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> 信頼できるソースからのkubeconfigファイルのみを使用してください。特別に細工されたkubeconfigファイルを使用すると、悪意のあるコードの実行やファイルの公開につながる可能性があります。
信頼できないkubeconfigファイルを使用しなければならない場合は、シェルスクリプトを使用するのと同じように、まず最初に慎重に検査してください。</div><p>デフォルトでは、<code>kubectl</code>は<code>$HOME/.kube</code>ディレクトリ内にある<code>config</code>という名前のファイルを探します。<code>KUBECONFIG</code>環境変数を設定するか、<a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a>フラグで指定することで、別のkubeconfigファイルを指定することもできます。</p><p>kubeconfigファイルの作成と指定に関するステップバイステップの手順を知りたいときは、<a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters>複数のクラスターへのアクセスを設定する</a>を参照してください。</p><h2 id=複数のクラスター-ユーザ-認証の仕組みのサポート>複数のクラスター、ユーザ、認証の仕組みのサポート</h2><p>複数のクラスターを持っていて、ユーザーやコンポーネントがさまざまな方法で認証を行う次のような状況を考えてみます。</p><ul><li>実行中のkubeletが証明書を使用して認証を行う可能性がある。</li><li>ユーザーがトークンを使用して認証を行う可能性がある。</li><li>管理者が個別のユーザに提供する複数の証明書を持っている可能性がある。</li></ul><p>kubeconfigファイルを使用すると、クラスター、ユーザー、名前空間を組織化することができます。また、contextを定義することで、複数のクラスターや名前空間を素早く簡単に切り替えられます。</p><h2 id=context>Context</h2><p>kubeconfigファイルの<em>context</em>要素は、アクセスパラメーターを使いやすい名前でグループ化するために使われます。各contextは3つのパラメータ、cluster、namespace、userを持ちます。デフォルトでは、<code>kubectl</code>コマンドラインツールはクラスターとの通信に<em>current context</em>のパラメーターを使用します。</p><p>current contextを選択するには、以下のコマンドを使用します。</p><pre tabindex=0><code>kubectl config use-context
</code></pre><h2 id=kubeconfig環境変数>KUBECONFIG環境変数</h2><p><code>KUBECONFIG</code>環境変数には、kubeconfigファイルのリストを指定できます。LinuxとMacでは、リストはコロン区切りです。Windowsでは、セミコロン区切りです。<code>KUBECONFIG</code>環境変数は必須ではありません。<code>KUBECONFIG</code>環境変数が存在しない場合は、<code>kubectl</code>はデフォルトのkubeconfigファイルである<code>$HOME/.kube/config</code>を使用します。</p><p><code>KUBECONFIG</code>環境変数が存在する場合は、<code>kubectl</code>は<code>KUBECONFIG</code>環境変数にリストされているファイルをマージした結果を有効な設定として使用します。</p><h2 id=kubeconfigファイルのマージ>kubeconfigファイルのマージ</h2><p>設定ファイルを確認するには、以下のコマンドを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>上で説明したように、出力は1つのkubeconfigファイルから作られる場合も、複数のkubeconfigファイルをマージした結果となる場合もあります。</p><p><code>kubectl</code>がkubeconfigファイルをマージするときに使用するルールを以下に示します。</p><ol><li><p>もし<code>--kubeconfig</code>フラグが設定されていた場合、指定したファイルだけが使用されます。マージは行いません。このフラグに指定できるのは1つのファイルだけです。</p><p>そうでない場合、<code>KUBECONFIG</code>環境変数が設定されていた場合には、それをマージするべきファイルのリストとして使用します。<code>KUBECONFIG</code>環境変数にリストされたファイルのマージは、次のようなルールに従って行われます。</p><ul><li>空のファイルを無視する。</li><li>デシリアライズできない内容のファイルに対してエラーを出す。</li><li>特定の値やmapのキーを設定する最初のファイルが勝つ。</li><li>値やmapのキーは決して変更しない。
例: 最初のファイルが指定した<code>current-context</code>を保持する。
例: 2つのファイルが<code>red-user</code>を指定した場合、1つ目のファイルの<code>red-user</code>だけを使用する。もし2つ目のファイルの<code>red-user</code>以下に競合しないエントリーがあったとしても、それらは破棄する。</li></ul><p><code>KUBECONFIG</code>環境変数を設定する例については、<a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable>KUBECONFIG環境変数を設定する</a>を参照してください。</p><p>それ以外の場合は、デフォルトのkubeconfigファイル<code>$HOME/.kube/config</code>をマージせずに使用します。</p></li><li><p>以下のチェーンで最初に見つかったものをもとにして、使用するcontextを決定する。</p><ol><li><code>--context</code>コマンドラインフラグが存在すれば、それを使用する。</li><li>マージしたkubeconrfigファイルから<code>current-context</code>を使用する。</li></ol><p>この時点では、空のcontextも許容されます。</p></li><li><p>クラスターとユーザーを決定する。この時点では、contextである場合もそうでない場合もあります。以下のチェーンで最初に見つかったものをもとにして、クラスターとユーザーを決定します。この手順はユーザーとクラスターについてそれぞれ1回ずつ、合わせて2回実行されます。</p><ol><li>もし存在すれば、コマンドラインフラグ<code>--user</code>または<code>--cluster</code>を使用する。</li><li>もしcontextが空でなければ、contextからユーザーまたはクラスターを取得する。</li></ol><p>この時点では、ユーザーとクラスターは空である可能性があります。</p></li><li><p>使用する実際のクラスター情報を決定する。この時点では、クラスター情報は存在しない可能性があります。以下のチェーンで最初に見つかったものをもとにして、クラスター情報の各パーツをそれぞれを構築します。</p><ol><li>もし存在すれば、<code>--server</code>、<code>--certificate-authority</code>、<code>--insecure-skip-tls-verify</code>コマンドラインフラグを使用する。</li><li>もしマージしたkubeconfigファイルにクラスター情報の属性が存在すれば、それを使用する。</li><li>もしサーバーの場所が存在しなければ、マージは失敗する。</li></ol></li><li><p>使用する実際のユーザー情報を決定する。クラスター情報の場合と同じルールを使用して、ユーザー情報を構築します。ただし、ユーザーごとに許可される認証方法は1つだけです。</p><ol><li>もし存在すれば、<code>--client-certificate</code>、<code>--client-key</code>、<code>--username</code>、<code>--password</code>、<code>--token</code>コマンドラインフラグを使用する。</li><li>マージしたkubeconfigファイルの<code>user</code>フィールドを使用する。</li><li>もし2つの競合する方法が存在する場合、マージは失敗する。</li></ol></li><li><p>もし何らかの情報がまだ不足していれば、デフォルトの値を使用し、認証情報については場合によってはプロンプトを表示する。</p></li></ol><h2 id=ファイルリファレンス>ファイルリファレンス</h2><p>kubeconfigファイル内のファイルとパスのリファレンスは、kubeconfigファイルの位置からの相対パスで指定します。コマンドライン上のファイルのリファレンスは、現在のワーキングディレクトリからの相対パスです。<code>$HOME/.kube/config</code>内では、相対パスは相対のまま、絶対パスは絶対のまま保存されます。</p><h2 id=プロキシー>プロキシー</h2><p>kubeconfigファイルで<code>proxy-url</code>を使用すると、以下のようにクラスターごとにプロキシーを使用するように<code>kubectl</code>を設定することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>proxy-url</span>:<span style=color:#bbb> </span>http://proxy.example.org:3128<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://k8s.example.org/k8s/clusters/c-xxyyzz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>複数のクラスターへのアクセスを設定する</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ed4ae5e4344d619bc6df6e1278efae74>6 - Podの優先度とプリエンプション</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code></div><p><a href=/ja/docs/concepts/workloads/pods/>Pod</a>は <em>priority</em>（優先度）を持つことができます。
優先度は他のPodに対する相対的なPodの重要度を示します。
もしPodをスケジューリングできないときには、スケジューラーはそのPodをスケジューリングできるようにするため、優先度の低いPodをプリエンプトする（追い出す）ことを試みます。</p><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong><p>クラスターの全てのユーザーが信用されていない場合、悪意のあるユーザーが可能な範囲で最も高い優先度のPodを作成することが可能です。これは他のPodが追い出されたりスケジューリングできない状態を招きます。
管理者はResourceQuotaを使用して、ユーザーがPodを高い優先度で作成することを防ぐことができます。</p><p>詳細は<a href=/ja/docs/concepts/policy/resource-quotas/#limit-priority-class-consumption-by-default>デフォルトで優先度クラスの消費を制限する</a>
を参照してください。</p></div><h2 id=優先度とプリエンプションを使う方法>優先度とプリエンプションを使う方法</h2><p>優先度とプリエンプションを使うには、</p><ol><li><p>1つまたは複数の<a href=#priorityclass>PriorityClass</a>を追加します</p></li><li><p>追加したPriorityClassを<a href=#pod-priority><code>priorityClassName</code></a>に設定したPodを作成します。
もちろんPodを直接作る必要はありません。
一般的には<code>priorityClassName</code>をDeploymentのようなコレクションオブジェクトのPodテンプレートに追加します。</p></li></ol><p>これらの手順のより詳しい情報については、この先を読み進めてください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Kubernetesには最初から既に2つのPriorityClassが設定された状態になっています。
<code>system-cluster-critical</code>と<code>system-node-critical</code>です。
これらは汎用のクラスであり、<a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/>重要なコンポーネントが常に最初にスケジュールされることを保証する</a>ために使われます。</div><h2 id=priorityclass>PriorityClass</h2><p>PriorityClassはnamespaceによらないオブジェクトで、優先度クラスの名称から優先度を表す整数値への対応を定義します。
PriorityClassオブジェクトのメタデータの<code>name</code>フィールドにて名称を指定します。
値は<code>value</code>フィールドで指定し、必須です。
値が大きいほど、高い優先度を示します。
PriorityClassオブジェクトの名称は<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>として適切であり、かつ<code>system-</code>から始まってはいけません。</p><p>PriorityClassオブジェクトは10億以下の任意の32ビットの整数値を持つことができます。
それよりも大きな値は通常はプリエンプトや追い出すべきではない重要なシステム用のPodのために予約されています。
クラスターの管理者は割り当てたい優先度に対して、PriorityClassオブジェクトを1つずつ作成すべきです。</p><p>PriorityClassは任意でフィールド<code>globalDefault</code>と<code>description</code>を設定可能です。
<code>globalDefault</code>フィールドは<code>priorityClassName</code>が指定されないPodはこのPriorityClassを使うべきであることを示します。<code>globalDefault</code>がtrueに設定されたPriorityClassはシステムで一つのみ存在可能です。<code>globalDefault</code>が設定されたPriorityClassが存在しない場合は、<code>priorityClassName</code>が設定されていないPodの優先度は0に設定されます。</p><p><code>description</code>フィールドは任意の文字列です。クラスターの利用者に対して、PriorityClassをどのような時に使うべきか示すことを意図しています。</p><h3 id=podpriorityと既存のクラスターに関する注意>PodPriorityと既存のクラスターに関する注意</h3><ul><li><p>もし既存のクラスターをこの機能がない状態でアップグレードすると、既存のPodの優先度は実質的に0になります。</p></li><li><p><code>globalDefault</code>が<code>true</code>に設定されたPriorityClassを追加しても、既存のPodの優先度は変わりません。PriorityClassのそのような値は、PriorityClassが追加された以後に作成されたPodのみに適用されます。</p></li><li><p>PriorityClassを削除した場合、削除されたPriorityClassの名前を使用する既存のPodは変更されませんが、削除されたPriorityClassの名前を使うPodをそれ以上作成することはできなくなります。</p></li></ul><h3 id=priorityclassの例>PriorityClassの例</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;この優先度クラスはXYZサービスのPodに対してのみ使用すべきです。&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=non-preempting-priority-class>非プリエンプトのPriorityClass</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p><code>PreemptionPolicy: Never</code>と設定されたPodは、スケジューリングのキューにおいて他の優先度の低いPodよりも優先されますが、他のPodをプリエンプトすることはありません。
スケジューリングされるのを待つ非プリエンプトのPodは、リソースが十分に利用可能になるまでスケジューリングキューに残ります。
非プリエンプトのPodは、他のPodと同様に、スケジューラーのバックオフの対象になります。これは、スケジューラーがPodをスケジューリングしようと試みたものの失敗した場合、低い頻度で再試行するようにして、より優先度の低いPodが先にスケジューリングされることを許します。</p><p>非プリエンプトのPodは、他の優先度の高いPodにプリエンプトされる可能性はあります。</p><p><code>PreemptionPolicy</code>はデフォルトでは<code>PreemptLowerPriority</code>に設定されており、これが設定されているPodは優先度の低いPodをプリエンプトすることを許容します。これは既存のデフォルトの挙動です。
<code>PreemptionPolicy</code>を<code>Never</code>に設定すると、これが設定されたPodはプリエンプトを行わないようになります。</p><p>ユースケースの例として、データサイエンスの処理を挙げます。
ユーザーは他の処理よりも優先度を高くしたいジョブを追加できますが、そのとき既存の実行中のPodの処理結果をプリエンプトによって破棄させたくはありません。
<code>PreemptionPolicy: Never</code>が設定された優先度の高いジョブは、他の既にキューイングされたPodよりも先に、クラスターのリソースが「自然に」開放されたときにスケジューリングされます。</p><h3 id=非プリエンプトのpriorityclassの例>非プリエンプトのPriorityClassの例</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority-nonpreempting<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preemptionPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;この優先度クラスは他のPodをプリエンプトさせません。&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=pod-priority>Podの優先度</h2><p>一つ以上のPriorityClassがあれば、仕様にPriorityClassを指定したPodを作成することができるようになります。優先度のアドミッションコントローラーは<code>priorityClassName</code>フィールドを使用し、優先度の整数値を設定します。PriorityClassが見つからない場合、そのPodの作成は拒否されます。</p><p>下記のYAMLは上記の例で作成したPriorityClassを使用するPodの設定の例を示します。優先度のアドミッションコントローラーは仕様を確認し、このPodの優先度は1000000であると設定します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=スケジューリング順序におけるpodの優先度の効果>スケジューリング順序におけるPodの優先度の効果</h3><p>Podの優先度が有効な場合、スケジューラーは待機状態のPodをそれらの優先度順に並べ、スケジューリングキューにおいてより優先度の低いPodよりも前に来るようにします。その結果、その条件を満たしたときには優先度の高いPodは優先度の低いPodより早くスケジューリングされます。優先度の高いPodがスケジューリングできない場合は、スケジューラーは他の優先度の低いPodのスケジューリングも試みます。</p><h2 id=プリエンプション>プリエンプション</h2><p>Podが作成されると、スケジューリング待ちのキューに入り待機状態になります。スケジューラーはキューからPodを取り出し、ノードへのスケジューリングを試みます。Podに指定された条件を全て満たすノードが見つからない場合は、待機状態のPodのためにプリエンプションロジックが発動します。待機状態のPodをPと呼ぶことにしましょう。プリエンプションロジックはPよりも優先度の低いPodを一つ以上追い出せばPをスケジューリングできるようになるノードを探します。そのようなノードがあれば、優先度の低いPodはノードから追い出されます。Podが追い出された後に、Pはノードへスケジューリング可能になります。</p><h3 id=ユーザーへ開示される情報>ユーザーへ開示される情報</h3><p>Pod PがノードNのPodをプリエンプトした場合、ノードNの名称がPのステータスの<code>nominatedNodeName</code>フィールドに設定されます。このフィールドはスケジューラーがPod Pのために予約しているリソースの追跡を助け、ユーザーにクラスターにおけるプリエンプトに関する情報を与えます。</p><p>Pod Pは必ずしも「指名したノード」へスケジューリングされないことに注意してください。Podがプリエンプトされると、そのPodは終了までの猶予期間を得ます。スケジューラーがPodの終了を待つ間に他のノードが利用可能になると、スケジューラーは他のノードをPod Pのスケジューリング先にします。この結果、Podの<code>nominatedNodeName</code>と<code>nodeName</code>は必ずしも一致しません。また、スケジューラーがノードNのPodをプリエンプトさせた後に、Pod Pよりも優先度の高いPodが来た場合、スケジューラーはノードNをその新しい優先度の高いPodへ与えます。このような場合は、スケジューラーはPod Pの<code>nominatedNodeName</code>を消去します。これによって、スケジューラーはPod Pが他のノードのPodをプリエンプトさせられるようにします。</p><h3 id=プリエンプトの制限>プリエンプトの制限</h3><h4 id=プリエンプトされるpodの正常終了>プリエンプトされるPodの正常終了</h4><p>Podがプリエンプトされると、<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>猶予期間</a>が与えられます。</p><p>Podは作業を完了し、終了するために十分な時間が与えられます。仮にそうでない場合、強制終了されます。この猶予期間によって、スケジューラーがPodをプリエンプトした時刻と、待機状態のPod Pがノード Nにスケジュール可能になるまでの時刻の間に間が開きます。この間、スケジューラーは他の待機状態のPodをスケジュールしようと試みます。プリエンプトされたPodが終了したら、スケジューラーは待ち行列にあるPodをスケジューリングしようと試みます。そのため、Podがプリエンプトされる時刻と、Pがスケジュールされた時刻には間が開くことが一般的です。この間を最小にするには、優先度の低いPodの猶予期間を0または小さい値にする方法があります。</p><h4 id=poddisruptionbudgetは対応するが-保証されない>PodDisruptionBudgetは対応するが、保証されない</h4><p><a href=/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a> (PDB)は、アプリケーションのオーナーが冗長化されたアプリケーションのPodが意図的に中断される数の上限を設定できるようにするものです。KubernetesはPodをプリエンプトする際にPDBに対応しますが、PDBはベストエフォートで考慮します。スケジューラーはプリエンプトさせたとしてもPDBに違反しないPodを探します。そのようなPodが見つからない場合でもプリエンプションは実行され、PDBに反しますが優先度の低いPodが追い出されます。</p><h4 id=優先度の低いpodにおけるpod間のアフィニティ>優先度の低いPodにおけるPod間のアフィニティ</h4><p>次の条件が真の場合のみ、ノードはプリエンプションの候補に入ります。
「待機状態のPodよりも優先度の低いPodをノードから全て追い出したら、待機状態のPodをノードへスケジュールできるか」</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> プリエンプションは必ずしも優先度の低いPodを全て追い出しません。
優先度の低いPodを全て追い出さなくても待機状態のPodがスケジューリングできる場合、一部のPodのみ追い出されます。
このような場合であったとしても、上記の条件は真である必要があります。偽であれば、そのノードはプリエンプションの対象とはされません。</div><p>待機状態のPodが、優先度の低いPodとの間でPod間のアフィニティを持つ場合、Pod間のアフィニティはそれらの優先度の低いPodがなければ満たされません。この場合、スケジューラーはノードのどのPodもプリエンプトしようとはせず、代わりに他のノードを探します。スケジューラーは適切なノードを探せる場合と探せない場合があります。この場合、待機状態のPodがスケジューリングされる保証はありません。</p><p>この問題に対して推奨される解決策は、優先度が同一または高いPodに対してのみPod間のアフィニティを作成することです。</p><h4 id=複数ノードに対するプリエンプション>複数ノードに対するプリエンプション</h4><p>Pod PがノードNにスケジューリングできるよう、ノードNがプリエンプションの対象となったとします。
他のノードのPodがプリエンプトされた場合のみPが実行可能になることもあります。下記に例を示します。</p><ul><li>Pod PをノードNに配置することを検討します。</li><li>Pod QはノードNと同じゾーンにある別のノードで実行中です。</li><li>Pod Pはゾーンに対するQへのアンチアフィニティを持ちます (<code>topologyKey: topology.kubernetes.io/zone</code>)。</li><li>Pod Pと、ゾーン内の他のPodに対しては他のアンチアフィニティはない状態です。</li><li>Pod PをノードNへスケジューリングするには、Pod Qをプリエンプトすることが考えられますが、スケジューラーは複数ノードにわたるプリエンプションは行いません。そのため、Pod PはノードNへはスケジューリングできないとみなされます。</li></ul><p>Pod Qがそのノードから追い出されると、Podアンチアフィニティに違反しなくなるので、Pod PはノードNへスケジューリング可能になります。</p><p>複数ノードに対するプリエンプションに関しては、十分な需要があり、合理的な性能を持つアルゴリズムを見つけられた場合に、追加することを検討する可能性があります。</p><h2 id=トラブルシューティング>トラブルシューティング</h2><p>Podの優先度とプリエンプションは望まない副作用をもたらす可能性があります。
いくつかの起こりうる問題と、その対策について示します。</p><h3 id=podが不必要にプリエンプトされる>Podが不必要にプリエンプトされる</h3><p>プリエンプションは、リソースが不足している場合に優先度の高い待機状態のPodのためにクラスターの既存のPodを追い出します。
誤って高い優先度をPodに割り当てると、意図しない高い優先度のPodはクラスター内でプリエンプションを引き起こす可能性があります。Podの優先度はPodの仕様の<code>priorityClassName</code>フィールドにて指定されます。優先度を示す整数値へと変換された後、<code>podSpec</code>の<code>priority</code>へ設定されます。</p><p>この問題に対処するには、Podの<code>priorityClassName</code>をより低い優先度に変更するか、このフィールドを未設定にすることができます。<code>priorityClassName</code>が未設定の場合、デフォルトでは優先度は0とされます。</p><p>Podがプリエンプトされたとき、プリエンプトされたPodのイベントが記録されます。
プリエンプションはPodに必要なリソースがクラスターにない場合のみ起こるべきです。
このような場合、プリエンプションはプリエンプトされるPodよりも待機状態のPodの優先度が高い場合のみ発生します。
プリエンプションは待機状態のPodがない場合や待機状態のPodがプリエンプト対象のPod以下の優先度を持つ場合には決して発生しません。そのような状況でプリエンプションが発生した場合、問題を報告してください。</p><h3 id=podはプリエンプトされたが-プリエンプトさせたpodがスケジューリングされない>Podはプリエンプトされたが、プリエンプトさせたPodがスケジューリングされない</h3><p>Podがプリエンプトされると、それらのPodが要求した猶予期間が与えられます。そのデフォルトは30秒です。
Podがその期間内に終了しない場合、強制終了されます。プリエンプトされたPodがなくなれば、プリエンプトさせたPodはスケジューリング可能です。</p><p>プリエンプトさせたPodがプリエンプトされたPodの終了を待っている間に、より優先度の高いPodが同じノードに対して作成されることもあります。この場合、スケジューラーはプリエンプトさせたPodの代わりに優先度の高いPodをスケジューリングします。</p><p>これは予期された挙動です。優先度の高いPodは優先度の低いPodに取って代わります。</p><h3 id=優先度の高いpodが優先度の低いpodより先にプリエンプトされる>優先度の高いPodが優先度の低いPodより先にプリエンプトされる</h3><p>スケジューラーは待機状態のPodが実行可能なノードを探します。ノードが見つからない場合、スケジューラーは任意のノードから優先度の低いPodを追い出し、待機状態のPodのためのリソースを確保しようとします。
仮に優先度の低いPodが動いているノードが待機状態のPodを動かすために適切ではない場合、スケジューラーは他のノードで動いているPodと比べると、優先度の高いPodが動いているノードをプリエンプションの対象に選ぶことがあります。この場合もプリエンプトされるPodはプリエンプトを起こしたPodよりも優先度が低い必要があります。</p><p>複数のノードがプリエンプションの対象にできる場合、スケジューラーは優先度が最も低いPodのあるノードを選ぼうとします。しかし、そのようなPodがPodDisruptionBudgetを持っており、プリエンプトするとPDBに反する場合はスケジューラーは優先度の高いPodのあるノードを選ぶこともあります。</p><p>複数のノードがプリエンプションの対象として利用可能で、上記の状況に当てはまらない場合、スケジューラーは優先度の最も低いノードを選択します。</p><h2 id=interactions-of-pod-priority-and-qos>Podの優先度とQoSの相互作用</h2><p>Podの優先度と<a class=glossary-tooltip title='QoS Class (Quality of Service Class) provides a way for Kubernetes to classify pods within the cluster into several classes and make decisions about scheduling and eviction.' data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-qos-class' target=_blank aria-label=QoSクラス>QoSクラス</a>は直交する機能で、わずかに相互作用がありますが、デフォルトではQoSクラスによる優先度の設定の制約はありません。スケジューラーのプリエンプションのロジックはプリエンプションの対象を決めるときにQoSクラスは考慮しません。
プリエンプションはPodの優先度を考慮し、優先度が最も低いものを候補とします。より優先度の高いPodは優先度の低いPodを追い出すだけではプリエンプトを起こしたPodのスケジューリングに不十分な場合と、<code>PodDisruptionBudget</code>により優先度の低いPodが保護されている場合のみ対象になります。</p><p>QoSとPodの優先度の両方を考慮するコンポーネントは<a href=/docs/tasks/administer-cluster/out-of-resource/>リソース不足によりkubeletがPodを追い出す</a>のみです。
kubeletは追い出すPodの順位付けを次の順で行います。枯渇したリソースを要求以上に使用しているか、優先度、枯渇したリソースの消費量の複数のPodの要求に対する相対値。
詳細は<a href=/docs/tasks/administer-cluster/out-of-resource/#evicting-end-user-pods>エンドユーザーのPodの追い出し</a>を参照してください。</p><p>kubeletによるリソース不足時のPodの追い出しでは、リソースの消費が要求を超えないPodは追い出されません。優先度の低いPodのリソースの利用量がその要求を超えていなければ、追い出されることはありません。より優先度が高く、要求を超えてリソースを使用しているPodが追い出されます。</p><h2 id=次の項目>次の項目</h2><ul><li>PriorityClassと関連付けてResourceQuotaを使用することに関して <a href=/ja/docs/concepts/policy/resource-quotas/#limit-priority-class-consumption-by-default>デフォルトで優先度クラスの消費を制限する</a></li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>