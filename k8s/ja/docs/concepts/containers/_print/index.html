<!doctype html><html lang=ja class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/containers/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/containers/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/containers/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/containers/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/containers/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/containers/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/containers/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/containers/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/containers/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/containers/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/containers/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>コンテナ | Kubernetes</title><meta property="og:title" content="コンテナ"><meta property="og:description" content="アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/containers/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="コンテナ"><meta itemprop=description content="アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術"><meta name=twitter:card content="summary"><meta name=twitter:title content="コンテナ"><meta name=twitter:description content="アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術"><meta property="og:description" content="アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術"><meta name=twitter:description content="アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/containers/"><meta property="og:title" content="コンテナ"><meta name=twitter:title content="コンテナ"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ja/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ja/docs/>ドキュメント</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/blog/>Blogs</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/training/>トレーニング</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/partners/>パートナー</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/community/>コミュニティ</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/case-studies/>ケーススタディ</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>バージョン</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ja/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/containers/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/containers/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/containers/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/concepts/containers/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ja/docs/concepts/containers/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語 (Japanese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/containers/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/containers/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/containers/>한국어 (Korean)</a>
<a class=dropdown-item href=/fr/docs/concepts/containers/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/containers/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/containers/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/containers/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/containers/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/containers/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/containers/>Tiếng Việt (Vietnamese)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.</p><p><a href=/ja/docs/concepts/containers/>このページの通常のビューに戻る</a>.</p></div><h1 class=title>コンテナ</h1><div class=lead>アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術</div><ul><li>1: <a href=#pg-8fda96dc403731ceba5e0ddd0ab3ad15>コンテナの概要</a></li><li>2: <a href=#pg-16042b4652ad19e565c7263824029a43>イメージ</a></li><li>3: <a href=#pg-643212488f778acf04bebed65ba34441>コンテナ環境</a></li><li>4: <a href=#pg-a858027489648786a3b16264e451272b>ランタイムクラス(Runtime Class)</a></li><li>5: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>コンテナライフサイクルフック</a></li></ul><div class=content><p>実行するそれぞれのコンテナは繰り返し使用可能です。依存関係を含めて標準化されており、どこで実行しても同じ動作が得られることを意味しています。</p><p>コンテナは基盤となるホストインフラからアプリケーションを切り離します。これにより、さまざまなクラウドやOS環境下でのデプロイが容易になります。</p><h2 id=container-images>コンテナイメージ</h2><p><a href=/ja/docs/concepts/containers/images/>コンテナイメージ</a>はすぐに実行可能なソフトウェアパッケージで、アプリケーションの実行に必要なものをすべて含んています。コードと必要なランタイム、アプリケーションとシステムのライブラリ、そして必須な設定項目のデフォルト値を含みます。</p><p>設計上、コンテナは不変で、既に実行中のコンテナのコードを変更することはできません。コンテナ化されたアプリケーションがあり変更したい場合は、変更を含んだ新しいイメージをビルドし、コンテナを再作成して、更新されたイメージから起動する必要があります。</p><h2 id=コンテナランタイム>コンテナランタイム</h2><p>コンテナランタイムは、コンテナの実行を担当するソフトウェアです。</p><p>Kubernetesは次の複数のコンテナランタイムをサポートします。
<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>、<a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>、<a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>、
および全ての
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>
実装です。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/concepts/containers/images/>コンテナイメージ</a>についてお読みください。</li><li><a href=/ja/docs/concepts/workloads/pods/>Pod</a>についてお読みください。</li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-8fda96dc403731ceba5e0ddd0ab3ad15>1 - コンテナの概要</h1><p>コンテナは、アプリケーションの(コンパイルされた)コードと、実行時に必要な依存関係をパッケージ化するための技術です。実行する各コンテナは再現性があります。依存関係を含めることによる標準化は、どこで実行しても同じ動作が得られることを意味します。</p><p>コンテナは、基礎となるホストインフラストラクチャからアプリケーションを切り離します。これにより、さまざまなクラウド環境やOS環境でのデプロイが容易になります。</p><h2 id=container-images>コンテナイメージ</h2><p><a href=/docs/concepts/containers/images/>コンテナイメージ</a>は、アプリケーションを実行するために必要なすべてのものを含んだ、すぐに実行可能なソフトウェアパッケージです。コードとそれが必要とする任意のランタイム、アプリケーションとシステムのライブラリ、および必須の設定のデフォルト値が含まれています。</p><p>設計上、コンテナは不変であるため、すでに実行中のコンテナのコードを変更することはできません。コンテナ化されたアプリケーションがあり、変更を加えたい場合は、変更を含む新しいコンテナをビルドし、コンテナを再作成して更新されたイメージから起動する必要があります。</p><h2 id=container-runtimes>コンテナランタイム</h2><p>コンテナランタイムは、コンテナの実行を担当するソフトウェアです。</p><p>Kubernetesは次の複数のコンテナランタイムをサポートします。
<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>、<a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>、<a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>、
および全ての
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>
実装です。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/docs/concepts/containers/images/>コンテナイメージ</a>についてお読みください。</li><li><a href=/ja/docs/concepts/workloads/pods/>Pod</a>についてお読みください。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-16042b4652ad19e565c7263824029a43>2 - イメージ</h1><p>コンテナイメージはアプリケーションと依存関係のあるすべてソフトウェアをカプセル化したバイナリデータを表します。コンテナイメージはスタンドアロンで実行可能なソフトウェアをひとつにまとめ、ランタイム環境に関する想定を明確に定義しています。</p><p>アプリケーションのコンテナイメージを作成し、一般的には<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>で参照する前にレジストリへPushします。</p><p>このページではコンテナイメージの概要を説明します。</p><h2 id=イメージの名称>イメージの名称</h2><p>コンテナイメージは、<code>pause</code>、<code>example/mycontainer</code>、または<code>kube-apiserver</code>のような名前が通常つけられます。
イメージにはレジストリのホスト名も含めることができ(例：<code>fictional.registry.example/imagename</code>)、さらにポート番号も含めることが可能です(例：<code>fictional.registry.example:10443/imagename</code>)。</p><p>レジストリのホスト名を指定しない場合は、KubernetesはDockerパブリックレジストリを意味していると見なします。</p><p>イメージ名の後に、<em>タグ</em> を追加することができます(<code>docker</code>や<code>podman</code>のようなコマンドを利用した場合と同様)。
タグによって同じイメージの異なるバージョンを識別できます。</p><p>イメージタグは大文字と小文字、数値、アンダースコア(<code>_</code>)、ピリオド(<code>.</code>)とマイナス(<code>-</code>)で構成されます。
イメージタグでは区切り記号(<code>_</code>、<code>-</code>、<code>.</code>)を指定できる追加ルールがあります。
タグを指定しない場合は、Kubernetesは<code>latest</code>タグを指定したと見なします。</p><h2 id=イメージの更新>イメージの更新</h2><p><a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>、<a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>、Pod、またはPodテンプレートを含むその他のオブジェクトを最初に作成するとき、デフォルトでは、Pod内のすべてのコンテナのPullポリシーは、明示的に指定されていない場合、<code>IfNotPresent</code>に設定されます。</p><p>イメージがすでに存在する場合、このポリシーは<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>にイメージのPullをスキップさせます。</p><h3 id=イメージpullポリシー>イメージPullポリシー</h3><p>コンテナの<code>imagePullPolicy</code>とイメージのタグは、<a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>が指定されたイメージをPull(ダウンロード)しようとする時に影響します。</p><p>以下は、<code>imagePullPolicy</code>に設定できる値とその効果の一覧です。</p><dl><dt><code>IfNotPresent</code></dt><dd>イメージがローカルにまだ存在しない場合のみ、イメージがPullされます。</dd><dt><code>Always</code></dt><dd>kubeletがコンテナを起動するときは常にコンテナイメージレジストリに照会して、イメージ名をイメージ<a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>ダイジェスト</a>に解決します。
ローカルにキャッシュされた同一ダイジェストのコンテナイメージがあった場合、kubeletはキャッシュされたイメージを使用します。
そうでない場合、kubeletは解決されたダイジェストのイメージをPullし、そのイメージを使ってコンテナを起動します。</dd><dt><code>Never</code></dt><dd>kubeletは、イメージを取得しようとしません。ローカルにイメージがすでに存在する場合、kubeletはコンテナを起動しようとします。それ以外の場合、起動に失敗します。
詳細は、<a href=#pre-pulled-images>事前にPullしたイメージ</a>を参照してください。</dd></dl><p>レジストリに確実にアクセスできるのであれば、基盤となるイメージプロバイダーのキャッシュセマンティクスにより<code>imagePullPolicy: Always</code>でも効率的です。
コンテナランタイムは、イメージレイヤーが既にノード上に存在することを認識できるので、再度ダウンロードする必要がありません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>本番環境でコンテナをデプロイする場合は、<code>:latest</code>タグの使用を避けるべきです。
実行中のイメージのバージョンを追跡するのが難しく、正しくロールバックすることがより困難になるためです。</p><p>かわりに、<code>v1.42.0</code>のような特定できるタグを指定してください。</p></div><p>Podがいつも同じバージョンのコンテナイメージを使用するために、イメージのダイジェストを指定することができます。<code>&lt;image-name>:&lt;tag></code>を<code>&lt;image-name>@&lt;digest></code>に置き換えてください(例えば、<code>image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>)。</p><p>イメージタグを使用する場合、イメージレジストリがそのイメージのタグが表すコードを変更すると、新旧のコードを実行するPodが混在することになるかもしれません。
イメージダイジェストは特定のバージョンのイメージを一意に識別するため、Kubernetesは特定のイメージ名とダイジェストが指定されたコンテナを起動するたびに同じコードを実行します。
イメージをダイジェストで指定することは、レジストリの変更でそのようなバージョンの混在を起こさないように、実行するコードを固定します。</p><p>Pod(およびPodテンプレート)を作成する時に、実行中のワークロードがタグではなくイメージダイジェストに基づき定義されるように変化させるサードパーティーの<a href=/docs/reference/access-authn-authz/admission-controllers/>アドミッションコントローラー</a>があります。
レジストリでどのようなタグの変更があっても、すべてのワークロードが必ず同じコードを実行するようにしたい場合に役立ちます。</p><h4 id=imagepullpolicy-defaulting>デフォルトのイメージPullポリシー</h4><p>新しいPodがAPIサーバに送信されると、クラスターは特定の条件が満たされたときに<code>imagePullPolicy</code>フィールドを設定します。</p><ul><li><code>imagePullPolicy</code>フィールドを省略し、コンテナイメージのタグに<code>:latest</code>を指定した場合、<code>imagePullPolicy</code>には自動的に<code>Always</code>が設定される</li><li><code>imagePullPolicy</code>フィールドを省略し、コンテナイメージのタグを指定しなかった場合、<code>imagePullPolicy</code>には自動的に<code>Always</code>が設定される</li><li><code>imagePullPolicy</code>フィールドを省略し、コンテナイメージのタグに<code>:latest</code>以外を指定した場合、<code>imagePullPolicy</code>には自動的に<code>IfNotPresent</code>が設定される</li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>コンテナの<code>imagePullPolicy</code>の値は、そのオブジェクトが最初に <em>作成</em> されたときに常に設定され、イメージのタグが後で変更された場合でも更新されません。</p><p>例えば、タグが<code>:latest</code> <em>でない</em> イメージを使ってDeploymentを生成した場合、後でDeploymentのイメージを<code>:latest</code>タグに変更しても、<code>imagePullPolicy</code>は<code>Always</code>に更新されません。オブジェクトのPullポリシーは、初期作成後に手動で変更する必要があります。</p></div><h4 id=必要なイメージをpullする>必要なイメージをPullする</h4><p>常に強制的にPullしたい場合は、以下のいずれかを行ってください。</p><ul><li>コンテナの<code>imagePullPolicy</code>に<code>Always</code>を設定する。</li><li><code>imagePullPolicy</code>を省略し、使用するイメージに<code>:latest</code>タグ使用する。Pod生成時に、Kubernetesがポリシーに<code>Always</code>を設定する。</li><li><code>imagePullPolicy</code>と使用するイメージのタグを省略する。Pod生成時に、Kubernetesがポリシーに<code>Always</code>を設定する。</li><li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a>アドミッションコントローラーを有効にする。</li></ul><h3 id=imagepullbackoff>ImagePullBackOff</h3><p>kubeletがコンテナランタイムを使ってPodのコンテナの生成を開始するとき、<code>ImagePullBackOff</code>のためにコンテナが<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#container-state-waiting>Waiting</a>状態になる可能性があります。</p><p><code>ImagePullBackOff</code>ステータスは、KubernetesがコンテナイメージをPullできないために、コンテナを開始できないことを意味します(イメージ名が無効である、<code>imagePullSecret</code>なしでプライベートレジストリからPullしたなどの理由のため)。<code>BackOff</code>は、バックオフの遅延を増加させながらKubernetesがイメージをPullしようとし続けることを示します。</p><p>Kubernetesは、組み込まれた制限である300秒(5分)に達するまで、試行するごとに遅延を増加させます。</p><h2 id=イメージインデックスを使ったマルチアーキテクチャイメージ>イメージインデックスを使ったマルチアーキテクチャイメージ</h2><p>コンテナレジストリはバイナリイメージの提供だけでなく、<a href=https://github.com/opencontainers/image-spec/blob/master/image-index.md>コンテナイメージインデックス</a>も提供する事ができます。イメージインデックスはコンテナのアーキテクチャ固有バージョンに関する複数の<a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>イメージマニフェスト</a>を指すことができます。イメージインデックスの目的はイメージの名前(例:<code>pause</code>、<code>example/mycontainer</code>、<code>kube-apiserver</code>)をもたせ、様々なシステムが使用しているマシンアーキテクチャにあう適切なバイナリイメージを取得できることです。</p><p>Kubernetes自身は、通常コンテナイメージに<code>-$(ARCH)</code>のサフィックスを持つ名前をつけます。下位互換の為にサフィックス付きの古い仕様のイメージを生成してください。その目的は、<code>pause</code>のようなすべてのアーキテクチャのマニフェストを持つイメージと、サフィックスのあるイメージをハードコードしていた可能性のある古い仕様の設定やYAMLファイルと下位互換がある<code>pause-amd64</code>のようなイメージを生成することです。</p><h2 id=プライベートレジストリを使用する方法>プライベートレジストリを使用する方法</h2><p>プライベートレジストリではイメージを読み込む為にキーが必要になる場合があります。<br>認証情報はいくつかの方法で提供できます。</p><ul><li>プライベートレジストリへの認証をNodeに設定する<ul><li>すべてのPodがプライベートレジストリを読み取ることができる</li><li>クラスター管理者によるNodeの設定が必要</li></ul></li><li>事前にPullされたイメージ<ul><li>すべてのPodがNode上にキャッシュされたイメージを利用できる</li><li>セットアップするためにはすべてのNodeに対するrootアクセスが必要</li></ul></li><li>PodでImagePullSecretsを指定する<ul><li>キーを提供したPodのみがプライベートレジストリへアクセスできる</li></ul></li><li>ベンダー固有またはローカルエクステンション<ul><li>カスタムNode構成を使っている場合、あなた(または、あなたのクラウドプロバイダー)はコンテナレジストリへの認証の仕組みを組み込むことができる</li></ul></li></ul><p>これらのオプションについて、以下で詳しく説明します。</p><h3 id=プライベートレジストリへの認証をnodeに設定する>プライベートレジストリへの認証をNodeに設定する</h3><p>認証情報を設定するための具体的な手順は、使用するコンテナランタイムとレジストリに依存します。最も正確な情報として、ソリューションのドキュメントを参照する必要があります。</p><p>プライベートなコンテナイメージレジストリを設定する例として、<a href=/docs/tasks/configure-pod-container/pull-image-private-registry>プライベートレジストリからイメージをPullする</a>タスクを参照してください。その例では、Docker Hubのプライベートレジストリを使用しています。</p><h3 id=config-json>config.jsonの解釈</h3><p><code>config.json</code>の解釈は、Dockerのオリジナルの実装とKubernetesの解釈で異なります。
Dockerでは、<code>auths</code>キーはルートURLしか指定できませんが、Kubernetesではプレフィックスのマッチしたパスだけでなく、グロブパターンのURLも指定できます。
以下のような<code>config.json</code>が有効であるということです。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;*my-registry.io/images&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;…&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ルートURL(<code>*my-registry.io</code>)は、以下の構文でマッチングされます:</p><pre tabindex=0><code>pattern:
    { term }

term:
    &#39;*&#39;         セパレーター以外の任意の文字列にマッチする
    &#39;?&#39;         セパレーター以外の任意の一文字にマッチする
    &#39;[&#39; [ &#39;^&#39; ] { character-range } &#39;]&#39;
                文字クラス (空であってはならない)
    c           文字 c とマッチする (c != &#39;*&#39;, &#39;?&#39;, &#39;\\&#39;, &#39;[&#39;)
    &#39;\\&#39; c      文字 c とマッチする

character-range:
    c           文字 c とマッチする (c != &#39;\\&#39;, &#39;-&#39;, &#39;]&#39;)
    &#39;\\&#39; c      文字 c とマッチする
    lo &#39;-&#39; hi   lo &lt;= c &lt;= hi の文字 c とマッチする
</code></pre><p>イメージのPull操作では、有効なパターンごとに認証情報をCRIコンテナランタイムに渡すようになりました。例えば、以下のようなコンテナイメージ名は正常にマッチングされます。</p><ul><li><code>my-registry.io/images</code></li><li><code>my-registry.io/images/my-image</code></li><li><code>my-registry.io/images/another-image</code></li><li><code>sub.my-registry.io/images/my-image</code></li><li><code>a.sub.my-registry.io/images/my-image</code></li></ul><p>kubeletは、見つかったすべての認証情報に対してイメージのPullを順次実行します。これは、次のように<code>config.json</code>に複数のエントリーを書くことも可能であることを意味します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;my-registry.io/images&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;…&#34;</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;my-registry.io/images/subpath&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;…&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>コンテナが<code>my-registry.io/images/subpath/my-image</code>をPullするイメージとして指定した場合、kubeletが認証ソースの片方からダウンロードに失敗すると、両方の認証ソースからダウンロードを試みます。</p><h3 id=pre-pulled-images>事前にPullしたイメージ</h3><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Node構成を制御できる場合、この方法が適しています。
クラウドプロバイダーがNodeを管理し自動的に設定を置き換える場合は、確実に機能できません。</div><p>デフォルトでは、kubeletは指定されたレジストリからそれぞれのイメージをPullしようとします。
また一方では、コンテナの<code>imagePullPolicy</code>プロパティに<code>IfNotPresent</code>や<code>Never</code>が設定されている場合、ローカルのイメージが使用されます。(それぞれに対して、優先的またはか排他的に)</p><p>レジストリ認証の代替として事前にPullしたイメージを利用したい場合、クラスターのすべてのNodeが同じ事前にPullしたイメージを持っていることを確認する必要があります。</p><p>特定のイメージをあらかじめロードしておくことは高速化やプライベートレジストリへの認証の代替として利用することができます。</p><p>すべてのPodは事前にPullしたイメージへの読み取りアクセス権をもちます。</p><h3 id=podでimagepullsecretsを指定する>PodでimagePullSecretsを指定する</h3><div class="alert alert-info note callout" role=alert><strong>備考:</strong> この方法がプライベートレジストリのイメージに基づいてコンテナを実行するための推奨の方法です。</div><p>KubernetesはPodでのコンテナイメージレジストリキーの指定をサポートしています。</p><h4 id=dockerの設定を利用してsecretを作成する>Dockerの設定を利用してSecretを作成する。</h4><p>レジストリへの認証のためにユーザー名、レジストリのパスワード、クライアントのメールアドレス、およびそのホスト名を知っている必要があります。</p><p>適切な大文字の値を置き換えて、次のコマンドを実行します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</span></span></code></pre></div><p>既にDocker認証情報ファイルを持っている場合は、上記のコマンドの代わりに、認証情報ファイルをKubernetes <a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secrets>Secrets</a>としてインポートすることができます。
<a href=/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>既存のDocker認証情報に基づいてSecretを作成する</a> で、この設定方法を説明します.</p><p>これは複数のプライベートコンテナレジストリを使用している場合に特に有効です。<code>kubectl create secret docker-registry</code>はひとつのプライベートレジストリにのみ機能するSecretを作成するからです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Podは自分自身のNamespace内にあるimage pull secretsのみが参照可能であるため、この作業はNemespace毎に1回行う必要があります。</div><h4 id=podのimagepullsecretsを参照する方法>PodのimagePullSecretsを参照する方法</h4><p>これで、<code>imagePullSecrets</code>セクションをPod定義へ追加することでSecretを参照するPodを作成できます。</p><p>例:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>  namespace: awesomeapps
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  imagePullSecrets:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: myregistrykey
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>これは、プライベートレジストリを使用する各Podで行う必要があります。</p><p>ただし、この項目の設定は<a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>リソースの中でimagePullSecretsを指定することで自動化することができます。</p><p>詳細の手順は、<a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>ImagePullSecretsをService Accountに追加する</a>をクリックしてください。</p><p>これを各Nodeの<code>.docker/config.json</code>に組み合わせて利用できます。認証情報はマージされます。</p><h2 id=ユースケース>ユースケース</h2><p>プライベートレジストリを設定するためのソリューションはいくつかあります。ここでは、いくつかの一般的なユースケースと推奨される解決方法を示します。</p><ol><li>クラスターに独自仕様でない(例えば、オープンソース)イメージだけを実行する。イメージを非公開にする必要がない<ul><li>パブリックレジストリのパブリックイメージを利用する<ul><li>設定は必要ない</li><li>クラウドプロバイダーによっては、可用性の向上とイメージをPullする時間を短くする為に、自動的にキャッシュやミラーされたパプリックイメージが提供される</li></ul></li></ul></li><li>社外には非公開の必要があるが、すべてのクラスター利用者には見せてよい独自仕様のイメージをクラスターで実行している<ul><li>ホストされたプライペートレジストリを使用<ul><li>プライベートレジストリにアクセスする必要があるノードには、手動設定が必要となる場合がある</li></ul></li><li>または、オープンな読み取りアクセスを許可したファイヤーウォールの背後で内部向けプライベートレジストリを実行する<ul><li>Kubernetesの設定は必要ない</li></ul></li><li>イメージへのアクセスを制御できるホストされたコンテナイメージレジストリサービスを利用する<ul><li>Nodeを手動設定するよりもクラスターのオートスケーリングのほうがうまく機能する</li></ul></li><li>また、Node設定変更を自由にできないクラスターでは<code>imagePullSecrets</code>を使用する</li></ul></li><li>独自仕様のイメージを含むクラスターで、いくつかは厳格なアクセス制御が必要である<ul><li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImagesアドミッションコントローラー</a>が有効化かを確認する必要がある。さもないと、全部のPodがすべてのイメージへのアクセスができてしまう可能性がある</li><li>機密データはイメージに含めてしまうのではなく、"Secret"リソースに移行する</li></ul></li><li>それぞれのテナントが独自のプライベートレジストリを必要とするマルチテナントのクラスターである<ul><li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImagesアドミッションコントローラー</a>が有効化を確認する必要がある。さもないと、すべてのテナントの全Podが全部のイメージにアクセスできてしまう可能性がある</li><li>認証が必要なプライベートレジストリを実行する</li><li>それぞれのテナントでレジストリ認証を生成し、Secretへ設定し、各テナントのNamespaceに追加する</li><li>テナントは、Secretを各NamespaceのimagePullSecretsへ追加する</li></ul></li></ol><p>複数のレジストリへのアクセスが必要な場合、それぞれのレジストリ毎にひとつのSecretを作成する事ができます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>OCI Image Manifest Specification</a>を読む</li><li><a href=/ja/docs/concepts/architecture/garbage-collection/#container-image-garbage-collection>コンテナのガベージコレクション</a>について学ぶ</li><li><a href=/docs/tasks/configure-pod-container/pull-image-private-registry>pulling an Image from a Private Registry</a>について学ぶ</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-643212488f778acf04bebed65ba34441>3 - コンテナ環境</h1><p>このページでは、コンテナ環境で利用可能なリソースについて説明します。</p><h2 id=コンテナ環境>コンテナ環境</h2><p>Kubernetesはコンテナにいくつかの重要なリソースを提供します。</p><ul><li>イメージと1つ以上のボリュームの組み合わせのファイルシステム</li><li>コンテナ自体に関する情報</li><li>クラスター内の他のオブジェクトに関する情報</li></ul><h3 id=コンテナ情報>コンテナ情報</h3><p>コンテナの <em>ホスト名</em> は、コンテナが実行されているPodの名前です。
ホスト名は<code>hostname</code>コマンドまたはlibcの<a href=http://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a>関数呼び出しにより利用可能です。</p><p>Podの名前と名前空間は<a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>downward API</a>を通じて環境変数として利用可能です。</p><p>Pod定義からのユーザー定義の環境変数もコンテナで利用できます。
コンテナイメージで静的に指定されている環境変数も同様です。</p><h3 id=クラスター情報>クラスター情報</h3><p>コンテナの作成時に実行されていたすべてのサービスのリストは、環境変数として使用できます。
このリストは、新しいコンテナのPodおよびKubernetesコントロールプレーンサービスと同じ名前空間のサービスに制限されます。</p><p><em>bar</em> という名前のコンテナに対応する <em>foo</em> という名前のサービスの場合、以下の変数が定義されています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;サービスが実行されているホスト&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;サービスが実行されているポート&gt;
</span></span></code></pre></div><p>サービスは専用のIPアドレスを持ち、<a href=http://releases.k8s.io/v1.25.0/cluster/addons/dns/>DNSアドオン</a>が有効の場合、DNSを介してコンテナで利用可能です。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/containers/container-lifecycle-hooks/>コンテナライフサイクルフック</a>の詳細</li><li><a href=/ja/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>コンテナライフサイクルイベントへのハンドラー紐付け</a>のハンズオン</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a858027489648786a3b16264e451272b>4 - ランタイムクラス(Runtime Class)</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code></div><p>このページではRuntimeClassリソースと、runtimeセクションのメカニズムについて説明します。</p><p>RuntimeClassはコンテナランタイムの設定を選択するための機能です。そのコンテナランタイム設定はPodのコンテナを稼働させるために使われます。</p><h2 id=runtimeclassを使う動機>RuntimeClassを使う動機</h2><p>異なるPodに異なるRuntimeClassを設定することで、パフォーマンスとセキュリティのバランスをとることができます。例えば、ワークロードの一部に高レベルの情報セキュリティ保証が必要な場合、ハードウェア仮想化を使用するコンテナランタイムで実行されるようにそれらのPodをスケジュールすることを選択できます。その後、追加のオーバーヘッドを犠牲にして、代替ランタイムをさらに分離することでメリットが得られます。</p><p>RuntimeClassを使用して、コンテナランタイムは同じで設定が異なるPodを実行することもできます。</p><h2 id=セットアップ>セットアップ</h2><ol><li>ノード上でCRI実装を設定する。(ランタイムに依存)</li><li>対応するRuntimeClassリソースを作成する。</li></ol><h3 id=1-ノード上でcri実装を設定する>1. ノード上でCRI実装を設定する</h3><p>RuntimeClassを通じて利用可能な設定はContainer Runtime Interface (CRI)の実装依存となります。
ユーザーの環境のCRI実装の設定方法は、対応するドキュメント(<a href=#cri-configuration>下記</a>)を参照ください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> RuntimeClassは、クラスター全体で同じ種類のノード設定であることを仮定しています。(これは全てのノードがコンテナランタイムに関して同じ方法で構成されていることを意味します)。
設定が異なるノードをサポートするには、<a href=#scheduling>スケジューリング</a>を参照してください。</div><p>RuntimeClassの設定は、RuntimeClassによって参照される<code>ハンドラー</code>名を持ちます。そのハンドラーは有効な<a href=/ja/docs/concepts/overview/working-with-objects/names/#dns-label-names>DNSラベル名</a>でなくてはなりません。</p><h3 id=2-対応するruntimeclassリソースを作成する>2. 対応するRuntimeClassリソースを作成する</h3><p>ステップ1にて設定する各項目は、関連する<code>ハンドラー</code> 名を持ちます。それはどの設定かを指定するものです。各ハンドラーにおいて、対応するRuntimeClassオブジェクトが作成されます。</p><p>そのRuntimeClassリソースは現時点で2つの重要なフィールドを持ちます。それはRuntimeClassの名前(<code>metadata.name</code>)とハンドラー(<code>handler</code>)です。そのオブジェクトの定義は下記のようになります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># RuntimeClassはnode.k8s.ioというAPIグループで定義されます。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RuntimeClass名</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RuntimeClassはネームスペースなしのリソースです。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 対応するCRI設定</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>myconfiguration<span style=color:#bbb>
</span></span></span></code></pre></div><p>RuntimeClassオブジェクトの名前は<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>に従う必要があります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> RuntimeClassの書き込み操作(create/update/patch/delete)はクラスター管理者のみに制限されることを推奨します。
これはたいていデフォルトで有効となっています。さらなる詳細に関しては<a href=/docs/reference/access-authn-authz/authorization/>Authorization
Overview</a>を参照してください。</div><h2 id=使用例>使用例</h2><p>RuntimeClassがクラスターに対して設定されると、PodSpecで<code>runtimeClassName</code>を指定して使用できます。
例えば</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>これは、kubeletに対してPodを稼働させるためのRuntimeClassを使うように指示します。もし設定されたRuntimeClassが存在しない場合や、CRIが対応するハンドラーを実行できない場合、そのPodは<code>Failed</code>という<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>フェーズ</a>になります。
エラーメッセージに関しては対応する<a href=/docs/tasks/debug/debug-application/debug-running-pod/>イベント</a>を参照して下さい。</p><p>もし<code>runtimeClassName</code>が指定されていない場合、デフォルトのRuntimeHandlerが使用され、これはRuntimeClassの機能が無効であるときのふるまいと同じものとなります。</p><h3 id=cri-configuration>CRIの設定</h3><p>CRIランタイムのセットアップに関するさらなる詳細は、<a href=/docs/setup/cri/>CRIのインストール</a>を参照してください。</p><h4 id=hahahugoshortcode-s3-hbhb><a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a></h4><p>ランタイムハンドラーは、<code>/etc/containerd/config.toml</code>にあるcontainerdの設定ファイルにより設定されます。
正しいハンドラーは、その<code>runtime</code>セクションで設定されます。</p><pre tabindex=0><code>[plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes.${HANDLER_NAME}]
</code></pre><p>詳細はcontainerdの<a href=https://github.com/containerd/containerd/blob/main/docs/cri/config.md>設定に関するドキュメント</a>を参照してください。</p><h4 id=hahahugoshortcode-s4-hbhb><a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a></h4><p>ランタイムハンドラーは、<code>/etc/crio/crio.conf</code>にあるCRI-Oの設定ファイルにより設定されます。
正しいハンドラーは<a href=https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md#crioruntime-table>crio.runtime
table</a>で設定されます。</p><pre tabindex=0><code>[crio.runtime.runtimes.${HANDLER_NAME}]
  runtime_path = &#34;${PATH_TO_BINARY}&#34;
</code></pre><p>詳細はCRI-Oの<a href=https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md>設定に関するドキュメント</a>を参照してください。</p><h2 id=scheduling>スケジューリング</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code></div><p>RuntimeClassの<code>scheduling</code>フィールドを指定することで、設定されたRuntimeClassをサポートするノードにPodがスケジューリングされるように制限することができます。
<code>scheduling</code>が設定されていない場合、このRuntimeClassはすべてのノードでサポートされていると仮定されます。</p><p>特定のRuntimeClassをサポートしているノードへPodが配置されることを保証するために、各ノードは<code>runtimeclass.scheduling.nodeSelector</code>フィールドによって選択される共通のラベルを持つべきです。
RuntimeClassのnodeSelectorはアドミッション機能によりPodのnodeSelectorに統合され、効率よくノードを選択します。
もし設定が衝突した場合は、Pod作成は拒否されるでしょう。</p><p>もしサポートされているノードが他のRuntimeClassのPodが稼働しないようにtaint付与されていた場合、RuntimeClassに対して<code>tolerations</code>を付与することができます。
<code>nodeSelector</code>と同様に、tolerationsはPodのtolerationsにアドミッション機能によって統合され、効率よく許容されたノードを選択します。</p><p>ノードの選択とtolerationsについての詳細は<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>ノード上へのPodのスケジューリング</a>を参照してください。</p><h3 id=podオーバーヘッド>Podオーバーヘッド</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [stable]</code></div><p>Podが稼働する時に関連する <em>オーバーヘッド</em> リソースを指定できます。オーバーヘッドを宣言すると、クラスター(スケジューラーを含む)がPodとリソースに関する決定を行うときにオーバーヘッドを考慮することができます。</p><p>PodのオーバーヘッドはRuntimeClass内の<code>overhead</code>フィールドによって定義されます。
このフィールドを使用することで、RuntimeClassを使用して稼働するPodのオーバーヘッドを指定することができ、Kubernetes内部で使用されるオーバーヘッドを確保することができます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md>RuntimeClassデザイン</a></li><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md#runtimeclass-scheduling>RuntimeClassスケジューリングデザイン</a></li><li><a href=/docs/concepts/scheduling-eviction/pod-overhead/>Podオーバーヘッド</a>のコンセプトを読む</li><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/688-pod-overhead>PodOverhead機能デザイン</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e6941d969d81540208a3e78bc56f43bc>5 - コンテナライフサイクルフック</h1><p>このページでは、kubeletにより管理されるコンテナがコンテナライフサイクルフックフレームワークを使用して、管理ライフサイクル中にイベントによって引き起こされたコードを実行する方法について説明します。</p><h2 id=概要>概要</h2><p>Angularなどのコンポーネントライフサイクルフックを持つ多くのプログラミング言語フレームワークと同様に、Kubernetesはコンテナにライフサイクルフックを提供します。
フックにより、コンテナは管理ライフサイクル内のイベントを認識し、対応するライフサイクルフックが実行されたときにハンドラーに実装されたコードを実行できます。</p><h2 id=コンテナフック>コンテナフック</h2><p>コンテナに公開されている2つのフックがあります。</p><p><code>PostStart</code></p><p>このフックはコンテナが作成された直後に実行されます。
しかし、フックがコンテナのENTRYPOINTの前に実行されるという保証はありません。
ハンドラーにパラメーターは渡されません。</p><p><code>PreStop</code></p><p>このフックは、APIからの要求、またはliveness/startup probeの失敗、プリエンプション、リソース競合などの管理イベントが原因でコンテナが終了する直前に呼び出されます。コンテナがすでに終了状態または完了状態にある場合には<code>PreStop</code>フックの呼び出しは失敗し、コンテナを停止するTERMシグナルが送信される前にフックは完了する必要があります。<code>PreStop</code>フックが実行される前にPodの終了猶予期間のカウントダウンが開始されるので、ハンドラーの結果に関わらず、コンテナはPodの終了猶予期間内に最終的に終了します。
ハンドラーにパラメーターは渡されません。</p><p>終了動作の詳細な説明は、<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>Termination of Pods</a>にあります。</p><h3 id=フックハンドラーの実装>フックハンドラーの実装</h3><p>コンテナは、フックのハンドラーを実装して登録することでそのフックにアクセスできます。
コンテナに実装できるフックハンドラーは2種類あります。</p><ul><li>Exec - コンテナのcgroupsと名前空間の中で、 <code>pre-stop.sh</code>のような特定のコマンドを実行します。
コマンドによって消費されたリソースはコンテナに対してカウントされます。</li><li>HTTP - コンテナ上の特定のエンドポイントに対してHTTP要求を実行します。</li></ul><h3 id=フックハンドラーの実行>フックハンドラーの実行</h3><p>コンテナライフサイクル管理フックが呼び出されると、Kubernetes管理システムはフックアクションにしたがってハンドラーを実行します。
<code>httpGet</code>と<code>tcpSocket</code>はkubeletプロセスによって実行され、<code>exec</code>はコンテナの中で実行されます。</p><p>フックハンドラーの呼び出しは、コンテナを含むPodのコンテキスト内で同期しています。
これは、<code>PostStart</code>フックの場合、コンテナのENTRYPOINTとフックは非同期に起動することを意味します。
しかし、フックの実行に時間がかかりすぎたりハングしたりすると、コンテナは<code>running</code>状態になることができません。</p><p><code>PreStop</code>フックはコンテナを停止するシグナルから非同期で実行されるのではなく、TERMシグナルが送られる前に実行を完了する必要があります。
もし<code>PreStop</code>フックが実行中にハングした場合、Podは<code>Terminating</code>状態になり、
<code>terminationGracePeriodSeconds</code>の時間切れで強制終了されるまで続きます。
この猶予時間は、<code>PreStop</code>フックが実行され正常にコンテナを停止できるまでの合計時間に適用されます。
例えば<code>terminationGracePeriodSeconds</code>が60で、フックの終了に55秒かかり、シグナルを受信した後にコンテナを正常に停止させるのに10秒かかる場合、コンテナは正常に停止する前に終了されてしまいます。<code>terminationGracePeriodSeconds</code>が、これら2つの実行にかかる合計時間(55+10)よりも短いからです。</p><p><code>PostStart</code>または<code>PreStop</code>フックが失敗した場合、コンテナは強制終了します。</p><p>ユーザーはフックハンドラーをできるだけ軽量にするべきです。
ただし、コンテナを停止する前に状態を保存するなどの場合は、長時間のコマンド実行が必要なケースもあります。</p><h3 id=フック配信保証>フック配信保証</h3><p>フックの配信は <em>少なくとも1回</em> を意図しています。これはフックが<code>PostStart</code>や<code>PreStop</code>のような任意のイベントに対して複数回呼ばれることがあることを意味します。
これを正しく処理するのはフックの実装次第です。</p><p>通常、1回の配信のみが行われます。
たとえば、HTTPフックレシーバーがダウンしていてトラフィックを受け取れない場合、再送信は試みられません。
ただし、まれに二重配信が発生することがあります。
たとえば、フックの送信中にkubeletが再起動した場合、kubeletが起動した後にフックが再送信される可能性があります。</p><h3 id=フックハンドラーのデバッグ>フックハンドラーのデバッグ</h3><p>フックハンドラーのログは、Podのイベントには表示されません。
ハンドラーが何らかの理由で失敗した場合は、イベントをブロードキャストします。
<code>PostStart</code>の場合、これは<code>FailedPostStartHook</code>イベントで、<code>PreStop</code>の場合、これは<code>FailedPreStopHook</code>イベントです。
失敗の<code>FailedPreStopHook</code>イベントを自分自身で生成する場合には、<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/lifecycle-events.yaml>lifecycle-events.yaml</a>ファイルに対してpostStartのコマンドを"badcommand"に変更し、適用してください。
<code>kubectl describe pod lifecycle-demo</code>を実行した結果のイベントの出力例を以下に示します。</p><pre tabindex=0><code>Events:
  Type     Reason               Age              From               Message
  ----     ------               ----             ----               -------
  Normal   Scheduled            7s               default-scheduler  Successfully assigned default/lifecycle-demo to ip-XXX-XXX-XX-XX.us-east-2...
  Normal   Pulled               6s               kubelet            Successfully pulled image &#34;nginx&#34; in 229.604315ms
  Normal   Pulling              4s (x2 over 6s)  kubelet            Pulling image &#34;nginx&#34;
  Normal   Created              4s (x2 over 5s)  kubelet            Created container lifecycle-demo-container
  Normal   Started              4s (x2 over 5s)  kubelet            Started container lifecycle-demo-container
  Warning  FailedPostStartHook  4s (x2 over 5s)  kubelet            Exec lifecycle hook ([badcommand]) for Container &#34;lifecycle-demo-container&#34; in Pod &#34;lifecycle-demo_default(30229739-9651-4e5a-9a32-a8f1688862db)&#34; failed - error: command &#39;badcommand&#39; exited with 126: , message: &#34;OCI runtime exec failed: exec failed: container_linux.go:380: starting container process caused: exec: \&#34;badcommand\&#34;: executable file not found in $PATH: unknown\r\n&#34;
  Normal   Killing              4s (x2 over 5s)  kubelet            FailedPostStartHook
  Normal   Pulled               4s               kubelet            Successfully pulled image &#34;nginx&#34; in 215.66395ms
  Warning  BackOff              2s (x2 over 3s)  kubelet            Back-off restarting failed container
</code></pre><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/containers/container-environment/>コンテナ環境</a>の詳細</li><li><a href=/ja/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>コンテナライフサイクルイベントへのハンドラー紐付け</a>のハンズオン</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>