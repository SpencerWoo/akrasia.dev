<!doctype html><html lang=ja class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/extend-kubernetes/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/extend-kubernetes/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Kubernetesを拡張する | Kubernetes</title><meta property="og:title" content="Kubernetesを拡張する"><meta property="og:description" content="Kubernetesクラスターの挙動を変えるいろいろな方法"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/extend-kubernetes/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Kubernetesを拡張する"><meta itemprop=description content="Kubernetesクラスターの挙動を変えるいろいろな方法"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubernetesを拡張する"><meta name=twitter:description content="Kubernetesクラスターの挙動を変えるいろいろな方法"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Kubernetesクラスターの挙動を変えるいろいろな方法"><meta property="og:description" content="Kubernetesクラスターの挙動を変えるいろいろな方法"><meta name=twitter:description content="Kubernetesクラスターの挙動を変えるいろいろな方法"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/extend-kubernetes/"><meta property="og:title" content="Kubernetesを拡張する"><meta name=twitter:title content="Kubernetesを拡張する"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ja/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ja/docs/>ドキュメント</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/blog/>Blogs</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/training/>トレーニング</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/partners/>パートナー</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/community/>コミュニティ</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/case-studies/>ケーススタディ</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>バージョン</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ja/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/extend-kubernetes/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/extend-kubernetes/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/extend-kubernetes/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/concepts/extend-kubernetes/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ja/docs/concepts/extend-kubernetes/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語 (Japanese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/extend-kubernetes/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/extend-kubernetes/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/extend-kubernetes/>한국어 (Korean)</a>
<a class=dropdown-item href=/fr/docs/concepts/extend-kubernetes/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/extend-kubernetes/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/extend-kubernetes/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/extend-kubernetes/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/extend-kubernetes/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.</p><p><a href=/ja/docs/concepts/extend-kubernetes/>このページの通常のビューに戻る</a>.</p></div><h1 class=title>Kubernetesを拡張する</h1><div class=lead>Kubernetesクラスターの挙動を変えるいろいろな方法</div><ul><li>1: <a href=#pg-5c2b36cd0ddbe006b575d4e54c63d508>Kubernetesクラスターの拡張</a></li><li>2: <a href=#pg-0af41d3bd7c785621b58b7564793396a>Kubernetes APIの拡張</a></li><ul><li>2.1: <a href=#pg-342388440304e19ce30c0f8ada1c77ce>カスタムリソース</a></li><li>2.2: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>アグリゲーションレイヤーを使ったKubernetes APIの拡張</a></li></ul><li>3: <a href=#pg-3131452556176159fb269593c1a52012>オペレーターパターン</a></li></ul><div class=content><p>Kubernetesは柔軟な設定が可能で、高い拡張性を持っています。
結果として、Kubernetesのプロジェクトソースコードをフォークしたり、パッチを当てて利用することは滅多にありません。
このガイドは、Kubernetesクラスターをカスタマイズするための選択肢を記載します。
管理しているKubernetesクラスターを、動作環境の要件にどのように適合させるべきかを理解したい<a class=glossary-tooltip title=クラスターを設定、管理そして、監視する人 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-cluster-operator' target=_blank aria-label=クラスター管理者>クラスター管理者</a>を対象にしています。
将来の <a class=glossary-tooltip title=自身のプロジェクトの要件に合わせ、Kubernetesプラットフォームをカスタマイズする人 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-platform-developer' target=_blank aria-label=プラットフォーム開発者>プラットフォーム開発者</a> 、またはKubernetesプロジェクトの<a class=glossary-tooltip title=Kubernetesプロジェクトやコミュニティのために、コード、ドキュメント、またはその他の作業に自身の時間を使って貢献している人々 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-contributor' target=_blank aria-label=コントリビューター>コントリビューター</a>にとっても、どのような拡張のポイントやパターンが存在するのか、また、それぞれのトレードオフや制限事項を学ぶための導入として役立つでしょう。</p><h2 id=概要>概要</h2><p>カスタマイズのアプローチには大きく分けて、フラグ、ローカル設定ファイル、またはAPIリソースの変更のみを含んだ <em>設定</em> と、稼働しているプログラムまたはサービスも含んだ <em>拡張</em> があります。このドキュメントでは、主に拡張について説明します。</p><h2 id=設定>設定</h2><p><em>設定ファイル</em> と <em>フラグ</em> はオンラインドキュメントのリファレンスセクションの中の、各項目に記載されています:</p><ul><li><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a>.</li></ul><p>ホスティングされたKubernetesサービスやマネージドなKubernetesでは、フラグと設定ファイルが常に変更できるとは限りません。変更可能な場合でも、通常はクラスターの管理者のみが変更できます。また、それらは将来のKubernetesバージョンで変更される可能性があり、設定変更にはプロセスの再起動が必要になるかもしれません。これらの理由により、この方法は他の選択肢が無いときにのみ利用するべきです。</p><p><a href=/ja/docs/concepts/policy/resource-quotas/>ResourceQuota</a>、<a href=/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>、<a href=/ja/docs/concepts/services-networking/network-policies/>NetworkPolicy</a>、そしてロールベースアクセス制御(<a href=/ja/docs/reference/access-authn-authz/rbac/>RBAC</a>)といった <em>ビルトインポリシーAPI</em> は、ビルトインのKubernetes APIです。APIは通常、ホスティングされたKubernetesサービスやマネージドなKubernetesで利用されます。これらは宣言的で、Podのような他のKubernetesリソースと同じ慣例に従っています。そのため、新しいクラスターの設定は繰り返し再利用することができ、アプリケーションと同じように管理することが可能です。さらに、安定版(stable)を利用している場合、他のKubernetes APIのような<a href=/docs/reference/deprecation-policy/>定義済みのサポートポリシー</a>を利用することができます。これらの理由により、この方法は、適切な用途の場合、 <em>設定ファイル</em> や <em>フラグ</em> よりも好まれます。</p><h2 id=拡張>拡張</h2><p>拡張はKubernetesを拡張し、深く統合されたソフトウェアの構成要素です。
これは新しいタイプと、新しい種類のハードウェアをサポートするために利用されます。</p><p>ほとんどのクラスター管理者は、ホスティングされている、またはディストリビューションとしてのKubernetesを使っているでしょう。
結果として、ほとんどのKubernetesユーザーは既存の拡張を使えばよいため、新しい拡張を書く必要は無いと言えます。</p><h2 id=extension-patterns>拡張パターン</h2><p>Kubernetesは、クライアントのプログラムを書くことで自動化ができるようにデザインされています。
Kubernetes APIに読み書きをするどのようなプログラムも、役に立つ自動化機能を提供することができます。
<em>自動化機能</em> はクラスター上、またはクラスター外で実行できます。
このドキュメントに後述のガイダンスに従うことで、高い可用性を持つ頑強な自動化機能を書くことができます。
自動化機能は通常、ホスティングされているクラスター、マネージドな環境など、どのKubernetesクラスター上でも動きます。</p><p>Kubernetes上でうまく動くクライアントプログラムを書くために、<em>コントローラー</em> パターンという明確なパターンがあります。
コントローラーは通常、オブジェクトの <code>.spec</code> を読み取り、何らかの処理をして、オブジェクトの <code>.status</code> を更新します。</p><p>コントローラーはKubernetesのクライアントです。Kubernetesがクライアントとして動き、外部のサービスを呼び出す場合、それは <em>Webhook</em> と呼ばれます。
呼び出されるサービスは <em>Webhookバックエンド</em> と呼ばれます。コントローラーのように、Webhookも障害点を追加します。</p><p>Webhookのモデルでは、Kubernetesは外部のサービスを呼び出します。
<em>バイナリプラグイン</em> モデルでは、Kubernetesはバイナリ(プログラム)を実行します。
バイナリプラグインはkubelet(例、<a href=/docs/concepts/storage/volumes/#flexVolume>FlexVolumeプラグイン</a>、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>)、またkubectlで利用されています。</p><p>下図は、それぞれの拡張ポイントが、Kubernetesのコントロールプレーンとどのように関わっているかを示しています。</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vQBRWyXLVUlQPlp7BvxvV9S1mxyXSM6rAc_cbLANvKlu6kCCf-kGTporTMIeG5GZtUdxXz1xowN7RmL/pub?w=960&h=720"><h2 id=拡張ポイント>拡張ポイント</h2><p>この図は、Kubernetesにおける拡張ポイントを示しています。</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vSH5ZWUO2jH9f34YHenhnCd14baEb4vT-pzfxeFC7NzdNqRDgdz4DDAVqArtH4onOGqh0bhwMX0zGBb/pub?w=425&h=809"><ol><li>ユーザーは頻繁に<code>kubectl</code>を使って、Kubernetes APIとやり取りをします。<a href=/docs/tasks/extend-kubectl/kubectl-plugins/>Kubectlプラグイン</a>は、kubectlのバイナリを拡張します。これは個別ユーザーのローカル環境のみに影響を及ぼすため、サイト全体にポリシーを強制することはできません。</li><li>APIサーバーは全てのリクエストを処理します。APIサーバーのいくつかの拡張ポイントは、リクエストを認可する、コンテキストに基づいてブロックする、リクエストを編集する、そして削除を処理することを可能にします。これらは<a href=/docs/concepts/extend-kubernetes/#api-access-extensions>APIアクセス拡張</a>セクションに記載されています。</li><li>APIサーバーは様々な種類の <em>リソース</em> を扱います。<code>Pod</code>のような <em>ビルトインリソース</em> はKubernetesプロジェクトにより定義され、変更できません。ユーザーも、自身もしくは、他のプロジェクトで定義されたリソースを追加することができます。それは <em>カスタムリソース</em> と呼ばれ、<a href=/docs/concepts/extend-kubernetes/#user-defined-types>カスタムリソース</a>セクションに記載されています。カスタムリソースは度々、APIアクセス拡張と一緒に使われます。</li><li>KubernetesのスケジューラーはPodをどのノードに配置するかを決定します。スケジューリングを拡張するには、いくつかの方法があります。それらは<a href=/docs/concepts/extend-kubernetes/#scheduler-extensions>スケジューラー拡張</a>セクションに記載されています。</li><li>Kubernetesにおける多くの振る舞いは、APIサーバーのクライアントであるコントローラーと呼ばれるプログラムに実装されています。コントローラーは度々、カスタムリソースと共に使われます。</li><li>kubeletはサーバー上で実行され、Podが仮想サーバーのようにクラスターネットワーク上にIPを持った状態で起動することをサポートします。<a href=/docs/concepts/extend-kubernetes/#network-plugins>ネットワークプラグイン</a>がPodのネットワーキングにおける異なる実装を適用することを可能にします。</li><li>kubeletはまた、コンテナのためにボリュームをマウント、アンマウントします。新しい種類のストレージは<a href=/docs/concepts/extend-kubernetes/#storage-plugins>ストレージプラグイン</a>を通じてサポートされます。</li></ol><p>もしあなたがどこから始めるべきかわからない場合、このフローチャートが役立つでしょう。一部のソリューションは、いくつかの種類の拡張を含んでいることを留意してください。</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vRWXNNIVWFDqzDY0CsKZJY3AR8sDeFDXItdc5awYxVH8s0OLherMlEPVUpxPIB1CSUu7GPk7B2fEnzM/pub?w=1440&h=1080"><h2 id=api拡張>API拡張</h2><h3 id=ユーザー定義タイプ>ユーザー定義タイプ</h3><p>新しいコントローラー、アプリケーションの設定に関するオブジェクト、また宣言型APIを定義し、それらを<code>kubectl</code>のようなKubernetesのツールから管理したい場合、Kubernetesにカスタムリソースを追加することを検討して下さい。</p><p>カスタムリソースはアプリケーション、ユーザー、監視データのデータストレージとしては使わないで下さい。</p><p>カスタムリソースに関するさらなる情報は、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソースコンセプトガイド</a>を参照して下さい。</p><h3 id=新しいapiと自動化機能の連携>新しいAPIと自動化機能の連携</h3><p>カスタムリソースAPIと制御ループの組み合わせは<a href=/ja/docs/concepts/extend-kubernetes/operator/>オペレーターパターン</a>と呼ばれています。オペレーターパターンは、通常ステートフルな特定のアプリケーションを管理するために利用されます。これらのカスタムAPIと制御ループは、ストレージ、またはポリシーのような他のリソースを管理するためにも利用されます。</p><h3 id=ビルトインリソースの変更>ビルトインリソースの変更</h3><p>カスタムリソースを追加し、KubernetesAPIを拡張する場合、新たに追加されたリソースは常に新しいAPIグループに分類されます。既存のAPIグループを置き換えたり、変更することはできません。APIを追加することは直接、既存のAPI(例、Pod)の振る舞いに影響を与えることは無いですが、APIアクセス拡張の場合、その可能性があります。</p><h3 id=api-access-extensions>APIアクセス拡張</h3><p>リクエストがKubernetes APIサーバーに到達すると、まず最初に認証が行われ、次に認可、その後、様々なAdmission Controlの対象になります。このフローの詳細は<a href=/docs/concepts/security/controlling-access/>Kubernetes APIへのアクセスをコントロールする</a>を参照して下さい。</p><p>これらの各ステップごとに拡張ポイントが用意されています。</p><p>Kubdernetesはいくつかのビルトイン認証方式をサポートしています。それは認証プロキシの後ろに配置することも可能で、認可ヘッダーを通じて(Webhookの)検証のために外部サービスにトークンを送ることもできます。全てのこれらの方法は<a href=/ja/docs/reference/access-authn-authz/authentication/>認証ドキュメント</a>でカバーされています。</p><h3 id=認証>認証</h3><p><a href=/ja/docs/reference/access-authn-authz/authentication/>認証</a>は、全てのリクエストのヘッダーまたは証明書情報を、リクエストを投げたクライアントのユーザー名にマッピングします。</p><p>Kubernetesはいくつかのビルトイン認証方式と、それらが要件に合わない場合、<a href=/ja/docs/reference/access-authn-authz/authentication/#webhook-token-authentication>認証Webhook</a>を提供します。</p><h3 id=認可>認可</h3><p><a href=/docs/reference/access-authn-authz/webhook/>認可</a>は特定のユーザーがAPIリソースに対して、読み込み、書き込み、そしてその他の操作が可能かどうかを決定します。それはオブジェクト全体のレベルで機能し、任意のオブジェクトフィールドに基づいての区別は行いません。もしビルトインの認可メカニズムが要件に合わない場合、<a href=/docs/reference/access-authn-authz/webhook/>認可Webhook</a>が、ユーザー提供のコードを呼び出し認可の決定を行うことを可能にします。</p><h3 id=動的admission-control>動的Admission Control</h3><p>リクエストが認可された後、もしそれが書き込み操作だった場合、リクエストは<a href=/docs/reference/access-authn-authz/admission-controllers/>Admission Control</a>のステップを通ります。ビルトインのステップに加え、いくつかの拡張が存在します:</p><ul><li><a href=/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook>イメージポリシーWebhook</a>は、コンテナでどのイメージを実行することができるかを制限する</li><li>任意のAdmission Controlの決定を行うには、一般的な<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Admission webhook</a>が利用できる。Admission Webhookは作成、更新を拒絶できる</li></ul><h2 id=インフラストラクチャ拡張>インフラストラクチャ拡張</h2><h3 id=ストレージプラグイン>ストレージプラグイン</h3><p><a href=/docs/concepts/storage/volumes/#flexVolume>Flex Volumes</a>は、Kubeletがバイナリプラグインを呼び出してボリュームをマウントすることにより、ユーザーはビルトインのサポートなしでボリュームタイプをマウントすることを可能にします。</p><h3 id=デバイスプラグイン>デバイスプラグイン</h3><p><a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a>を通じて、ノードが新たなノードのリソース(CPU、メモリなどのビルトインのものに加え)を見つけることを可能にします。</p><h3 id=ネットワークプラグイン>ネットワークプラグイン</h3><p>他のネットワークファブリックが<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>を通じてサポートされます。</p><h3 id=スケジューラー拡張>スケジューラー拡張</h3><p>スケジューラーは特別な種類のコントローラーで、Podを監視し、Podをノードに割り当てます。デフォルトのコントローラーを完全に置き換えることもできますが、他のKubernetesのコンポーネントの利用を継続する、または<a href=/docs/tasks/extend-kubernetes/configure-multiple-schedulers/>複数のスケジューラー</a>を同時に動かすこともできます。</p><p>これはかなりの大きな作業で、ほとんど全てのKubernetesユーザーはスケジューラーを変更する必要はありません。</p><p>スケジューラは<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/scheduler_extender.md>Webhook</a>もサポートしており、Webhookバックエンド(スケジューラー拡張)を通じてPodを配置するために選択されたノードをフィルタリング、優先度付けすることが可能です。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>についてより深く学ぶ</li><li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>動的Admission control</a>について学ぶ</li><li>インフラストラクチャ拡張についてより深く学ぶ<ul><li><a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a></li><li><a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a></li></ul></li><li><a href=/docs/tasks/extend-kubectl/kubectl-plugins/>kubectlプラグイン</a>について学ぶ</li><li><a href=/ja/docs/concepts/extend-kubernetes/operator/>オペレーターパターン</a>について学ぶ</li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5c2b36cd0ddbe006b575d4e54c63d508>1 - Kubernetesクラスターの拡張</h1><p>Kubernetesは柔軟な設定が可能で、高い拡張性を持っています。
結果として、Kubernetesのプロジェクトソースコードをフォークしたり、パッチを当てて利用することは滅多にありません。</p><p>このガイドは、Kubernetesクラスターをカスタマイズするための選択肢を記載します。
管理しているKubernetesクラスターを、動作環境の要件にどのように適合させるべきかを理解したい<a class=glossary-tooltip title=クラスターを設定、管理そして、監視する人 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-cluster-operator' target=_blank aria-label=クラスター管理者>クラスター管理者</a>を対象にしています。
将来の <a class=glossary-tooltip title=自身のプロジェクトの要件に合わせ、Kubernetesプラットフォームをカスタマイズする人 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-platform-developer' target=_blank aria-label=プラットフォーム開発者>プラットフォーム開発者</a> 、またはKubernetesプロジェクトの<a class=glossary-tooltip title=Kubernetesプロジェクトやコミュニティのために、コード、ドキュメント、またはその他の作業に自身の時間を使って貢献している人々 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-contributor' target=_blank aria-label=コントリビューター>コントリビューター</a>にとっても、どのような拡張のポイントやパターンが存在するのか、また、それぞれのトレードオフや制限事項を学ぶための導入として役立つでしょう。</p><h2 id=概要>概要</h2><p>カスタマイズのアプローチには大きく分けて、フラグ、ローカル設定ファイル、またはAPIリソースの変更のみを含んだ <em>コンフィグレーション</em> と、稼働しているプログラムまたはサービスも含んだ <em>エクステンション</em> があります。このドキュメントでは、主にエクステンションについて説明します。</p><h2 id=コンフィグレーション>コンフィグレーション</h2><p><em>設定ファイル</em> と <em>フラグ</em> はオンラインドキュメントのリファレンスセクションの中の、各項目に記載されています:</p><ul><li><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a></li><li><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a></li></ul><p>ホスティングされたKubernetesサービスやマネージドなKubernetesでは、フラグと設定ファイルが常に変更できるとは限りません。変更可能な場合でも、通常はクラスターの管理者のみが変更できます。また、それらは将来のKubernetesバージョンで変更される可能性があり、設定変更にはプロセスの再起動が必要になるかもしれません。これらの理由により、この方法は他の選択肢が無いときにのみ利用するべきです。</p><p><a href=/ja/docs/concepts/policy/resource-quotas/>ResourceQuota</a>、<a href=/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>、<a href=/docs/concepts/services-networking/network-policies/>NetworkPolicy</a>、そしてロールベースアクセス制御(<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>)といった <em>ビルトインポリシーAPI</em> は、ビルトインのKubernetes APIです。APIは通常、ホスティングされたKubernetesサービスやマネージドなKubernetesで利用されます。これらは宣言的で、Podのような他のKubernetesリソースと同じ慣例に従っています。そのため、新しいクラスターの設定は繰り返し再利用することができ、アプリケーションと同じように管理することが可能です。さらに、安定版(stable)を利用している場合、他のKubernetes APIのような<a href=/docs/reference/using-api/deprecation-policy/>定義済みのサポートポリシー</a>を利用することができます。これらの理由により、この方法は、適切な用途の場合、 <em>設定ファイル</em> や <em>フラグ</em> よりも好まれます。</p><h2 id=エクステンション>エクステンション</h2><p>エクステンションはKubernetesを拡張し、深く統合されたソフトウェアの構成要素です。
これは新しいタイプと、新しい種類のハードウェアをサポートするために利用されます。</p><p>ほとんどのクラスター管理者は、ホスティングされている、またはディストリビューションとしてのKubernetesを使っているでしょう。
結果として、ほとんどのKubernetesユーザーは既存のエクステンションを使えばよいため、新しいエクステンションを書く必要は無いと言えます。</p><h2 id=extension-patterns>エクステンションパターン</h2><p>Kubernetesは、クライアントのプログラムを書くことで自動化ができるようにデザインされています。
Kubernetes APIに読み書きをするどのようなプログラムも、役に立つ自動化機能を提供することができます。
<em>自動化機能</em> はクラスター上、またはクラスター外で実行できます。
このドキュメントに後述のガイダンスに従うことで、高い可用性を持つ頑強な自動化機能を書くことができます。
自動化機能は通常、ホスティングされているクラスター、マネージドな環境など、どのKubernetesクラスター上でも動きます。</p><p>Kubernetes上でうまく動くクライアントプログラムを書くために、<em>コントローラー</em> パターンという明確なパターンがあります。
コントローラーは通常、オブジェクトの <code>.spec</code> を読み取り、何らかの処理をして、オブジェクトの <code>.status</code> を更新します。</p><p>コントローラーはKubernetesのクライアントです。Kubernetesがクライアントとして動き、外部のサービスを呼び出す場合、それは <em>Webhook</em> と呼ばれます。
呼び出されるサービスは <em>Webhookバックエンド</em> と呼ばれます。コントローラーのように、Webhookも障害点を追加します。</p><p>Webhookのモデルでは、Kubernetesは外部のサービスを呼び出します。
<em>バイナリプラグイン</em> モデルでは、Kubernetesはバイナリ(プログラム)を実行します。
バイナリプラグインはkubelet(例、<a href=/docs/concepts/storage/volumes/#flexvolume>FlexVolumeプラグイン</a>、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>)、またkubectlで利用されています。</p><p>下図は、それぞれの拡張ポイントが、Kubernetesのコントロールプレーンとどのように関わっているかを示しています。</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vQBRWyXLVUlQPlp7BvxvV9S1mxyXSM6rAc_cbLANvKlu6kCCf-kGTporTMIeG5GZtUdxXz1xowN7RmL/pub?w=960&h=720"><h2 id=拡張ポイント>拡張ポイント</h2><p>この図は、Kubernetesにおける拡張ポイントを示しています。</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vSH5ZWUO2jH9f34YHenhnCd14baEb4vT-pzfxeFC7NzdNqRDgdz4DDAVqArtH4onOGqh0bhwMX0zGBb/pub?w=425&h=809"><ol><li>ユーザーは頻繁に<code>kubectl</code>を使って、Kubernetes APIとやり取りをします。<a href=/docs/tasks/extend-kubectl/kubectl-plugins/>Kubectlプラグイン</a>は、kubectlのバイナリを拡張します。これは個別ユーザーのローカル環境のみに影響を及ぼすため、サイト全体にポリシーを強制することはできません。</li><li>APIサーバーは全てのリクエストを処理します。APIサーバーのいくつかの拡張ポイントは、リクエストを認可する、コンテキストに基づいてブロックする、リクエストを編集する、そして削除を処理することを可能にします。これらは<a href=/ja/docs/concepts/extend-kubernetes/#api-access-extensions>APIアクセスエクステンション</a>セクションに記載されています。</li><li>APIサーバーは様々な種類の <em>リソース</em> を扱います。<code>Pod</code>のような <em>ビルトインリソース</em> はKubernetesプロジェクトにより定義され、変更できません。ユーザーも、自身もしくは、他のプロジェクトで定義されたリソースを追加することができます。それは <em>カスタムリソース</em> と呼ばれ、<a href=/ja/docs/concepts/extend-kubernetes/#user-defined-types>カスタムリソース</a>セクションに記載されています。カスタムリソースは度々、APIアクセスエクステンションと一緒に使われます。</li><li>KubernetesのスケジューラーはPodをどのノードに配置するかを決定します。スケジューリングを拡張するには、いくつかの方法があります。それらは<a href=/ja/docs/concepts/extend-kubernetes/#scheduler-extensions>スケジューラーエクステンション</a>セクションに記載されています。</li><li>Kubernetesにおける多くの振る舞いは、APIサーバーのクライアントであるコントローラーと呼ばれるプログラムに実装されています。コントローラーは度々、カスタムリソースと共に使われます。</li><li>kubeletはサーバー上で実行され、Podが仮想サーバーのようにクラスターネットワーク上にIPを持った状態で起動することをサポートします。<a href=/ja/docs/concepts/extend-kubernetes/#network-plugins>ネットワークプラグイン</a>がPodのネットワーキングにおける異なる実装を適用することを可能にします。</li><li>kubeletはまた、コンテナのためにボリュームをマウント、アンマウントします。新しい種類のストレージは<a href=/ja/docs/concepts/extend-kubernetes/#storage-plugins>ストレージプラグイン</a>を通じてサポートされます。</li></ol><p>もしあなたがどこから始めるべきかわからない場合、このフローチャートが役立つでしょう。一部のソリューションは、いくつかの種類のエクステンションを含んでいることを留意してください。</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vRWXNNIVWFDqzDY0CsKZJY3AR8sDeFDXItdc5awYxVH8s0OLherMlEPVUpxPIB1CSUu7GPk7B2fEnzM/pub?w=1440&h=1080"><h2 id=apiエクステンション>APIエクステンション</h2><h3 id=ユーザー定義タイプ>ユーザー定義タイプ</h3><p>新しいコントローラー、アプリケーションの設定に関するオブジェクト、また宣言型APIを定義し、それらを<code>kubectl</code>のようなKubernetesのツールから管理したい場合、Kubernetesにカスタムリソースを追加することを検討して下さい。</p><p>カスタムリソースはアプリケーション、ユーザー、監視データのデータストレージとしては使わないで下さい。</p><p>カスタムリソースに関するさらなる情報は、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソースコンセプトガイド</a>を参照して下さい。</p><h3 id=新しいapiと自動化機能の連携>新しいAPIと自動化機能の連携</h3><p>カスタムリソースAPIと制御ループの組み合わせは<a href=/ja/docs/concepts/extend-kubernetes/operator/>オペレーターパターン</a>と呼ばれています。オペレーターパターンは、通常ステートフルな特定のアプリケーションを管理するために利用されます。これらのカスタムAPIと制御ループは、ストレージ、またはポリシーのような他のリソースを管理するためにも利用されます。</p><h3 id=ビルトインリソースの変更>ビルトインリソースの変更</h3><p>カスタムリソースを追加し、KubernetesAPIを拡張する場合、新たに追加されたリソースは常に新しいAPIグループに分類されます。既存のAPIグループを置き換えたり、変更することはできません。APIを追加することは直接、既存のAPI(例、Pod)の振る舞いに影響を与えることは無いですが、APIアクセスエクステンションの場合、その可能性があります。</p><h3 id=apiアクセスエクステンション>APIアクセスエクステンション</h3><p>リクエストがKubernetes APIサーバーに到達すると、まず最初に認証が行われ、次に認可、その後、様々なAdmission Controlの対象になります。このフローの詳細は<a href=/docs/concepts/security/controlling-access/>Kubernetes APIへのアクセスをコントロールする</a>を参照して下さい。</p><p>これらの各ステップごとに拡張ポイントが用意されています。</p><p>Kubdernetesはいくつかのビルトイン認証方式をサポートしています。それは認証プロキシの後ろに配置することも可能で、認可ヘッダーを通じて(Webhookの)検証のために外部サービスにトークンを送ることもできます。全てのこれらの方法は<a href=/ja/docs/reference/access-authn-authz/authentication/>認証ドキュメント</a>でカバーされています。</p><h3 id=認証>認証</h3><p><a href=/ja/docs/reference/access-authn-authz/authentication/>認証</a>は、全てのリクエストのヘッダーまたは証明書情報を、リクエストを投げたクライアントのユーザー名にマッピングします。</p><p>Kubernetesはいくつかのビルトイン認証方式と、それらが要件に合わない場合、<a href=/docs/reference/access-authn-authz/authentication/#webhook-token-authentication>認証Webhook</a>を提供します。</p><h3 id=認可>認可</h3><p><a href=/docs/reference/access-authn-authz/webhook/>認可</a>は特定のユーザーがAPIリソースに対して、読み込み、書き込み、そしてその他の操作が可能かどうかを決定します。それはオブジェクト全体のレベルで機能し、任意のオブジェクトフィールドに基づいての区別は行いません。もしビルトインの認可メカニズムが要件に合わない場合、<a href=/docs/reference/access-authn-authz/webhook/>認可Webhook</a>が、ユーザー提供のコードを呼び出し認可の決定を行うことを可能にします。</p><h3 id=動的admission-control>動的Admission Control</h3><p>リクエストが認可された後、もしそれが書き込み操作だった場合、リクエストは<a href=/docs/reference/access-authn-authz/admission-controllers/>Admission Control</a>のステップを通ります。ビルトインのステップに加え、いくつかのエクステンションが存在します:</p><ul><li><a href=/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook>イメージポリシーWebhook</a>は、コンテナでどのイメージを実行することができるかを制限する</li><li>任意のAdmission Controlの決定を行うには、一般的な<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Admission webhook</a>が利用できる。Admission Webhookは作成、更新を拒絶できる</li></ul><h2 id=インフラストラクチャエクステンション>インフラストラクチャエクステンション</h2><h3 id=ストレージプラグイン>ストレージプラグイン</h3><p><a href=/docs/concepts/storage/volumes/#flexvolume>Flex Volumes</a>は、Kubeletがバイナリプラグインを呼び出してボリュームをマウントすることにより、ユーザーはビルトインのサポートなしでボリュームタイプをマウントすることを可能にします。</p><h3 id=デバイスプラグイン>デバイスプラグイン</h3><p><a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a>を通じて、ノードが新たなノードのリソース(CPU、メモリなどのビルトインのものに加え)を見つけることを可能にします。</p><h3 id=ネットワークプラグイン>ネットワークプラグイン</h3><p>他のネットワークファブリックが<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>を通じてサポートされます。</p><h3 id=スケジューラーエクステンション>スケジューラーエクステンション</h3><p>スケジューラーは特別な種類のコントローラーで、Podを監視し、Podをノードに割り当てます。デフォルトのコントローラーを完全に置き換えることもできますが、他のKubernetesのコンポーネントの利用を継続する、または<a href=/docs/tasks/extend-kubernetes/configure-multiple-schedulers/>複数のスケジューラー</a>を同時に動かすこともできます。</p><p>これはかなりの大きな作業で、ほとんど全てのKubernetesユーザーはスケジューラーを変更する必要はありません。</p><p>スケジューラは<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/scheduler_extender.md>Webhook</a>もサポートしており、Webhookバックエンド(スケジューラーエクステンション)を通じてPodを配置するために選択されたノードをフィルタリング、優先度付けすることが可能です。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>についてより深く学ぶ</li><li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>動的Admission control</a>について学ぶ</li><li>インフラストラクチャエクステンションについてより深く学ぶ<ul><li><a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a></li><li><a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a></li></ul></li><li><a href=/docs/tasks/extend-kubectl/kubectl-plugins/>kubectlプラグイン</a>について学ぶ</li><li><a href=/docs/concepts/extend-kubernetes/operator/>オペレーターパターン</a>について学ぶ</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0af41d3bd7c785621b58b7564793396a>2 - Kubernetes APIの拡張</h1></div><div class=td-content><h1 id=pg-342388440304e19ce30c0f8ada1c77ce>2.1 - カスタムリソース</h1><p><em>カスタムリソース</em> はKubernetes APIの拡張です。このページでは、いつKubernetesのクラスターにカスタムリソースを追加するべきなのか、そしていつスタンドアローンのサービスを利用するべきなのかを議論します。カスタムリソースを追加する2つの方法と、それらの選択方法について説明します。</p><h2 id=カスタムリソース>カスタムリソース</h2><p><em>リソース</em> は、<a href=/ja/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>のエンドポイントで、特定の<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/>APIオブジェクト</a>のコレクションを保持します。例えば、ビルトインの <em>Pods</em> リソースは、Podオブジェクトのコレクションを包含しています。</p><p><em>カスタムリソース</em> は、Kubernetes APIの拡張で、デフォルトのKubernetesインストールでは、必ずしも利用できるとは限りません。つまりそれは、特定のKubernetesインストールのカスタマイズを表します。しかし、今現在、多数のKubernetesのコア機能は、カスタムリソースを用いて作られており、Kubernetesをモジュール化しています。</p><p>カスタムリソースは、稼働しているクラスターに動的に登録され、現れたり、消えたりし、クラスター管理者はクラスター自体とは無関係にカスタムリソースを更新できます。一度、カスタムリソースがインストールされると、ユーザーは<a href=/ja/docs/reference/kubectl/overview/>kubectl</a>を使い、ビルトインのリソースである <em>Pods</em> と同じように、オブジェクトを作成、アクセスすることが可能です。</p><h2 id=カスタムコントローラー>カスタムコントローラー</h2><p>カスタムリソースそれ自身は、単純に構造化データを格納、取り出す機能を提供します。カスタムリソースを <em>カスタムコントローラー</em> と組み合わせることで、カスタムリソースは真の <em>宣言的API</em> を提供します。</p><p><a href=/ja/docs/concepts/overview/kubernetes-api/>宣言的API</a>は、リソースのあるべき状態を <em>宣言</em> または指定することを可能にし、Kubernetesオブジェクトの現在の状態を、あるべき状態に同期し続けるように動きます。
コントローラーは、構造化データをユーザーが指定したあるべき状態と解釈し、その状態を管理し続けます。</p><p>稼働しているクラスターのライフサイクルとは無関係に、カスタムコントローラーをデプロイ、更新することが可能です。カスタムコントローラーはあらゆるリソースと連携できますが、カスタムリソースと組み合わせると特に効果を発揮します。<a href=https://coreos.com/blog/introducing-operators.html>オペレーターパターン</a>は、カスタムリソースとカスタムコントローラーの組み合わせです。カスタムコントローラーにより、特定アプリケーションのドメイン知識を、Kubernetes APIの拡張に変換することができます。</p><h2 id=カスタムリソースをクラスターに追加するべきか>カスタムリソースをクラスターに追加するべきか？</h2><p>新しいAPIを作る場合、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIをKubernetesクラスターAPIにアグリゲート(集約)する</a>か、もしくはAPIをスタンドアローンで動かすかを検討します。</p><table><thead><tr><th>APIアグリゲーションを使う場合:</th><th>スタンドアローンAPIを使う場合:</th></tr></thead><tbody><tr><td>APIが<a href=#%E5%AE%A3%E8%A8%80%E7%9A%84API>宣言的</a></td><td>APIが<a href=#%E5%AE%A3%E8%A8%80%E7%9A%84API>宣言的</a>モデルに適さない</td></tr><tr><td>新しいリソースを<code>kubectl</code>を使い読み込み、書き込みしたい</td><td><code>kubectl</code>のサポートは必要ない</td></tr><tr><td>新しいリソースをダッシュボードのような、Kubernetes UIで他のビルトインリソースと同じように管理したい</td><td>Kubernetes UIのサポートは必要ない</td></tr><tr><td>新しいAPIを開発している</td><td>APIを提供し、適切に機能するプログラムが既に存在している</td></tr><tr><td>APIグループ、名前空間というような、RESTリソースパスに割り当てられた、Kubernetesのフォーマット仕様の制限を許容できる(<a href=/ja/docs/concepts/overview/kubernetes-api/>API概要</a>を参照)</td><td>既に定義済みのREST APIと互換性を持っていなければならない</td></tr><tr><td>リソースはクラスターごとか、クラスター内の名前空間に自然に分けることができる</td><td>クラスター、または名前空間による分割がリソース管理に適さない。特定のリソースパスに基づいて管理したい</td></tr><tr><td><a href=#%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E6%A9%9F%E8%83%BD>Kubernetes APIサポート機能</a>を再利用したい</td><td>これらの機能は必要ない</td></tr></tbody></table><h3 id=宣言的api>宣言的API</h3><p>宣言的APIは、通常、下記に該当します:</p><ul><li>APIは、比較的少数の、比較的小さなオブジェクト(リソース)で構成されている</li><li>オブジェクトは、アプリケーションの設定、インフラストラクチャーを定義する</li><li>オブジェクトは、比較的更新頻度が低い</li><li>人は、オブジェクトの情報をよく読み書きする</li><li>オブジェクトに対する主要な手続きは、CRUD(作成、読み込み、更新、削除)になる</li><li>複数オブジェクトをまたいだトランザクションは必要ない: APIは今現在の状態ではなく、あるべき状態を表現する</li></ul><p>命令的APIは、宣言的ではありません。
APIが宣言的ではない兆候として、次のものがあります:</p><ul><li>クライアントから"これを実行"と命令がきて、完了の返答を同期的に受け取る</li><li>クライアントから"これを実行"と命令がきて、処理IDを取得する。そして処理が完了したかどうかを、処理IDを利用して別途問い合わせる</li><li>リモートプロシージャコール(RPC)という言葉が飛び交っている</li><li>直接、大量のデータを格納している(例、1オブジェクトあたり数kBより大きい、または数千オブジェクトより多い)</li><li>高帯域アクセス(持続的に毎秒数十リクエスト)が必要</li><li>エンドユーザーのデータ(画像、PII、その他)を格納している、またはアプリケーションが処理する大量のデータを格納している</li><li>オブジェクトに対する処理が、CRUDではない</li><li>APIをオブジェクトとして簡単に表現できない</li><li>停止している処理を処理ID、もしくは処理オブジェクトで表現することを選択している</li></ul><h2 id=configmapとカスタムリソースのどちらを使うべきか>ConfigMapとカスタムリソースのどちらを使うべきか？</h2><p>下記のいずれかに該当する場合は、ConfigMapを使ってください:</p><ul><li><code>mysql.cnf</code>、<code>pom.xml</code>のような、十分に文書化された設定ファイルフォーマットが既に存在している</li><li>単一キーのConfigMapに、設定ファイルの内容の全てを格納している</li><li>設定ファイルの主な用途は、クラスター上のPodで実行されているプログラムがファイルを読み込み、それ自体を構成することである</li><li>ファイルの利用者は、Kubernetes APIよりも、Pod内のファイルまたはPod内の環境変数を介して利用することを好む</li><li>ファイルが更新されたときに、Deploymentなどを介してローリングアップデートを行いたい</li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong> センシティブなデータには、ConfigMapに類似していますがよりセキュアな<a href=/ja/docs/concepts/configuration/secret/>secret</a>を使ってください</div><p>下記のほとんどに該当する場合、カスタムリソース(CRD、またはアグリゲートAPI)を使ってください:</p><ul><li>新しいリソースを作成、更新するために、Kubernetesのクライアントライブラリー、CLIを使いたい</li><li>kubectlのトップレベルサポートが欲しい(例、<code>kubectl get my-object object-name</code>)</li><li>新しい自動化の仕組みを作り、新しいオブジェクトの更新をウォッチしたい、その更新を契機に他のオブジェクトのCRUDを実行したい、またはその逆を行いたい</li><li>オブジェクトの更新を取り扱う、自動化の仕組みを書きたい</li><li><code>.spec</code>、<code>.status</code>、<code>.metadata</code>というような、Kubernetes APIの慣習を使いたい</li><li>オブジェクトは、制御されたリソースコレクションの抽象化、または他のリソースのサマリーとしたい</li></ul><h2 id=カスタムリソースを追加する>カスタムリソースを追加する</h2><p>Kubernetesは、クラスターへカスタムリソースを追加する2つの方法を提供しています:</p><ul><li>CRDはシンプルで、プログラミングなしに作成可能</li><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIアグリゲーション</a>は、プログラミングが必要だが、データがどのように格納され、APIバージョン間でどのように変換されるかというような、より詳細なAPIの振る舞いを制御できる</li></ul><p>Kubernetesは、さまざまなユーザーのニーズを満たすためにこれら2つのオプションを提供しており、使いやすさや柔軟性が損なわれることはありません。</p><p>アグリゲートAPIは、プロキシーとして機能するプライマリAPIサーバーの背後にある、下位のAPIServerです。このような配置は<a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIアグリゲーション</a>(AA)と呼ばれています。ユーザーにとっては、単にAPIサーバーが拡張されているように見えます。</p><p>CRDでは、APIサーバーの追加なしに、ユーザーが新しい種類のリソースを作成できます。CRDを使うには、APIアグリゲーションを理解する必要はありません。</p><p>どのようにインストールされたかに関わらず、新しいリソースはカスタムリソースとして参照され、ビルトインのKubernetesリソース(Podなど)とは区別されます。</p><h2 id=customresourcedefinition>CustomResourceDefinition</h2><p><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>APIリソースは、カスタムリソースを定義します。CRDオブジェクトを定義することで、指定した名前、スキーマで新しいカスタムリソースが作成されます。Kubernetes APIは、作成したカスタムリソースのストレージを提供、および処理します。
CRDオブジェクトの名前は<a href=/ja/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names>DNSサブドメイン名</a>に従わなければなりません。</p><p>これはカスタムリソースを処理するために、独自のAPIサーバーを書くことから解放してくれますが、一般的な性質として<a href=#API%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%A2%E3%82%B0%E3%83%AA%E3%82%B2%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3>APIサーバーアグリゲーション</a>と比べると、柔軟性に欠けます。</p><p>新しいカスタムリソースをどのように登録するか、新しいリソースタイプとの連携、そしてコントローラーを使いイベントを処理する方法例について、<a href=https://github.com/kubernetes/sample-controller>カスタムコントローラー例</a>を参照してください。</p><h2 id=apiサーバーアグリゲーション>APIサーバーアグリゲーション</h2><p>通常、Kubernetes APIの各リソースは、RESTリクエストとオブジェクトの永続的なストレージを管理するためのコードが必要です。メインのKubernetes APIサーバーは <em>Pod</em> や <em>Service</em> のようなビルトインのリソースを処理し、またカスタムリソースも<a href=#customresourcedefinition>CRD</a>を通じて同じように管理することができます。</p><p><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>アグリゲーションレイヤー</a>は、独自のAPIサーバーを書き、デプロイすることで、カスタムリソースに特化した実装の提供を可能にします。メインのAPIサーバーが、処理したいカスタムリソースへのリクエストを独自のAPIサーバーに委譲することで、他のクライアントからも利用できるようにします。</p><h2 id=カスタムリソースの追加方法を選択する>カスタムリソースの追加方法を選択する</h2><p>CRDは簡単に使えます。アグリゲートAPIはより柔軟です。ニーズに最も合う方法を選択してください。</p><p>通常、CRDは下記の場合に適しています:</p><ul><li>少数のフィールドしか必要ない</li><li>そのリソースは社内のみで利用している、または小さいオープンソースプロジェクトの一部で利用している(商用プロダクトではない)</li></ul><h3 id=使いやすさの比較>使いやすさの比較</h3><p>CRDは、アグリゲートAPIと比べ、簡単に作れます。</p><table><thead><tr><th>CRD</th><th>アグリゲートAPI</th></tr></thead><tbody><tr><td>プログラミングが不要で、ユーザーはCRDコントローラーとしてどの言語でも選択可能</td><td>Go言語でプログラミングし、バイナリとイメージの作成が必要</td></tr><tr><td>追加のサービスは不要。CRDはAPIサーバーで処理される</td><td>追加のサービス作成が必要で、障害が発生する可能性がある</td></tr><tr><td>CRDが作成されると、継続的なサポートは無い。バグ修正は通常のKubernetesマスターのアップグレードで行われる</td><td>定期的にアップストリームからバグ修正の取り込み、リビルド、そしてアグリゲートAPIサーバーの更新が必要かもしれない</td></tr><tr><td>複数バージョンのAPI管理は不要。例えば、あるリソースを操作するクライアントを管理していた場合、APIのアップグレードと一緒に更新される</td><td>複数バージョンのAPIを管理しなければならない。例えば、世界中に共有されている拡張機能を開発している場合</td></tr></tbody></table><h3 id=高度な機能-柔軟性>高度な機能、柔軟性</h3><p>アグリゲートAPIは、例えばストレージレイヤーのカスタマイズのような、より高度なAPI機能と他の機能のカスタマイズを可能にします。</p><table><thead><tr><th>機能</th><th>詳細</th><th>CRD</th><th>アグリゲートAPI</th></tr></thead><tbody><tr><td>バリデーション</td><td>エラーを予防し、クライアントと無関係にAPIを発達させることができるようになる。これらの機能は多数のクライアントがおり、同時に全てを更新できないときに最も効果を発揮する</td><td>はい、ほとんどのバリデーションは<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 validation</a>で、CRDに指定できる。その他のバリデーションは<a href=/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook-alpha-in-1-8-beta-in-1-9>Webhookのバリデーション</a>によりサポートされている</td><td>はい、任意のバリデーションが可能</td></tr><tr><td>デフォルト設定</td><td>上記を参照</td><td>はい、<a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#defaulting>OpenAPI v3.0 validation</a>の<code>default</code>キーワード(1.17でGA)、または<a href=/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook>Mutating Webhook</a>を通じて可能 (ただし、この方法は古いオブジェクトをetcdから読み込む場合には動きません)</td><td>はい</td></tr><tr><td>複数バージョニング</td><td>同じオブジェクトを、違うAPIバージョンで利用可能にする。フィールドの名前を変更するなどのAPIの変更を簡単に行うのに役立つ。クライアントのバージョンを管理する場合、重要性は下がる</td><td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning>はい</a></td><td>はい</td></tr><tr><td>カスタムストレージ</td><td>異なる性能のストレージが必要な場合(例えば、キーバリューストアの代わりに時系列データベース)または、セキュリティの分離(例えば、機密情報の暗号化、その他)</td><td>いいえ</td><td>はい</td></tr><tr><td>カスタムビジネスロジック</td><td>オブジェクトが作成、読み込み、更新、また削除されるときに任意のチェック、アクションを実行する</td><td>はい、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Webhooks</a>を利用</td><td>はい</td></tr><tr><td>サブリソースのスケール</td><td>HorizontalPodAutoscalerやPodDisruptionBudgetなどのシステムが、新しいリソースと連携できるようにする</td><td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource>はい</a></td><td>はい</td></tr><tr><td>サブリソースの状態</td><td>ユーザーがspecセクションに書き込み、コントローラーがstatusセクションに書き込む際に、より詳細なアクセスコントロールができるようにする。カスタムリソースのデータ変換時にオブジェクトの世代を上げられるようにする(リソース内のspecとstatusでセクションが分離している必要がある)</td><td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource>はい</a></td><td>はい</td></tr><tr><td>その他のサブリソース</td><td>"logs"や"exec"のような、CRUD以外の処理の追加</td><td>いいえ</td><td>はい</td></tr><tr><td>strategic-merge-patch</td><td><code>Content-Type: application/strategic-merge-patch+json</code>で、PATCHをサポートする新しいエンドポイント。ローカル、サーバー、どちらでも更新されうるオブジェクトに有用。さらなる情報は<a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>"APIオブジェクトをkubectl patchで決まった場所で更新"</a>を参照</td><td>いいえ</td><td>はい</td></tr><tr><td>プロトコルバッファ</td><td>プロトコルバッファを使用するクライアントをサポートする新しいリソース</td><td>いいえ</td><td>はい</td></tr><tr><td>OpenAPIスキーマ</td><td>サーバーから動的に取得できる型のOpenAPI(Swagger)スキーマはあるか、許可されたフィールドのみが設定されるようにすることで、ユーザーはフィールド名のスペルミスから保護されているか、型は強制されているか(言い換えると、「文字列」フィールドに「int」を入れさせない)</td><td>はい、<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 validation</a> スキーマがベース(1.16でGA)</td><td>はい</td></tr></tbody></table><h3 id=一般的な機能>一般的な機能</h3><p>CRD、またはアグリゲートAPI、どちらを使ってカスタムリソースを作った場合でも、Kubernetesプラットフォーム外でAPIを実装するのに比べ、多数の機能が提供されます:</p><table><thead><tr><th>機能</th><th>何を実現するか</th></tr></thead><tbody><tr><td>CRUD</td><td>新しいエンドポイントが、HTTP、<code>kubectl</code>を通じて、基本的なCRUD処理をサポート</td></tr><tr><td>Watch</td><td>新しいエンドポイントが、HTTPを通じて、KubernetesのWatch処理をサポート</td></tr><tr><td>Discovery</td><td><code>kubectl</code>やダッシュボードのようなクライアントが、自動的にリソースの一覧表示、個別表示、フィールドの編集処理を提供</td></tr><tr><td>json-patch</td><td>新しいエンドポイントが<code>Content-Type: application/json-patch+json</code>を用いたPATCHをサポート</td></tr><tr><td>merge-patch</td><td>新しいエンドポイントが<code>Content-Type: application/merge-patch+json</code>を用いたPATCHをサポート</td></tr><tr><td>HTTPS</td><td>新しいエンドポイントがHTTPSを利用</td></tr><tr><td>ビルトイン認証</td><td>拡張機能へのアクセスに認証のため、コアAPIサーバー(アグリゲーションレイヤー)を利用</td></tr><tr><td>ビルトイン認可</td><td>拡張機能へのアクセスにコアAPIサーバーで使われている認可メカニズムを再利用(例、RBAC)</td></tr><tr><td>ファイナライザー</td><td>外部リソースの削除が終わるまで、拡張リソースの削除をブロック</td></tr><tr><td>Admission Webhooks</td><td>拡張リソースの作成/更新/削除処理時に、デフォルト値の設定、バリデーションを実施</td></tr><tr><td>UI/CLI 表示</td><td>kubectl、ダッシュボードで拡張リソースを表示</td></tr><tr><td>未設定 対 空設定</td><td>クライアントは、フィールドの未設定とゼロ値を区別することができる</td></tr><tr><td>クライアントライブラリーの生成</td><td>Kubernetesは、一般的なクライアントライブラリーと、タイプ固有のクライアントライブラリーを生成するツールを提供</td></tr><tr><td>ラベルとアノテーション</td><td>ツールがコアリソースとカスタムリソースの編集方法を知っているオブジェクト間で、共通のメタデータを提供</td></tr></tbody></table><h2 id=カスタムリソースのインストール準備>カスタムリソースのインストール準備</h2><p>クラスターにカスタムリソースを追加する前に、いくつか認識しておくべき事項があります。</p><h3 id=サードパーティのコードと新しい障害点>サードパーティのコードと新しい障害点</h3><p>CRDを作成しても、勝手に新しい障害点が追加されてしまうことはありませんが(たとえば、サードパーティのコードをAPIサーバーで実行することによって)、パッケージ(たとえば、Chart)またはその他のインストールバンドルには、多くの場合、CRDと新しいカスタムリソースのビジネスロジックを実装するサードパーティコードが入ったDeploymentが含まれます。</p><p>アグリゲートAPIサーバーのインストールすると、常に新しいDeploymentが付いてきます。</p><h3 id=ストレージ>ストレージ</h3><p>カスタムリソースは、ConfigMapと同じ方法でストレージの容量を消費します。多数のカスタムリソースを作成すると、APIサーバーのストレージ容量を超えてしまうかもしれません。</p><p>アグリゲートAPIサーバーも、メインのAPIサーバーと同じストレージを利用するかもしれません。その場合、同じ問題が発生しえます。</p><h3 id=認証-認可-そして監査>認証、認可、そして監査</h3><p>CRDでは、APIサーバーのビルトインリソースと同じ認証、認可、そして監査ロギングの仕組みを利用します。</p><p>もしRBACを使っている場合、ほとんどのRBACのロールは新しいリソースへのアクセスを許可しません。(クラスター管理者ロール、もしくはワイルドカードで作成されたロールを除く)新しいリソースには、明示的にアクセスを許可する必要があります。多くの場合、CRDおよびアグリゲートAPIには、追加するタイプの新しいロール定義がバンドルされています。</p><p>アグリゲートAPIサーバーでは、APIサーバーのビルトインリソースと同じ認証、認可、そして監査の仕組みを使う場合と使わない場合があります。</p><h2 id=カスタムリソースへのアクセス>カスタムリソースへのアクセス</h2><p>Kubernetesの<a href=/docs/reference/using-api/client-libraries/>クライアントライブラリー</a>を使い、カスタムリソースにアクセスすることが可能です。全てのクライアントライブラリーがカスタムリソースをサポートしているわけでは無いですが、<em>Go</em> と <em>Python</em> のライブラリーはサポートしています。</p><p>カスタムリソースは、下記のような方法で操作できます:</p><ul><li><code>kubectl</code></li><li>kubernetesの動的クライアント</li><li>自作のRESTクライアント</li><li><a href=https://github.com/kubernetes/code-generator>Kubernetesクライアント生成ツール</a>を使い生成したクライアント(生成は高度な作業ですが、一部のプロジェクトは、CRDまたはAAとともにクライアントを提供する場合があります)</li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Kubernetes APIをアグリゲーションレイヤーで拡張する方法</a>について学ぶ</li><li><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>Kubernetes APIをCustomResourceDefinitionで拡張する方法</a>について学ぶ</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>2.2 - アグリゲーションレイヤーを使ったKubernetes APIの拡張</h1><p>アグリゲーションレイヤーを使用すると、KubernetesのコアAPIで提供されている機能を超えて、追加のAPIでKubernetesを拡張できます。追加のAPIは、<a href=/docs/concepts/extend-kubernetes/service-catalog/>service-catalog</a>のような既製のソリューション、または自分で開発したAPIのいずれかです。</p><p>アグリゲーションレイヤーは、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>とは異なり、<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a>に新しい種類のオブジェクトを認識させる方法です。</p><h2 id=アグリゲーションレイヤー>アグリゲーションレイヤー</h2><p>アグリゲーションレイヤーは、kube-apiserverのプロセス内で動きます。拡張リソースが登録されるまでは、アグリゲーションレイヤーは何もしません。APIを登録するには、ユーザーはKubernetes APIで使われるURLのパスを"要求"した、<em>APIService</em> オブジェクトを追加します。それを追加すると、アグリゲーションレイヤーはAPIパス(例、<code>/apis/myextension.mycompany.io/v1/…</code>)への全てのアクセスを、登録されたAPIServiceにプロキシーします。</p><p>APIServiceを実装する最も一般的な方法は、クラスター内で実行されるPodで<em>拡張APIサーバー</em> を実行することです。クラスター内のリソース管理に拡張APIサーバーを使用している場合、拡張APIサーバー("extension-apiserver"とも呼ばれます)は通常、1つ以上の<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>とペアになっています。apiserver-builderライブラリは、拡張APIサーバーと関連するコントローラーの両方にスケルトンを提供します。</p><h3 id=応答遅延>応答遅延</h3><p>拡張APIサーバーは、kube-apiserverとの間の低遅延ネットワーキングが必要です。
kube-apiserverとの間を5秒以内に往復するためには、ディスカバリーリクエストが必要です。</p><p>拡張APIサーバーがそのレイテンシ要件を達成できない場合は、その要件を満たすように変更することを検討してください。また、kube-apiserverで<code>EnableAggregatedDiscoveryTimeout=false</code> <a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を設定することで、タイムアウト制限を無効にすることができます。この非推奨のフィーチャーゲートは将来のリリースで削除される予定です。</p><h2 id=次の項目>次の項目</h2><ul><li>アグリゲーターをあなたの環境で動かすには、まず<a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>アグリゲーションレイヤーを設定</a>します</li><li>そして、アグリゲーションレイヤーと一緒に動作させるために<a href=/docs/tasks/extend-kubernetes/setup-extension-api-server/>extension api-serverをセットアップ</a>します</li><li>また、<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>Custom Resource Definitionを使いKubernetes APIを拡張する</a>方法を学んで下さい</li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#apiservice-v1-apiregistration-k8s-io>APIService</a>の仕様をお読み下さい</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3131452556176159fb269593c1a52012>3 - オペレーターパターン</h1><p>オペレーターは<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>を使用するKubernetesへのソフトウェア拡張です。
オペレーターは、特に<a href=/ja/docs/concepts/#kubernetes-control-plane>制御ループ</a>のようなKubernetesが持つ仕組みに準拠しています。</p><h2 id=モチベーション>モチベーション</h2><p>オペレーターパターンはサービス、またはサービス群を管理している運用担当者の主な目的をキャプチャすることが目標です。
特定のアプリケーション、サービスの面倒を見ている運用担当者は、システムがどのように振る舞うべきか、どのようにデプロイをするか、何らかの問題があったときにどのように対応するかについて深い知識を持っています。</p><p>Kubernetes上でワークロードを稼働させている人は、しばしば繰り返し可能なタスクを自動化することを好みます。
オペレーターパターンは、Kubernetes自身が提供している機能を超えて、あなたがタスクを自動化するために、どのようにコードを書くかをキャプチャします。</p><h2 id=kubernetesにおけるオペレーター>Kubernetesにおけるオペレーター</h2><p>Kubernetesは自動化のために設計されています。追加の作業、設定無しに、Kubernetesのコア機能によって多数のビルトインされた自動化機能が提供されます。
ワークロードのデプロイおよび稼働を自動化するためにKubernetesを使うことができます。 <em>さらに</em> Kubernetesがそれをどのように行うかの自動化も可能です。</p><p>Kubernetesの<a class=glossary-tooltip title='A specialized controller used to manage a custom resource' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=オペレーターパターン>オペレーターパターン</a>コンセプトは、Kubernetesのソースコードを修正すること無く、一つ以上のカスタムリソースに<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=カスタムコントローラー>カスタムコントローラー</a>をリンクすることで、クラスターの振る舞いを拡張することを可能にします。
オペレーターはKubernetes APIのクライアントで、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Custom Resource</a>にとっての、コントローラーのように振る舞います。</p><h2 id=example>オペレーターの例</h2><p>オペレーターを使い自動化できるいくつかのことは、下記のようなものがあります:</p><ul><li>必要に応じてアプリケーションをデプロイする</li><li>アプリケーションの状態のバックアップを取得、リストアする</li><li>アプリケーションコードの更新と同時に、例えばデータベーススキーマ、追加の設定修正など必要な変更の対応を行う</li><li>Kubernetes APIをサポートしていないアプリケーションに、サービスを公開してそれらを発見する</li><li>クラスターの回復力をテストするために、全て、または一部分の障害をシミュレートする</li><li>内部のリーダー選出プロセス無しに、分散アプリケーションのリーダーを選択する</li></ul><p>オペレーターをもっと詳しく見るとどのように見えるでしょうか？より詳細な例を示します:</p><ol><li>クラスターに設定可能なSampleDBという名前のカスタムリソース</li><li>オペレーターの、コントローラー部分を含むPodが実行されていることを保証するDeployment</li><li>オペレーターのコードを含んだコンテナイメージ</li><li>設定されているSampleDBのリソースを見つけるために、コントロールプレーンに問い合わせるコントローラーのコード</li><li>オペレーターのコアは、現実を、設定されているリソースにどのように合わせるかをAPIサーバーに伝えるコードです。<ul><li>もし新しいSampleDBを追加した場合、オペレーターは永続化データベースストレージを提供するためにPersistentVolumeClaimsをセットアップし、StatefulSetがSampleDBの起動と、初期設定を担うJobを走らせます</li><li>もしそれを削除した場合、オペレーターはスナップショットを取り、StatefulSetとVolumeも合わせて削除されたことを確認します</li></ul></li><li>オペレーターは定期的なデータベースのバックアップも管理します。それぞれのSampleDBリソースについて、オペレーターはデータベースに接続可能な、バックアップを取得するPodをいつ作成するかを決定します。これらのPodはデータベース接続の詳細情報、クレデンシャルを保持するConfigMapとSecret、もしくはどちらかに依存するでしょう。</li><li>オペレーターは、管理下のリソースの堅牢な自動化を提供することを目的としているため、補助的な追加コードが必要になるかもしれません。この例では、データベースが古いバージョンで動いているかどうかを確認するコードで、その場合、アップグレードを行うJobをあなたに代わり作成します。</li></ol><h2 id=オペレーターのデプロイ>オペレーターのデプロイ</h2><p>オペレーターをデプロイする最も一般的な方法は、Custom Resource Definitionとそれに関連するコントローラーをクラスターに追加することです。
このコントローラーは通常、あなたがコンテナアプリケーションを動かすのと同じように、<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>外で動作します。</p><p>例えば、コントローラーをDeploymentとしてクラスター内で動かすことができます。</p><h2 id=using-operators>オペレーターを利用する</h2><p>一度オペレーターをデプロイすると、そのオペレーターを使って、それ自身が使うリソースの種類を追加、変更、または削除できます。
上記の利用例に従ってオペレーターそのもののためのDeploymentをセットアップし、以下のようなコマンドを実行します:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get SampleDB                   <span style=color:#080;font-style:italic># 設定したデータベースを発見します</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl edit SampleDB/example-database <span style=color:#080;font-style:italic># 手動でいくつかの設定を変更します</span>
</span></span></code></pre></div><p>これだけです！オペレーターが変更の適用だけでなく既存のサービスがうまく稼働し続けるように面倒を見てくれます。</p><h2 id=writing-operator>自分でオペレーターを書く</h2><p>必要な振る舞いを実装したオペレーターがエコシステム内に無い場合、自分で作成することができます。
<a href=#whats-next>次の項目</a>で、自分でクラウドネイティブオペレーターを作るときに利用できるライブラリやツールのリンクを見つけることができます。</p><p>オペレーター（すなわち、コントローラー）はどの言語/ランタイムでも実装でき、<a href=/docs/reference/using-api/client-libraries/>Kubernetes APIのクライアント</a>として機能させることができます。</p><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Custom Resources</a>をより深く学びます</li><li>ユースケースに合わせた、既製のオペレーターを<a href=https://operatorhub.io/>OperatorHub.io</a>から見つけます</li><li>自前のオペレーターを書くために既存のツールを使います、例:<ul><li><a href=https://juju.is/>Charmed Operator Framework</a></li><li><a href=https://github.com/java-operator-sdk/java-operator-sdk>Java Operator SDK</a></li><li><a href=https://github.com/nolar/kopf>Kopf</a> (Kubernetes Operator Pythonic Framework)</li><li><a href=https://kube.rs/>kube-rs</a> (Rust)</li><li><a href=https://kudo.dev/>KUDO</a>（Kubernetes Universal Declarative Operator）を使います</li><li><a href=https://book.kubebuilder.io/>kubebuilder</a>を使います</li><li><a href=https://buehler.github.io/dotnet-operator-sdk/>KubeOps</a> (dotnet operator SDK)</li><li><a href=https://metacontroller.github.io/metacontroller/intro.html>Metacontroller</a>を自分で実装したWebHooksと一緒に使います</li><li><a href=https://operatorframework.io>Operator Framework</a>を使います</li><li><a href=https://github.com/flant/shell-operator>shell-operator</a></li></ul></li><li>自前のオペレーターを他のユーザーのために<a href=https://operatorhub.io/>公開</a>します</li><li>オペレーターパターンを紹介している<a href=https://coreos.com/blog/introducing-operators.html>CoreOSオリジナル記事</a>を読みます</li><li>Google Cloudが出したオペレーター作成のベストプラクティス<a href=https://cloud.google.com/blog/products/containers-kubernetes/best-practices-for-building-kubernetes-operators-and-stateful-apps>記事</a>を読みます</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>