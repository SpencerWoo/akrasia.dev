<!doctype html><html lang=ja class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/extend-kubernetes/api-extension/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/extend-kubernetes/api-extension/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Kubernetes APIの拡張 | Kubernetes</title><meta property="og:title" content="Kubernetes APIの拡張"><meta property="og:description" content="プロダクショングレードのコンテナ管理基盤"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/extend-kubernetes/api-extension/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Kubernetes APIの拡張"><meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubernetes APIの拡張"><meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/extend-kubernetes/api-extension/"><meta property="og:title" content="Kubernetes APIの拡張"><meta name=twitter:title content="Kubernetes APIの拡張"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ja/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ja/docs/>ドキュメント</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/blog/>Blogs</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/training/>トレーニング</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/partners/>パートナー</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/community/>コミュニティ</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/case-studies/>ケーススタディ</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>バージョン</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ja/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/extend-kubernetes/api-extension/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/extend-kubernetes/api-extension/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/extend-kubernetes/api-extension/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/concepts/extend-kubernetes/api-extension/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ja/docs/concepts/extend-kubernetes/api-extension/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語 (Japanese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/extend-kubernetes/api-extension/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/extend-kubernetes/api-extension/>한국어 (Korean)</a>
<a class=dropdown-item href=/fr/docs/concepts/extend-kubernetes/api-extension/>Français (French)</a>
<a class=dropdown-item href=/es/docs/concepts/extend-kubernetes/api-extension/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/extend-kubernetes/api-extension/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/extend-kubernetes/api-extension/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.</p><p><a href=/ja/docs/concepts/extend-kubernetes/api-extension/>このページの通常のビューに戻る</a>.</p></div><h1 class=title>Kubernetes APIの拡張</h1><ul><li>1: <a href=#pg-342388440304e19ce30c0f8ada1c77ce>カスタムリソース</a></li><li>2: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>アグリゲーションレイヤーを使ったKubernetes APIの拡張</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-342388440304e19ce30c0f8ada1c77ce>1 - カスタムリソース</h1><p><em>カスタムリソース</em> はKubernetes APIの拡張です。このページでは、いつKubernetesのクラスターにカスタムリソースを追加するべきなのか、そしていつスタンドアローンのサービスを利用するべきなのかを議論します。カスタムリソースを追加する2つの方法と、それらの選択方法について説明します。</p><h2 id=カスタムリソース>カスタムリソース</h2><p><em>リソース</em> は、<a href=/ja/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>のエンドポイントで、特定の<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/>APIオブジェクト</a>のコレクションを保持します。例えば、ビルトインの <em>Pods</em> リソースは、Podオブジェクトのコレクションを包含しています。</p><p><em>カスタムリソース</em> は、Kubernetes APIの拡張で、デフォルトのKubernetesインストールでは、必ずしも利用できるとは限りません。つまりそれは、特定のKubernetesインストールのカスタマイズを表します。しかし、今現在、多数のKubernetesのコア機能は、カスタムリソースを用いて作られており、Kubernetesをモジュール化しています。</p><p>カスタムリソースは、稼働しているクラスターに動的に登録され、現れたり、消えたりし、クラスター管理者はクラスター自体とは無関係にカスタムリソースを更新できます。一度、カスタムリソースがインストールされると、ユーザーは<a href=/ja/docs/reference/kubectl/overview/>kubectl</a>を使い、ビルトインのリソースである <em>Pods</em> と同じように、オブジェクトを作成、アクセスすることが可能です。</p><h2 id=カスタムコントローラー>カスタムコントローラー</h2><p>カスタムリソースそれ自身は、単純に構造化データを格納、取り出す機能を提供します。カスタムリソースを <em>カスタムコントローラー</em> と組み合わせることで、カスタムリソースは真の <em>宣言的API</em> を提供します。</p><p><a href=/ja/docs/concepts/overview/kubernetes-api/>宣言的API</a>は、リソースのあるべき状態を <em>宣言</em> または指定することを可能にし、Kubernetesオブジェクトの現在の状態を、あるべき状態に同期し続けるように動きます。
コントローラーは、構造化データをユーザーが指定したあるべき状態と解釈し、その状態を管理し続けます。</p><p>稼働しているクラスターのライフサイクルとは無関係に、カスタムコントローラーをデプロイ、更新することが可能です。カスタムコントローラーはあらゆるリソースと連携できますが、カスタムリソースと組み合わせると特に効果を発揮します。<a href=https://coreos.com/blog/introducing-operators.html>オペレーターパターン</a>は、カスタムリソースとカスタムコントローラーの組み合わせです。カスタムコントローラーにより、特定アプリケーションのドメイン知識を、Kubernetes APIの拡張に変換することができます。</p><h2 id=カスタムリソースをクラスターに追加するべきか>カスタムリソースをクラスターに追加するべきか？</h2><p>新しいAPIを作る場合、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIをKubernetesクラスターAPIにアグリゲート(集約)する</a>か、もしくはAPIをスタンドアローンで動かすかを検討します。</p><table><thead><tr><th>APIアグリゲーションを使う場合:</th><th>スタンドアローンAPIを使う場合:</th></tr></thead><tbody><tr><td>APIが<a href=#%E5%AE%A3%E8%A8%80%E7%9A%84API>宣言的</a></td><td>APIが<a href=#%E5%AE%A3%E8%A8%80%E7%9A%84API>宣言的</a>モデルに適さない</td></tr><tr><td>新しいリソースを<code>kubectl</code>を使い読み込み、書き込みしたい</td><td><code>kubectl</code>のサポートは必要ない</td></tr><tr><td>新しいリソースをダッシュボードのような、Kubernetes UIで他のビルトインリソースと同じように管理したい</td><td>Kubernetes UIのサポートは必要ない</td></tr><tr><td>新しいAPIを開発している</td><td>APIを提供し、適切に機能するプログラムが既に存在している</td></tr><tr><td>APIグループ、名前空間というような、RESTリソースパスに割り当てられた、Kubernetesのフォーマット仕様の制限を許容できる(<a href=/ja/docs/concepts/overview/kubernetes-api/>API概要</a>を参照)</td><td>既に定義済みのREST APIと互換性を持っていなければならない</td></tr><tr><td>リソースはクラスターごとか、クラスター内の名前空間に自然に分けることができる</td><td>クラスター、または名前空間による分割がリソース管理に適さない。特定のリソースパスに基づいて管理したい</td></tr><tr><td><a href=#%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E6%A9%9F%E8%83%BD>Kubernetes APIサポート機能</a>を再利用したい</td><td>これらの機能は必要ない</td></tr></tbody></table><h3 id=宣言的api>宣言的API</h3><p>宣言的APIは、通常、下記に該当します:</p><ul><li>APIは、比較的少数の、比較的小さなオブジェクト(リソース)で構成されている</li><li>オブジェクトは、アプリケーションの設定、インフラストラクチャーを定義する</li><li>オブジェクトは、比較的更新頻度が低い</li><li>人は、オブジェクトの情報をよく読み書きする</li><li>オブジェクトに対する主要な手続きは、CRUD(作成、読み込み、更新、削除)になる</li><li>複数オブジェクトをまたいだトランザクションは必要ない: APIは今現在の状態ではなく、あるべき状態を表現する</li></ul><p>命令的APIは、宣言的ではありません。
APIが宣言的ではない兆候として、次のものがあります:</p><ul><li>クライアントから"これを実行"と命令がきて、完了の返答を同期的に受け取る</li><li>クライアントから"これを実行"と命令がきて、処理IDを取得する。そして処理が完了したかどうかを、処理IDを利用して別途問い合わせる</li><li>リモートプロシージャコール(RPC)という言葉が飛び交っている</li><li>直接、大量のデータを格納している(例、1オブジェクトあたり数kBより大きい、または数千オブジェクトより多い)</li><li>高帯域アクセス(持続的に毎秒数十リクエスト)が必要</li><li>エンドユーザーのデータ(画像、PII、その他)を格納している、またはアプリケーションが処理する大量のデータを格納している</li><li>オブジェクトに対する処理が、CRUDではない</li><li>APIをオブジェクトとして簡単に表現できない</li><li>停止している処理を処理ID、もしくは処理オブジェクトで表現することを選択している</li></ul><h2 id=configmapとカスタムリソースのどちらを使うべきか>ConfigMapとカスタムリソースのどちらを使うべきか？</h2><p>下記のいずれかに該当する場合は、ConfigMapを使ってください:</p><ul><li><code>mysql.cnf</code>、<code>pom.xml</code>のような、十分に文書化された設定ファイルフォーマットが既に存在している</li><li>単一キーのConfigMapに、設定ファイルの内容の全てを格納している</li><li>設定ファイルの主な用途は、クラスター上のPodで実行されているプログラムがファイルを読み込み、それ自体を構成することである</li><li>ファイルの利用者は、Kubernetes APIよりも、Pod内のファイルまたはPod内の環境変数を介して利用することを好む</li><li>ファイルが更新されたときに、Deploymentなどを介してローリングアップデートを行いたい</li></ul><div class="alert alert-info note callout" role=alert><strong>備考:</strong> センシティブなデータには、ConfigMapに類似していますがよりセキュアな<a href=/ja/docs/concepts/configuration/secret/>secret</a>を使ってください</div><p>下記のほとんどに該当する場合、カスタムリソース(CRD、またはアグリゲートAPI)を使ってください:</p><ul><li>新しいリソースを作成、更新するために、Kubernetesのクライアントライブラリー、CLIを使いたい</li><li>kubectlのトップレベルサポートが欲しい(例、<code>kubectl get my-object object-name</code>)</li><li>新しい自動化の仕組みを作り、新しいオブジェクトの更新をウォッチしたい、その更新を契機に他のオブジェクトのCRUDを実行したい、またはその逆を行いたい</li><li>オブジェクトの更新を取り扱う、自動化の仕組みを書きたい</li><li><code>.spec</code>、<code>.status</code>、<code>.metadata</code>というような、Kubernetes APIの慣習を使いたい</li><li>オブジェクトは、制御されたリソースコレクションの抽象化、または他のリソースのサマリーとしたい</li></ul><h2 id=カスタムリソースを追加する>カスタムリソースを追加する</h2><p>Kubernetesは、クラスターへカスタムリソースを追加する2つの方法を提供しています:</p><ul><li>CRDはシンプルで、プログラミングなしに作成可能</li><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIアグリゲーション</a>は、プログラミングが必要だが、データがどのように格納され、APIバージョン間でどのように変換されるかというような、より詳細なAPIの振る舞いを制御できる</li></ul><p>Kubernetesは、さまざまなユーザーのニーズを満たすためにこれら2つのオプションを提供しており、使いやすさや柔軟性が損なわれることはありません。</p><p>アグリゲートAPIは、プロキシーとして機能するプライマリAPIサーバーの背後にある、下位のAPIServerです。このような配置は<a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIアグリゲーション</a>(AA)と呼ばれています。ユーザーにとっては、単にAPIサーバーが拡張されているように見えます。</p><p>CRDでは、APIサーバーの追加なしに、ユーザーが新しい種類のリソースを作成できます。CRDを使うには、APIアグリゲーションを理解する必要はありません。</p><p>どのようにインストールされたかに関わらず、新しいリソースはカスタムリソースとして参照され、ビルトインのKubernetesリソース(Podなど)とは区別されます。</p><h2 id=customresourcedefinition>CustomResourceDefinition</h2><p><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>APIリソースは、カスタムリソースを定義します。CRDオブジェクトを定義することで、指定した名前、スキーマで新しいカスタムリソースが作成されます。Kubernetes APIは、作成したカスタムリソースのストレージを提供、および処理します。
CRDオブジェクトの名前は<a href=/ja/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names>DNSサブドメイン名</a>に従わなければなりません。</p><p>これはカスタムリソースを処理するために、独自のAPIサーバーを書くことから解放してくれますが、一般的な性質として<a href=#API%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%A2%E3%82%B0%E3%83%AA%E3%82%B2%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3>APIサーバーアグリゲーション</a>と比べると、柔軟性に欠けます。</p><p>新しいカスタムリソースをどのように登録するか、新しいリソースタイプとの連携、そしてコントローラーを使いイベントを処理する方法例について、<a href=https://github.com/kubernetes/sample-controller>カスタムコントローラー例</a>を参照してください。</p><h2 id=apiサーバーアグリゲーション>APIサーバーアグリゲーション</h2><p>通常、Kubernetes APIの各リソースは、RESTリクエストとオブジェクトの永続的なストレージを管理するためのコードが必要です。メインのKubernetes APIサーバーは <em>Pod</em> や <em>Service</em> のようなビルトインのリソースを処理し、またカスタムリソースも<a href=#customresourcedefinition>CRD</a>を通じて同じように管理することができます。</p><p><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>アグリゲーションレイヤー</a>は、独自のAPIサーバーを書き、デプロイすることで、カスタムリソースに特化した実装の提供を可能にします。メインのAPIサーバーが、処理したいカスタムリソースへのリクエストを独自のAPIサーバーに委譲することで、他のクライアントからも利用できるようにします。</p><h2 id=カスタムリソースの追加方法を選択する>カスタムリソースの追加方法を選択する</h2><p>CRDは簡単に使えます。アグリゲートAPIはより柔軟です。ニーズに最も合う方法を選択してください。</p><p>通常、CRDは下記の場合に適しています:</p><ul><li>少数のフィールドしか必要ない</li><li>そのリソースは社内のみで利用している、または小さいオープンソースプロジェクトの一部で利用している(商用プロダクトではない)</li></ul><h3 id=使いやすさの比較>使いやすさの比較</h3><p>CRDは、アグリゲートAPIと比べ、簡単に作れます。</p><table><thead><tr><th>CRD</th><th>アグリゲートAPI</th></tr></thead><tbody><tr><td>プログラミングが不要で、ユーザーはCRDコントローラーとしてどの言語でも選択可能</td><td>Go言語でプログラミングし、バイナリとイメージの作成が必要</td></tr><tr><td>追加のサービスは不要。CRDはAPIサーバーで処理される</td><td>追加のサービス作成が必要で、障害が発生する可能性がある</td></tr><tr><td>CRDが作成されると、継続的なサポートは無い。バグ修正は通常のKubernetesマスターのアップグレードで行われる</td><td>定期的にアップストリームからバグ修正の取り込み、リビルド、そしてアグリゲートAPIサーバーの更新が必要かもしれない</td></tr><tr><td>複数バージョンのAPI管理は不要。例えば、あるリソースを操作するクライアントを管理していた場合、APIのアップグレードと一緒に更新される</td><td>複数バージョンのAPIを管理しなければならない。例えば、世界中に共有されている拡張機能を開発している場合</td></tr></tbody></table><h3 id=高度な機能-柔軟性>高度な機能、柔軟性</h3><p>アグリゲートAPIは、例えばストレージレイヤーのカスタマイズのような、より高度なAPI機能と他の機能のカスタマイズを可能にします。</p><table><thead><tr><th>機能</th><th>詳細</th><th>CRD</th><th>アグリゲートAPI</th></tr></thead><tbody><tr><td>バリデーション</td><td>エラーを予防し、クライアントと無関係にAPIを発達させることができるようになる。これらの機能は多数のクライアントがおり、同時に全てを更新できないときに最も効果を発揮する</td><td>はい、ほとんどのバリデーションは<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 validation</a>で、CRDに指定できる。その他のバリデーションは<a href=/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook-alpha-in-1-8-beta-in-1-9>Webhookのバリデーション</a>によりサポートされている</td><td>はい、任意のバリデーションが可能</td></tr><tr><td>デフォルト設定</td><td>上記を参照</td><td>はい、<a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#defaulting>OpenAPI v3.0 validation</a>の<code>default</code>キーワード(1.17でGA)、または<a href=/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook>Mutating Webhook</a>を通じて可能 (ただし、この方法は古いオブジェクトをetcdから読み込む場合には動きません)</td><td>はい</td></tr><tr><td>複数バージョニング</td><td>同じオブジェクトを、違うAPIバージョンで利用可能にする。フィールドの名前を変更するなどのAPIの変更を簡単に行うのに役立つ。クライアントのバージョンを管理する場合、重要性は下がる</td><td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning>はい</a></td><td>はい</td></tr><tr><td>カスタムストレージ</td><td>異なる性能のストレージが必要な場合(例えば、キーバリューストアの代わりに時系列データベース)または、セキュリティの分離(例えば、機密情報の暗号化、その他)</td><td>いいえ</td><td>はい</td></tr><tr><td>カスタムビジネスロジック</td><td>オブジェクトが作成、読み込み、更新、また削除されるときに任意のチェック、アクションを実行する</td><td>はい、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Webhooks</a>を利用</td><td>はい</td></tr><tr><td>サブリソースのスケール</td><td>HorizontalPodAutoscalerやPodDisruptionBudgetなどのシステムが、新しいリソースと連携できるようにする</td><td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource>はい</a></td><td>はい</td></tr><tr><td>サブリソースの状態</td><td>ユーザーがspecセクションに書き込み、コントローラーがstatusセクションに書き込む際に、より詳細なアクセスコントロールができるようにする。カスタムリソースのデータ変換時にオブジェクトの世代を上げられるようにする(リソース内のspecとstatusでセクションが分離している必要がある)</td><td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource>はい</a></td><td>はい</td></tr><tr><td>その他のサブリソース</td><td>"logs"や"exec"のような、CRUD以外の処理の追加</td><td>いいえ</td><td>はい</td></tr><tr><td>strategic-merge-patch</td><td><code>Content-Type: application/strategic-merge-patch+json</code>で、PATCHをサポートする新しいエンドポイント。ローカル、サーバー、どちらでも更新されうるオブジェクトに有用。さらなる情報は<a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>"APIオブジェクトをkubectl patchで決まった場所で更新"</a>を参照</td><td>いいえ</td><td>はい</td></tr><tr><td>プロトコルバッファ</td><td>プロトコルバッファを使用するクライアントをサポートする新しいリソース</td><td>いいえ</td><td>はい</td></tr><tr><td>OpenAPIスキーマ</td><td>サーバーから動的に取得できる型のOpenAPI(Swagger)スキーマはあるか、許可されたフィールドのみが設定されるようにすることで、ユーザーはフィールド名のスペルミスから保護されているか、型は強制されているか(言い換えると、「文字列」フィールドに「int」を入れさせない)</td><td>はい、<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 validation</a> スキーマがベース(1.16でGA)</td><td>はい</td></tr></tbody></table><h3 id=一般的な機能>一般的な機能</h3><p>CRD、またはアグリゲートAPI、どちらを使ってカスタムリソースを作った場合でも、Kubernetesプラットフォーム外でAPIを実装するのに比べ、多数の機能が提供されます:</p><table><thead><tr><th>機能</th><th>何を実現するか</th></tr></thead><tbody><tr><td>CRUD</td><td>新しいエンドポイントが、HTTP、<code>kubectl</code>を通じて、基本的なCRUD処理をサポート</td></tr><tr><td>Watch</td><td>新しいエンドポイントが、HTTPを通じて、KubernetesのWatch処理をサポート</td></tr><tr><td>Discovery</td><td><code>kubectl</code>やダッシュボードのようなクライアントが、自動的にリソースの一覧表示、個別表示、フィールドの編集処理を提供</td></tr><tr><td>json-patch</td><td>新しいエンドポイントが<code>Content-Type: application/json-patch+json</code>を用いたPATCHをサポート</td></tr><tr><td>merge-patch</td><td>新しいエンドポイントが<code>Content-Type: application/merge-patch+json</code>を用いたPATCHをサポート</td></tr><tr><td>HTTPS</td><td>新しいエンドポイントがHTTPSを利用</td></tr><tr><td>ビルトイン認証</td><td>拡張機能へのアクセスに認証のため、コアAPIサーバー(アグリゲーションレイヤー)を利用</td></tr><tr><td>ビルトイン認可</td><td>拡張機能へのアクセスにコアAPIサーバーで使われている認可メカニズムを再利用(例、RBAC)</td></tr><tr><td>ファイナライザー</td><td>外部リソースの削除が終わるまで、拡張リソースの削除をブロック</td></tr><tr><td>Admission Webhooks</td><td>拡張リソースの作成/更新/削除処理時に、デフォルト値の設定、バリデーションを実施</td></tr><tr><td>UI/CLI 表示</td><td>kubectl、ダッシュボードで拡張リソースを表示</td></tr><tr><td>未設定 対 空設定</td><td>クライアントは、フィールドの未設定とゼロ値を区別することができる</td></tr><tr><td>クライアントライブラリーの生成</td><td>Kubernetesは、一般的なクライアントライブラリーと、タイプ固有のクライアントライブラリーを生成するツールを提供</td></tr><tr><td>ラベルとアノテーション</td><td>ツールがコアリソースとカスタムリソースの編集方法を知っているオブジェクト間で、共通のメタデータを提供</td></tr></tbody></table><h2 id=カスタムリソースのインストール準備>カスタムリソースのインストール準備</h2><p>クラスターにカスタムリソースを追加する前に、いくつか認識しておくべき事項があります。</p><h3 id=サードパーティのコードと新しい障害点>サードパーティのコードと新しい障害点</h3><p>CRDを作成しても、勝手に新しい障害点が追加されてしまうことはありませんが(たとえば、サードパーティのコードをAPIサーバーで実行することによって)、パッケージ(たとえば、Chart)またはその他のインストールバンドルには、多くの場合、CRDと新しいカスタムリソースのビジネスロジックを実装するサードパーティコードが入ったDeploymentが含まれます。</p><p>アグリゲートAPIサーバーのインストールすると、常に新しいDeploymentが付いてきます。</p><h3 id=ストレージ>ストレージ</h3><p>カスタムリソースは、ConfigMapと同じ方法でストレージの容量を消費します。多数のカスタムリソースを作成すると、APIサーバーのストレージ容量を超えてしまうかもしれません。</p><p>アグリゲートAPIサーバーも、メインのAPIサーバーと同じストレージを利用するかもしれません。その場合、同じ問題が発生しえます。</p><h3 id=認証-認可-そして監査>認証、認可、そして監査</h3><p>CRDでは、APIサーバーのビルトインリソースと同じ認証、認可、そして監査ロギングの仕組みを利用します。</p><p>もしRBACを使っている場合、ほとんどのRBACのロールは新しいリソースへのアクセスを許可しません。(クラスター管理者ロール、もしくはワイルドカードで作成されたロールを除く)新しいリソースには、明示的にアクセスを許可する必要があります。多くの場合、CRDおよびアグリゲートAPIには、追加するタイプの新しいロール定義がバンドルされています。</p><p>アグリゲートAPIサーバーでは、APIサーバーのビルトインリソースと同じ認証、認可、そして監査の仕組みを使う場合と使わない場合があります。</p><h2 id=カスタムリソースへのアクセス>カスタムリソースへのアクセス</h2><p>Kubernetesの<a href=/docs/reference/using-api/client-libraries/>クライアントライブラリー</a>を使い、カスタムリソースにアクセスすることが可能です。全てのクライアントライブラリーがカスタムリソースをサポートしているわけでは無いですが、<em>Go</em> と <em>Python</em> のライブラリーはサポートしています。</p><p>カスタムリソースは、下記のような方法で操作できます:</p><ul><li><code>kubectl</code></li><li>kubernetesの動的クライアント</li><li>自作のRESTクライアント</li><li><a href=https://github.com/kubernetes/code-generator>Kubernetesクライアント生成ツール</a>を使い生成したクライアント(生成は高度な作業ですが、一部のプロジェクトは、CRDまたはAAとともにクライアントを提供する場合があります)</li></ul><h2 id=次の項目>次の項目</h2><ul><li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Kubernetes APIをアグリゲーションレイヤーで拡張する方法</a>について学ぶ</li><li><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>Kubernetes APIをCustomResourceDefinitionで拡張する方法</a>について学ぶ</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>2 - アグリゲーションレイヤーを使ったKubernetes APIの拡張</h1><p>アグリゲーションレイヤーを使用すると、KubernetesのコアAPIで提供されている機能を超えて、追加のAPIでKubernetesを拡張できます。追加のAPIは、<a href=/docs/concepts/extend-kubernetes/service-catalog/>service-catalog</a>のような既製のソリューション、または自分で開発したAPIのいずれかです。</p><p>アグリゲーションレイヤーは、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>とは異なり、<a class=glossary-tooltip title='Kubernetes APIを提供するコントロールプレーンのコンポーネントです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a>に新しい種類のオブジェクトを認識させる方法です。</p><h2 id=アグリゲーションレイヤー>アグリゲーションレイヤー</h2><p>アグリゲーションレイヤーは、kube-apiserverのプロセス内で動きます。拡張リソースが登録されるまでは、アグリゲーションレイヤーは何もしません。APIを登録するには、ユーザーはKubernetes APIで使われるURLのパスを"要求"した、<em>APIService</em> オブジェクトを追加します。それを追加すると、アグリゲーションレイヤーはAPIパス(例、<code>/apis/myextension.mycompany.io/v1/…</code>)への全てのアクセスを、登録されたAPIServiceにプロキシーします。</p><p>APIServiceを実装する最も一般的な方法は、クラスター内で実行されるPodで<em>拡張APIサーバー</em> を実行することです。クラスター内のリソース管理に拡張APIサーバーを使用している場合、拡張APIサーバー("extension-apiserver"とも呼ばれます)は通常、1つ以上の<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>とペアになっています。apiserver-builderライブラリは、拡張APIサーバーと関連するコントローラーの両方にスケルトンを提供します。</p><h3 id=応答遅延>応答遅延</h3><p>拡張APIサーバーは、kube-apiserverとの間の低遅延ネットワーキングが必要です。
kube-apiserverとの間を5秒以内に往復するためには、ディスカバリーリクエストが必要です。</p><p>拡張APIサーバーがそのレイテンシ要件を達成できない場合は、その要件を満たすように変更することを検討してください。また、kube-apiserverで<code>EnableAggregatedDiscoveryTimeout=false</code> <a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を設定することで、タイムアウト制限を無効にすることができます。この非推奨のフィーチャーゲートは将来のリリースで削除される予定です。</p><h2 id=次の項目>次の項目</h2><ul><li>アグリゲーターをあなたの環境で動かすには、まず<a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>アグリゲーションレイヤーを設定</a>します</li><li>そして、アグリゲーションレイヤーと一緒に動作させるために<a href=/docs/tasks/extend-kubernetes/setup-extension-api-server/>extension api-serverをセットアップ</a>します</li><li>また、<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>Custom Resource Definitionを使いKubernetes APIを拡張する</a>方法を学んで下さい</li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#apiservice-v1-apiregistration-k8s-io>APIService</a>の仕様をお読み下さい</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>