<!doctype html><html lang=ja class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/storage/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/storage/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/storage/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/storage/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/storage/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/storage/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/storage/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/storage/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/storage/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/storage/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>ストレージ | Kubernetes</title><meta property="og:title" content="ストレージ"><meta property="og:description" content="プロダクショングレードのコンテナ管理基盤"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/storage/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="ストレージ"><meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary"><meta name=twitter:title content="ストレージ"><meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/storage/"><meta property="og:title" content="ストレージ"><meta name=twitter:title content="ストレージ"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ja/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ja/docs/>ドキュメント</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/blog/>Blogs</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/training/>トレーニング</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/partners/>パートナー</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/community/>コミュニティ</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ja/case-studies/>ケーススタディ</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>バージョン</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ja/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/storage/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/storage/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/storage/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/concepts/storage/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ja/docs/concepts/storage/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>日本語 (Japanese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/storage/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/storage/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/storage/>한국어 (Korean)</a>
<a class=dropdown-item href=/fr/docs/concepts/storage/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/storage/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/storage/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/storage/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/storage/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/storage/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.</p><p><a href=/ja/docs/concepts/storage/>このページの通常のビューに戻る</a>.</p></div><h1 class=title>ストレージ</h1><ul><li>1: <a href=#pg-27795584640a03bd2024f1fe3b3ab754>ボリューム</a></li><li>2: <a href=#pg-ffd12528a12882b282e1bd19e29f9e75>永続ボリューム</a></li><li>3: <a href=#pg-2db414b26d4daec3ebed19dd837830c3>投影ボリューム</a></li><li>4: <a href=#pg-707ca81a34eb1ca202f34692e9917d1e>CSI Volume Cloning</a></li><li>5: <a href=#pg-4d00116c86dade62bdd5be7dc2afa1ca>VolumeSnapshotClass</a></li><li>6: <a href=#pg-018f0a7fc6e2f6d16da37702fc39b4f3>ボリュームの動的プロビジョニング(Dynamic Volume Provisioning)</a></li><li>7: <a href=#pg-00cd24f4570b7acaac75c2551c948bc7>ストレージ容量</a></li><li>8: <a href=#pg-4f40cb95a671e51b4f0156a409d95c6d>ボリュームヘルスモニタリング</a></li><li>9: <a href=#pg-b2e4b16ac37988c678a3312a4a6639f8>ノード固有のボリューム制限</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-27795584640a03bd2024f1fe3b3ab754>1 - ボリューム</h1><p>コンテナ内のディスク上のファイルは一時的なものであり、コンテナ内で実行する場合、重要なアプリケーションでいくつかの問題が発生します。1つの問題は、コンテナがクラッシュしたときにファイルが失われることです。kubeletはコンテナを再起動しますが、クリーンな状態です。
2番目の問題は、<code>Pod</code>で一緒に実行されているコンテナ間でファイルを共有するときに発生します。
Kubernetes<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>の抽象化は、これらの問題の両方を解決します。
<a href=/ja/docs/concepts/workloads/pods/>Pod</a>に精通していることをお勧めします。</p><h2 id=背景>背景</h2><p>Dockerには<a href=https://docs.docker.com/storage/>ボリューム</a>の概念がありますが、多少緩く、管理も不十分です。Dockerボリュームは、ディスク上または別のコンテナ内のディレクトリです。Dockerはボリュームドライバーを提供しますが、機能は多少制限されています。</p><p>Kubernetesは多くの種類のボリュームをサポートしています。
<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>は任意の数のボリュームタイプを同時に使用できます。
エフェメラルボリュームタイプにはPodの存続期間がありますが、永続ボリュームはPodの存続期間を超えて存在します。
Podが存在しなくなると、Kubernetesはエフェメラルボリュームを破棄します。ただしKubernetesは永続ボリュームを破棄しません。
特定のPod内のあらゆる種類のボリュームについて、データはコンテナの再起動後も保持されます。</p><p>コアとなるボリュームはディレクトリであり、Pod内のコンテナからアクセスできるデータが含まれている可能性があります。
ディレクトリがどのように作成されるか、それをバックアップするメディア、およびそのコンテンツは、使用する特定のボリュームタイプによって決まります。</p><p>ボリュームを使用するには、<code>.spec.volumes</code>でPodに提供するボリュームを指定し、<code>.spec.containers[*].volumeMounts</code>でそれらのボリュームをコンテナにマウントする場所を宣言します。
コンテナ内のプロセスは<a class=glossary-tooltip title=アプリケーションの実行に必要なソフトウェアのセットを持つ、保存されたコンテナの実体です。 data-toggle=tooltip data-placement=top href='/ja/docs/reference/glossary/?all=true#term-image' target=_blank aria-label=コンテナイメージ>コンテナイメージ</a>の初期コンテンツと、コンテナ内にマウントされたボリューム(定義されている場合)で構成されるファイルシステムビューを確認します。
プロセスは、コンテナイメージのコンテンツと最初に一致するルートファイルシステムを確認します。
そのファイルシステム階層内への書き込みは、もし許可されている場合、後続のファイルシステムアクセスを実行するときにそのプロセスが表示する内容に影響します。
ボリュームはイメージ内の<a href=#using-subpath>指定されたパス</a>へマウントされます。
Pod内で定義されたコンテナごとに、コンテナが使用する各ボリュームをマウントする場所を個別に指定する必要があります。</p><p>ボリュームは他のボリューム内にマウントできません(ただし、関連するメカニズムについては、<a href=#using-subpath>subPathの使用</a>を参照してください)。
またボリュームには、別のボリューム内の何かへのハードリンクを含めることはできません。</p><h2 id=volume-types>ボリュームの種類</h2><p>Kubernetesはいくつかのタイプのボリュームをサポートしています。</p><h3 id=awselasticblockstore>awsElasticBlockStore</h3><p><code>awsElasticBlockStore</code>ボリュームは、Amazon Web Services(AWS)<a href=https://aws.amazon.com/ebs/>EBSボリューム</a>をPodにマウントします。
Podを削除すると消去される<code>emptyDir</code>とは異なり、EBSボリュームのコンテンツは保持されたままボリュームはアンマウントされます。
これは、EBSボリュームにデータを事前入力でき、データをPod間で共有できることを意味します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用する前に、<code>aws ec2 create-volume</code>またはAWSAPIを使用してEBSボリュームを作成する必要があります。</div><p><code>awsElasticBlockStore</code>ボリュームを使用する場合、いくつかの制限があります。</p><ul><li>Podが実行されているノードはAWS EC2インスタンスである必要があります</li><li>これらのインスタンスは、EBSボリュームと同じリージョンおよびアベイラビリティーゾーンにある必要があります</li><li>EBSは、ボリュームをマウントする単一のEC2インスタンスのみをサポートします</li></ul><h4 id=aws-ebsボリュームの作成>AWS EBSボリュームの作成</h4><p>PodでEBSボリュームを使用する前に作成する必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>aws ec2 create-volume --availability-zone<span style=color:#666>=</span>eu-west-1a --size<span style=color:#666>=</span><span style=color:#666>10</span> --volume-type<span style=color:#666>=</span>gp2
</span></span></code></pre></div><p>ゾーンがクラスターを立ち上げたゾーンと一致していることを確認してください。サイズとEBSボリュームタイプが使用に適していることを確認してください。</p><h4 id=aws-ebs設定例>AWS EBS設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This AWS EBS volume must already exist.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>awsElasticBlockStore</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;volume id&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>EBSボリュームがパーティション化されている場合は、オプションのフィールド<code>partition: "&lt;partition number>"</code>を指定して、マウントするパーティションを指定できます。</p><h4 id=aws-ebs-csiの移行>AWS EBS CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p><code>awsElasticBlockStore</code>の<code>CSIMigration</code>機能を有効にすると、すべてのプラグイン操作が既存のツリー内プラグインから<code>ebs.csi.aws.com</code>Container Storage Interface(CSI)ドライバーにリダイレクトされます。
この機能を使用するには、<a href=https://github.com/kubernetes-sigs/aws-ebs-csi-driver>AWS EBS CSIドライバー</a>がクラスターにインストールされ、<code>CSIMigration</code>と<code>CSIMigrationAWS</code>のbeta機能が有効になっている必要があります。</p><h4 id=aws-ebs-csiの移行の完了>AWS EBS CSIの移行の完了</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code></div><p><code>awsElasticBlockStore</code>ストレージプラグインがコントローラーマネージャーとkubeletによって読み込まれないようにするには、<code>InTreePluginAWSUnregister</code>フラグを<code>true</code>に設定します。</p><h3 id=azuredisk>azureDisk</h3><p><code>azureDisk</code>ボリュームタイプは、MicrosoftAzure<a href=https://docs.microsoft.com/en-us/azure/aks/csi-storage-drivers>データディスク</a>をPodにマウントします。</p><p>詳細については、<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_disk/README.md><code>azureDisk</code>ボリュームプラグイン</a>を参照してください。</p><h4 id=azuredisk-csiの移行>azureDisk CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p><code>azureDisk</code>の<code>CSIMigration</code>機能を有効にすると、すべてのプラグイン操作が既存のツリー内プラグインから<code>disk.csi.azure.com</code>Container Storage Interface(CSI)ドライバーにリダイレクトされます。
この機能を利用するには、クラスターに<a href=https://github.com/kubernetes-sigs/azuredisk-csi-driver>Azure Disk CSI Driver</a>をインストールし、<code>CSIMigration</code>および<code>CSIMigrationAzureDisk</code>機能を有効化する必要があります。</p><h3 id=azurefile>azureFile</h3><p><code>azureFile</code>ボリュームタイプは、Microsoft Azureファイルボリューム(SMB 2.1および3.0)をPodにマウントします。</p><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_file/README.md><code>azureFile</code> volume plugin</a>を参照してください。</p><h4 id=azurefile-csiの移行>azureFile CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code></div><p><code>zureFile</code>の<code>CSIMigration</code>機能を有効にすると、既存のツリー内プラグインから<code>file.csi.azure.com</code>Container Storage Interface(CSI)Driverへすべてのプラグイン操作がリダイレクトされます。
この機能を利用するには、クラスターに<a href=https://github.com/kubernetes-sigs/azurefile-csi-driver>Azure File CSI Driver</a>をインストールし、<code>CSIMigration</code>および<code>CSIMigrationAzureFile</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効化する必要があります。</p><p>Azure File CSIドライバーは、異なるfsgroupで同じボリュームを使用することをサポートしていません。AzurefileCSIの移行が有効になっている場合、異なるfsgroupで同じボリュームを使用することはまったくサポートされません。</p><h3 id=cephfs>cephfs</h3><p><code>cephfs</code>ボリュームを使用すると、既存のCephFSボリュームをPodにマウントすることができます。
Podを取り外すと消去される<code>emptyDir</code>とは異なり、<code>cephfs</code>ボリュームは内容を保持したまま単にアンマウントされるだけです。
つまり<code>cephfs</code>ボリュームにあらかじめデータを入れておき、そのデータをPod間で共有することができます。
<code>cephfs</code>ボリュームは複数の書き込み元によって同時にマウントすることができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 事前に共有をエクスポートした状態で、自分のCephサーバーを起動しておく必要があります。</div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/volumes/cephfs/>CephFSの例</a>を参照してください。</p><h3 id=cinder>cinder</h3><div class="alert alert-info note callout" role=alert><strong>備考:</strong> KubernetesはOpenStackクラウドプロバイダーで構成する必要があります。</div><p><code>cinder</code>ボリュームタイプは、PodにOpenStackのCinderのボリュームをマウントするために使用されます。</p><h4 id=cinderボリュームの設定例>Cinderボリュームの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This OpenStack volume must already exist.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cinder</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;volume id&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=openstack-csiの移行>OpenStack CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code></div><p>Cinderの<code>CSIMigration</code>機能は、Kubernetes1.21ではデフォルトで有効になっています。
既存のツリー内プラグインからのすべてのプラグイン操作を<code>cinder.csi.openstack.org</code>Container Storage Interface(CSI) Driverへリダイレクトします。
<a href=https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/cinder-csi-plugin/using-cinder-csi-plugin.md>OpenStack Cinder CSIドライバー</a>をクラスターにインストールする必要があります。
<code>CSIMigrationOpenStack</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を<code>false</code>に設定すると、クラスターのCinder CSIマイグレーションを無効化することができます。
<code>CSIMigrationOpenStack</code>機能を無効にすると、ツリー内のCinderボリュームプラグインがCinderボリュームのストレージ管理のすべての側面に責任を持つようになります。</p><h3 id=configmap>configMap</h3><p><a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>は構成データをPodに挿入する方法を提供します。
ConfigMapに格納されたデータは、タイプ<code>configMap</code>のボリュームで参照され、Podで実行されているコンテナ化されたアプリケーションによって使用されます。</p><p>ConfigMapを参照するときは、ボリューム内のConfigMapの名前を指定します。
ConfigMapの特定のエントリに使用するパスをカスタマイズできます。
次の設定は、<code>log-config</code> ConfigMapを<code>configmap-pod</code>というPodにマウントする方法を示しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>log-config</code>ConfigMapはボリュームとしてマウントされ、その<code>log_level</code>エントリに格納されているすべてのコンテンツは、パス<code>/etc/config/log_level</code>のPodにマウントされます。
このパスはボリュームの<code>mountPath</code>と<code>log_level</code>をキーとする<code>path</code>から派生することに注意してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><ul><li><p>使用する前に<a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>を作成する必要があります。</p></li><li><p><a href=#using-subpath><code>subPath</code></a>ボリュームマウントとしてConfigMapを使用するコンテナはConfigMapの更新を受信しません。</p></li><li><p>テキストデータはUTF-8文字エンコードを使用してファイルとして公開されます。その他の文字エンコードには<code>binaryData</code>を使用します。</p></li></ul></div><h3 id=downwardapi>downwardAPI</h3><p><code>downwardAPI</code>ボリュームは、アプリケーションへのdownward APIデータを利用できるようになります。ディレクトリをマウントし、要求されたデータをプレーンテキストファイルに書き込みます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <a href=#using-subpath><code>subPath</code></a>ボリュームマウントとしてdownward APIを使用するコンテナは、downward APIの更新を受け取りません。</div><p>詳細については<a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>downward API example</a>を参照してください。</p><h3 id=emptydir>emptyDir</h3><p><code>emptyDir</code>ボリュームはPodがノードに割り当てられたときに最初に作成され、そのPodがそのノードで実行されている限り存在します。
名前が示すように<code>emptyDir</code>ボリュームは最初は空です。
Pod内のすべてのコンテナは<code>emptyDir</code>ボリューム内の同じファイルを読み書きできますが、そのボリュームは各コンテナで同じパスまたは異なるパスにマウントされることがあります。
何らかの理由でPodがノードから削除されると、<code>emptyDir</code>内のデータは永久に削除されます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> コンテナがクラッシュしても、ノードからPodが削除されることは<em>ありません</em>。<code>emptyDir</code>ボリューム内のデータは、コンテナのクラッシュしても安全です。</div><p><code>emptyDir</code>のいくつかの用途は次の通りです。</p><ul><li>ディスクベースのマージソートなどのスクラッチスペース</li><li>クラッシュからの回復のための長い計算のチェックポイント</li><li>Webサーバーコンテナがデータを提供している間にコンテンツマネージャコンテナがフェッチするファイルを保持する</li></ul><p>環境に応じて、<code>emptyDir</code>ボリュームは、ディスクやSSD、ネットワークストレージなど、ノードをバックアップするあらゆる媒体に保存されます。
ただし、<code>emptyDir.medium</code>フィールドを<code>"Memory"</code>に設定すると、Kubernetesは代わりにtmpfs(RAMベースのファイルシステム)をマウントします。
tmpfsは非常に高速ですが、ディスクと違ってノードのリブート時にクリアされ、書き込んだファイルはコンテナのメモリー制限にカウントされることに注意してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>SizeMemoryBackedVolumes</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>が有効な場合、メモリーバックアップボリュームにサイズを指定することができます。
サイズが指定されていない場合、メモリーでバックアップされたボリュームは、Linuxホストのメモリーの50％のサイズになります。</div><h4 id=emptydirの設定例>emptyDirの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/cache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=fc>fc (fibre channel)</h3><p><code>fc</code>ボリュームタイプを使用すると、既存のファイバーチャネルブロックストレージボリュームをPodにマウントできます。
<code>targetWWNs</code>ボリューム構成のパラメーターを使用して、単一または複数のターゲットWorld Wide Name(WWN)を指定できます。
複数のWWNが指定されている場合、targetWWNは、それらのWWNがマルチパス接続からのものであると想定します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Kubernetesホストがアクセスできるように、事前にこれらのLUN(ボリューム)をターゲットWWNに割り当ててマスクするようにFCSANゾーニングを構成する必要があります。</div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/fibre_channel>fibre channelの例</a>を参照してください。</p><h3 id=flocker>flocker (非推奨)</h3><p><a href=https://github.com/ClusterHQ/flocker>Flocker</a>はオープンソースのクラスター化されたコンテナデータボリュームマネージャーです。
Flockerは、さまざまなストレージバックエンドに支えられたデータボリュームの管理とオーケストレーションを提供します。</p><p><code>flocker</code>ボリュームを使用すると、FlockerデータセットをPodにマウントできます。
もしデータセットがまだFlockerに存在しない場合は、まずFlocker CLIかFlocker APIを使ってデータセットを作成する必要があります。
データセットがすでに存在する場合は、FlockerによってPodがスケジュールされているノードに再アタッチされます。
これは、必要に応じてPod間でデータを共有できることを意味します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用する前に、独自のFlockerインストールを実行する必要があります。</div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/flocker>Flocker example</a>を参照してください。</p><h3 id=gcepersistentdisk>gcePersistentDisk</h3><p><code>gcePersistentDisk</code>ボリュームは、Google Compute Engine (GCE)の<a href=https://cloud.google.com/compute/docs/disks>永続ディスク</a>(PD)をPodにマウントします。
Podを取り外すと消去される<code>emptyDir</code>とは異なり、PDの内容は保持されボリュームは単にアンマウントされるだけです。これはPDにあらかじめデータを入れておくことができ、そのデータをPod間で共有できることを意味します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>gcloud</code>を使用する前に、またはGCE APIまたはUIを使用してPDを作成する必要があります。</div><p><code>gcePersistentDisk</code>を使用する場合、いくつかの制限があります。</p><ul><li>Podが実行されているノードはGCE VMである必要があります</li><li>これらのVMは、永続ディスクと同じGCEプロジェクトおよびゾーンに存在する必要があります</li></ul><p>GCE永続ディスクの機能の1つは、永続ディスクへの同時読み取り専用アクセスです。<code>gcePersistentDisk</code>ボリュームを使用すると、複数のコンシューマーが永続ディスクを読み取り専用として同時にマウントできます。
これはPDにデータセットを事前入力してから、必要な数のPodから並行して提供できることを意味します。
残念ながらPDは読み取り/書き込みモードで1つのコンシューマーのみがマウントできます。同時書き込みは許可されていません。</p><p>PDが読み取り専用であるか、レプリカ数が0または1でない限り、ReplicaSetによって制御されるPodでGCE永続ディスクを使用すると失敗します。</p><h4 id=gce-create-persistent-disk>GCE永続ディスクの作成</h4><p>PodでGCE永続ディスクを使用する前に、それを作成する必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud compute disks create --size<span style=color:#666>=</span>500GB --zone<span style=color:#666>=</span>us-central1-a my-data-disk
</span></span></code></pre></div><h4 id=gce永続ディスクの設定例>GCE永続ディスクの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This GCE PD must already exist.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=リージョン永続ディスク>リージョン永続ディスク</h4><p><a href=https://cloud.google.com/compute/docs/disks/#repds>リージョン永続ディスク</a>機能を使用すると、同じリージョン内の2つのゾーンで使用できる永続ディスクを作成できます。
この機能を使用するには、ボリュームをPersistentVolumeとしてプロビジョニングする必要があります。Podから直接ボリュームを参照することはサポートされていません。</p><h4 id=リージョンpd-persistentvolumeを手動でプロビジョニングする>リージョンPD PersistentVolumeを手動でプロビジョニングする</h4><p><a href=/docs/concepts/storage/storage-classes/#gce-pd>GCE PDのStorageClass</a>を使用して動的プロビジョニングが可能です。
SPDPersistentVolumeを作成する前に、永続ディスクを作成する必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud compute disks create --size<span style=color:#666>=</span>500GB my-data-disk
</span></span><span style=display:flex><span>  --region us-central1
</span></span><span style=display:flex><span>  --replica-zones us-central1-a,us-central1-b
</span></span></code></pre></div><h4 id=リージョン永続ディスクの設定例>リージョン永続ディスクの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>400Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># failure-domain.beta.kubernetes.io/zone should be used prior to 1.21</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- us-central1-a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- us-central1-b<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=gce-csiの移行>GCE CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p>GCE PDの<code>CSIMigration</code>機能を有効にすると、すべてのプラグイン操作が既存のツリー内プラグインから<code>pd.csi.storage.gke.io</code>Container Storage Interface (CSI) Driverにリダイレクトされるようになります。
この機能を使用するには、クラスターに<a href=https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver>GCE PD CSI Driver</a>がインストールされ、<code>CSIMigration</code>と<code>CSIMigrationGCE</code>のbeta機能が有効になっている必要があります。</p><h4 id=gce-csiの移行の完了>GCE CSIの移行の完了</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code></div><p><code>gcePersistentDisk</code>ストレージプラグインがコントローラーマネージャーとkubeletによって読み込まれないようにするには、<code>InTreePluginGCEUnregister</code>フラグを<code>true</code>に設定します。</p><h3 id=gitrepo>gitRepo(非推奨)</h3><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> <code>gitRepo</code>ボリュームタイプは非推奨です。gitリポジトリを使用してコンテナをプロビジョニングするには、Gitを使用してリポジトリのクローンを作成するInitContainerに<a href=#emptydir>EmptyDir</a>をマウントしてから、Podのコンテナに<a href=#emptydir>EmptyDir</a>をマウントします。</div><p><code>gitRepo</code>ボリュームは、ボリュームプラグインの一例です。このプラグインは空のディレクトリをマウントし、そのディレクトリにgitリポジトリをクローンしてPodで使えるようにします。</p><p><code>gitRepo</code>ボリュームの例を次に示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mypath<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gitRepo</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>repository</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;git@somewhere:me/my-git-repository.git&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>revision</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;22f1d8406d464b0c0874075539c1f2e96c253775&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=glusterfs>glusterfs</h3><p><code>glusterfs</code>ボリュームは<a href=https://www.gluster.org>Glusterfs</a>(オープンソースのネットワークファイルシステム)ボリュームをPodにマウントできるようにするものです。
Podを取り外すと消去される<code>emptyDir</code>とは異なり、<code>glusterfs</code>ボリュームの内容は保持され、単にアンマウントされるだけです。
これは、glusterfsボリュームにデータを事前に入力でき、データをPod間で共有できることを意味します。
GlusterFSは複数のライターが同時にマウントすることができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> GlusterFSを使用するためには、事前にGlusterFSのインストールを実行しておく必要があります。</div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/volumes/glusterfs>GlusterFSの例</a>を参照してください。</p><h3 id=hostpath>hostPath</h3><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong><p>HostPathボリュームには多くのセキュリティリスクがあり、可能な場合はHostPathの使用を避けることがベストプラクティスです。HostPathボリュームを使用する必要がある場合は、必要なファイルまたはディレクトリのみにスコープを設定し、読み取り専用としてマウントする必要があります。</p><p>AdmissionPolicyによって特定のディレクトリへのHostPathアクセスを制限する場合、ポリシーを有効にするために<code>volumeMounts</code>は<code>readOnly</code>マウントを使用するように要求されなければなりません。</p></div><p><code>hostPath</code>ボリュームは、ファイルまたはディレクトリをホストノードのファイルシステムからPodにマウントします。
これはほとんどのPodに必要なものではありませんが、一部のアプリケーションには強力なエスケープハッチを提供します。</p><p>たとえば<code>hostPath</code>のいくつかの使用法は次のとおりです。</p><ul><li>Dockerの内部にアクセスする必要があるコンテナを実行する場合:<code>hostPath</code>に<code>/var/lib/docker</code>を使用します。</li><li>コンテナ内でcAdvisorを実行する場合:<code>hostPath</code>に<code>/sys</code>を指定します。</li><li>Podが実行される前に、与えられた<code>hostPath</code>が存在すべきかどうか、作成すべきかどうか、そして何として存在すべきかを指定できるようにします。</li></ul><p>必須の<code>path</code>プロパティに加えて、オプションで<code>hostPath</code>ボリュームに<code>type</code>を指定することができます。</p><p>フィールド<code>type</code>でサポートされている値は次のとおりです。</p><table><thead><tr><th style=text-align:left>値</th><th style=text-align:left>ふるまい</th></tr></thead><tbody><tr><td style=text-align:left></td><td style=text-align:left>空の文字列(デフォルト)は下位互換性のためです。つまり、hostPathボリュームをマウントする前にチェックは実行されません。</td></tr><tr><td style=text-align:left><code>DirectoryOrCreate</code></td><td style=text-align:left>指定されたパスに何も存在しない場合、必要に応じて、権限を0755に設定し、Kubeletと同じグループと所有権を持つ空のディレクトリが作成されます。</td></tr><tr><td style=text-align:left><code>Directory</code></td><td style=text-align:left>指定されたパスにディレクトリが存在する必要があります。</td></tr><tr><td style=text-align:left><code>FileOrCreate</code></td><td style=text-align:left>指定されたパスに何も存在しない場合、必要に応じて、権限を0644に設定し、Kubeletと同じグループと所有権を持つ空のファイルが作成されます。</td></tr><tr><td style=text-align:left><code>File</code></td><td style=text-align:left>指定されたパスにファイルが存在する必要があります。</td></tr><tr><td style=text-align:left><code>Socket</code></td><td style=text-align:left>UNIXソケットは、指定されたパスに存在する必要があります。</td></tr><tr><td style=text-align:left><code>CharDevice</code></td><td style=text-align:left>キャラクターデバイスは、指定されたパスに存在する必要があります。</td></tr><tr><td style=text-align:left><code>BlockDevice</code></td><td style=text-align:left>ブロックデバイスは、指定されたパスに存在する必要があります。</td></tr></tbody></table><p>このタイプのボリュームを使用するときは、以下の理由のため注意してください。</p><ul><li>HostPath は、特権的なシステム認証情報(Kubeletなど)や特権的なAPI(コンテナランタイムソケットなど)を公開する可能性があり、コンテナのエスケープやクラスターの他の部分への攻撃に利用される可能性があります。</li><li>同一構成のPod(PodTemplateから作成されたものなど)は、ノード上のファイルが異なるため、ノードごとに動作が異なる場合があります。</li><li>ホスト上に作成されたファイルやディレクトリは、rootでしか書き込みができません。<a href=/docs/tasks/configure-pod-container/security-context/>特権コンテナ</a>内でrootとしてプロセスを実行するか、ホスト上のファイルのパーミッションを変更して<code>hostPath</code>ボリュームに書き込みができるようにする必要があります。</li></ul><h4 id=hostpathの設定例>hostPathの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># directory location on host</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this field is optional</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Directory<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> <code>FileOrCreate</code>モードでは、ファイルの親ディレクトリは作成されません。マウントされたファイルの親ディレクトリが存在しない場合、Podは起動に失敗します。
このモードが確実に機能するようにするには、<a href=%EF%BC%83hostpath-fileorcreate-example><code>FileOrCreate</code>構成</a>に示すように、ディレクトリとファイルを別々にマウントしてみてください。</div><h4 id=hostpath-fileorcreate-example>hostPath FileOrCreateの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver:latest<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/local/aaa<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/local/aaa/1.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Ensure the file directory is created.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/local/aaa<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/local/aaa/1.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>FileOrCreate<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=iscsi>iscsi</h3><p><code>iscsi</code>ボリュームは、既存のiSCSI(SCSI over IP)ボリュームをPodにマウントすることができます。
Podを取り外すと消去される<code>emptyDir</code>とは異なり、<code>iscsi</code>ボリュームの内容は保持され、単にアンマウントされるだけです。
つまり、iscsiボリュームにはあらかじめデータを入れておくことができ、そのデータをPod間で共有することができるのです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用する前に、ボリュームを作成したiSCSIサーバーを起動する必要があります。</div><p>iSCSIの特徴として、複数のコンシューマーから同時に読み取り専用としてマウントできることが挙げられます。
つまり、ボリュームにあらかじめデータセットを入れておき、必要な数のPodから並行してデータを提供することができます。
残念ながら、iSCSIボリュームは1つのコンシューマによってのみ読み書きモードでマウントすることができます。
同時に書き込みを行うことはできません。</p><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/volumes/iscsi>iSCSIの例</a>を参照してください。</p><h3 id=local>local</h3><p><code>local</code>ボリュームは、ディスク、パーティション、ディレクトリなど、マウントされたローカルストレージデバイスを表します。</p><p>ローカルボリュームは静的に作成されたPersistentVolumeとしてのみ使用できます。動的プロビジョニングはサポートされていません。</p><p><code>hostPath</code>ボリュームと比較して、<code>local</code>ボリュームは手動でノードにPodをスケジューリングすることなく、耐久性と移植性に優れた方法で使用することができます。
システムはPersistentVolume上のノードアフィニティーを見ることで、ボリュームのノード制約を認識します。</p><p>ただし、<code>local</code>ボリュームは、基盤となるノードの可用性に左右されるため、すべてのアプリケーションに適しているわけではありません。
ノードが異常になると、Podは<code>local</code>ボリュームにアクセスできなくなります。
このボリュームを使用しているPodは実行できません。<code>local</code>ボリュームを使用するアプリケーションは、基盤となるディスクの耐久性の特性に応じて、この可用性の低下と潜在的なデータ損失に耐えられる必要があります。</p><p>次の例では、<code>local</code>ボリュームと<code>nodeAffinity</code>を使用したPersistentVolumeを示しています。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>100Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>local-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>local</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/mnt/disks/ssd1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/hostname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- example-node<span style=color:#bbb>
</span></span></span></code></pre></div><p>ローカルボリュームを使用する場合は、PersistentVolume <code>nodeAffinity</code>を設定する必要があります。
KubernetesのスケジューラはPersistentVolume <code>nodeAffinity</code>を使用して、これらのPodを正しいノードにスケジューリングします。</p><p>PersistentVolume <code>volumeMode</code>を(デフォルト値の「Filesystem」ではなく)「Block」に設定して、ローカルボリュームをrawブロックデバイスとして公開できます。</p><p>ローカルボリュームを使用する場合、<code>volumeBindingMode</code>を<code>WaitForFirstConsumer</code>に設定したStorageClassを作成することをお勧めします。
詳細については、local <a href=/docs/concepts/storage/storage-classes/#local>StorageClass</a>の例を参照してください。
ボリュームバインディングを遅延させると、PersistentVolumeClaimバインディングの決定が、ノードリソース要件、ノードセレクター、Podアフィニティ、Podアンチアフィニティなど、Podが持つ可能性のある他のノード制約も含めて評価されるようになります。</p><p>ローカルボリュームのライフサイクルの管理を改善するために、外部の静的プロビジョナーを個別に実行できます。
このプロビジョナーはまだ動的プロビジョニングをサポートしていないことに注意してください。
外部ローカルプロビジョナーの実行方法の例については、<a href=https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner>ローカルボリュームプロビジョナーユーザーガイド</a>を参照してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ボリュームのライフサイクルを管理するために外部の静的プロビジョナーが使用されていない場合、ローカルのPersistentVolumeは、ユーザーによる手動のクリーンアップと削除を必要とします。</div><h3 id=nfs>nfs</h3><p><code>nfs</code>ボリュームは、既存のNFS(Network File System)共有をPodにマウントすることを可能にします。Podを取り外すと消去される<code>emptyDir</code>とは異なり、<code>nfs</code>ボリュームのコンテンツは保存され、単にアンマウントされるだけです。
つまり、NFSボリュームにはあらかじめデータを入れておくことができ、そのデータをPod間で共有することができます。
NFSは複数のライターによって同時にマウントすることができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用する前に、共有をエクスポートしてNFSサーバーを実行する必要があります。</div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/nfs>NFSの例</a>を参照してください。</p><h3 id=persistentvolumeclaim>persistentVolumeClaim</h3><p><code>PersistentVolumeClaim</code>ボリュームは<a href=/ja/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>をPodにマウントするために使用されます。
PersistentVolumeClaimは、ユーザが特定のクラウド環境の詳細を知らなくても、耐久性のあるストレージ(GCE永続ディスクやiSCSIボリュームなど)を「要求」するための方法です。</p><p>詳細については<a href=/ja/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>を参照してください。</p><h3 id=portworxvolume>portworxVolume</h3><p><code>portworxVolume</code>は、Kubernetesとハイパーコンバージドで動作するエラスティックブロックストレージレイヤーです。
<a href=https://portworx.com/use-case/kubernetes-storage/>Portworx</a>は、サーバー内のストレージをフィンガープリントを作成し、機能に応じて階層化し、複数のサーバーにまたがって容量を集約します。
Portworxは、仮想マシンまたはベアメタルのLinuxノードでゲスト内動作します。</p><p><code>portworxVolume</code>はKubernetesを通して動的に作成することができますが、事前にプロビジョニングしてPodの中で参照することもできます。
以下は、事前にプロビジョニングされたPortworxボリュームを参照するPodの例です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-portworx-volume-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This Portworx volume must already exist.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>portworxVolume</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pxvol&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;fs-type&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Podで使用する前に、<code>pxvol</code>という名前の既存のPortworxVolumeがあることを確認してください。</div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/portworx/README.md>Portworxボリューム</a>の例を参照してください。</p><h3 id=投影>投影</h3><p>投影ボリュームは、複数の既存のボリュームソースを同じディレクトリにマッピングします。
詳細については<a href=/docs/concepts/storage/projected-volumes/>投影ボリューム</a>を参照してください。</p><h3 id=quobyte>quobyte(非推奨)</h3><p><code>quobyte</code>ボリュームは、既存の<a href=https://www.quobyte.com>Quobyte</a>ボリュームをPodにマウントすることができます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用する前にQuobyteをセットアップして、ボリュームを作成した状態で動作させる必要があります。</div><p>CSIは、Kubernetes内部でQuobyteボリュームを使用するための推奨プラグインです。
QuobyteのGitHubプロジェクトには、CSIを使用してQuobyteをデプロイするための<a href=https://github.com/quobyte/quobyte-csi#quobyte-csi>手順</a>と例があります</p><h3 id=rbd>rbd</h3><p><code>rbd</code>ボリュームは<a href=https://docs.ceph.com/en/latest/rbd/>Rados Block Device</a>(RBD)ボリュームをPodにマウントすることを可能にします。
Podを取り外すと消去される<code>emptyDir</code>とは異なり、<code>rbd</code>ボリュームの内容は保存され、ボリュームはアンマウントされます。つまり、RBDボリュームにはあらかじめデータを入れておくことができ、そのデータをPod間で共有することができるのです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> RBDを使用する前に、Cephのインストールが実行されている必要があります。</div><p>RBDの特徴として、複数のコンシューマーから同時に読み取り専用としてマウントできることが挙げられます。
つまり、ボリュームにあらかじめデータセットを入れておき、必要な数のPodから並行して提供することができるのです。
残念ながら、RBDボリュームは1つのコンシューマーによってのみ読み書きモードでマウントすることができます。
同時に書き込みを行うことはできません。</p><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/volumes/rbd>RBDの例</a>を参照してください。</p><h4 id=rbd-csi-migration>RBD CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code></div><p><code>RBD</code>の<code>CSIMigration</code>機能を有効にすると、既存のツリー内プラグインから<code>rbd.csi.ceph.com</code><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>ドライバーにすべてのプラグイン操作がリダイレクトされます。
この機能を使用するには、クラスターに<a href=https://github.com/ceph/ceph-csi>Ceph CSIドライバー</a>をインストールし、<code>CSIMigration</code>および<code>csiMigrationRBD</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にしておく必要があります。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>ストレージを管理するKubernetesクラスターオペレーターとして、RBD CSIドライバーへの移行を試みる前に完了する必要のある前提条件は次のとおりです。</p><ul><li>Ceph CSIドライバー(<code>rbd.csi.ceph.com</code>)v3.5.0以降をKubernetesクラスターにインストールする必要があります。</li><li>CSIドライバーの動作に必要なパラメーターとして<code>clusterID</code>フィールドがありますが、ツリー内StorageClassには<code>monitors</code>フィールドがあるため、Kubernetesストレージ管理者はCSI config mapでモニターハッシュ(例：<code>#echo -n '&lt;monitors_string>' | md5sum</code>)に基づいたclusterIDを作成し、モニターをこのclusterID設定の下に保持しなければなりません。</li><li>また、ツリー内Storageclassの<code>adminId</code>の値が<code>admin</code>と異なる場合、ツリー内Storageclassに記載されている<code>adminSecretName</code>に<code>adminId</code>パラメーター値のbase64値をパッチしなければなりませんが、それ以外はスキップすることが可能です。</li></ul></div><h3 id=secret>secret</h3><p><code>secret</code>ボリュームは、パスワードなどの機密情報をPodに渡すために使用します。
Kubernetes APIにsecretを格納し、Kubernetesに直接結合することなくPodが使用するファイルとしてマウントすることができます。
<code>secret</code>ボリュームはtmpfs(RAM-backed filesystem)によってバックアップされるため、不揮発性ストレージに書き込まれることはありません。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用する前にKubernetes APIでSecretを作成する必要があります。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <a href=#using-subpath><code>SubPath</code></a>ボリュームマウントとしてSecretを使用しているコンテナは、Secretの更新を受け取りません。</div><p>詳細については<a href=/ja/docs/concepts/configuration/secret/>Secretの設定</a>を参照してください。</p><h3 id=storageos>storageOS(非推奨)</h3><p><code>storageos</code>ボリュームを使用すると、既存の<a href=https://www.storageos.com>StorageOS</a>ボリュームをPodにマウントできます。</p><p>StorageOSは、Kubernetes環境内でコンテナとして実行され、Kubernetesクラスター内の任意のノードからローカルストレージまたは接続されたストレージにアクセスできるようにします。
データを複製してノードの障害から保護することができます。シンプロビジョニングと圧縮により使用率を向上させ、コストを削減できます。</p><p>根本的にStorageOSは、コンテナにブロックストレージを提供しファイルシステムからアクセスできるようにします。</p><p>StorageOS Containerは64ビットLinuxを必要とし、追加の依存関係はありません。
無償の開発者ライセンスが利用可能です。</p><div class="alert alert-warning caution callout" role=alert><strong>注意:</strong> StorageOSボリュームにアクセスする、またはプールにストレージ容量を提供する各ノードでStorageOSコンテナを実行する必要があります。
インストール手順については、<a href=https://docs.storageos.com>StorageOSドキュメント</a>を参照してください。</div><p>次の例は、StorageOSを使用したPodの設定です。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-storageos-redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>kubernetes/redis:v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MASTER<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/redis-master-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageos</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The `redis-vol01` volume must already exist within StorageOS in the `default` namespace.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>redis-vol01<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>StorageOS、動的プロビジョニング、およびPersistentVolumeClaimの詳細については、<a href=https://github.com/kubernetes/examples/blob/master/volumes/storageos>StorageOSの例</a>を参照してください。</p><h3 id=vspherevolume>vsphereVolume</h3><div class="alert alert-info note callout" role=alert><strong>備考:</strong> KubernetesvSphereクラウドプロバイダーを設定する必要があります。クラウドプロバイダーの設定については、<a href=https://vmware.github.io/vsphere-storage-for-kubernetes/documentation/>vSphere入門ガイド</a>を参照してください。</div><p><code>vsphereVolume</code>は、vSphereVMDKボリュームをPodにマウントするために使用されます。
ボリュームの内容は、マウント解除されたときに保持されます。VMFSとVSANの両方のデータストアをサポートします。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Podで使用する前に、次のいずれかの方法を使用してvSphereVMDKボリュームを作成する必要があります。</div><h4 id=creating-vmdk-volume>Creating a VMDK volume</h4><p>次のいずれかの方法を選択して、VMDKを作成します。</p><ul class="nav nav-tabs" id=tabs-volumes role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabs-volumes-0 role=tab aria-controls=tabs-volumes-0 aria-selected=true>vmkfstoolsを使用して作成する</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tabs-volumes-1 role=tab aria-controls=tabs-volumes-1>vmware-vdiskmanagerを使用して作成する</a></li></ul><div class=tab-content id=tabs-volumes><div id=tabs-volumes-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabs-volumes-0><p><p>最初にESXにSSHで接続し、次に以下のコマンドを使用してVMDKを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>vmkfstools -c 2G /vmfs/volumes/DatastoreName/volumes/myDisk.vmdk
</span></span></code></pre></div></div><div id=tabs-volumes-1 class=tab-pane role=tabpanel aria-labelledby=tabs-volumes-1><p><p>次のコマンドを使用してVMDKを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>vmware-vdiskmanager -c -t <span style=color:#666>0</span> -s 40GB -a lsilogic myDisk.vmdk
</span></span></code></pre></div></div></div><h4 id=vsphere-vmdk-configuration>vSphere VMDKの設定例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-vmdk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-vmdk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This VMDK volume must already exist.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>vsphereVolume</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumePath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;[DatastoreName] volumes/myDisk&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>詳細については<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere>vSphereボリューム</a>の例を参照してください。</p><h4 id=vsphere-csi-migration>vSphere CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p><code>vsphereVolume</code>の<code>CSIMigration</code>機能を有効にすると、既存のツリー内プラグインから<code>csi.vsphere.vmware.com</code><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>ドライバーにすべてのプラグイン操作がリダイレクトされます。
この機能を使用するには、クラスターに<a href=https://github.com/kubernetes-sigs/vsphere-csi-driver>vSphere CSIドライバー</a>がインストールされ、<code>CSIMigration</code>および<code>CSIMigrationvSphere</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>が有効になっていなければなりません。</p><p>また、vSphere vCenter/ESXiのバージョンが7.0u1以上、HWのバージョンがVM version 15以上であることが条件です。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>組み込みの<code>vsphereVolume</code>プラグインの次のStorageClassパラメーターは、vSphere CSIドライバーでサポートされていません。</p><ul><li><code>diskformat</code></li><li><code>hostfailurestotolerate</code></li><li><code>forceprovisioning</code></li><li><code>cachereservation</code></li><li><code>diskstripes</code></li><li><code>objectspacereservation</code></li><li><code>iopslimit</code></li></ul><p>これらのパラメーターを使用して作成された既存のボリュームはvSphere CSIドライバーに移行されますが、vSphere CSIドライバーで作成された新しいボリュームはこれらのパラメーターに従わないことに注意してください。</p></div><h4 id=vsphere-csi-migration-complete>vSphere CSIの移行の完了</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p><code>vsphereVolume</code>プラグインがコントローラーマネージャーとkubeletによって読み込まれないようにするには、<code>InTreePluginvSphereUnregister</code>機能フラグを<code>true</code>に設定する必要があります。すべてのワーカーノードに<code>csi.vsphere.vmware.com</code><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>ドライバーをインストールする必要があります。</p><h4 id=portworx-csiの移行>Portworx CSIの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code></div><p>Portworxの<code>CSIMigration</code>機能が追加されましたが、Kubernetes 1.23ではAlpha状態であるため、デフォルトで無効になっています。
すべてのプラグイン操作を既存のツリー内プラグインから<code>pxd.portworx.com</code>Container Storage Interface(CSI)ドライバーにリダイレクトします。
<a href=https://docs.portworx.com/portworx-install-with-kubernetes/storage-operations/csi/>Portworx CSIドライバー</a>をクラスターにインストールする必要があります。
この機能を有効にするには、kube-controller-managerとkubeletで<code>CSIMigrationPortworx=true</code>を設定します。</p><h2 id=using-subpath>subPathの使用</h2><p>1つのPodで複数の用途に使用するために1つのボリュームを共有すると便利な場合があります。
<code>volumeMounts.subPath</code>プロパティは、ルートではなく、参照されるボリューム内のサブパスを指定します。</p><p>次の例は、単一の共有ボリュームを使用してLAMPスタック(Linux Apache MySQL PHP)でPodを構成する方法を示しています。
このサンプルの<code>subPath</code>構成は、プロダクションでの使用にはお勧めしません。</p><p>PHPアプリケーションのコードとアセットはボリュームの<code>html</code>フォルダーにマップされ、MySQLデータベースはボリュームの<code>mysql</code>フォルダーに保存されます。例えば:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-lamp-site<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;rootpasswd&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>php:7.0-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/www/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>my-lamp-site-data<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=using-subpath-expanded-environment>拡張された環境変数でのsubPathの使用</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code></div><p><code>subPathExpr</code>フィールドを使用して、downwart API環境変数から<code>subPath</code>ディレクトリ名を作成します。
<code>subPath</code>プロパティと<code>subPathExpr</code>プロパティは相互に排他的です。</p><p>この例では、<code>Pod</code>が<code>subPathExpr</code>を使用して、<code>hostPath</code>ボリューム<code>/var/log/pods</code>内に<code>pod1</code>というディレクトリを作成します。
<code>hostPath</code>ボリュームは<code>downwardAPI</code>から<code>Pod</code>名を受け取ります。
ホストディレクトリ<code>/var/log/pods/pod1</code>は、コンテナ内の<code>/logs</code>にマウントされます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>POD_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while [ true ]; do echo &#39;Hello&#39;; sleep 10; done | tee -a /logs/hello.txt&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/logs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># The variable expansion uses round brackets (not curly brackets).</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>subPathExpr</span>:<span style=color:#bbb> </span>$(POD_NAME)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/pods<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=リソース>リソース</h2><p><code>emptyDir</code>ボリュームの記憶媒体(DiskやSSDなど)は、kubeletのルートディレクトリ(通常は<code>/var/lib/kubelet</code>)を保持するファイルシステムの媒体によって決定されます。
<code>emptyDir</code>または<code>hostPath</code>ボリュームが消費する容量に制限はなく、コンテナ間またはPod間で隔離されることもありません。</p><p>リソース仕様を使用したスペースの要求については、<a href=/ja/docs/concepts/configuration/manage-resources-containers/>リソースの管理方法</a>を参照してください。</p><h2 id=ツリー外のボリュームプラグイン>ツリー外のボリュームプラグイン</h2><p>ツリー外ボリュームプラグインには<a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label='Container Storage Interface'>Container Storage Interface</a>(CSI)、およびFlexVolume(非推奨)があります。
これらのプラグインによりストレージベンダーは、プラグインのソースコードをKubernetesリポジトリに追加することなく、カスタムストレージプラグインを作成することができます。</p><p>以前は、すべてのボリュームプラグインが「ツリー内」にありました。
「ツリー内」のプラグインは、Kubernetesのコアバイナリとともにビルド、リンク、コンパイルされ、出荷されていました。
つまり、Kubernetesに新しいストレージシステム(ボリュームプラグイン)を追加するには、Kubernetesのコアコードリポジトリにコードをチェックインする必要があったのです。</p><p>CSIとFlexVolumeはどちらも、ボリュームプラグインをKubernetesコードベースとは独立して開発し、拡張機能としてKubernetesクラスターにデプロイ(インストール)することを可能にします。</p><p>ツリー外のボリュームプラグインの作成を検討しているストレージベンダーについては、<a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md>ボリュームプラグインのFAQ</a>を参照してください。</p><h3 id=csi>csi</h3><p><a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>Container Storage Interface</a>(CSI)は、コンテナオーケストレーションシステム(Kubernetesなど)の標準インターフェイスを定義して、任意のストレージシステムをコンテナワークロードに公開します。</p><p>詳細については<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md>CSI design proposal</a>を参照してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> CSI仕様バージョン0.2および0.3のサポートは、Kubernetes v1.13で非推奨になり、将来のリリースで削除される予定です。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> CSIドライバーは、すべてのKubernetesリリース間で互換性があるとは限りません。各Kubernetesリリースでサポートされているデプロイ手順と互換性マトリックスについては、特定のCSIドライバーのドキュメントを確認してください。</div><p>CSI互換のボリュームドライバーがKubernetesクラスター上に展開されると、ユーザーは<code>csi</code>ボリュームタイプを使用して、CSIドライバーによって公開されたボリュームをアタッチまたはマウントすることができます。</p><p><code>csi</code>ボリュームはPodで3つの異なる方法によって使用することができます。</p><ul><li><a href=#persistentvolumeclaim>PersistentVolumeClaim</a>の参照を通して</li><li><a href=/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes>一般的なエフェメラルボリューム</a>(alpha機能)で</li><li>ドライバーがそれをサポートしている場合は、<a href=/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>CSIエフェメラルボリューム</a>(beta機能)を使って</li></ul><p>ストレージ管理者は、CSI永続ボリュームを構成するために次のフィールドを使用できます。</p><ul><li><code>driver</code>: 使用するボリュームドライバーの名前を指定する文字列。
この値は<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#getplugininfo>CSI spec</a>で定義されたCSIドライバーが<code>GetPluginInfoResponse</code>で返す値に対応していなければなりません。
これはKubernetesが呼び出すCSIドライバーを識別するために使用され、CSIドライバーコンポーネントがCSIドライバーに属するPVオブジェクトを識別するために使用されます。</li><li><code>volumeHandle</code>: ボリュームを一意に識別する文字列。この値は、<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>CSI spec</a>で定義されたCSIドライバーが<code>CreateVolumeResponse</code>の<code>volume.id</code>フィールドに返す値に対応していなければなりません。この値はCSIボリュームドライバーのすべての呼び出しで、ボリュームを参照する際に<code>volume_id</code>として渡されます。</li><li><code>readOnly</code>: ボリュームを読み取り専用として「ControllerPublished」(添付)するかどうかを示すオプションのブール値。デフォルトはfalseです。この値は、<code>ControllerPublishVolumeRequest</code>の<code>readonly</code>フィールドを介してCSIドライバーに渡されます。</li><li><code>fsType</code>: PVの<code>VolumeMode</code>が<code>Filesystem</code>の場合、このフィールドを使用して、ボリュームのマウントに使用する必要のあるファイルシステムを指定できます。ボリュームがフォーマットされておらず、フォーマットがサポートされている場合、この値はボリュームのフォーマットに使用されます。この値は、<code>ControllerPublishVolumeRequest</code>、<code>NodeStageVolumeRequest</code>、および<code>NodePublishVolumeRequest</code>の<code>VolumeCapability</code>フィールドを介してCSIドライバーに渡されます。</li><li><code>volumeAttributes</code>: ボリュームの静的プロパティを指定する、文字列から文字列へのマップ。このマップは、<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>CSI spec</a>で定義されているように、CSIドライバーが<code>CreateVolumeResponse</code>の<code>volume.attributes</code>フィールドで返すマップと一致しなければなりません。このマップは<code>ControllerPublishVolumeRequest</code>,<code>NodeStageVolumeRequest</code>,<code>NodePublishVolumeRequest</code>の<code>volume_context</code>フィールドを介してCSIドライバーに渡されます。</li><li><code>controllerPublishSecretRef</code>: CSI<code>ControllerPublishVolume</code>および<code>ControllerUnpublishVolume</code>呼び出しを完了するためにCSIドライバーに渡す機密情報を含むsecretオブジェクトへの参照。このフィールドはオプションで、secretが必要ない場合は空にすることができます。secretに複数のsecretが含まれている場合は、すべてのsecretが渡されます。</li><li><code>nodeStageSecretRef</code>: CSI<code>NodeStageVolume</code>呼び出しを完了するために、CSIドライバーに渡す機密情報を含むsecretオブジェクトへの参照。このフィールドはオプションで、secretが必要ない場合は空にすることができます。secretに複数のsecretが含まれている場合、すべてのsecretが渡されます。</li><li><code>nodePublishSecretRef</code>: CSI<code>NodePublishVolume</code>呼び出しを完了するために、CSIドライバーに渡す機密情報を含むsecretオブジェクトへの参照。このフィールドはオプションで、secretが必要ない場合は空にすることができます。secretオブジェクトが複数のsecretを含んでいる場合、すべてのsecretが渡されます。</li></ul><h4 id=csi-rawブロックボリュームのサポート>CSI rawブロックボリュームのサポート</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>外部のCSIドライバーを使用するベンダーは、Kubernetesワークロードでrawブロックボリュームサポートを実装できます。</p><p>CSI固有の変更を行うことなく、通常どおり、<a href=/docs/concepts/storage/persistent-volumes/#raw-block-volume-support>rawブロックボリュームをサポートするPersistentVolume/PersistentVolumeClaim</a>を設定できます。</p><h4 id=csiエフェメラルボリューム>CSIエフェメラルボリューム</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code></div><p>Pod仕様内でCSIボリュームを直接構成できます。この方法で指定されたボリュームは一時的なものであり、Podを再起動しても持続しません。詳細については<a href=/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>エフェメラルボリューム</a>を参照してください。</p><p>CSIドライバーの開発方法の詳細については<a href=https://kubernetes-csi.github.io/docs/>kubernetes-csiドキュメント</a>を参照してください。</p><h4 id=ツリー内プラグインからcsiドライバーへの移行>ツリー内プラグインからCSIドライバーへの移行</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p><code>CSIMigration</code>機能を有効にすると、既存のツリー内プラグインに対する操作が、対応するCSIプラグイン(インストールおよび構成されていることが期待されます)に転送されます。
その結果、オペレーターは、ツリー内プラグインに取って代わるCSIドライバーに移行するときに、既存のストレージクラス、PersistentVolume、またはPersistentVolumeClaim(ツリー内プラグインを参照)の構成を変更する必要がありません。</p><p>サポートされている操作と機能には、プロビジョニング/削除、アタッチ/デタッチ、マウント/アンマウント、およびボリュームのサイズ変更が含まれます。</p><p><code>CSIMigration</code>をサポートし、対応するCSIドライバーが実装されているツリー内プラグインは、<a href=%EF%BC%83volume-types>ボリュームのタイプ</a>にリストされています。</p><h3 id=flexvolume>flexVolume</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [deprecated]</code></div><p>FlexVolumeは、ストレージドライバーとのインターフェースにexecベースのモデルを使用するツリー外プラグインインターフェースです。FlexVolumeドライバーのバイナリは、各ノード、場合によってはコントロールプレーンノードにも、あらかじめ定義されたボリュームプラグインパスにインストールする必要があります。</p><p>Podは<code>flexVolume</code>ツリー内ボリュームプラグインを通してFlexVolumeドライバーと対話します。</p><p>詳細については<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md#readme>FlexVolumeのREADME</a>を参照してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>FlexVolumeは非推奨です。ツリー外のCSIドライバーを使用することは、外部ストレージをKubernetesと統合するための推奨される方法です。</p><p>FlexVolumeドライバーのメンテナーは、CSIドライバーを実装し、FlexVolumeドライバーのユーザーをCSIに移行するのを支援する必要があります。FlexVolumeのユーザーは、同等のCSIドライバーを使用するようにワークロードを移動する必要があります。</p></div><h2 id=マウントの伝播>マウントの伝播</h2><p>マウントの伝播により、コンテナによってマウントされたボリュームを、同じPod内の他のコンテナ、または同じノード上の他のPodに共有できます。</p><p>ボリュームのマウント伝播は、<code>Container.volumeMounts</code>の<code>mountPropagation</code>フィールドによって制御されます。その値は次のとおりです。</p><ul><li><p><code>None</code> - このボリュームマウントは、ホストによってこのボリュームまたはそのサブディレクトリにマウントされる後続のマウントを受け取りません。同様に、コンテナによって作成されたマウントはホストに表示されません。これがデフォルトのモードです。</p><p>このモードは<a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>Linuxカーネルドキュメント</a>で説明されている<code>private</code>マウント伝播と同じです。</p></li><li><p><code>HostToContainer</code> - このボリュームマウントは、このボリュームまたはそのサブディレクトリのいずれかにマウントされる後続のすべてのマウントを受け取ります。</p><p>つまりホストがボリュームマウント内に何かをマウントすると、コンテナはそこにマウントされていることを確認します。</p><p>同様に同じボリュームに対して<code>Bidirectional</code>マウント伝搬を持つPodが何かをマウントすると、<code>HostToContainer</code>マウント伝搬を持つコンテナはそれを見ることができます。</p><p>このモードは<a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>Linuxカーネルドキュメント</a>で説明されている<code>rslave</code>マウント伝播と同じです。</p></li><li><p><code>Bidirectional</code> - このボリュームマウントは、<code>HostToContainer</code>マウントと同じように動作します。さらに、コンテナによって作成されたすべてのボリュームマウントは、ホストと、同じボリュームを使用するすべてのPodのすべてのコンテナに伝播されます。</p><p>このモードの一般的な使用例は、FlexVolumeまたはCSIドライバーを備えたPod、または<code>hostPath</code>ボリュームを使用してホストに何かをマウントする必要があるPodです。</p><p>このモードは<a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>Linuxカーネルドキュメント</a>で説明されている<code>rshared</code>マウント伝播と同じです。</p><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> <code>Bidirectional</code>マウント伝搬は危険です。ホストオペレーティングシステムにダメージを与える可能性があるため、特権的なコンテナでのみ許可されています。
Linuxカーネルの動作に精通していることが強く推奨されます。
また、Pod内のコンテナによって作成されたボリュームマウントは、終了時にコンテナによって破棄(アンマウント)される必要があります。</div></li></ul><h3 id=構成>構成</h3><p>一部のデプロイメント(CoreOS、RedHat/Centos、Ubuntu)でマウント伝播が正しく機能する前に、以下に示すように、Dockerでマウント共有を正しく構成する必要があります。</p><p>Dockerの<code>systemd</code>サービスファイルを編集します。以下のように<code>MountFlags</code>を設定します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>MountFlags</span><span style=color:#666>=</span>shared
</span></span></code></pre></div><p>または、<code>MountFlags=slave</code>があれば削除してください。その後、Dockerデーモンを再起動します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart docker
</span></span></code></pre></div><h2 id=次の項目>次の項目</h2><p><a href=/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>永続ボリュームを使用してWordPressとMySQLをデプロイする例</a>に従ってください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ffd12528a12882b282e1bd19e29f9e75>2 - 永続ボリューム</h1><p>このドキュメントではKubernetesの <em>PersistentVolume</em> について説明します。<a href=/docs/concepts/storage/volumes/>ボリューム</a>を一読することをおすすめします。</p><h2 id=概要>概要</h2><p>ストレージを管理することはインスタンスを管理することとは全くの別物です。PersistentVolumeサブシステムは、ストレージが何から提供されているか、どのように消費されているかをユーザーと管理者から抽象化するAPIを提供します。これを実現するためのPersistentVolumeとPersistentVolumeClaimという2つの新しいAPIリソースを紹介します。</p><p><em>PersistentVolume</em> (PV)は<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>を使って管理者もしくは動的にプロビジョニングされるクラスターのストレージの一部です。これはNodeと同じようにクラスターリソースの一部です。PVはVolumeのようなボリュームプラグインですが、PVを使う個別のPodとは独立したライフサイクルを持っています。このAPIオブジェクトはNFS、iSCSIやクラウドプロバイダー固有のストレージシステムの実装の詳細を捕捉します。</p><p><em>PersistentVolumeClaim</em> (PVC)はユーザーによって要求されるストレージです。これはPodと似ています。PodはNodeリソースを消費し、PVCはPVリソースを消費します。Podは特定レベルのCPUとメモリーリソースを要求することができます。クレームは特定のサイズやアクセスモード(例えば、ReadWriteOnce、ReadOnlyMany、ReadWriteManyにマウントできます。詳しくは<a href=#access-modes>アクセスモード</a>を参照してください)を要求することができます。</p><p>PersistentVolumeClaimはユーザーに抽象化されたストレージリソースの消費を許可する一方、ユーザーは色々な問題に対処するためにパフォーマンスといった様々なプロパティを持ったPersistentVolumeを必要とすることは一般的なことです。クラスター管理者はユーザーに様々なボリュームがどのように実装されているかを表に出すことなく、サイズやアクセスモードだけではない色々な点で異なった、様々なPersistentVolumeを提供できる必要があります。これらのニーズに応えるために <em>StorageClass</em> リソースがあります。</p><p><a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/>実例を含む詳細なチュートリアル</a>を参照して下さい。</p><h2 id=ボリュームと要求のライフサイクル>ボリュームと要求のライフサイクル</h2><p>PVはクラスター内のリソースです。PVCはこれらのリソースの要求でありまた、クレームのチェックとしても機能します。PVとPVCの相互作用はこのライフサイクルに従います。</p><h3 id=プロビジョニング>プロビジョニング</h3><p>PVは静的か動的どちらかでプロビジョニングされます。</p><h4 id=静的>静的</h4><p>クラスター管理者は多数のPVを作成します。それらはクラスターのユーザーが使うことのできる実際のストレージの詳細を保持します。それらはKubernetes APIに存在し、利用できます。</p><h4 id=動的>動的</h4><p>ユーザーのPersistentVolumeClaimが管理者の作成したいずれの静的PVにも一致しない場合、クラスターはPVC用にボリュームを動的にプロビジョニングしようとする場合があります。
このプロビジョニングはStorageClassに基づいています。PVCは<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>の要求が必要であり、管理者は動的プロビジョニングを行うためにストレージクラスの作成・設定が必要です。ストレージクラスを""にしたストレージ要求は、自身の動的プロビジョニングを事実上無効にします。</p><p>ストレージクラスに基づいたストレージの動的プロビジョニングを有効化するには、クラスター管理者が<code>DefaultStorageClass</code><a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass>アドミッションコントローラー</a>をAPIサーバーで有効化する必要があります。
これは例えば、<code>DefaultStorageClass</code>がAPIサーバーコンポーネントの<code>--enable-admission-plugins</code>フラグのコンマ区切りの順序付きリストの中に含まれているかで確認できます。
APIサーバーのコマンドラインフラグの詳細については<a href=/docs/admin/kube-apiserver/>kube-apiserver</a>のドキュメントを参照してください。</p><h3 id=バインディング>バインディング</h3><p>ユーザは、特定のサイズのストレージとアクセスモードを指定した上でPersistentVolumeClaimを作成します（動的プロビジョニングの場合は、すでに作られています）。マスター内のコントロールループは、新しく作られるPVCをウォッチして、それにマッチするPVが見つかったときに、それらを紐付けます。PVが新しいPVC用に動的プロビジョニングされた場合、コントロールループは常にPVをそのPVCに紐付けます。そうでない場合、ユーザーは常に少なくとも要求したサイズ以上のボリュームを取得しますが、ボリュームは要求されたサイズを超えている可能性があります。一度紐付けされると、どのように紐付けられたかに関係なくPersistentVolumeClaimの紐付けは排他的（決められた特定のPVとしか結びつかない状態）になります。PVCからPVへの紐付けは、PersistentVolumeとPersistentVolumeClaim間の双方向の紐付けであるClaimRefを使用した1対1のマッピングになっています。</p><p>一致するボリュームが存在しない場合、クレームはいつまでも紐付けされないままになります。一致するボリュームが利用可能になると、クレームがバインドされます。たとえば、50GiのPVがいくつもプロビジョニングされているクラスターだとしても、100Giを要求するPVCとは一致しません。100GiのPVがクラスターに追加されると、PVCを紐付けできます。</p><h3 id=使用>使用</h3><p>Podは要求をボリュームとして使用します。クラスターは、要求を検査して紐付けられたボリュームを見つけそのボリュームをPodにマウントします。複数のアクセスモードをサポートするボリュームの場合、ユーザーはPodのボリュームとしてクレームを使う時にどのモードを希望するかを指定します。</p><p>ユーザーがクレームを取得し、そのクレームがバインドされると、バインドされたPVは必要な限りそのユーザーに属します。ユーザーはPodをスケジュールし、Podのvolumesブロックに<code>persistentVolumeClaim</code>を含めることで、バインドされたクレームのPVにアクセスします。
<a href=#claims-as-volumes>書式の詳細はこちらを確認して下さい。</a></p><h3 id=使用中のストレージオブジェクトの保護>使用中のストレージオブジェクトの保護</h3><p>使用中のストレージオブジェクト保護機能の目的はデータ損失を防ぐために、Podによって実際に使用されている永続ボリュームクレーム(PVC)と、PVCにバインドされている永続ボリューム(PV)がシステムから削除されないようにすることです。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> PVCを使用しているPodオブジェクトが存在する場合、PVCはPodによって実際に使用されています。</div><p>ユーザーがPodによって実際に使用されているPVCを削除しても、そのPVCはすぐには削除されません。PVCの削除は、PVCがPodで使用されなくなるまで延期されます。また、管理者がPVCに紐付けられているPVを削除しても、PVはすぐには削除されません。PVがPVCに紐付けられなくなるまで、PVの削除は延期されます。</p><p>PVCの削除が保護されているかは、PVCのステータスが<code>Terminating</code>になっていて、そして<code>Finalizers</code>のリストに<code>kubernetes.io/pvc-protection</code>が含まれているかで確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pvc hostpath
</span></span><span style=display:flex><span>Name:          hostpath
</span></span><span style=display:flex><span>Namespace:     default
</span></span><span style=display:flex><span>StorageClass:  example-hostpath
</span></span><span style=display:flex><span>Status:        Terminating
</span></span><span style=display:flex><span>Volume:
</span></span><span style=display:flex><span>Labels:        &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:   volume.beta.kubernetes.io/storage-class<span style=color:#666>=</span>example-hostpath
</span></span><span style=display:flex><span>               volume.beta.kubernetes.io/storage-provisioner<span style=color:#666>=</span>example.com/hostpath
</span></span><span style=display:flex><span>Finalizers:    <span style=color:#666>[</span>kubernetes.io/pvc-protection<span style=color:#666>]</span>
</span></span></code></pre></div><p>同様にPVの削除が保護されているかは、PVのステータスが<code>Terminating</code>になっていて、そして<code>Finalizers</code>のリストに<code>kubernetes.io/pv-protection</code>が含まれているかで確認できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pv task-pv-volume
</span></span><span style=display:flex><span>Name:            task-pv-volume
</span></span><span style=display:flex><span>Labels:          <span style=color:#b8860b>type</span><span style=color:#666>=</span><span style=color:#a2f>local</span>
</span></span><span style=display:flex><span>Annotations:     &lt;none&gt;
</span></span><span style=display:flex><span>Finalizers:      <span style=color:#666>[</span>kubernetes.io/pv-protection<span style=color:#666>]</span>
</span></span><span style=display:flex><span>StorageClass:    standard
</span></span><span style=display:flex><span>Status:          Terminating
</span></span><span style=display:flex><span>Claim:
</span></span><span style=display:flex><span>Reclaim Policy:  Delete
</span></span><span style=display:flex><span>Access Modes:    RWO
</span></span><span style=display:flex><span>Capacity:        1Gi
</span></span><span style=display:flex><span>Message:
</span></span><span style=display:flex><span>Source:
</span></span><span style=display:flex><span>    Type:          HostPath <span style=color:#666>(</span>bare host directory volume<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    Path:          /tmp/data
</span></span><span style=display:flex><span>    HostPathType:
</span></span><span style=display:flex><span>Events:            &lt;none&gt;
</span></span></code></pre></div><h3 id=再クレーム>再クレーム</h3><p>ユーザーは、ボリュームの使用が完了したら、リソースの再クレームを許可するAPIからPVCオブジェクトを削除できます。PersistentVolumeの再クレームポリシーはそのクレームが解放された後のボリュームの処理をクラスターに指示します。現在、ボリュームは保持、リサイクル、または削除できます。</p><h4 id=保持>保持</h4><p><code>Retain</code>という再クレームポリシーはリソースを手動で再クレームすることができます。PersistentVolumeClaimが削除される時、PersistentVolumeは依然として存在はしますが、ボリュームは解放済みです。ただし、以前のクレームデータはボリューム上に残っているため、別のクレームにはまだ使用できません。管理者は次の手順でボリュームを手動で再クレームできます。</p><ol><li>PersistentVolumeを削除します。PVが削除された後も、外部インフラストラクチャー(AWS EBS、GCE PD、Azure Disk、Cinderボリュームなど)に関連付けられたストレージアセットは依然として残ります。</li><li>ストレージアセットに関連するのデータを手動で適切にクリーンアップします。</li><li>関連するストレージアセットを手動で削除するか、同じストレージアセットを再利用したい場合、新しいストレージアセット定義と共にPersistentVolumeを作成します。</li></ol><h4 id=delete>削除</h4><p><code>Delete</code>再クレームポリシーをサポートするボリュームプラグインの場合、削除するとPersistentVolumeオブジェクトがKubernetesから削除されるだけでなく、AWS EBS、GCE PD、Azure Disk、Cinderボリュームなどの外部インフラストラクチャーの関連ストレージアセットも削除されます。動的にプロビジョニングされたボリュームは、<a href=#reclaim-policy>StorageClassの再クレームポリシー</a>を継承します。これはデフォルトで削除です。管理者は、ユーザーの需要に応じてStorageClassを構成する必要があります。そうでない場合、PVは作成後に編集またはパッチを適用する必要があります。<a href=/docs/tasks/administer-cluster/change-pv-reclaim-policy/>PersistentVolumeの再クレームポリシーの変更</a>を参照してください。</p><h4 id=リサイクル>リサイクル</h4><div class="alert alert-danger warning callout" role=alert><strong>警告:</strong> <code>Recycle</code>再クレームポリシーは非推奨になりました。代わりに、動的プロビジョニングを使用することをおすすめします。</div><p>基盤となるボリュームプラグインでサポートされている場合、<code>Recycle</code>再クレームポリシーはボリュームに対して基本的な削除(<code>rm -rf /thevolume/*</code>)を実行し、新しいクレームに対して再び利用できるようにします。</p><p>管理者は<a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>reference</a>で説明するように、Kubernetesコントローラーマネージャーのコマンドライン引数を使用して、カスタムリサイクラーPodテンプレートを構成できます。カスタムリサイクラーPodテンプレートには、次の例に示すように、<code>volumes</code>仕様が含まれている必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/any/path/it/will/be/replaced<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/busybox&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;test -e /scrub &amp;&amp; rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  &amp;&amp; test -z \&#34;$(ls -A /scrub)\&#34; || exit 1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/scrub<span style=color:#bbb>
</span></span></span></code></pre></div><p>ただし、カスタムリサイクラーPodテンプレートの<code>volumes</code>パート内で指定された特定のパスは、リサイクルされるボリュームの特定のパスに置き換えられます。</p><h3 id=永続ボリュームの予約>永続ボリュームの予約</h3><p>コントロールプレーンは、永続ボリュームクレームをクラスター内の一致する永続ボリュームに<a href=#%E3%83%90%E3%82%A4%E3%83%B3%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0>バインド</a>できます。
ただし、永続ボリュームクレームを特定の永続ボリュームにバインドする場合、それらを事前にバインドする必要があります。</p><p>永続ボリュームクレームで永続ボリュームを指定することにより、その特定の永続ボリュームと永続ボリュームクレームの間のバインディングを宣言します。
永続ボリュームが存在し、その<code>claimRef</code>フィールドで永続ボリュームクレームを予約していない場合に永続ボリュームと永続ボリュームクレームがバインドされます。</p><p>バインディングは、ノードアフィニティを含むいくつかのボリュームの一致基準に関係なく発生します。
コントロールプレーンは、依然として<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>、アクセスモード、および要求されたストレージサイズが有効であることをチェックします。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 空の文字列を明示的に指定する必要があります。そうしないとデフォルトのストレージクラスが設定されてしまいます。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>この方法は、永続ボリュームへのバインド特権を保証するものではありません。
他の永続ボリュームクレームが指定した永続ボリュームを使用できる場合、最初にそのストレージボリュームを予約する必要があります。
永続ボリュームの<code>claimRef</code>フィールドに関連する永続ボリュームクレームを指定して、他の永続ボリュームクレームがその永続ボリュームにバインドできないようにしてください。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>claimRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>これは、既存の永続ボリュームを再利用する場合など、<code>claimPolicy</code>が<code>Retain</code>に設定されている永続ボリュームを使用する場合に役立ちます。</p><h3 id=永続ボリュームクレームの拡大>永続ボリュームクレームの拡大</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>PersistentVolumeClaim(PVC)の拡大はデフォルトで有効です。次のボリュームの種類で拡大できます。</p><ul><li>gcePersistentDisk</li><li>awsElasticBlockStore</li><li>Cinder</li><li>glusterfs</li><li>rbd</li><li>Azure File</li><li>Azure Disk</li><li>Portworx</li><li>FlexVolumes</li><li>CSI</li></ul><p>そのストレージクラスの<code>allowVolumeExpansion</code>フィールドがtrueとなっている場合のみ、PVCを拡大できます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gluster-vol-default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://192.168.10.100:8080&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>PVCに対してさらに大きなボリュームを要求するには、PVCオブジェクトを編集してより大きなサイズを指定します。これによりPersistentVolumeを受け持つ基盤にボリュームの拡大がトリガーされます。クレームを満たすため新しくPersistentVolumeが作成されることはありません。代わりに既存のボリュームがリサイズされます。</p><h4 id=csiボリュームの拡張>CSIボリュームの拡張</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [stable]</code></div><p>CSIボリュームの拡張のサポートはデフォルトで有効になっていますが、ボリューム拡張をサポートするにはボリューム拡張を利用できるCSIドライバーも必要です。詳細については、それぞれのCSIドライバーのドキュメントを参照してください。</p><h4 id=ファイルシステムを含むボリュームのリサイズ>ファイルシステムを含むボリュームのリサイズ</h4><p>ファイルシステムがXFS、Ext3、またはExt4の場合にのみ、ファイルシステムを含むボリュームのサイズを変更できます。</p><p>ボリュームにファイルシステムが含まれる場合、新しいPodが<code>PersistentVolumeClaim</code>でReadWriteモードを使用している場合にのみ、ファイルシステムのサイズが変更されます。ファイルシステムの拡張は、Podの起動時、もしくはPodの実行時で基盤となるファイルシステムがオンラインの拡張をサポートする場合に行われます。</p><p>FlexVolumesでは、ドライバの<code>RequiresFSResize</code>機能がtrueに設定されている場合、サイズを変更できます。
FlexVolumeは、Podの再起動時にサイズ変更できます。</p><h4 id=使用中の永続ボリュームクレームのリサイズ>使用中の永続ボリュームクレームのリサイズ</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 使用中のPVCの拡張は、Kubernetes 1.15以降のベータ版と、1.11以降のアルファ版として利用可能です。<code>ExpandInUsePersistentVolume</code>機能を有効化する必要があります。これはベータ機能のため多くのクラスターで自動的に行われます。詳細については、<a href=/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>のドキュメントを参照してください。</div><p>この場合、既存のPVCを使用しているPodまたはDeploymentを削除して再作成する必要はありません。使用中のPVCは、ファイルシステムが拡張されるとすぐにPodで自動的に使用可能になります。この機能は、PodまたはDeploymentで使用されていないPVCには影響しません。拡張を完了する前に、PVCを使用するPodを作成する必要があります。</p><p>他のボリュームタイプと同様、FlexVolumeボリュームは、Podによって使用されている最中でも拡張できます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> FlexVolumeのリサイズは、基盤となるドライバーがリサイズをサポートしている場合のみ可能です。</div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> EBSの拡張は時間がかかる操作です。また変更は、ボリュームごとに6時間に1回までというクォータもあります。</div><h4 id=ボリューム拡張時の障害からの復旧>ボリューム拡張時の障害からの復旧</h4><p>基盤ストレージの拡張に失敗した際には、クラスターの管理者はPersistent Volume Claim (PVC)の状態を手動で復旧し、リサイズ要求をキャンセルします。それをしない限り、リサイズ要求は管理者の介入なしにコントローラーによって継続的に再試行されます。</p><ol><li>PersistentVolumeClaim(PVC)にバインドされているPersistentVolume(PV)を<code>Retain</code>再クレームポリシーとしてマークします。</li><li>PVCを削除します。PVは<code>Retain</code>再クレームポリシーを持っているため、PVCを再び作成したときにいかなるデータも失うことはありません。</li><li><code>claimRef</code>エントリーをPVスペックから削除して、新しいPVCがそれにバインドできるようにします。これによりPVは<code>Available</code>になります。</li><li>PVより小さいサイズでPVCを再作成し、PVCの<code>volumeName</code>フィールドをPVの名前に設定します。これにより新しいPVCを既存のPVにバインドします。</li><li>PVを再クレームポリシーを復旧することを忘れずに行ってください。</li></ol><h2 id=永続ボリュームの種類>永続ボリュームの種類</h2><p>PersistentVolumeの種類はプラグインとして実装されます。Kubernetesは現在次のプラグインに対応しています。</p><ul><li><a href=/docs/concepts/storage/volumes/#awselasticblockstore><code>awsElasticBlockStore</code></a> - AWS Elastic Block Store (EBS)</li><li><a href=/docs/concepts/storage/volumes/#azuredisk><code>azureDisk</code></a> - Azure Disk</li><li><a href=/docs/concepts/storage/volumes/#azurefile><code>azureFile</code></a> - Azure File</li><li><a href=/docs/concepts/storage/volumes/#cephfs><code>cephfs</code></a> - CephFS volume</li><li><a href=/docs/concepts/storage/volumes/#cinder><code>cinder</code></a> - Cinder (OpenStack block storage)
(<strong>非推奨</strong>)</li><li><a href=/docs/concepts/storage/volumes/#csi><code>csi</code></a> - Container Storage Interface (CSI)</li><li><a href=/docs/concepts/storage/volumes/#fc><code>fc</code></a> - Fibre Channel (FC) storage</li><li><a href=/docs/concepts/storage/volumes/#flexVolume><code>flexVolume</code></a> - FlexVolume</li><li><a href=/docs/concepts/storage/volumes/#flocker><code>flocker</code></a> - Flocker storage</li><li><a href=/docs/concepts/storage/volumes/#gcepersistentdisk><code>gcePersistentDisk</code></a> - GCE Persistent Disk</li><li><a href=/docs/concepts/storage/volumes/#glusterfs><code>glusterfs</code></a> - Glusterfs volume</li><li><a href=/docs/concepts/storage/volumes/#hostpath><code>hostPath</code></a> - HostPath volume
(テスト用の単一ノードのみ。マルチノードクラスターでは動作しません。代わりに<code>local</code>ボリュームを利用することを検討してください。)</li><li><a href=/docs/concepts/storage/volumes/#iscsi><code>iscsi</code></a> - iSCSI (SCSI over IP) storage</li><li><a href=/docs/concepts/storage/volumes/#local><code>local</code></a> - ノードにマウントされたローカルストレージデバイス</li><li><a href=/docs/concepts/storage/volumes/#nfs><code>nfs</code></a> - Network File System (NFS) storage</li><li><code>photonPersistentDisk</code> - Photon controller persistent disk
(対応するクラウドプロバイダーが削除されたため、このボリュームタイプは機能しなくなりました。)</li><li><a href=/docs/concepts/storage/volumes/#portworxvolume><code>portworxVolume</code></a> - Portworx volume</li><li><a href=/docs/concepts/storage/volumes/#quobyte><code>quobyte</code></a> - Quobyte volume</li><li><a href=/docs/concepts/storage/volumes/#rbd><code>rbd</code></a> - Rados Block Device (RBD) volume</li><li><a href=/docs/concepts/storage/volumes/#scaleio><code>scaleIO</code></a> - ScaleIO volume
(<strong>非推奨</strong>)</li><li><a href=/docs/concepts/storage/volumes/#storageos><code>storageos</code></a> - StorageOS volume</li><li><a href=/docs/concepts/storage/volumes/#vspherevolume><code>vsphereVolume</code></a> - vSphere VMDK volume</li></ul><h2 id=永続ボリューム>永続ボリューム</h2><p>各PVには、仕様とボリュームのステータスが含まれているspecとstatusが含まれています。
PersistentVolumeオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv0003<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Recycle<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- hard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- nfsvers=4.1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nfs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/tmp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.2</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> クラスター内でPersistentVolumeを使用するには、ボリュームタイプに関連するヘルパープログラムが必要な場合があります。
この例では、PersistentVolumeはNFSタイプで、NFSファイルシステムのマウントをサポートするためにヘルパープログラム<code>/sbin/mount.nfs</code>が必要になります。</div><h3 id=容量>容量</h3><p>通常、PVには特定のストレージ容量があります。これはPVの<code>capacity</code>属性を使用して設定されます。容量によって期待される単位を理解するためには、Kubernetesの<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>リソースモデル</a>を参照してください。</p><p>現在、設定または要求できるのはストレージサイズのみです。将来の属性には、IOPS、スループットなどが含まれます。</p><h3 id=ボリュームモード>ボリュームモード</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>KubernetesはPersistentVolumesの2つの<code>volumeModes</code>をサポートしています: <code>Filesystem</code>と<code>Block</code>です。<br><code>volumeMode</code>は任意のAPIパラメーターです。<br><code>Filesystem</code>は<code>volumeMode</code>パラメーターが省略されたときに使用されるデフォルトのモードです。</p><p><code>volumeMode: Filesystem</code>であるボリュームはPodに<em>マウント</em>されてディレクトリになります。 ボリュームがブロックデバイスでデバイスが空の時、Kubernetesは初めてそれにマウントされる前にデバイスのファイルシステムを作成します。</p><p><code>volumeMode</code>の値を<code>Block</code>に設定してボリュームをRAWブロックデバイスとして使用します。<br>このようなボリュームは、ファイルシステムを持たないブロックデバイスとしてPodに提示されます。<br>このモードは、Podとボリュームの間のファイルシステムレイヤなしにボリュームにアクセスする可能な限り最速の方法をPodに提供するのに便利です。一方で、Pod上で実行しているアプリケーションはRAWブロックデバイスの扱い方を知っていなければなりません。<br>Pod内で<code>volumeMode: Block</code>とともにボリュームを使用する例としては、<a href=#raw-block-volume-support>Raw Block Volume Support</a>を参照してください。</p><h3 id=アクセスモード>アクセスモード</h3><p>PersistentVolumeは、リソースプロバイダーがサポートする方法でホストにマウントできます。次の表に示すように、プロバイダーにはさまざまな機能があり、各PVのアクセスモードは、その特定のボリュームでサポートされる特定のモードに設定されます。たとえば、NFSは複数の読み取り/書き込みクライアントをサポートできますが、特定のNFSのPVはサーバー上で読み取り専用としてエクスポートされる場合があります。各PVは、その特定のPVの機能を記述する独自のアクセスモードのセットを取得します。</p><p>アクセスモードは次の通りです。</p><dl><dt><code>ReadWriteOnce</code></dt><dd>ボリュームは単一のNodeで読み取り/書き込みとしてマウントできます</dd><dt><code>ReadOnlyMany</code></dt><dd>ボリュームは多数のNodeで読み取り専用としてマウントできます</dd><dt><code>ReadWriteMany</code></dt><dd>ボリュームは多数のNodeで読み取り/書き込みとしてマウントできます</dd><dt><code>ReadWriteOncePod</code></dt><dd>ボリュームは、単一のPodで読み取り/書き込みとしてマウントできます。クラスタ全体で1つのPodのみがそのPVCの読み取りまたは書き込みを行えるようにする場合は、ReadWriteOncePodアクセスモードを使用します。これは、CSIボリュームとKubernetesバージョン1.22以降でのみサポートされます。</dd></dl><p>これについてはブログ<a href=/blog/2021/09/13/read-write-once-pod-access-mode-alpha/>Introducing Single Pod Access Mode for PersistentVolumes</a>に詳細が記載されています。</p><p>CLIではアクセスモードは次のように略されます。</p><ul><li>RWO - ReadWriteOnce</li><li>ROX - ReadOnlyMany</li><li>RWX - ReadWriteMany</li></ul><blockquote><p><strong>Important!</strong> ボリュームは、多数のモードをサポートしていても、一度に1つのアクセスモードでしかマウントできません。たとえば、GCEPersistentDiskは、単一NodeではReadWriteOnceとして、または多数のNodeではReadOnlyManyとしてマウントできますが、同時にマウントすることはできません。</p></blockquote><table><thead><tr><th style=text-align:left>ボリュームプラグイン</th><th style=text-align:center>ReadWriteOnce</th><th style=text-align:center>ReadOnlyMany</th><th style=text-align:center>ReadWriteMany</th></tr></thead><tbody><tr><td style=text-align:left>AWSElasticBlockStore</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>AzureFile</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>AzureDisk</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>CephFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>Cinder</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>CSI</td><td style=text-align:center>ドライバーに依存</td><td style=text-align:center>ドライバーに依存</td><td style=text-align:center>ドライバーに依存</td></tr><tr><td style=text-align:left>FC</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>FlexVolume</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>ドライバーに依存</td></tr><tr><td style=text-align:left>Flocker</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>GCEPersistentDisk</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Glusterfs</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>HostPath</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>iSCSI</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Quobyte</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>NFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>RBD</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>VsphereVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>- (Podが連結されている場合のみ)</td></tr><tr><td style=text-align:left>PortworxVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>ScaleIO</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>StorageOS</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr></tbody></table><h3 id=class>Class</h3><p>PVはクラスを持つことができます。これは<code>storageClassName</code>属性を<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>の名前に設定することで指定されます。特定のクラスのPVは、そのクラスを要求するPVCにのみバインドできます。<code>storageClassName</code>にクラスがないPVは、特定のクラスを要求しないPVCにのみバインドできます。</p><p>以前<code>volume.beta.kubernetes.io/storage-class</code>アノテーションは、<code>storageClassName</code>属性の代わりに使用されていました。このアノテーションはまだ機能しています。ただし、将来のKubernetesリリースでは完全に非推奨です。</p><h3 id=reclaim-policy>再クレームポリシー</h3><p>現在の再クレームポリシーは次のとおりです。</p><ul><li>保持 -- 手動再クレーム</li><li>リサイクル -- 基本的な削除 (<code>rm -rf /thevolume/*</code>)</li><li>削除 -- AWS EBS、GCE PD、Azure Disk、もしくはOpenStack Cinderボリュームに関連するストレージアセットを削除</li></ul><p>現在、NFSとHostPathのみがリサイクルをサポートしています。AWS EBS、GCE PD、Azure Disk、およびCinder volumeは削除をサポートしています。</p><h3 id=マウントオプション>マウントオプション</h3><p>Kubernetes管理者は永続ボリュームがNodeにマウントされるときの追加マウントオプションを指定できます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> すべての永続ボリュームタイプがすべてのマウントオプションをサポートするわけではありません。</div><p>次のボリュームタイプがマウントオプションをサポートしています。</p><ul><li>AWSElasticBlockStore</li><li>AzureDisk</li><li>AzureFile</li><li>CephFS</li><li>Cinder (OpenStackブロックストレージ)</li><li>GCEPersistentDisk</li><li>Glusterfs</li><li>NFS</li><li>Quobyte Volumes</li><li>RBD (Ceph Block Device)</li><li>StorageOS</li><li>VsphereVolume</li><li>iSCSI</li></ul><p>マウントオプションは検証されないため、不正だった場合マウントは失敗します。</p><p>以前<code>volume.beta.kubernetes.io/mount-options</code>アノテーションが<code>mountOptions</code>属性の代わりに使われていました。このアノテーションはまだ機能しています。ただし、将来のKubernetesリリースでは完全に非推奨です。</p><h3 id=ノードアフィニティ>ノードアフィニティ</h3><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ほとんどのボリュームタイプはこのフィールドを設定する必要がありません。<a href=/docs/concepts/storage/volumes/#awselasticblockstore>AWS EBS</a>、<a href=/docs/concepts/storage/volumes/#gcepersistentdisk>GCE PD</a>、もしくは<a href=/docs/concepts/storage/volumes/#azuredisk>Azure Disk</a>ボリュームブロックタイプの場合自動的に設定されます。<a href=/docs/concepts/storage/volumes/#local>local</a>ボリュームは明示的に設定する必要があります。</div><p>PVは<a href=/docs/reference/generated/kubernetes-api/v1.25/#volumenodeaffinity-v1-core>ノードアフィニティ</a>を指定して、このボリュームにアクセスできるNodeを制限する制約を定義できます。PVを使用するPodは、ノードアフィニティによって選択されたNodeにのみスケジュールされます。</p><h3 id=フェーズ>フェーズ</h3><p>ボリュームは次のフェーズのいずれかです。</p><ul><li>利用可能 -- まだクレームに紐付いていない自由なリソース</li><li>バウンド -- クレームに紐付いている</li><li>リリース済み -- クレームが削除されたが、クラスターにまだクレームされている</li><li>失敗 -- 自動再クレームに失敗</li></ul><p>CLIにはPVに紐付いているPVCの名前が表示されます。</p><h2 id=persistentvolumeclaims>永続ボリューム要求</h2><p>各PVCにはspecとステータスが含まれます。これは、仕様とクレームのステータスです。</p><p>PersistentVolumeClaimオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>8Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>release</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- {<span style=color:green;font-weight:700>key: environment, operator: In, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=アクセスモード-1>アクセスモード</h3><p>クレームは、特定のアクセスモードでストレージを要求するときにボリュームと同じ規則を使用します。</p><h3 id=ボリュームモード-1>ボリュームモード</h3><p>クレームは、ボリュームと同じ規則を使用して、ファイルシステムまたはブロックデバイスとしてのボリュームの消費を示します。</p><h3 id=リソース>リソース</h3><p>Podと同様に、クレームは特定の量のリソースを要求できます。この場合、要求はストレージ用です。同じ<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>リソースモデル</a>がボリュームとクレームの両方に適用されます。</p><h3 id=セレクター>セレクター</h3><p>クレームでは、<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルセレクター</a>を指定して、ボリュームセットをさらにフィルター処理できます。ラベルがセレクターに一致するボリュームのみがクレームにバインドできます。セレクターは2つのフィールドで構成できます。</p><ul><li><code>matchLabels</code> - ボリュームはこの値のラベルが必要です</li><li><code>matchExpressions</code> - キー、値のリスト、およびキーと値を関連付ける演算子を指定することによって作成された要件のリスト。有効な演算子は、In、NotIn、ExistsおよびDoesNotExistです。</li></ul><p><code>matchLabels</code>と<code>matchExpressions</code>の両方からのすべての要件はANDで結合されます。一致するには、すべてが一致する必要があります。</p><h3 id=クラス>クラス</h3><p>クレームは、<code>storageClassName</code>属性を使用して<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>の名前を指定することにより、特定のクラスを要求できます。PVCにバインドできるのは、PVCと同じ<code>storageClassName</code>を持つ、要求されたクラスのPVのみです。</p><p>PVCは必ずしもクラスをリクエストする必要はありません。<code>storageClassName</code>が<code>""</code>に設定されているPVCは、クラスのないPVを要求していると常に解釈されるため、クラスのないPVにのみバインドできます（アノテーションがないか、<code>""</code>に等しい1つのセット）。<code>storageClassName</code>のないPVCはまったく同じではなく、<a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code>アドミッションプラグイン</a>がオンになっているかどうかによって、クラスターによって異なる方法で処理されます。</p><ul><li>アドミッションプラグインがオンになっている場合、管理者はデフォルトの<code>StorageClass</code>を指定できます。<code>storageClassName</code>を持たないすべてのPVCは、そのデフォルトのPVにのみバインドできます。デフォルトの<code>StorageClass</code>の指定は、<code>StorageClass</code>オブジェクトで<code>storageclass.kubernetes.io/is-default-class</code>アノテーションを<code>true</code>に設定することにより行われます。管理者がデフォルトを指定しない場合、クラスターは、アドミッションプラグインがオフになっているかのようにPVC作成をレスポンスします。複数のデフォルトが指定されている場合、アドミッションプラグインはすべてのPVCの作成を禁止します。</li><li>アドミッションプラグインがオフになっている場合、デフォルトの<code>StorageClass</code>の概念はありません。<code>storageClassName</code>を持たないすべてのPVCは、クラスを持たないPVにのみバインドできます。この場合、storageClassNameを持たないPVCは、<code>storageClassName</code>が<code>""</code>に設定されているPVCと同じように扱われます。</li></ul><p>インストール方法によっては、インストール時にアドオンマネージャーによってデフォルトのストレージクラスがKubernetesクラスターにデプロイされる場合があります。</p><p>PVCが<code>selector</code>を要求することに加えて<code>StorageClass</code>を指定する場合、要件はANDで一緒に結合されます。要求されたクラスのPVと要求されたラベルのみがPVCにバインドされます。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 現在、<code>selector</code>が空ではないPVCは、PVを動的にプロビジョニングできません。</div><p>以前は、<code>storageClassName</code>属性の代わりに<code>volume.beta.kubernetes.io/storage-class</code>アノテーションが使用されていました。このアノテーションはまだ機能しています。ただし、今後のKubernetesリリースではサポートされません。</p><h2 id=ボリュームとしてのクレーム>ボリュームとしてのクレーム</h2><p>Podは、クレームをボリュームとして使用してストレージにアクセスします。クレームは、そのクレームを使用するPodと同じ名前空間に存在する必要があります。クラスターは、Podの名前空間でクレームを見つけ、それを使用してクレームを支援しているPersistentVolumeを取得します。次に、ボリュームがホストとPodにマウントされます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfrontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/www/html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=名前空間に関する注意>名前空間に関する注意</h3><p>PersistentVolumeバインドは排他的であり、PersistentVolumeClaimは名前空間オブジェクトであるため、"多"モード(<code>ROX</code>、<code>RWX</code>)でクレームをマウントすることは1つの名前空間内でのみ可能です。</p><h2 id=rawブロックボリュームのサポート>Rawブロックボリュームのサポート</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>次のボリュームプラグインは、必要に応じて動的プロビジョニングを含むrawブロックボリュームをサポートします。</p><ul><li>AWSElasticBlockStore</li><li>AzureDisk</li><li>CSI</li><li>FC (Fibre Channel)</li><li>GCEPersistentDisk</li><li>iSCSI</li><li>Local volume</li><li>OpenStack Cinder</li><li>RBD (Ceph Block Device)</li><li>VsphereVolume</li></ul><h3 id=persistent-volume-using-a-raw-block-volume>Rawブロックボリュームを使用した永続ボリューム</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fc</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetWWNs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;50060e801049cfd1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lun</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=rawブロックボリュームを要求する永続ボリュームクレーム>Rawブロックボリュームを要求する永続ボリュームクレーム</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=コンテナにrawブロックデバイスパスを追加するpod仕様>コンテナにRawブロックデバイスパスを追加するPod仕様</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-block-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fc-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:26<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;tail -f /dev/null&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeDevices</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>devicePath</span>:<span style=color:#bbb> </span>/dev/xvda<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> Podにrawブロックデバイスを追加する場合は、マウントパスの代わりにコンテナーでデバイスパスを指定します。</div><h3 id=ブロックボリュームのバインド>ブロックボリュームのバインド</h3><p>ユーザーがPersistentVolumeClaim specの<code>volumeMode</code>フィールドを使用してrawブロックボリュームの要求を示す場合、バインディングルールは、このモードをspecの一部として考慮しなかった以前のリリースとわずかに異なります。表にリストされているのは、ユーザーと管理者がrawブロックデバイスを要求するために指定可能な組み合わせの表です。この表は、ボリュームがバインドされるか、組み合わせが与えられないかを示します。静的にプロビジョニングされたボリュームのボリュームバインディングマトリクスはこちらです。</p><table><thead><tr><th>PVボリュームモード</th><th style=text-align:center>PVCボリュームモード</th><th style=text-align:right>結果</th></tr></thead><tbody><tr><td>未定義</td><td style=text-align:center>未定義</td><td style=text-align:right>バインド</td></tr><tr><td>未定義</td><td style=text-align:center>ブロック</td><td style=text-align:right>バインドなし</td></tr><tr><td>未定義</td><td style=text-align:center>ファイルシステム</td><td style=text-align:right>バインド</td></tr><tr><td>ブロック</td><td style=text-align:center>未定義</td><td style=text-align:right>バインドなし</td></tr><tr><td>ブロック</td><td style=text-align:center>ブロック</td><td style=text-align:right>バインド</td></tr><tr><td>ブロック</td><td style=text-align:center>ファイルシステム</td><td style=text-align:right>バインドなし</td></tr><tr><td>ファイルシステム</td><td style=text-align:center>ファイルシステム</td><td style=text-align:right>バインド</td></tr><tr><td>ファイルシステム</td><td style=text-align:center>ブロック</td><td style=text-align:right>バインドなし</td></tr><tr><td>ファイルシステム</td><td style=text-align:center>未定義</td><td style=text-align:right>バインド</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>備考:</strong> アルファリリースでは、静的にプロビジョニングされたボリュームのみがサポートされます。管理者は、rawブロックデバイスを使用する場合、これらの値を考慮するように注意する必要があります。</div><h2 id=ボリュームのスナップショットとスナップショットからのボリュームの復元のサポート>ボリュームのスナップショットとスナップショットからのボリュームの復元のサポート</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p>ボリュームスナップショット機能は、CSIボリュームプラグインのみをサポートするために追加されました。詳細については、<a href=/docs/concepts/storage/volume-snapshots/>ボリュームのスナップショット</a>を参照してください。</p><p>ボリュームスナップショットのデータソースからボリュームを復元する機能を有効にするには、apiserverおよびcontroller-managerで<code>VolumeSnapshotDataSource</code>フィーチャーゲートを有効にします。</p><h3 id=create-persistent-volume-claim-from-volume-snapshot>ボリュームスナップショットから永続ボリュームクレームを作成する</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>restore-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>csi-hostpath-sc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=ボリュームの複製>ボリュームの複製</h2><p><a href=/ja/docs/concepts/storage/volume-pvc-datasource/>ボリュームの複製</a>はCSIボリュームプラグインにのみ利用可能です。</p><p>PVCデータソースからのボリューム複製機能を有効にするには、apiserverおよびcontroller-managerで<code>VolumeSnapshotDataSource</code>フィーチャーゲートを有効にします。</p><h3 id=create-persistent-volume-claim-from-an-existing-pvc>既存のPVCからの永続ボリュームクレーム作成</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloned-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>my-csi-plugin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>existing-src-pvc-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=可搬性の高い設定の作成>可搬性の高い設定の作成</h2><p>もし幅広いクラスターで実行され、永続ボリュームが必要となる構成テンプレートやサンプルを作成している場合は、次のパターンを使用することをお勧めします。</p><ul><li><p>構成にPersistentVolumeClaimオブジェクトを含める(DeploymentやConfigMapと共に)</p></li><li><p>ユーザーが設定をインスタンス化する際にPersistentVolumeを作成する権限がない場合があるため、設定にPersistentVolumeオブジェクトを含めない。</p></li><li><p>テンプレートをインスタンス化する時にストレージクラス名を指定する選択肢をユーザーに与える</p><ul><li>ユーザーがストレージクラス名を指定する場合、persistentVolumeClaim.storageClassName フィールドにその値を入力する。これにより、クラスターが管理者によって有効にされたストレージクラスを持っている場合、PVCは正しいストレージクラスと一致する。</li><li>ユーザーがストレージクラス名を指定しない場合、<code>persistentVolumeClaim.storageClassName</code>フィールドはnilのままにする。これにより、PVはユーザーにクラスターのデフォルトストレージクラスで自動的にプロビジョニングされる。多くのクラスター環境ではデフォルトのストレージクラスがインストールされているが、管理者は独自のデフォルトストレージクラスを作成することができる。</li></ul></li><li><p>ツールがPVCを監視し、しばらくしてもバインドされないことをユーザーに表示する。これはクラスターが動的ストレージをサポートしない(この場合ユーザーは対応するPVを作成するべき)、もしくはクラスターがストレージシステムを持っていない(この場合ユーザーはPVCを必要とする設定をデプロイできない)可能性があることを示す。</p><h2 id=次の項目>次の項目</h2></li></ul><ul><li><a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume>Creating a Persistent Volume</a>について学ぶ</li><li><a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolumeclaim>Creating a Persistent Volume Claim</a>について学ぶ</li><li><a href=https://git.k8s.io/design-proposals-archive/storage/persistent-storage.md>Persistent Storage design document</a>を読む</li></ul><h3 id=リファレンス>リファレンス</h3><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolume-v1-core>PersistentVolume</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumespec-v1-core>PersistentVolumeSpec</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumeclaim-v1-core>PersistentVolumeClaim</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumeclaimspec-v1-core>PersistentVolumeClaimSpec</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2db414b26d4daec3ebed19dd837830c3>3 - 投影ボリューム</h1><p>このドキュメントでは、Kubernetesの<em>投影ボリューム</em>について説明します。<a href=/docs/concepts/storage/volumes/>ボリューム</a>に精通していることをお勧めします。</p><h2 id=概要>概要</h2><p>ボリュームは、いくつかの既存の<code>投影</code>ボリュームソースを同じディレクトリにマップします。</p><p>現在、次のタイプのボリュームソースを投影できます。</p><ul><li><a href=/docs/concepts/storage/volumes/#secret><code>secret</code></a></li><li><a href=/docs/concepts/storage/volumes/#downwardapi><code>downwardAPI</code></a></li><li><a href=/docs/concepts/storage/volumes/#configmap><code>configMap</code></a></li><li><code>serviceAccountToken</code></li></ul><p>すべてのソースは、Podと同じnamespaceにある必要があります。詳細は<a href=https://github.com/kubernetes/design-proposals-archive/blob/main/node/all-in-one-volume.md>all-in-one volume</a>デザインドキュメントを参照してください。</p><h3 id=example-configuration-secret-downwardapi-configmap>secret、downwardAPI、およびconfigMapを使用した構成例</h3><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/storage/projected-secret-downwardapi-configmap.yaml download=pods/storage/projected-secret-downwardapi-configmap.yaml><code>pods/storage/projected-secret-downwardapi-configmap.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-secret-downwardapi-configmap-yaml")' title="Copy pods/storage/projected-secret-downwardapi-configmap.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-secret-downwardapi-configmap-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>volume-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;labels&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.labels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;cpu_limit&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-config<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h3 id=example-configuration-secrets-nondefault-permission-mode>構成例:デフォルト以外のアクセス許可モードが設定されたsecret</h3><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/storage/projected-secrets-nondefault-permission-mode.yaml download=pods/storage/projected-secrets-nondefault-permission-mode.yaml><code>pods/storage/projected-secrets-nondefault-permission-mode.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-secrets-nondefault-permission-mode-yaml")' title="Copy pods/storage/projected-secrets-nondefault-permission-mode.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-secrets-nondefault-permission-mode-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>volume-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>511</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>各投影ボリュームソースは、specの<code>sources</code>にリストされています。パラメーターは、2つの例外を除いてほぼ同じです。</p><ul><li>secretについて、ConfigMapの命名と一致するように<code>secretName</code>フィールドが<code>name</code>に変更されました。</li><li><code>defaultMode</code>はprojectedレベルでのみ指定でき、各ボリュームソースには指定できません。ただし上に示したように、個々の投影ごとに<code>mode</code>を明示的に設定できます。</li></ul><p><code>TokenRequestProjection</code>機能が有効になっている場合、現在の<a href=/ja/docs/reference/access-authn-authz/authentication/#service-account-token>サービスアカウントトークン</a>を指定されたパスのPodに挿入できます。例えば:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/storage/projected-service-account-token.yaml download=pods/storage/projected-service-account-token.yaml><code>pods/storage/projected-service-account-token.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-service-account-token-yaml")' title="Copy pods/storage/projected-service-account-token.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-service-account-token-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sa-token-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>token-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/service-account&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>token-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>audience</span>:<span style=color:#bbb> </span>api<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>token<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>この例のPodには、挿入されたサービスアカウントトークンを含む投影ボリュームがあります。このトークンはPodのコンテナがKubernetes APIサーバーにアクセスするために使用できます。この<code>audience</code>フィールドにはトークンの受信対象者が含まれています。トークンの受信者は、トークンの<code>audience</code>フィールドで指定された識別子で自分自身であるかを識別します。そうでない場合はトークンを拒否します。このフィールドはオプションで、デフォルトではAPIサーバーの識別子が指定されます。</p><p><code>expirationSeconds</code>はサービスアカウントトークンが有効であると予想される期間です。
デフォルトは1時間で、最低でも10分(600秒)でなければなりません。
管理者は、APIサーバーに<code>--service-account-max-token-expiration</code>オプションを指定することで、その最大値を制限することも可能です。
<code>path</code>フィールドは、投影ボリュームのマウントポイントへの相対パスを指定します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> 投影ボリュームソースを<a href=/docs/concepts/storage/volumes/#using-subpath><code>subPath</code></a>ボリュームマウントとして使用しているコンテナは、それらのボリュームソースの更新を受信しません。</div><h2 id=securitycontextの相互作用>SecurityContextの相互作用</h2><p>サービスアカウントの投影ボリューム拡張でのファイル権限処理の<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/2451-service-account-token-volumes#proposal>提案</a>により、正しい所有者権限が設定された投影ファイルが導入されました。</p><h3 id=linux>Linux</h3><p>投影ボリュームがあり、Podの<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context><code>SecurityContext</code></a>に<code>RunAsUser</code>が設定されているLinux Podでは、投影されたファイルには、コンテナユーザーの所有権を含む正しい所有権が設定されます。</p><h3 id=windows>Windows</h3><p>投影ボリュームを持ち、Podの<code>SecurityContext</code>で<code>RunAsUsername</code>を設定したWindows Podでは、Windowsのユーザーアカウント管理方法により所有権が強制されません。
Windowsは、ローカルユーザーとグループアカウントをセキュリティアカウントマネージャー(SAM)と呼ばれるデータベースファイルに保存し、管理します。
各コンテナはSAMデータベースの独自のインスタンスを維持し、コンテナの実行中はホストはそのインスタンスを見ることができません。
Windowsコンテナは、OSのユーザーモード部分をホストから分離して実行するように設計されており、そのため仮想SAMデータベースを維持することになります。
そのため、ホスト上で動作するkubeletには、仮想化されたコンテナアカウントのホストファイル所有権を動的に設定する機能がありません。
ホストマシン上のファイルをコンテナと共有する場合は、<code>C:\</code>以外の独自のボリュームマウントに配置することをお勧めします。</p><p>デフォルトでは、投影ボリュームファイルの例に示されているように、投影されたファイルには次の所有権があります。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>PS </span>C:\&gt; <span style=color:#a2f>Get-Acl</span> C:\var\run\secrets\kubernetes.io\serviceaccount\..2021_08_31_22_22_18.<span style=color:#666>318230061</span>\ca.crt | <span style=color:#a2f>Format-List</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Path   <span>:</span> Microsoft.PowerShell.Core\FileSystem::C:\var\run\secrets\kubernetes.io\serviceaccount\..2021_08_31_22_22_18.<span style=color:#666>318230061</span>\ca.crt
</span></span><span style=display:flex><span>Owner  <span>:</span> BUILTIN\Administrators
</span></span><span style=display:flex><span><span style=color:#a2f>Group </span> <span>:</span> NT AUTHORITY\SYSTEM
</span></span><span style=display:flex><span>Access <span>:</span> NT AUTHORITY\SYSTEM Allow  FullControl
</span></span><span style=display:flex><span>         BUILTIN\Administrators Allow  FullControl
</span></span><span style=display:flex><span>         BUILTIN\Users Allow  ReadAndExecute, Synchronize
</span></span><span style=display:flex><span>Audit  <span>:</span>
</span></span><span style=display:flex><span>Sddl   <span>:</span> O:BAG<span>:</span>SYD<span>:</span>AI(A;ID;FA;;;SY)(A;ID;FA;;;BA)(A;ID;0x1200a9;;;BU)
</span></span></code></pre></div><p>これは、<code>ContainerAdministrator</code>のようなすべての管理者ユーザーが読み取り、書き込み、および実行アクセス権を持ち、非管理者ユーザーが読み取りおよび実行アクセス権を持つことを意味します。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong><p>一般に、コンテナにホストへのアクセスを許可することは、潜在的なセキュリティの悪用への扉を開く可能性があるため、お勧めできません。</p><p>Windows Podの<code>SecurityContext</code>に<code>RunAsUser</code>を指定して作成すると、Podは<code>ContainerCreating</code>で永久に固まります。したがって、Windows PodでLinux専用の<code>RunAsUser</code>オプションを使用しないことをお勧めします。</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-707ca81a34eb1ca202f34692e9917d1e>4 - CSI Volume Cloning</h1><p>このドキュメントではKubernetesで既存のCSIボリュームの複製についてのコンセプトを説明します。このページを読む前にあらかじめ<a href=/docs/concepts/storage/volumes>ボリューム</a>についてよく理解していることが望ましいです。</p><h2 id=イントロダクション>イントロダクション</h2><p><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>のボリューム複製機能は、ユーザーが<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>の複製を作成することを示す<code>dataSource</code>フィールドで既存の<a class=glossary-tooltip title=コンテナ内でボリュームとしてマウントするためにPersistentVolume内で定義されたストレージリソースを要求します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PVC>PVC</a>を指定するためのサポートを追加します。</p><p>複製は既存のKubernetesボリュームの複製として定義され、標準のボリュームと同じように使用できます。唯一の違いは、プロビジョニング時に「新しい」空のボリュームを作成するのではなく、バックエンドデバイスが指定されたボリュームの正確な複製を作成することです。</p><p>複製の実装は、Kubernetes APIの観点からは新しいPVCの作成時に既存のPVCをdataSourceとして指定する機能を追加するだけです。ソースPVCはバインドされており、使用可能でなければなりません(使用中ではありません)。</p><p>この機能を使用する場合、ユーザーは次のことに注意する必要があります:</p><ul><li>複製のサポート(<code>VolumePVCDataSource</code>)はCSIドライバーのみです。</li><li>複製のサポートは動的プロビジョニングのみです。</li><li>CSIドライバーはボリューム複製機能を実装している場合としていない場合があります。</li><li>PVCは複製先のPVCと同じ名前空間に存在する場合にのみ複製できます(複製元と複製先は同じ名前空間になければなりません)。</li><li>複製は同じストレージクラス内でのみサポートされます。<ul><li>宛先ボリュームは、ソースと同じストレージクラスである必要があります。</li><li>デフォルトのストレージクラスを使用でき、仕様ではstorageClassNameを省略できます。</li></ul></li><li>複製は同じVolumeMode設定を使用する2つのボリューム間でのみ実行できます(ブロックモードのボリュームを要求する場合、ソースもブロックモードである必要があります)。</li></ul><h2 id=プロビジョニング>プロビジョニング</h2><p>複製は同じ名前空間内の既存のPVCを参照するdataSourceを追加すること以外は他のPVCと同様にプロビジョニングされます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>clone-of-pvc-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>myns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>cloning<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pvc-1<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>備考:</strong> <code>spec.resources.requests.storage</code>に容量の値を指定する必要があります。指定する値は、ソースボリュームの容量と同じかそれ以上である必要があります。</div><p>このyamlの作成結果は指定された複製元である<code>pvc-1</code>と全く同じデータを持つ<code>clone-of-pvc-1</code>という名前の新しいPVCです。</p><h2 id=使い方>使い方</h2><p>新しいPVCが使用可能になると、複製されたPVCは他のPVCと同じように利用されます。またこの時点で新しく作成されたPVCは独立したオブジェクトであることが期待されます。元のdataSource PVCを考慮せず個別に利用、複製、スナップショット、削除できます。これはまた複製元が新しく作成された複製にリンクされておらず、新しく作成された複製に影響を与えずに変更または削除できることを意味します。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4d00116c86dade62bdd5be7dc2afa1ca>5 - VolumeSnapshotClass</h1><p>このドキュメントでは、Kubernetesにおける<code>VolumeSnapshotClass</code>のコンセプトについて説明します。<br>関連する項目として、<a href=/docs/concepts/storage/volume-snapshots/>Volumeのスナップショット</a>と<a href=/docs/concepts/storage/storage-classes>ストレージクラス</a>も参照してください。</p><h2 id=イントロダクション>イントロダクション</h2><p><code>StorageClass</code>はVolumeをプロビジョンするときに、ストレージの"クラス"に関する情報を記述する方法を提供します。それと同様に、<code>VolumeSnapshotClass</code>ではVolumeSnapshotをプロビジョンするときに、ストレージの"クラス"に関する情報を記述する方法を提供します。</p><h2 id=volumesnapshotclass-リソース>VolumeSnapshotClass リソース</h2><p>各<code>VolumeSnapshotClass</code>は<code>driver</code>、<code>deletionPolicy</code>と<code>parameters</code>フィールドを含み、それらは、そのクラスに属する<code>VolumeSnapshot</code>が動的にプロビジョンされるときに使われます。</p><p><code>VolumeSnapshotClass</code>オブジェクトの名前は重要であり、それはユーザーがどのように特定のクラスをリクエストできるかを示したものです。管理者は初めて<code>VolumeSnapshotClass</code>オブジェクトを作成するときに、その名前と他のパラメーターをセットし、そのオブジェクトは一度作成されるとそのあと更新することができません。</p><p>管理者は、バインド対象のクラスを1つもリクエストしないようなVolumeSnapshotのために、デフォルトの<code>VolumeSnapshotClass</code>を指定することができます。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=driver>Driver</h3><p>VolumeSnapshotClassは、VolumeSnapshotをプロビジョンするときに何のCSIボリュームプラグインを使うか決定するための<code>driver</code>フィールドを持っています。このフィールドは必須となります。</p><h3 id=deletionpolicy>DeletionPolicy</h3><p>VolumeSnapshotClassにはdeletionPolicyがあります。これにより、バインドされている <code>VolumeSnapshot</code>オブジェクトが削除されるときに、<code>VolumeSnapshotContent</code>がどうなるかを設定することができます。VolumeSnapshotのdeletionPolicyは、<code>Retain</code>または<code>Delete</code>のいずれかです。このフィールドは指定しなければなりません。</p><p>deletionPolicyが<code>Delete</code>の場合、元となるストレージスナップショットは <code>VolumeSnapshotContent</code>オブジェクトとともに削除されます。deletionPolicyが<code>Retain</code>の場合、元となるスナップショットと<code>VolumeSnapshotContent</code>の両方が残ります。</p><h2 id=parameters>Parameters</h2><p>VolumeSnapshotClassは、そのクラスに属するVolumeSnapshotを指定するパラメータを持っています。
<code>driver</code>に応じて様々なパラメータを使用できます。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-018f0a7fc6e2f6d16da37702fc39b4f3>6 - ボリュームの動的プロビジョニング(Dynamic Volume Provisioning)</h1><p>ボリュームの動的プロビジョニングにより、ストレージ用のボリュームをオンデマンドに作成することができます。
動的プロビジョニングなしでは、クラスター管理者はクラウドプロバイダーまたはストレージプロバイダーに対して新規のストレージ用のボリュームと<a href=/ja/docs/concepts/storage/persistent-volumes/><code>PersistentVolume</code>オブジェクト</a>を作成するように手動で指示しなければなりません。動的プロビジョニングの機能によって、クラスター管理者がストレージを事前にプロビジョンする必要がなくなります。その代わりに、ユーザーによってリクエストされたときに自動でストレージをプロビジョンします。</p><h2 id=バックグラウンド>バックグラウンド</h2><p>ボリュームの動的プロビジョニングの実装は<code>storage.k8s.io</code>というAPIグループ内の<code>StorageClass</code>というAPIオブジェクトに基づいています。クラスター管理者は<code>StorageClass</code>オブジェクトを必要に応じていくつでも定義でき、各オブジェクトはボリュームをプロビジョンする<em>Volumeプラグイン</em> (別名<em>プロビジョナー</em>)と、プロビジョンされるときにプロビジョナーに渡されるパラメータを指定します。
クラスター管理者はクラスター内で複数の種類のストレージ(同一または異なるストレージシステム)を定義し、さらには公開でき、それらのストレージはパラメータのカスタムセットを持ちます。この仕組みにおいて、エンドユーザーはストレージがどのようにプロビジョンされるか心配する必要がなく、それでいて複数のストレージオプションから選択できることを保証します。</p><p>StorageClassに関するさらなる情報は<a href=/docs/concepts/storage/storage-classes/>Storage Class</a>を参照ください。</p><h2 id=動的プロビジョニングを有効にする>動的プロビジョニングを有効にする</h2><p>動的プロビジョニングを有効にするために、クラスター管理者はユーザーのために1つまたはそれ以上のStorageClassを事前に作成する必要があります。StorageClassオブジェクトは、動的プロビジョニングが実行されるときに、どのプロビジョナーが使用されるべきか、またどのようなパラメーターをプロビジョナーに渡すべきか定義します。StorageClassオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p><p>下記のマニフェストでは標準的な永続化ディスクをプロビジョンする"slow"というStorageClassを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></span></span></code></pre></div><p>下記のマニフェストではSSDを使った永続化ディスクをプロビジョンする"fast"というStorageClassを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-ssd<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=動的プロビジョニングの使用>動的プロビジョニングの使用</h2><p>ユーザーは<code>PersistentVolumeClaim</code>リソース内でStorageClassを含むことで、動的にプロビジョンされたStorageをリクエストできます。Kubernetes v1.6以前では、この機能は<code>volume.beta.kubernetes.io/storage-class</code>アノテーションを介して使うことができました。しかしこのアノテーションではv1.6から廃止になりました。その代わりユーザーは現在では<code>PersistentVolumeClaim</code>オブジェクトの<code>storageClassName</code>を使う必要があります。このフィールドの値は、管理者によって設定された<code>StorageClass</code>の名前と一致しなければなりません(<a href=#enabling-dynamic-provisioning>下記</a>のセクションも参照ください)。</p><p>"fast"というStorageClassを選択するために、例としてユーザーは下記のPersistentVolumeClaimを作成します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>claim1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>30Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>このリソースによってSSDのような永続化ディスクが自動的にプロビジョンされます。このリソースが削除された時、そのボリュームは削除されます。</p><h2 id=デフォルトの挙動>デフォルトの挙動</h2><p>動的プロビジョニングは、もしStorageClassが1つも指定されていないときに全てのPersistentVolumeClaimが動的にプロビジョンされるようにクラスター上で有効にできます。クラスター管理者は、下記を行うことによりこのふるまいを有効にできます。</p><ul><li>1つの<code>StorageClass</code>オブジェクトを<em>default</em> としてマーキングする</li><li>API Server上で<a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code>管理コントローラー</a>を有効にする。</li></ul><p>管理者は<code>StorageClass</code>に対して<code>storageclass.kubernetes.io/is-default-class</code>アノテーションをつけることで、デフォルトのStorageClassとしてマーキングできます。
デフォルトの<code>StorageClass</code>がクラスター内で存在し、かつユーザーが<code>PersistentVolumeClaim</code>リソースで<code>storageClassName</code>を指定しなかった場合、<code>DefaultStorageClass</code>という管理コントローラーは<code>storageClassName</code>フィールドの値をデフォルトのStorageClassを指し示すように自動で追加します。</p><p>注意点として、クラスター上では最大1つしか<em>デフォルト</em> のStorageClassが指定できず、<code>storageClassName</code>を明示的に指定しない<code>PersistentVolumeClaim</code>は作成することもできません。</p><h2 id=トポロジーに関する注意>トポロジーに関する注意</h2><p><a href=/docs/setup/multiple-zones>マルチゾーン</a>クラスター内では、Podは単一のリージョン内のゾーンをまたいでしか稼働できません。シングルゾーンのStorageバックエンドはPodがスケジュールされるゾーン内でプロビジョンされる必要があります。これは<a href=/docs/concepts/storage/storage-classes/#volume-binding-mode>Volume割り当てモード</a>を設定することにより可能となります。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-00cd24f4570b7acaac75c2551c948bc7>7 - ストレージ容量</h1><p>ストレージ容量は、Podが実行されるノードごとに制限があったり、大きさが異なる可能性があります。たとえば、NASがすべてのノードからはアクセスできなかったり、初めからストレージがノードローカルでしか利用できない可能性があります。</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [alpha]</code></div><p>このページでは、Kubernetesがストレージ容量を追跡し続ける方法と、スケジューラーがその情報を利用して、残りの未作成のボリュームのために十分なストレージ容量へアクセスできるノード上にどのようにPodをスケジューリングするかについて説明します。もしストレージ容量の追跡がなければ、スケジューラーは、ボリュームをプロビジョニングするために十分な容量のないノードを選択してしまい、スケジューリングの再試行が複数回行われてしまう恐れがあります。</p><p>ストレージ容量の追跡は、<a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label='Container Storage Interface'>Container Storage Interface</a>(CSI)向けにサポートされており、CSIドライバーのインストール時に<a href=#enabling-storage-capacity-tracking>有効にする必要があります</a>。</p><h2 id=api>API</h2><p>この機能には、以下の2つのAPI拡張があります。</p><ul><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#csistoragecapacity-v1alpha1-storage-k8s-io>CSIStorageCapacity</a>オブジェクト: このオブジェクトは、CSIドライバーがインストールされた名前空間に生成されます。各オブジェクトには1つのストレージクラスに対する容量の情報が含まれ、そのストレージに対してどのノードがアクセス権を持つかが定められています。</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#csidriverspec-v1-storage-k8s-io><code>CSIDriverSpec.StorageCapacity</code>フィールド</a>: <code>true</code>に設定すると、Kubernetesのスケジューラーが、CSIドライバーを使用するボリュームに対してストレージ容量を考慮するようになります。</p></li></ul><h2 id=スケジューリング>スケジューリング</h2><p>ストレージ容量の情報がKubernetesのスケジューラーで利用されるのは、以下のすべての条件を満たす場合です。</p><ul><li><code>CSIStorageCapacity</code>フィーチャーゲートがtrueである</li><li>Podがまだ作成されていないボリュームを使用する時</li><li>そのボリュームが、CSIドライバーを参照し、<a href=/docs/concepts/storage/storage-classes/#volume-binding-mode>volume binding mode</a>に<code>WaitForFirstConsumer</code>を使う<a class=glossary-tooltip title=StorageClassは管理者が利用可能なさまざまなストレージタイプを記述する方法を提供します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/storage-classes target=_blank aria-label=StorageClass>StorageClass</a>を使用している</li><li>ドライバーに対する<code>CSIDriver</code>オブジェクトの<code>StorageCapacity</code>がtrueに設定されている</li></ul><p>その場合、スケジューラーはPodに対して、十分なストレージ容量が利用できるノードだけを考慮するようになります。このチェックは非常に単純で、ボリュームのサイズと、<code>CSIStorageCapacity</code>オブジェクトに一覧された容量を、ノードを含むトポロジーで比較するだけです。</p><p>volume binding modeが<code>Immediate</code>のボリュームの場合、ストレージドライバーはボリュームを使用するPodとは関係なく、ボリュームを作成する場所を決定します。次に、スケジューラーはボリュームが作成された後、Podをボリュームが利用できるノードにスケジューリングします。</p><p><a href=/docs/concepts/storage/volumes/#csi>CSI ephemeral volumes</a>の場合、スケジューリングは常にストレージ容量を考慮せずに行われます。このような動作になっているのは、このボリュームタイプはノードローカルな特別なCSIドライバーでのみ使用され、そこでは特に大きなリソースが必要になることはない、という想定に基づいています。</p><h2 id=再スケジューリング>再スケジューリング</h2><p><code>WaitForFirstConsumer</code>ボリュームがあるPodに対してノードが選択された場合は、その決定はまだ一時的なものです。次のステップで、CSIストレージドライバーに対して、選択されたノード上でボリュームが利用可能になることが予定されているというヒントを使用してボリュームの作成を要求します。</p><p>Kubernetesは古い容量の情報をもとにノードを選択する場合があるため、実際にはボリュームが作成できないという可能性が存在します。その場合、ノードの選択がリセットされ、KubernetesスケジューラーはPodに割り当てるノードを再び探します。</p><h2 id=制限>制限</h2><p>ストレージ容量を追跡することで、1回目の試行でスケジューリングが成功する可能性が高くなります。しかし、スケジューラーは潜在的に古い情報に基づいて決定を行う可能性があるため、成功を保証することはできません。通常、ストレージ容量の情報が存在しないスケジューリングと同様のリトライの仕組みによって、スケジューリングの失敗に対処します。</p><p>スケジューリングが永続的に失敗する状況の1つは、Podが複数のボリュームを使用する場合で、あるトポロジーのセグメントで1つのボリュームがすでに作成された後、もう1つのボリュームのために十分な容量が残っていないような場合です。この状況から回復するには、たとえば、容量を増加させたり、すでに作成されたボリュームを削除するなどの手動での対応が必要です。この問題に自動的に対処するためには、まだ<a href=https://github.com/kubernetes/enhancements/pull/1703>追加の作業</a>が必要となっています。</p><h2 id=enabling-storage-capacity-tracking>ストレージ容量の追跡を有効にする</h2><p>ストレージ容量の追跡は<em>アルファ機能</em>であり、<code>CSIStorageCapacity</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>と<code>storage.k8s.io/v1alpha1</code> <a class=glossary-tooltip title='A set of related paths in the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label='API group'>API group</a>を有効にした場合にのみ、有効化されます。詳細については、<code>--feature-gates</code>および<code>--runtime-config</code> <a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserverパラメータ</a>を参照してください。</p><p>Kubernetesクラスターがこの機能をサポートしているか簡単に確認するには、以下のコマンドを実行して、CSIStorageCapacityオブジェクトを一覧表示します。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csistoragecapacities --all-namespaces
</span></span></code></pre></div><p>クラスターがCSIStorageCapacityをサポートしていれば、CSIStorageCapacityのリストが表示されるか、次のメッセージが表示されます。</p><pre tabindex=0><code>No resources found
</code></pre><p>もしサポートされていなければ、代わりに次のエラーが表示されます。</p><pre tabindex=0><code>error: the server doesn&#39;t have a resource type &#34;csistoragecapacities&#34;
</code></pre><p>クラスター内で機能を有効化することに加えて、CSIドライバーもこの機能をサポートしている必要があります。詳細については、各ドライバーのドキュメントを参照してください。</p><h2 id=次の項目>次の項目</h2><ul><li>設計に関するさらなる情報について知るために、<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1472-storage-capacity-tracking/README.md>Storage Capacity Constraints for Pod Scheduling KEP</a>を読む。</li><li>この機能の今後の開発に関する情報について知るために、<a href=https://github.com/kubernetes/enhancements/issues/1472>enhancement tracking issue #1472</a>を参照する。</li><li><a href=/ja/docs/concepts/scheduling-eviction/kube-scheduler/>Kubernetesのスケジューラー</a>についてもっと学ぶ。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4f40cb95a671e51b4f0156a409d95c6d>8 - ボリュームヘルスモニタリング</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code></div><p><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>ボリュームヘルスモニタリングにより、CSIドライバーは、基盤となるストレージシステムから異常なボリューム状態を検出し、それらを<a class=glossary-tooltip title=コンテナ内でボリュームとしてマウントするためにPersistentVolume内で定義されたストレージリソースを要求します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PVC>PVC</a>または<a class=glossary-tooltip title='一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。' data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>のイベントとして報告できます。</p><h2 id=ボリュームヘルスモニタリング>ボリュームヘルスモニタリング</h2><p>Kubernetes <em>volume health monitoring</em> は、KubernetesがContainerStorageInterface(CSI)を実装する方法の一部です。ボリュームヘルスモニタリング機能は、外部のヘルスモニターコントローラーと<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>の2つのコンポーネントで実装されます。</p><p>CSIドライバーがコントローラー側からのボリュームヘルスモニタリング機能をサポートしている場合、CSIボリュームで異常なボリューム状態が検出されると、関連する<a class=glossary-tooltip title=コンテナ内でボリュームとしてマウントするためにPersistentVolume内で定義されたストレージリソースを要求します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PersistentVolumeClaim>PersistentVolumeClaim</a>(PVC)でイベントが報告されます。</p><p>外部ヘルスモニター<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>も、ノード障害イベントを監視します。<code>enable-node-watcher</code>フラグをtrueに設定することで、ノード障害の監視を有効にできます。外部ヘルスモニターがノード障害イベントを検出すると、コントローラーは、このPVCを使用するポッドが障害ノード上にあることを示すために、PVCでイベントが報告されることを報告します。</p><p>CSIドライバーがノード側からのボリュームヘルスモニタリング機能をサポートしている場合、CSIボリュームで異常なボリューム状態が検出されると、PVCを使用するすべてのPodでイベントが報告されます。さらに、ボリュームヘルス情報はKubelet VolumeStatsメトリクスとして公開されます。新しいメトリックkubelet_volume_stats_health_status_abnormalが追加されました。このメトリックには<code>namespace</code>と<code>persistentvolumeclaim</code>の2つのラベルが含まれます。カウントは1または0です。1はボリュームが異常であることを示し、0はボリュームが正常であることを示します。詳細については、<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1432-volume-health-monitor#kubelet-metrics-changes>KEP</a>を確認してください。</p><div class="alert alert-info note callout" role=alert><strong>備考:</strong> ノード側からこの機能を使用するには、<code>CSIVolumeHealth</code><a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>を有効にする必要があります。</div><h2 id=次の項目>次の項目</h2><p><a href=https://kubernetes-csi.github.io/docs/drivers.html>CSIドライバーのドキュメント</a>を参照して、この機能を実装しているCSIドライバーを確認してください。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b2e4b16ac37988c678a3312a4a6639f8>9 - ノード固有のボリューム制限</h1><p>このページでは、さまざまなクラウドプロバイダーのノードに接続できるボリュームの最大数について説明します。</p><p>通常、Google、Amazon、Microsoftなどのクラウドプロバイダーには、ノードに接続できるボリュームの数に制限があります。Kubernetesがこれらの制限を尊重することが重要です。
そうしないと、ノードでスケジュールされたPodが、ボリュームが接続されるのを待ってスタックする可能性があります。</p><h2 id=kubernetesのデフォルトの制限>Kubernetesのデフォルトの制限</h2><p>Kubernetesスケジューラーには、ノードに接続できるボリュームの数にデフォルトの制限があります。</p><table><tr><th>クラウドサービス</th><th>ノード当たりの最大ボリューム</th></tr><tr><td><a href=https://aws.amazon.com/ebs/>Amazon Elastic Block Store (EBS)</a></td><td>39</td></tr><tr><td><a href=https://cloud.google.com/persistent-disk/>Google Persistent Disk</a></td><td>16</td></tr><tr><td><a href=https://azure.microsoft.com/en-us/services/storage/main-disks/>Microsoft Azure Disk Storage</a></td><td>16</td></tr></table><h2 id=カスタム制限>カスタム制限</h2><p>これらの制限を変更するには、<code>KUBE_MAX_PD_VOLS</code>環境変数の値を設定し、スケジューラーを開始します。CSIドライバーの手順は異なる場合があります。制限をカスタマイズする方法については、CSIドライバーのドキュメントを参照してください。</p><p>デフォルトの制限よりも高い制限を設定する場合は注意してください。クラウドプロバイダーのドキュメントを参照して、設定した制限をノードが実際にサポートしていることを確認してください。</p><p>制限はクラスター全体に適用されるため、すべてのノードに影響します。</p><h2 id=動的ボリューム制限>動的ボリューム制限</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code></div><p>動的ボリューム制限は、次のボリュームタイプでサポートされています。</p><ul><li>Amazon EBS</li><li>Google Persistent Disk</li><li>Azure Disk</li><li>CSI</li></ul><p>ツリー内のボリュームプラグインによって管理されるボリュームの場合、Kubernetesはノードタイプを自動的に決定し、ノードに適切なボリュームの最大数を適用します。例えば:</p><ul><li><p><a href=https://cloud.google.com/compute/>Google Compute Engine</a>上では<a href=https://cloud.google.com/compute/docs/disks/#pdnumberlimits>ノードタイプ</a>に応じて、最大127個のボリュームをノードに接続できます。</p></li><li><p>M5、C5、R5、T3、およびZ1DインスタンスタイプのAmazon EBSディスクの場合、Kubernetesは25ボリュームのみをノードにアタッチできます。<a href=https://aws.amazon.com/ec2/>Amazon Elastic Compute Cloud (EC2)</a>の他のインスタンスタイプの場合、Kubernetesでは39個のボリュームをノードに接続できます。</p></li><li><p>Azureでは、ノードの種類に応じて、最大64個のディスクをノードに接続できます。詳細については、<a href=https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes>Azureの仮想マシンのサイズ</a>を参照してください。</p></li><li><p>CSIストレージドライバーが(<code>NodeGetInfo</code>を使用して)ノードの最大ボリューム数をアドバタイズする場合、<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>はその制限を尊重します。詳細については、<a href=https://github.com/ontainer-storage-interface/spec/blob/master/spec.md#nodegetinfo>CSIの仕様</a>を参照してください。</p></li><li><p>CSIドライバーに移行されたツリー内プラグインによって管理されるボリュームの場合、ボリュームの最大数はCSIドライバーによって報告される数になります。</p></li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/blog/>Blogs</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>